/*!
 * ONNX Runtime Web v1.22.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import{createRequire}from"module";const require=createRequire(import.meta.url);
var ce=Object.defineProperty;var pt=Object.getOwnPropertyDescriptor;var mt=Object.getOwnPropertyNames;var gt=Object.prototype.hasOwnProperty;var le=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,o)=>(typeof require<"u"?require:t)[o]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var C=(e,t)=>()=>(e&&(t=e(e=0)),t);var bt=(e,t)=>{for(var o in t)ce(e,o,{get:t[o],enumerable:!0})},yt=(e,t,o,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of mt(t))!gt.call(e,r)&&r!==o&&ce(e,r,{get:()=>t[r],enumerable:!(s=pt(t,r))||s.enumerable});return e};var wt=e=>yt(ce({},"__esModule",{value:!0}),e);var M,Q=C(()=>{"use strict";M=!!(typeof process<"u"&&process.versions&&process.versions.node)});var xe,ht,k,Ie,ve,St,Et,Ot,Tt,Pe,_e,fe=C(()=>{"use strict";Q();xe=M||typeof location>"u"?void 0:location.origin,ht=()=>{if(!M)return import.meta.url?.startsWith("file:")?new URL(new URL("ort.node.min.mjs",import.meta.url).href,xe).href:import.meta.url},k=ht(),Ie=()=>{if(k&&!k.startsWith("blob:"))return k.substring(0,k.lastIndexOf("/")+1)},ve=(e,t)=>{try{let o=t??k;return(o?new URL(e,o):new URL(e)).origin===xe}catch{return!1}},St=(e,t)=>{let o=t??k;try{return(o?new URL(e,o):new URL(e)).href}catch{return}},Et=(e,t)=>`${t??"./"}${e}`,Ot=async e=>{let o=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(o)},Tt=async e=>(await import(/*webpackIgnore:true*/e)).default,Pe=void 0,_e=async(e,t,o)=>{if(!e&&!t&&Pe&&k&&ve(k))return[void 0,Pe];{let s="ort-wasm-simd-threaded.mjs",r=e??St(s,t),a=!M&&o&&r&&!ve(r,t),n=a?await Ot(r):r??Et(s,t);return[a?n:void 0,await Tt(n)]}}});var de,pe,ee,Ae,Lt,vt,Ce,O,z=C(()=>{"use strict";fe();pe=!1,ee=!1,Ae=!1,Lt=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},vt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ce=async e=>{if(pe)return Promise.resolve();if(ee)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ae)throw new Error("previous call to 'initializeWebAssembly()' failed.");ee=!0;let t=e.initTimeout,o=e.numThreads;if(!vt())throw new Error("WebAssembly SIMD is not supported in the current environment.");let s=Lt();o>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+o+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=o=1);let r=e.wasmPaths,a=typeof r=="string"?r:void 0,n=r?.mjs,i=n?.href??n,c=r?.wasm,f=c?.href??c,h=e.wasmBinary,[y,u]=await _e(i,a,o>1),l=!1,x=[];if(t>0&&x.push(new Promise(S=>{setTimeout(()=>{l=!0,S()},t)})),x.push(new Promise((S,m)=>{let b={numThreads:o};if(h)b.wasmBinary=h;else if(f||a)b.locateFile=d=>f??a+d;else if(i&&i.indexOf("blob:")!==0)b.locateFile=d=>new URL(d,i).href;else if(y){let d=Ie();d&&(b.locateFile=w=>d+w)}u(b).then(d=>{ee=!1,pe=!0,de=d,S(),y&&URL.revokeObjectURL(y)},d=>{ee=!1,Ae=!0,m(d)})})),await Promise.race(x),l)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},O=()=>{if(pe&&de)return de;throw new Error("WebAssembly is not initialized yet.")}});var T,J,g,te=C(()=>{"use strict";z();T=(e,t)=>{let o=O(),s=o.lengthBytesUTF8(e)+1,r=o._malloc(s);return o.stringToUTF8(e,r,s),t.push(r),r},J=(e,t,o,s)=>{if(typeof e=="object"&&e!==null){if(o.has(e))throw new Error("Circular reference in options");o.add(e)}Object.entries(e).forEach(([r,a])=>{let n=t?t+r:r;if(typeof a=="object")J(a,n+".",o,s);else if(typeof a=="string"||typeof a=="number")s(n,a.toString());else if(typeof a=="boolean")s(n,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},g=e=>{let t=O(),o=t.stackSave();try{let s=t.PTR_SIZE,r=t.stackAlloc(2*s);t._OrtGetLastError(r,r+s);let a=Number(t.getValue(r,s===4?"i32":"i64")),n=t.getValue(r+s,"*"),i=n?t.UTF8ToString(n):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(o)}}});var Ue,Be=C(()=>{"use strict";z();te();Ue=e=>{let t=O(),o=0,s=[],r=e||{};try{if(e?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(r.terminate=!1);let a=0;return e?.tag!==void 0&&(a=T(e.tag,s)),o=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),o===0&&g("Can't create run options."),e?.extra!==void 0&&J(e.extra,"",new WeakSet,(n,i)=>{let c=T(n,s),f=T(i,s);t._OrtAddRunConfigEntry(o,c,f)!==0&&g(`Can't set a run config entry: ${n} - ${i}.`)}),[o,s]}catch(a){throw o!==0&&t._OrtReleaseRunOptions(o),s.forEach(n=>t._free(n)),a}}});var Pt,xt,It,_t,Me,ke=C(()=>{"use strict";z();te();Pt=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},xt=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},It=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(o=>(typeof o=="string"?o:o.name)==="webgpu")&&(e.enableMemPattern=!1)},_t=(e,t,o)=>{for(let s of t){let r=typeof s=="string"?s:s.name;switch(r){case"webnn":if(r="WEBNN",typeof s!="string"){let i=s?.deviceType;if(i){let c=T("deviceType",o),f=T(i,o);O()._OrtAddSessionConfigEntry(e,c,f)!==0&&g(`Can't set a session config entry: 'deviceType' - ${i}.`)}}break;case"webgpu":if(r="JS",typeof s!="string"){let n=s;if(n?.preferredLayout){if(n.preferredLayout!=="NCHW"&&n.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${n.preferredLayout}`);let i=T("preferredLayout",o),c=T(n.preferredLayout,o);O()._OrtAddSessionConfigEntry(e,i,c)!==0&&g(`Can't set a session config entry: 'preferredLayout' - ${n.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let a=T(r,o);O()._OrtAppendExecutionProvider(e,a)!==0&&g(`Can't append execution provider: ${r}.`)}},Me=e=>{let t=O(),o=0,s=[],r=e||{};It(r);try{let a=Pt(r.graphOptimizationLevel??"all"),n=xt(r.executionMode??"sequential"),i=typeof r.logId=="string"?T(r.logId,s):0,c=r.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let f=r.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let h=typeof r.optimizedModelFilePath=="string"?T(r.optimizedModelFilePath,s):0;if(o=t._OrtCreateSessionOptions(a,!!r.enableCpuMemArena,!!r.enableMemPattern,n,!!r.enableProfiling,0,i,c,f,h),o===0&&g("Can't create session options."),r.executionProviders&&_t(o,r.executionProviders,s),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let y=T("enableGraphCapture",s),u=T(r.enableGraphCapture.toString(),s);t._OrtAddSessionConfigEntry(o,y,u)!==0&&g(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[y,u]of Object.entries(r.freeDimensionOverrides)){if(typeof y!="string")throw new Error(`free dimension override name must be a string: ${y}`);if(typeof u!="number"||!Number.isInteger(u)||u<0)throw new Error(`free dimension override value must be a non-negative integer: ${u}`);let l=T(y,s);t._OrtAddFreeDimensionOverride(o,l,u)!==0&&g(`Can't set a free dimension override: ${y} - ${u}.`)}return r.extra!==void 0&&J(r.extra,"",new WeakSet,(y,u)=>{let l=T(y,s),x=T(u,s);t._OrtAddSessionConfigEntry(o,l,x)!==0&&g(`Can't set a session config entry: ${y} - ${u}.`)}),[o,s]}catch(a){throw o!==0&&t._OrtReleaseSessionOptions(o)!==0&&g("Can't release session options."),s.forEach(n=>t._free(n)),a}}});var G,De,H,We,Fe,re,ne,Re,me=C(()=>{"use strict";G=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},De=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},H=(e,t)=>{let o=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],s=typeof t=="number"?t:t.reduce((r,a)=>r*a,1);return o>0?Math.ceil(s*o):void 0},We=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Fe=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},re=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",ne=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Re=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var Y,ge=C(()=>{"use strict";Q();Y=async e=>{if(typeof e=="string")if(M)try{let{readFile:t}=le("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:o}=le("node:fs"),s=o(e),r=[];for await(let a of s)r.push(a);return new Uint8Array(Buffer.concat(r))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let o=t.headers.get("Content-Length"),s=o?parseInt(o,10):0;if(s<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),a;try{a=new ArrayBuffer(s)}catch(i){if(i instanceof RangeError){let c=Math.ceil(s/65536);a=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw i}let n=0;for(;;){let{done:i,value:c}=await r.read();if(i)break;let f=c.byteLength;new Uint8Array(a,n,f).set(c),n+=f}return new Uint8Array(a,0,s)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var At,je,$e,V,Ct,be,ze,Ge,Ne,He,Ve,qe=C(()=>{"use strict";Be();ke();me();z();te();ge();At=(e,t)=>{O()._OrtInit(e,t)!==0&&g("Can't initialize onnxruntime.")},je=async e=>{At(e.wasm.numThreads,Fe(e.logLevel))},$e=async(e,t)=>{},V=new Map,Ct=e=>{let t=O(),o=t.stackSave();try{let s=t.PTR_SIZE,r=t.stackAlloc(2*s);t._OrtGetInputOutputCount(e,r,r+s)!==0&&g("Can't get session input/output count.");let n=s===4?"i32":"i64";return[Number(t.getValue(r,n)),Number(t.getValue(r+s,n))]}finally{t.stackRestore(o)}},be=e=>{let t=O(),o=t._malloc(e.byteLength);if(o===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,o),[o,e.byteLength]},ze=async(e,t)=>{let o,s,r=O();Array.isArray(e)?[o,s]=e:e.buffer===r.HEAPU8.buffer?[o,s]=[e.byteOffset,e.byteLength]:[o,s]=be(e);let a=0,n=0,i=0,c=[],f=[],h=[];try{if([n,c]=Me(t),t?.externalData&&r.mountExternalData){let d=[];for(let w of t.externalData){let v=typeof w=="string"?w:w.path;d.push(Y(typeof w=="string"?w:w.data).then(A=>{r.mountExternalData(v,A)}))}await Promise.all(d)}for(let d of t?.executionProviders??[])if((typeof d=="string"?d:d.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,typeof d!="string"){let v=d,A=v?.context,D=v?.gpuDevice,W=v?.deviceType,X=v?.powerPreference;A?r.currentContext=A:D?r.currentContext=await r.jsepCreateMLContext(D):r.currentContext=await r.jsepCreateMLContext({deviceType:W,powerPreference:X})}else r.currentContext=await r.jsepCreateMLContext();break}a=await r._OrtCreateSession(o,s,n),a===0&&g("Can't create a session."),r.jsepOnCreateSession?.(),r.currentContext&&(r.jsepRegisterMLContext(a,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[y,u]=Ct(a),l=!!t?.enableGraphCapture,x=[],S=[],m=[];for(let d=0;d<y;d++){let w=r._OrtGetInputName(a,d);w===0&&g("Can't get an input name."),f.push(w),x.push(r.UTF8ToString(w))}for(let d=0;d<u;d++){let w=r._OrtGetOutputName(a,d);w===0&&g("Can't get an output name."),h.push(w);let v=r.UTF8ToString(w);S.push(v)}return V.set(a,[a,f,h,null,l,!1]),[a,x,S]}catch(y){throw f.forEach(u=>r._OrtFree(u)),h.forEach(u=>r._OrtFree(u)),i!==0&&r._OrtReleaseBinding(i)!==0&&g("Can't release IO binding."),a!==0&&r._OrtReleaseSession(a)!==0&&g("Can't release session."),y}finally{r._free(o),n!==0&&r._OrtReleaseSessionOptions(n)!==0&&g("Can't release session options."),c.forEach(y=>r._free(y)),r.unmountExternalData?.()}},Ge=e=>{let t=O(),o=V.get(e);if(!o)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,r,a,n,i]=o;n&&(i&&t._OrtClearBoundOutputs(n.handle)!==0&&g("Can't clear bound outputs."),t._OrtReleaseBinding(n.handle)!==0&&g("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),r.forEach(c=>t._OrtFree(c)),a.forEach(c=>t._OrtFree(c)),t._OrtReleaseSession(s)!==0&&g("Can't release session."),V.delete(e)},Ne=async(e,t,o,s,r,a=!1)=>{if(!e){t.push(0);return}let n=O(),i=n.PTR_SIZE,c=e[0],f=e[1],h=e[3],y=h,u,l;if(c==="string"&&(h==="gpu-buffer"||h==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(a&&h!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(h==="gpu-buffer"){let m=e[2].gpuBuffer;l=H(G(c),f);let b=n.jsepRegisterBuffer;if(!b)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');u=b(s,r,m,l)}else if(h==="ml-tensor"){let m=e[2].mlTensor;l=H(G(c),f);let b=n.jsepRegisterMLTensor;if(!b)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');u=b(s,m,G(c),f)}else{let m=e[2];if(Array.isArray(m)){l=i*m.length,u=n._malloc(l),o.push(u);for(let b=0;b<m.length;b++){if(typeof m[b]!="string")throw new TypeError(`tensor data at index ${b} is not a string`);n.setValue(u+b*i,T(m[b],o),"*")}}else{let b=n.jsepIsGraphInput;if(c!=="string"&&b){let d=n._OrtGetInputName(s,r),w=n.UTF8ToString(d);if(b(s,w)){let v=G(c);l=H(v,f),y="ml-tensor";let A=n.jsepCreateTemporaryTensor,D=n.jsepUploadTensor;if(!A||!D)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let W=await A(s,v,f);D(W,new Uint8Array(m.buffer,m.byteOffset,m.byteLength)),u=W}else l=m.byteLength,u=n._malloc(l),o.push(u),n.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,l),u)}else l=m.byteLength,u=n._malloc(l),o.push(u),n.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,l),u)}}let x=n.stackSave(),S=n.stackAlloc(4*f.length);try{f.forEach((b,d)=>n.setValue(S+d*i,b,i===4?"i32":"i64"));let m=n._OrtCreateTensor(G(c),u,l,S,f.length,Re(y));m===0&&g(`Can't create tensor for input/output. session=${s}, index=${r}.`),t.push(m)}finally{n.stackRestore(x)}},He=async(e,t,o,s,r,a)=>{let n=O(),i=n.PTR_SIZE,c=V.get(e);if(!c)throw new Error(`cannot run inference. invalid session id: ${e}`);let f=c[0],h=c[1],y=c[2],u=c[3],l=c[4],x=c[5],S=t.length,m=s.length,b=0,d=[],w=[],v=[],A=[],D=n.stackSave(),W=n.stackAlloc(S*i),X=n.stackAlloc(S*i),ae=n.stackAlloc(m*i),Ee=n.stackAlloc(m*i);try{[b,d]=Ue(a);for(let p=0;p<S;p++)await Ne(o[p],w,A,e,t[p],l);for(let p=0;p<m;p++)await Ne(r[p],v,A,e,S+s[p],l);for(let p=0;p<S;p++)n.setValue(W+p*i,w[p],"*"),n.setValue(X+p*i,h[t[p]],"*");for(let p=0;p<m;p++)n.setValue(ae+p*i,v[p],"*"),n.setValue(Ee+p*i,y[s[p]],"*");n.jsepOnRunStart?.(f);let U;U=await n._OrtRun(f,X,W,S,Ee,m,ae,b),U!==0&&g("failed to call OrtRun().");let N=[];for(let p=0;p<m;p++){let j=Number(n.getValue(ae+p*i,"*"));if(j===v[p]){N.push(r[p]);continue}let Oe=n.stackSave(),B=n.stackAlloc(4*i),q=!1,L,I=0;try{n._OrtGetTensorData(j,B,B+i,B+2*i,B+3*i)!==0&&g(`Can't access output tensor data on index ${p}.`);let ie=i===4?"i32":"i64",Z=Number(n.getValue(B,ie));I=n.getValue(B+i,"*");let Te=n.getValue(B+i*2,"*"),ft=Number(n.getValue(B+i*3,ie)),F=[];for(let P=0;P<ft;P++)F.push(Number(n.getValue(Te+P*i,ie)));n._OrtFree(Te)!==0&&g("Can't free memory for tensor dims.");let R=F.reduce((P,E)=>P*E,1);L=De(Z);let K=u?.outputPreferredLocations[s[p]];if(L==="string"){if(K==="gpu-buffer"||K==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let P=[];for(let E=0;E<R;E++){let $=n.getValue(I+E*i,"*"),ue=n.getValue(I+(E+1)*i,"*"),dt=E===R-1?void 0:ue-$;P.push(n.UTF8ToString($,dt))}N.push([L,F,P,"cpu"])}else if(K==="gpu-buffer"&&R>0){let P=n.jsepGetBuffer;if(!P)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let E=P(I),$=H(Z,R);if($===void 0||!re(L))throw new Error(`Unsupported data type: ${L}`);q=!0,N.push([L,F,{gpuBuffer:E,download:n.jsepCreateDownloader(E,$,L),dispose:()=>{n._OrtReleaseTensor(j)!==0&&g("Can't release tensor.")}},"gpu-buffer"])}else if(K==="ml-tensor"&&R>0){let P=n.jsepEnsureTensor,E=n.jsepIsInt64Supported;if(!P||!E)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(H(Z,R)===void 0||!ne(L))throw new Error(`Unsupported data type: ${L}`);if(L==="int64"&&!E(e))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let ue=await P(e,I,Z,F,!1);q=!0,N.push([L,F,{mlTensor:ue,download:n.jsepCreateMLTensorDownloader(I,L),dispose:()=>{n.jsepReleaseTensorId(I),n._OrtReleaseTensor(j)}},"ml-tensor"])}else{let P=We(L),E=new P(R);new Uint8Array(E.buffer,E.byteOffset,E.byteLength).set(n.HEAPU8.subarray(I,I+E.byteLength)),N.push([L,F,E,"cpu"])}}finally{n.stackRestore(Oe),L==="string"&&I&&n._free(I),q||n._OrtReleaseTensor(j),n.jsepOnRunEnd?.(f)}}return u&&!l&&(n._OrtClearBoundOutputs(u.handle)!==0&&g("Can't clear bound outputs."),V.set(e,[f,h,y,u,l,!1])),N}finally{n.stackRestore(D),w.forEach(U=>n._OrtReleaseTensor(U)),v.forEach(U=>n._OrtReleaseTensor(U)),A.forEach(U=>n._free(U)),b!==0&&n._OrtReleaseRunOptions(b),d.forEach(U=>n._free(U))}},Ve=e=>{let t=O(),o=V.get(e);if(!o)throw new Error("invalid session id");let s=o[0],r=t._OrtEndProfiling(s);r===0&&g("Can't get an profile file name."),t._OrtFree(r)}});import{env as we}from"onnxruntime-common";var ye,Je,Ye,Xe,Ze,Ke,Qe,et,tt,rt,he=C(()=>{"use strict";qe();z();fe();ye=!1,Je=!1,Ye=!1,Xe=async()=>{if(!Je){if(ye)throw new Error("multiple calls to 'initWasm()' detected.");if(Ye)throw new Error("previous call to 'initWasm()' failed.");ye=!0;try{await Ce(we.wasm),await je(we),Je=!0}catch(e){throw Ye=!0,e}finally{ye=!1}}},Ze=async e=>{await $e(we,e)},Ke=async e=>be(e),Qe=async(e,t)=>ze(e,t),et=async e=>{Ge(e)},tt=async(e,t,o,s,r,a)=>He(e,t,o,s,r,a),rt=async e=>{Ve(e)}});import{Tensor as Se,TRACE_FUNC_BEGIN as nt,TRACE_FUNC_END as ot}from"onnxruntime-common";var st,Bt,oe,at=C(()=>{"use strict";he();me();Q();ge();st=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Bt=e=>{switch(e[3]){case"cpu":return new Se(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!re(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:o,download:s,dispose:r}=e[2];return Se.fromGpuBuffer(o,{dataType:t,dims:e[1],download:s,dispose:r})}case"ml-tensor":{let t=e[0];if(!ne(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:o,download:s,dispose:r}=e[2];return Se.fromMLTensor(o,{dataType:t,dims:e[1],download:s,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},oe=class{async fetchModelAndCopyToWasmMemory(t){return Ke(await Y(t))}async loadModel(t,o){nt();let s;typeof t=="string"?M?s=await Y(t):s=await this.fetchModelAndCopyToWasmMemory(t):s=t,[this.sessionId,this.inputNames,this.outputNames]=await Qe(s,o),ot()}async dispose(){return et(this.sessionId)}async run(t,o,s){nt();let r=[],a=[];Object.entries(t).forEach(u=>{let l=u[0],x=u[1],S=this.inputNames.indexOf(l);if(S===-1)throw new Error(`invalid input '${l}'`);r.push(x),a.push(S)});let n=[],i=[];Object.entries(o).forEach(u=>{let l=u[0],x=u[1],S=this.outputNames.indexOf(l);if(S===-1)throw new Error(`invalid output '${l}'`);n.push(x),i.push(S)});let c=r.map((u,l)=>st(u,()=>`input "${this.inputNames[a[l]]}"`)),f=n.map((u,l)=>u?st(u,()=>`output "${this.outputNames[i[l]]}"`):null),h=await tt(this.sessionId,a,c,i,f,s),y={};for(let u=0;u<h.length;u++)y[this.outputNames[i[u]]]=n[u]??Bt(h[u]);return ot(),y}startProfiling(){}endProfiling(){rt(this.sessionId)}}});var ut={};bt(ut,{OnnxruntimeWebAssemblyBackend:()=>se,initializeFlags:()=>it,wasmBackend:()=>Mt});import{env as _}from"onnxruntime-common";var it,se,Mt,ct=C(()=>{"use strict";he();at();it=()=>{if((typeof _.wasm.initTimeout!="number"||_.wasm.initTimeout<0)&&(_.wasm.initTimeout=0),_.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof _.wasm.proxy!="boolean"&&(_.wasm.proxy=!1),typeof _.wasm.trace!="boolean"&&(_.wasm.trace=!1),typeof _.wasm.numThreads!="number"||!Number.isInteger(_.wasm.numThreads)||_.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)_.wasm.numThreads=1;else{let e=typeof navigator>"u"?le("node:os").cpus().length:navigator.hardwareConcurrency;_.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},se=class{async init(t){it(),await Xe(),await Ze(t)}async createInferenceSessionHandler(t,o){let s=new oe;return await s.loadModel(t,o),Promise.resolve(s)}},Mt=new se});export*from"onnxruntime-common";import*as kt from"onnxruntime-common";import{registerBackend as lt,env as Dt}from"onnxruntime-common";var Le="1.22.0";var Cr=kt;{let e=(ct(),wt(ut)).wasmBackend;lt("cpu",e,10),lt("wasm",e,10)}Object.defineProperty(Dt.versions,"web",{value:Le,enumerable:!0});export{Cr as default};
//# sourceMappingURL=ort.node.min.mjs.map
