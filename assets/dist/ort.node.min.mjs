/*!
 * ONNX Runtime Web v1.22.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import{createRequire}from"module";const require=createRequire(import.meta.url);
var ce=Object.defineProperty;var mt=Object.getOwnPropertyDescriptor;var gt=Object.getOwnPropertyNames;var bt=Object.prototype.hasOwnProperty;var fe=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var A=(e,t)=>()=>(e&&(t=e(e=0)),t);var wt=(e,t)=>{for(var n in t)ce(e,n,{get:t[n],enumerable:!0})},yt=(e,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of gt(t))!bt.call(e,r)&&r!==n&&ce(e,r,{get:()=>t[r],enumerable:!(s=mt(t,r))||s.enumerable});return e};var St=e=>yt(ce({},"__esModule",{value:!0}),e);var D,Q=A(()=>{"use strict";D=!!(typeof process<"u"&&process.versions&&process.versions.node)});var Ue,ht,Et,M,Be,Ie,Ot,Tt,vt,Pt,_e,xe,le=A(()=>{"use strict";Q();Ue=D||typeof location>"u"?void 0:location.origin,ht=import.meta.url>"file:"&&import.meta.url<"file;",Et=()=>{if(!D){if(ht){let e=URL;return new URL(new e("ort.node.min.mjs",import.meta.url).href,Ue).href}return import.meta.url}},M=Et(),Be=()=>{if(M&&!M.startsWith("blob:"))return M.substring(0,M.lastIndexOf("/")+1)},Ie=(e,t)=>{try{let n=t??M;return(n?new URL(e,n):new URL(e)).origin===Ue}catch{return!1}},Ot=(e,t)=>{let n=t??M;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},Tt=(e,t)=>`${t??"./"}${e}`,vt=async e=>{let n=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(n)},Pt=async e=>(await import(/*webpackIgnore:true*/e)).default,_e=void 0,xe=async(e,t,n)=>{if(!e&&!t&&_e&&M&&Ie(M))return[void 0,_e];{let s="ort-wasm-simd-threaded.mjs",r=e??Ot(s,t),i=!D&&n&&r&&!Ie(r,t),o=i?await vt(r):r??Tt(s,t);return[i?o:void 0,await Pt(o)]}}});var pe,de,ee,Ae,Lt,It,Ce,S,$=A(()=>{"use strict";le();de=!1,ee=!1,Ae=!1,Lt=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},It=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ce=async e=>{if(de)return Promise.resolve();if(ee)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ae)throw new Error("previous call to 'initializeWebAssembly()' failed.");ee=!0;let t=e.initTimeout,n=e.numThreads;if(!It())throw new Error("WebAssembly SIMD is not supported in the current environment.");let s=Lt();n>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let r=e.wasmPaths,i=typeof r=="string"?r:void 0,o=r?.mjs,a=o?.href??o,c=r?.wasm,f=c?.href??c,l=e.wasmBinary,[w,u]=await xe(a,i,n>1),p=!1,L=[];if(t>0&&L.push(new Promise(E=>{setTimeout(()=>{p=!0,E()},t)})),L.push(new Promise((E,g)=>{let b={numThreads:n};if(l)b.wasmBinary=l;else if(f||i)b.locateFile=d=>f??i+d;else if(a&&a.indexOf("blob:")!==0)b.locateFile=d=>new URL(d,a).href;else if(w){let d=Be();d&&(b.locateFile=h=>d+h)}u(b).then(d=>{ee=!1,de=!0,pe=d,E(),w&&URL.revokeObjectURL(w)},d=>{ee=!1,Ae=!0,g(d)})})),await Promise.race(L),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},S=()=>{if(de&&pe)return pe;throw new Error("WebAssembly is not initialized yet.")}});var _,J,y,te=A(()=>{"use strict";$();_=(e,t)=>{let n=S(),s=n.lengthBytesUTF8(e)+1,r=n._malloc(s);return n.stringToUTF8(e,r,s),t.push(r),r},J=(e,t,n,s)=>{if(typeof e=="object"&&e!==null){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([r,i])=>{let o=t?t+r:r;if(typeof i=="object")J(i,o+".",n,s);else if(typeof i=="string"||typeof i=="number")s(o,i.toString());else if(typeof i=="boolean")s(o,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},y=e=>{let t=S(),n=t.stackSave();try{let s=t.PTR_SIZE,r=t.stackAlloc(2*s);t._OrtGetLastError(r,r+s);let i=Number(t.getValue(r,s===4?"i32":"i64")),o=t.getValue(r+s,"*"),a=o?t.UTF8ToString(o):"";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(n)}}});var De,Me=A(()=>{"use strict";$();te();De=e=>{let t=S(),n=0,s=[],r=e||{};try{if(e?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(r.terminate=!1);let i=0;return e?.tag!==void 0&&(i=_(e.tag,s)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,i),n===0&&y("Can't create run options."),e?.extra!==void 0&&J(e.extra,"",new WeakSet,(o,a)=>{let c=_(o,s),f=_(a,s);t._OrtAddRunConfigEntry(n,c,f)!==0&&y(`Can't set a run config entry: ${o} - ${a}.`)}),[n,s]}catch(i){throw n!==0&&t._OrtReleaseRunOptions(n),s.forEach(o=>t._free(o)),i}}});var _t,Ut,Bt,re,xt,ke,We=A(()=>{"use strict";$();te();_t=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Ut=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Bt=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(e.enableMemPattern=!1)},re=(e,t,n,s)=>{let r=_(t,s),i=_(n,s);S()._OrtAddSessionConfigEntry(e,r,i)!==0&&y(`Can't set a session config entry: ${t} - ${n}.`)},xt=async(e,t,n)=>{for(let s of t){let r=typeof s=="string"?s:s.name,i=[];switch(r){case"webnn":if(r="WEBNN",typeof s!="string"){let w=s?.deviceType;w&&re(e,"deviceType",w,n)}break;case"webgpu":if(r="JS",typeof s!="string"){let l=s;if(l?.preferredLayout){if(l.preferredLayout!=="NCHW"&&l.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${l.preferredLayout}`);re(e,"preferredLayout",l.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let o=_(r,n),a=i.length,c=0,f=0;if(a>0){c=S()._malloc(a*S().PTR_SIZE),n.push(c),f=S()._malloc(a*S().PTR_SIZE),n.push(f);for(let l=0;l<a;l++)S().setValue(c+l*S().PTR_SIZE,i[l][0],"*"),S().setValue(f+l*S().PTR_SIZE,i[l][1],"*")}await S()._OrtAppendExecutionProvider(e,o,c,f,a)!==0&&y(`Can't append execution provider: ${r}.`)}},ke=async e=>{let t=S(),n=0,s=[],r=e||{};Bt(r);try{let i=_t(r.graphOptimizationLevel??"all"),o=Ut(r.executionMode??"sequential"),a=typeof r.logId=="string"?_(r.logId,s):0,c=r.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let f=r.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let l=typeof r.optimizedModelFilePath=="string"?_(r.optimizedModelFilePath,s):0;if(n=t._OrtCreateSessionOptions(i,!!r.enableCpuMemArena,!!r.enableMemPattern,o,!!r.enableProfiling,0,a,c,f,l),n===0&&y("Can't create session options."),r.executionProviders&&await xt(n,r.executionProviders,s),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);re(n,"enableGraphCapture",r.enableGraphCapture.toString(),s)}if(r.freeDimensionOverrides)for(let[w,u]of Object.entries(r.freeDimensionOverrides)){if(typeof w!="string")throw new Error(`free dimension override name must be a string: ${w}`);if(typeof u!="number"||!Number.isInteger(u)||u<0)throw new Error(`free dimension override value must be a non-negative integer: ${u}`);let p=_(w,s);t._OrtAddFreeDimensionOverride(n,p,u)!==0&&y(`Can't set a free dimension override: ${w} - ${u}.`)}return r.extra!==void 0&&J(r.extra,"",new WeakSet,(w,u)=>{re(n,w,u,s)}),[n,s]}catch(i){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&y("Can't release session options."),s.forEach(o=>t._free(o)),i}}});var z,Fe,H,Re,Ne,ne,oe,je,me=A(()=>{"use strict";z=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},Fe=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},H=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],s=typeof t=="number"?t:t.reduce((r,i)=>r*i,1);return n>0?Math.ceil(s*n):void 0},Re=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Ne=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ne=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",oe=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",je=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var Y,ge=A(()=>{"use strict";Q();Y=async e=>{if(typeof e=="string")if(D)try{let{readFile:t}=fe("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:n}=fe("node:fs"),s=n(e),r=[];for await(let i of s)r.push(i);return new Uint8Array(Buffer.concat(r))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),s=n?parseInt(n,10):0;if(s<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),i;try{i=new ArrayBuffer(s)}catch(a){if(a instanceof RangeError){let c=Math.ceil(s/65536);i=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw a}let o=0;for(;;){let{done:a,value:c}=await r.read();if(a)break;let f=c.byteLength;new Uint8Array(i,o,f).set(c),o+=f}return new Uint8Array(i,0,s)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var At,$e,ze,V,Ct,be,He,Ve,Ge,qe,Je,Ye=A(()=>{"use strict";Me();We();me();$();te();ge();At=(e,t)=>{S()._OrtInit(e,t)!==0&&y("Can't initialize onnxruntime.")},$e=async e=>{At(e.wasm.numThreads,Ne(e.logLevel))},ze=async(e,t)=>{S().asyncInit?.()},V=new Map,Ct=e=>{let t=S(),n=t.stackSave();try{let s=t.PTR_SIZE,r=t.stackAlloc(2*s);t._OrtGetInputOutputCount(e,r,r+s)!==0&&y("Can't get session input/output count.");let o=s===4?"i32":"i64";return[Number(t.getValue(r,o)),Number(t.getValue(r+s,o))]}finally{t.stackRestore(n)}},be=e=>{let t=S(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},He=async(e,t)=>{let n,s,r=S();Array.isArray(e)?[n,s]=e:e.buffer===r.HEAPU8.buffer?[n,s]=[e.byteOffset,e.byteLength]:[n,s]=be(e);let i=0,o=0,a=0,c=[],f=[],l=[];try{if([o,c]=await ke(t),t?.externalData&&r.mountExternalData){let d=[];for(let h of t.externalData){let T=typeof h=="string"?h:h.path;d.push(Y(typeof h=="string"?h:h.data).then(B=>{r.mountExternalData(T,B)}))}await Promise.all(d)}for(let d of t?.executionProviders??[])if((typeof d=="string"?d:d.name)==="webnn"){if(r.shouldTransferToMLTensor=!1,typeof d!="string"){let T=d,B=T?.context,k=T?.gpuDevice,W=T?.deviceType,X=T?.powerPreference;B?r.currentContext=B:k?r.currentContext=await r.jsepCreateMLContext(k):r.currentContext=await r.jsepCreateMLContext({deviceType:W,powerPreference:X})}else r.currentContext=await r.jsepCreateMLContext();break}i=await r._OrtCreateSession(n,s,o),r.webgpuOnCreateSession?.(i),i===0&&y("Can't create a session."),r.jsepOnCreateSession?.(),r.currentContext&&(r.jsepRegisterMLContext(i,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[w,u]=Ct(i),p=!!t?.enableGraphCapture,L=[],E=[],g=[];for(let d=0;d<w;d++){let h=r._OrtGetInputName(i,d);h===0&&y("Can't get an input name."),f.push(h),L.push(r.UTF8ToString(h))}for(let d=0;d<u;d++){let h=r._OrtGetOutputName(i,d);h===0&&y("Can't get an output name."),l.push(h);let T=r.UTF8ToString(h);E.push(T)}return V.set(i,[i,f,l,null,p,!1]),[i,L,E]}catch(w){throw f.forEach(u=>r._OrtFree(u)),l.forEach(u=>r._OrtFree(u)),a!==0&&r._OrtReleaseBinding(a)!==0&&y("Can't release IO binding."),i!==0&&r._OrtReleaseSession(i)!==0&&y("Can't release session."),w}finally{r._free(n),o!==0&&r._OrtReleaseSessionOptions(o)!==0&&y("Can't release session options."),c.forEach(w=>r._free(w)),r.unmountExternalData?.()}},Ve=e=>{let t=S(),n=V.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,r,i,o,a]=n;o&&(a&&t._OrtClearBoundOutputs(o.handle)!==0&&y("Can't clear bound outputs."),t._OrtReleaseBinding(o.handle)!==0&&y("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),r.forEach(c=>t._OrtFree(c)),i.forEach(c=>t._OrtFree(c)),t._OrtReleaseSession(s)!==0&&y("Can't release session."),V.delete(e)},Ge=async(e,t,n,s,r,i=!1)=>{if(!e){t.push(0);return}let o=S(),a=o.PTR_SIZE,c=e[0],f=e[1],l=e[3],w=l,u,p;if(c==="string"&&(l==="gpu-buffer"||l==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(i&&l!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(l==="gpu-buffer"){let g=e[2].gpuBuffer;p=H(z(c),f);{let b=o.jsepRegisterBuffer;if(!b)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');u=b(s,r,g,p)}}else if(l==="ml-tensor"){let g=e[2].mlTensor;p=H(z(c),f);let b=o.jsepRegisterMLTensor;if(!b)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');u=b(s,g,z(c),f)}else{let g=e[2];if(Array.isArray(g)){p=a*g.length,u=o._malloc(p),n.push(u);for(let b=0;b<g.length;b++){if(typeof g[b]!="string")throw new TypeError(`tensor data at index ${b} is not a string`);o.setValue(u+b*a,_(g[b],n),"*")}}else{let b=o.jsepIsGraphInput;if(c!=="string"&&b){let d=o._OrtGetInputName(s,r),h=o.UTF8ToString(d);if(b(s,h)){let T=z(c);p=H(T,f),w="ml-tensor";let B=o.jsepCreateTemporaryTensor,k=o.jsepUploadTensor;if(!B||!k)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let W=await B(s,T,f);k(W,new Uint8Array(g.buffer,g.byteOffset,g.byteLength)),u=W}else p=g.byteLength,u=o._malloc(p),n.push(u),o.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,p),u)}else p=g.byteLength,u=o._malloc(p),n.push(u),o.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,p),u)}}let L=o.stackSave(),E=o.stackAlloc(4*f.length);try{f.forEach((b,d)=>o.setValue(E+d*a,b,a===4?"i32":"i64"));let g=o._OrtCreateTensor(z(c),u,p,E,f.length,je(w));g===0&&y(`Can't create tensor for input/output. session=${s}, index=${r}.`),t.push(g)}finally{o.stackRestore(L)}},qe=async(e,t,n,s,r,i)=>{let o=S(),a=o.PTR_SIZE,c=V.get(e);if(!c)throw new Error(`cannot run inference. invalid session id: ${e}`);let f=c[0],l=c[1],w=c[2],u=c[3],p=c[4],L=c[5],E=t.length,g=s.length,b=0,d=[],h=[],T=[],B=[],k=o.stackSave(),W=o.stackAlloc(E*a),X=o.stackAlloc(E*a),ae=o.stackAlloc(g*a),Ee=o.stackAlloc(g*a);try{[b,d]=De(i);for(let m=0;m<E;m++)await Ge(n[m],h,B,e,t[m],p);for(let m=0;m<g;m++)await Ge(r[m],T,B,e,E+s[m],p);for(let m=0;m<E;m++)o.setValue(W+m*a,h[m],"*"),o.setValue(X+m*a,l[t[m]],"*");for(let m=0;m<g;m++)o.setValue(ae+m*a,T[m],"*"),o.setValue(Ee+m*a,w[s[m]],"*");o.jsepOnRunStart?.(f);let x;x=await o._OrtRun(f,X,W,E,Ee,g,ae,b),x!==0&&y("failed to call OrtRun().");let j=[];for(let m=0;m<g;m++){let G=Number(o.getValue(ae+m*a,"*"));if(G===T[m]){j.push(r[m]);continue}let Oe=o.stackSave(),C=o.stackAlloc(4*a),q=!1,v,I=0;try{o._OrtGetTensorData(G,C,C+a,C+2*a,C+3*a)!==0&&y(`Can't access output tensor data on index ${m}.`);let ue=a===4?"i32":"i64",Z=Number(o.getValue(C,ue));I=o.getValue(C+a,"*");let Te=o.getValue(C+a*2,"*"),dt=Number(o.getValue(C+a*3,ue)),F=[];for(let P=0;P<dt;P++)F.push(Number(o.getValue(Te+P*a,ue)));o._OrtFree(Te)!==0&&y("Can't free memory for tensor dims.");let R=F.reduce((P,O)=>P*O,1);v=Fe(Z);let K=u?.outputPreferredLocations[s[m]];if(v==="string"){if(K==="gpu-buffer"||K==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let P=[];for(let O=0;O<R;O++){let N=o.getValue(I+O*a,"*"),ve=o.getValue(I+(O+1)*a,"*"),Pe=O===R-1?void 0:ve-N;P.push(o.UTF8ToString(N,Pe))}j.push([v,F,P,"cpu"])}else if(K==="gpu-buffer"&&R>0){let P=o.jsepGetBuffer;if(!P)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let O=P(I),N=H(Z,R);if(N===void 0||!ne(v))throw new Error(`Unsupported data type: ${v}`);q=!0,j.push([v,F,{gpuBuffer:O,download:o.jsepCreateDownloader(O,N,v),dispose:()=>{o._OrtReleaseTensor(G)!==0&&y("Can't release tensor.")}},"gpu-buffer"])}else if(K==="ml-tensor"&&R>0){let P=o.jsepEnsureTensor;if(!P)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(H(Z,R)===void 0||!oe(v))throw new Error(`Unsupported data type: ${v}`);let N=await P(e,I,Z,F,!1);q=!0,j.push([v,F,{mlTensor:N,download:o.jsepCreateMLTensorDownloader(I,v),dispose:()=>{o.jsepReleaseTensorId(I),o._OrtReleaseTensor(G)}},"ml-tensor"])}else{let P=Re(v),O=new P(R);new Uint8Array(O.buffer,O.byteOffset,O.byteLength).set(o.HEAPU8.subarray(I,I+O.byteLength)),j.push([v,F,O,"cpu"])}}finally{o.stackRestore(Oe),v==="string"&&I&&o._free(I),q||o._OrtReleaseTensor(G),o.jsepOnRunEnd?.(f)}}return u&&!p&&(o._OrtClearBoundOutputs(u.handle)!==0&&y("Can't clear bound outputs."),V.set(e,[f,l,w,u,p,!1])),j}finally{o.stackRestore(k),h.forEach(x=>o._OrtReleaseTensor(x)),T.forEach(x=>o._OrtReleaseTensor(x)),B.forEach(x=>o._free(x)),b!==0&&o._OrtReleaseRunOptions(b),d.forEach(x=>o._free(x))}},Je=e=>{let t=S(),n=V.get(e);if(!n)throw new Error("invalid session id");let s=n[0],r=t._OrtEndProfiling(s);r===0&&y("Can't get an profile file name."),t._OrtFree(r)}});import{env as ye}from"onnxruntime-common";var we,Xe,Ze,Ke,Qe,et,tt,rt,nt,ot,Se=A(()=>{"use strict";Ye();$();le();we=!1,Xe=!1,Ze=!1,Ke=async()=>{if(!Xe){if(we)throw new Error("multiple calls to 'initWasm()' detected.");if(Ze)throw new Error("previous call to 'initWasm()' failed.");we=!0;try{await Ce(ye.wasm),await $e(ye),Xe=!0}catch(e){throw Ze=!0,e}finally{we=!1}}},Qe=async e=>{await ze(ye,e)},et=async e=>be(e),tt=async(e,t)=>He(e,t),rt=async e=>{Ve(e)},nt=async(e,t,n,s,r,i)=>qe(e,t,n,s,r,i),ot=async e=>{Je(e)}});import{Tensor as he,TRACE_FUNC_BEGIN as st,TRACE_FUNC_END as it}from"onnxruntime-common";var at,Mt,se,ut=A(()=>{"use strict";Se();me();Q();ge();at=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Mt=e=>{switch(e[3]){case"cpu":return new he(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!ne(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:s,dispose:r}=e[2];return he.fromGpuBuffer(n,{dataType:t,dims:e[1],download:s,dispose:r})}case"ml-tensor":{let t=e[0];if(!oe(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:s,dispose:r}=e[2];return he.fromMLTensor(n,{dataType:t,dims:e[1],download:s,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},se=class{async fetchModelAndCopyToWasmMemory(t){return et(await Y(t))}async loadModel(t,n){st();let s;typeof t=="string"?D?s=await Y(t):s=await this.fetchModelAndCopyToWasmMemory(t):s=t,[this.sessionId,this.inputNames,this.outputNames]=await tt(s,n),it()}async dispose(){return rt(this.sessionId)}async run(t,n,s){st();let r=[],i=[];Object.entries(t).forEach(u=>{let p=u[0],L=u[1],E=this.inputNames.indexOf(p);if(E===-1)throw new Error(`invalid input '${p}'`);r.push(L),i.push(E)});let o=[],a=[];Object.entries(n).forEach(u=>{let p=u[0],L=u[1],E=this.outputNames.indexOf(p);if(E===-1)throw new Error(`invalid output '${p}'`);o.push(L),a.push(E)});let c=r.map((u,p)=>at(u,()=>`input "${this.inputNames[i[p]]}"`)),f=o.map((u,p)=>u?at(u,()=>`output "${this.outputNames[a[p]]}"`):null),l=await nt(this.sessionId,i,c,a,f,s),w={};for(let u=0;u<l.length;u++)w[this.outputNames[a[u]]]=o[u]??Mt(l[u]);return it(),w}startProfiling(){}endProfiling(){ot(this.sessionId)}}});var ft={};wt(ft,{OnnxruntimeWebAssemblyBackend:()=>ie,initializeFlags:()=>ct,wasmBackend:()=>kt});import{env as U}from"onnxruntime-common";var ct,ie,kt,lt=A(()=>{"use strict";Se();ut();ct=()=>{if((typeof U.wasm.initTimeout!="number"||U.wasm.initTimeout<0)&&(U.wasm.initTimeout=0),U.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof U.wasm.proxy!="boolean"&&(U.wasm.proxy=!1),typeof U.wasm.trace!="boolean"&&(U.wasm.trace=!1),typeof U.wasm.numThreads!="number"||!Number.isInteger(U.wasm.numThreads)||U.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)U.wasm.numThreads=1;else{let e=typeof navigator>"u"?fe("node:os").cpus().length:navigator.hardwareConcurrency;U.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},ie=class{async init(t){ct(),await Ke(),await Qe(t)}async createInferenceSessionHandler(t,n){let s=new se;return await s.loadModel(t,n),Promise.resolve(s)}},kt=new ie});export*from"onnxruntime-common";import*as Wt from"onnxruntime-common";import{registerBackend as pt,env as Ft}from"onnxruntime-common";var Le="1.22.0";var Mr=Wt;{let e=(lt(),St(ft)).wasmBackend;pt("cpu",e,10),pt("wasm",e,10)}Object.defineProperty(Ft.versions,"web",{value:Le,enumerable:!0});export{Mr as default};
//# sourceMappingURL=ort.node.min.mjs.map
