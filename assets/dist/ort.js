/*!
 * ONNX Runtime Web v1.23.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";
var ort = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // common/dist/esm/backend-impl.js
  var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
  var init_backend_impl = __esm({
    "common/dist/esm/backend-impl.js"() {
      "use strict";
      backends = /* @__PURE__ */ new Map();
      backendsSortedByPriority = [];
      registerBackend = (name, backend, priority) => {
        if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
          const currentBackend = backends.get(name);
          if (currentBackend === void 0) {
            backends.set(name, { backend, priority });
          } else if (currentBackend.priority > priority) {
            return;
          } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
              throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
          }
          if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
              backendsSortedByPriority.splice(i, 1);
            }
            for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
              if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
                backendsSortedByPriority.splice(i2, 0, name);
                return;
              }
            }
            backendsSortedByPriority.push(name);
          }
          return;
        }
        throw new TypeError("not a valid backend");
      };
      tryResolveAndInitializeBackend = async (backendName) => {
        const backendInfo = backends.get(backendName);
        if (!backendInfo) {
          return "backend not found.";
        }
        if (backendInfo.initialized) {
          return backendInfo.backend;
        } else if (backendInfo.aborted) {
          return backendInfo.error;
        } else {
          const isInitializing = !!backendInfo.initPromise;
          try {
            if (!isInitializing) {
              backendInfo.initPromise = backendInfo.backend.init(backendName);
            }
            await backendInfo.initPromise;
            backendInfo.initialized = true;
            return backendInfo.backend;
          } catch (e) {
            if (!isInitializing) {
              backendInfo.error = `${e}`;
              backendInfo.aborted = true;
            }
            return backendInfo.error;
          } finally {
            delete backendInfo.initPromise;
          }
        }
      };
      resolveBackendAndExecutionProviders = async (options) => {
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
        const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
        let backend;
        const errors = [];
        const availableBackendNames = /* @__PURE__ */ new Set();
        for (const backendName of backendNames) {
          const resolveResult = await tryResolveAndInitializeBackend(backendName);
          if (typeof resolveResult === "string") {
            errors.push({ name: backendName, err: resolveResult });
          } else {
            if (!backend) {
              backend = resolveResult;
            }
            if (backend === resolveResult) {
              availableBackendNames.add(backendName);
            }
          }
        }
        if (!backend) {
          throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
        }
        for (const { name, err } of errors) {
          if (backendHints.includes(name)) {
            console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
          }
        }
        const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
        return [
          backend,
          new Proxy(options, {
            get: (target, prop) => {
              if (prop === "executionProviders") {
                return filteredEps;
              }
              return Reflect.get(target, prop);
            }
          })
        ];
      };
    }
  });

  // common/dist/esm/backend.js
  var init_backend = __esm({
    "common/dist/esm/backend.js"() {
      "use strict";
      init_backend_impl();
    }
  });

  // common/dist/esm/version.js
  var version;
  var init_version = __esm({
    "common/dist/esm/version.js"() {
      "use strict";
      version = "1.23.0";
    }
  });

  // common/dist/esm/env-impl.js
  var logLevelValue, env;
  var init_env_impl = __esm({
    "common/dist/esm/env-impl.js"() {
      "use strict";
      init_version();
      logLevelValue = "warning";
      env = {
        wasm: {},
        webgl: {},
        webgpu: {},
        versions: { common: version },
        set logLevel(value) {
          if (value === void 0) {
            return;
          }
          if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
          }
          logLevelValue = value;
        },
        get logLevel() {
          return logLevelValue;
        }
      };
      Object.defineProperty(env, "logLevel", { enumerable: true });
    }
  });

  // common/dist/esm/env.js
  var env2;
  var init_env = __esm({
    "common/dist/esm/env.js"() {
      "use strict";
      init_env_impl();
      env2 = env;
    }
  });

  // common/dist/esm/tensor-conversion-impl.js
  var tensorToDataURL, tensorToImageData;
  var init_tensor_conversion_impl = __esm({
    "common/dist/esm/tensor-conversion-impl.js"() {
      "use strict";
      tensorToDataURL = (tensor, options) => {
        const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
        canvas.width = tensor.dims[3];
        canvas.height = tensor.dims[2];
        const pixels2DContext = canvas.getContext("2d");
        if (pixels2DContext != null) {
          let width;
          let height;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
          }
          const inputformat = options?.format !== void 0 ? options.format : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          for (let i = 0; i < height; i++) {
            for (let j = 0; j < width; j++) {
              const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
              const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
              const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
              const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
              pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
              pixels2DContext.fillRect(j, i, 1, 1);
            }
          }
          if ("toDataURL" in canvas) {
            return canvas.toDataURL();
          } else {
            throw new Error("toDataURL is not supported");
          }
        } else {
          throw new Error("Can not access image data");
        }
      };
      tensorToImageData = (tensor, options) => {
        const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
        let image;
        if (pixels2DContext != null) {
          let width;
          let height;
          let channels;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[1];
            channels = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
            channels = tensor.dims[1];
          }
          const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          if (options !== void 0) {
            if (options.format !== void 0 && channels === 4 && options.format !== "RGBA" || channels === 3 && options.format !== "RGB" && options.format !== "BGR") {
              throw new Error("Tensor format doesn't match input tensor dims");
            }
          }
          const step = 4;
          let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          image = pixels2DContext.createImageData(width, height);
          for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
          }
        } else {
          throw new Error("Can not access image data");
        }
        return image;
      };
    }
  });

  // common/dist/esm/tensor-factory-impl.js
  var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromMLTensor, tensorFromPinnedBuffer;
  var init_tensor_factory_impl = __esm({
    "common/dist/esm/tensor-factory-impl.js"() {
      "use strict";
      init_tensor_impl();
      bufferToTensor = (buffer, options) => {
        if (buffer === void 0) {
          throw new Error("Image buffer must be defined");
        }
        if (options.height === void 0 || options.width === void 0) {
          throw new Error("Image height and width must be defined");
        }
        if (options.tensorLayout === "NHWC") {
          throw new Error("NHWC Tensor layout is not supported yet");
        }
        const { height, width } = options;
        const norm = options.norm ?? { mean: 255, bias: 0 };
        let normMean;
        let normBias;
        if (typeof norm.mean === "number") {
          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
        } else {
          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
        }
        if (typeof norm.bias === "number") {
          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
        } else {
          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
        }
        const inputformat = options.format !== void 0 ? options.format : "RGBA";
        const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
        const stride = height * width;
        const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGB") {
          step = 3;
          rImagePointer = 0;
          gImagePointer = 1;
          bImagePointer = 2;
          aImagePointer = -1;
        }
        if (outputformat === "RGBA") {
          aTensorPointer = stride * 3;
        } else if (outputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        } else if (outputformat === "BGR") {
          bTensorPointer = 0;
          gTensorPointer = stride;
          rTensorPointer = stride * 2;
        }
        for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
          float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
          float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
          float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
          if (aTensorPointer !== -1 && aImagePointer !== -1) {
            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
          }
        }
        const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
        return outputTensor;
      };
      tensorFromImage = async (image, options) => {
        const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
        const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
        const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
        const isString = typeof image === "string";
        let data;
        let bufferToTensorOptions = options ?? {};
        const createCanvas = () => {
          if (typeof document !== "undefined") {
            return document.createElement("canvas");
          } else if (typeof OffscreenCanvas !== "undefined") {
            return new OffscreenCanvas(1, 1);
          } else {
            throw new Error("Canvas is not supported");
          }
        };
        const createCanvasContext = (canvas) => {
          if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
            return canvas.getContext("2d");
          } else if (canvas instanceof OffscreenCanvas) {
            return canvas.getContext("2d");
          } else {
            return null;
          }
        };
        if (isHTMLImageEle) {
          const canvas = createCanvas();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            let height = image.height;
            let width = image.width;
            if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
              height = options.resizedHeight;
              width = options.resizedWidth;
            }
            if (options !== void 0) {
              bufferToTensorOptions = options;
              if (options.tensorFormat !== void 0) {
                throw new Error("Image input config format must be RGBA for HTMLImageElement");
              } else {
                bufferToTensorOptions.tensorFormat = "RGBA";
              }
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            }
            pixels2DContext.drawImage(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isImageDataEle) {
          let height;
          let width;
          if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          } else {
            height = image.height;
            width = image.width;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
          }
          bufferToTensorOptions.format = "RGBA";
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          if (options !== void 0) {
            const tempCanvas = createCanvas();
            tempCanvas.width = width;
            tempCanvas.height = height;
            const pixels2DContext = createCanvasContext(tempCanvas);
            if (pixels2DContext != null) {
              pixels2DContext.putImageData(image, 0, 0);
              data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
              throw new Error("Can not access image data");
            }
          } else {
            data = image.data;
          }
        } else if (isImageBitmap) {
          if (options === void 0) {
            throw new Error("Please provide image config with format for Imagebitmap");
          }
          const canvas = createCanvas();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            const height = image.height;
            const width = image.width;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
            return bufferToTensor(data, bufferToTensorOptions);
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isString) {
          return new Promise((resolve, reject) => {
            const canvas = createCanvas();
            const context = createCanvasContext(canvas);
            if (!image || !context) {
              return reject();
            }
            const newImage = new Image();
            newImage.crossOrigin = "Anonymous";
            newImage.src = image;
            newImage.onload = () => {
              canvas.width = newImage.width;
              canvas.height = newImage.height;
              context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
              const img = context.getImageData(0, 0, canvas.width, canvas.height);
              bufferToTensorOptions.height = canvas.height;
              bufferToTensorOptions.width = canvas.width;
              resolve(bufferToTensor(img.data, bufferToTensorOptions));
            };
          });
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
        if (data !== void 0) {
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
      };
      tensorFromTexture = (texture, options) => {
        const { width, height, download, dispose } = options;
        const dims = [1, height, width, 4];
        return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
      };
      tensorFromGpuBuffer = (gpuBuffer, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
      };
      tensorFromMLTensor = (mlTensor, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "ml-tensor", type: dataType ?? "float32", mlTensor, dims, download, dispose });
      };
      tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
    }
  });

  // common/dist/esm/tensor-impl-type-mapping.js
  var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
  var init_tensor_impl_type_mapping = __esm({
    "common/dist/esm/tensor-impl-type-mapping.js"() {
      "use strict";
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
        ["float32", Float32Array],
        ["uint8", Uint8Array],
        ["int8", Int8Array],
        ["uint16", Uint16Array],
        ["int16", Int16Array],
        ["int32", Int32Array],
        ["bool", Uint8Array],
        ["float64", Float64Array],
        ["uint32", Uint32Array],
        ["int4", Uint8Array],
        ["uint4", Uint8Array]
      ]);
      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
        [Float32Array, "float32"],
        [Uint8Array, "uint8"],
        [Int8Array, "int8"],
        [Uint16Array, "uint16"],
        [Int16Array, "int16"],
        [Int32Array, "int32"],
        [Float64Array, "float64"],
        [Uint32Array, "uint32"]
      ]);
      isTypedArrayChecked = false;
      checkTypedArray = () => {
        if (!isTypedArrayChecked) {
          isTypedArrayChecked = true;
          const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
          const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
          const Float16Array2 = globalThis.Float16Array;
          const isFloat16ArrayAvailable = typeof Float16Array2 !== "undefined" && Float16Array2.from;
          if (isBigInt64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
          }
          if (isBigUint64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
          }
          if (isFloat16ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array2);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array2, "float16");
          } else {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
          }
        }
      };
    }
  });

  // common/dist/esm/tensor-utils-impl.js
  var calculateSize, tensorReshape;
  var init_tensor_utils_impl = __esm({
    "common/dist/esm/tensor-utils-impl.js"() {
      "use strict";
      init_tensor_impl();
      calculateSize = (dims) => {
        let size = 1;
        for (let i = 0; i < dims.length; i++) {
          const dim = dims[i];
          if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
          }
          if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
          }
          size *= dim;
        }
        return size;
      };
      tensorReshape = (tensor, dims) => {
        switch (tensor.location) {
          case "cpu":
            return new Tensor(tensor.type, tensor.data, dims);
          case "cpu-pinned":
            return new Tensor({
              location: "cpu-pinned",
              data: tensor.data,
              type: tensor.type,
              dims
            });
          case "texture":
            return new Tensor({
              location: "texture",
              texture: tensor.texture,
              type: tensor.type,
              dims
            });
          case "gpu-buffer":
            return new Tensor({
              location: "gpu-buffer",
              gpuBuffer: tensor.gpuBuffer,
              type: tensor.type,
              dims
            });
          case "ml-tensor":
            return new Tensor({
              location: "ml-tensor",
              mlTensor: tensor.mlTensor,
              type: tensor.type,
              dims
            });
          default:
            throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
        }
      };
    }
  });

  // common/dist/esm/tensor-impl.js
  var Tensor;
  var init_tensor_impl = __esm({
    "common/dist/esm/tensor-impl.js"() {
      "use strict";
      init_tensor_conversion_impl();
      init_tensor_factory_impl();
      init_tensor_impl_type_mapping();
      init_tensor_utils_impl();
      Tensor = class {
        /**
         * implementation.
         */
        constructor(arg0, arg1, arg2) {
          checkTypedArray();
          let type;
          let dims;
          if (typeof arg0 === "object" && "location" in arg0) {
            this.dataLocation = arg0.location;
            type = arg0.type;
            dims = arg0.dims;
            switch (arg0.location) {
              case "cpu-pinned": {
                const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
                if (!expectedTypedArrayConstructor) {
                  throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
                }
                if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                  throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
                }
                this.cpuData = arg0.data;
                break;
              }
              case "texture": {
                if (type !== "float32") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
                }
                this.gpuTextureData = arg0.texture;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "gpu-buffer": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
                }
                this.gpuBufferData = arg0.gpuBuffer;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "ml-tensor": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint64" && type !== "int8" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
                }
                this.mlTensorData = arg0.mlTensor;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              default:
                throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
            }
          } else {
            let data;
            let maybeDims;
            if (typeof arg0 === "string") {
              type = arg0;
              maybeDims = arg2;
              if (arg0 === "string") {
                if (!Array.isArray(arg1)) {
                  throw new TypeError("A string tensor's data must be a string array.");
                }
                data = arg1;
              } else {
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === void 0) {
                  throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                  if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
                    throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
                  } else if (arg0 === "uint64" || arg0 === "int64") {
                    data = typedArrayConstructor.from(arg1, BigInt);
                  } else {
                    data = typedArrayConstructor.from(arg1);
                  }
                } else if (arg1 instanceof typedArrayConstructor) {
                  data = arg1;
                } else if (arg1 instanceof Uint8ClampedArray) {
                  if (arg0 === "uint8") {
                    data = Uint8Array.from(arg1);
                  } else {
                    throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
                  }
                } else if (arg0 === "float16" && arg1 instanceof Uint16Array && typedArrayConstructor !== Uint16Array) {
                  data = new globalThis.Float16Array(arg1.buffer, arg1.byteOffset, arg1.length);
                } else {
                  throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
              }
            } else {
              maybeDims = arg1;
              if (Array.isArray(arg0)) {
                if (arg0.length === 0) {
                  throw new TypeError("Tensor type cannot be inferred from an empty array.");
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === "string") {
                  type = "string";
                  data = arg0;
                } else if (firstElementType === "boolean") {
                  type = "bool";
                  data = Uint8Array.from(arg0);
                } else {
                  throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
              } else if (arg0 instanceof Uint8ClampedArray) {
                type = "uint8";
                data = Uint8Array.from(arg0);
              } else {
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === void 0) {
                  throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
              }
            }
            if (maybeDims === void 0) {
              maybeDims = [data.length];
            } else if (!Array.isArray(maybeDims)) {
              throw new TypeError("A tensor's dims must be a number array");
            }
            dims = maybeDims;
            this.cpuData = data;
            this.dataLocation = "cpu";
          }
          const size = calculateSize(dims);
          if (this.cpuData && size !== this.cpuData.length) {
            if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {
            } else {
              throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
            }
          }
          this.type = type;
          this.dims = dims;
          this.size = size;
        }
        // #endregion
        // #region factory
        static async fromImage(image, options) {
          return tensorFromImage(image, options);
        }
        static fromTexture(texture, options) {
          return tensorFromTexture(texture, options);
        }
        static fromGpuBuffer(gpuBuffer, options) {
          return tensorFromGpuBuffer(gpuBuffer, options);
        }
        static fromMLTensor(mlTensor, options) {
          return tensorFromMLTensor(mlTensor, options);
        }
        static fromPinnedBuffer(type, buffer, dims) {
          return tensorFromPinnedBuffer(type, buffer, dims);
        }
        // #endregion
        // #region conversions
        toDataURL(options) {
          return tensorToDataURL(this, options);
        }
        toImageData(options) {
          return tensorToImageData(this, options);
        }
        // #endregion
        // #region properties
        get data() {
          this.ensureValid();
          if (!this.cpuData) {
            throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
          }
          return this.cpuData;
        }
        get location() {
          return this.dataLocation;
        }
        get texture() {
          this.ensureValid();
          if (!this.gpuTextureData) {
            throw new Error("The data is not stored as a WebGL texture.");
          }
          return this.gpuTextureData;
        }
        get gpuBuffer() {
          this.ensureValid();
          if (!this.gpuBufferData) {
            throw new Error("The data is not stored as a WebGPU buffer.");
          }
          return this.gpuBufferData;
        }
        get mlTensor() {
          this.ensureValid();
          if (!this.mlTensorData) {
            throw new Error("The data is not stored as a WebNN MLTensor.");
          }
          return this.mlTensorData;
        }
        // #endregion
        // #region methods
        async getData(releaseData) {
          this.ensureValid();
          switch (this.dataLocation) {
            case "cpu":
            case "cpu-pinned":
              return this.data;
            case "texture":
            case "gpu-buffer":
            case "ml-tensor": {
              if (!this.downloader) {
                throw new Error("The current tensor is not created with a specified data downloader.");
              }
              if (this.isDownloading) {
                throw new Error("The current tensor is being downloaded.");
              }
              try {
                this.isDownloading = true;
                const data = await this.downloader();
                this.downloader = void 0;
                this.dataLocation = "cpu";
                this.cpuData = data;
                if (releaseData && this.disposer) {
                  this.disposer();
                  this.disposer = void 0;
                }
                return data;
              } finally {
                this.isDownloading = false;
              }
            }
            default:
              throw new Error(`cannot get data from location: ${this.dataLocation}`);
          }
        }
        dispose() {
          if (this.isDownloading) {
            throw new Error("The current tensor is being downloaded.");
          }
          if (this.disposer) {
            this.disposer();
            this.disposer = void 0;
          }
          this.cpuData = void 0;
          this.gpuTextureData = void 0;
          this.gpuBufferData = void 0;
          this.mlTensorData = void 0;
          this.downloader = void 0;
          this.isDownloading = void 0;
          this.dataLocation = "none";
        }
        // #endregion
        // #region tensor utilities
        ensureValid() {
          if (this.dataLocation === "none") {
            throw new Error("The tensor is disposed.");
          }
        }
        reshape(dims) {
          this.ensureValid();
          if (this.downloader || this.disposer) {
            throw new Error("Cannot reshape a tensor that owns GPU resource.");
          }
          return tensorReshape(this, dims);
        }
      };
    }
  });

  // common/dist/esm/tensor.js
  var Tensor2;
  var init_tensor = __esm({
    "common/dist/esm/tensor.js"() {
      "use strict";
      init_tensor_impl();
      Tensor2 = Tensor;
    }
  });

  // common/dist/esm/trace.js
  var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END, TRACE_EVENT_BEGIN, TRACE_EVENT_END;
  var init_trace = __esm({
    "common/dist/esm/trace.js"() {
      "use strict";
      init_env_impl();
      TRACE = (deviceType, label) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.timeStamp(`${deviceType}::ORT::${label}`);
      };
      TRACE_FUNC = (msg, extraMsg) => {
        const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
        let hasTraceFunc = false;
        for (let i = 0; i < stack.length; i++) {
          if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
            let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
            if (extraMsg) {
              label += `::${extraMsg}`;
            }
            TRACE("CPU", label);
            return;
          }
          if (stack[i].includes("TRACE_FUNC")) {
            hasTraceFunc = true;
          }
        }
      };
      TRACE_FUNC_BEGIN = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("BEGIN", extraMsg);
      };
      TRACE_FUNC_END = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("END", extraMsg);
      };
      TRACE_EVENT_BEGIN = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.time(`ORT::${extraMsg}`);
      };
      TRACE_EVENT_END = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.timeEnd(`ORT::${extraMsg}`);
      };
    }
  });

  // common/dist/esm/inference-session-impl.js
  var InferenceSession;
  var init_inference_session_impl = __esm({
    "common/dist/esm/inference-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      init_trace();
      InferenceSession = class _InferenceSession {
        constructor(handler) {
          this.handler = handler;
        }
        async run(feeds, arg1, arg2) {
          TRACE_FUNC_BEGIN();
          TRACE_EVENT_BEGIN("InferenceSession.run");
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name of arg1) {
                if (typeof name !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (this.outputNames.indexOf(name) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                }
                fetches[name] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name of this.outputNames) {
                if (arg1Keys.indexOf(name) !== -1) {
                  const v = arg1[name];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name of this.inputNames) {
            if (typeof feeds[name] === "undefined") {
              throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name of this.outputNames) {
              fetches[name] = null;
            }
          }
          const results = await this.handler.run(feeds, fetches, options);
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          TRACE_EVENT_END("InferenceSession.run");
          TRACE_FUNC_END();
          return returnValue;
        }
        async release() {
          return this.handler.dispose();
        }
        static async create(arg0, arg1, arg2, arg3) {
          TRACE_FUNC_BEGIN();
          TRACE_EVENT_BEGIN("InferenceSession.create");
          let filePathOrUint8Array;
          let options = {};
          if (typeof arg0 === "string") {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 === "number") {
              byteOffset = arg1;
              if (!Number.isSafeInteger(byteOffset)) {
                throw new RangeError("'byteOffset' must be an integer.");
              }
              if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
              }
              byteLength = arg0.byteLength - byteOffset;
              if (typeof arg2 === "number") {
                byteLength = arg2;
                if (!Number.isSafeInteger(byteLength)) {
                  throw new RangeError("'byteLength' must be an integer.");
                }
                if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                  throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                }
                if (typeof arg3 === "object" && arg3 !== null) {
                  options = arg3;
                } else if (typeof arg3 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'byteLength' must be a number.");
              }
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
          } else {
            throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
          }
          const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
          TRACE_EVENT_END("InferenceSession.create");
          TRACE_FUNC_END();
          return new _InferenceSession(handler);
        }
        startProfiling() {
          this.handler.startProfiling();
        }
        endProfiling() {
          this.handler.endProfiling();
        }
        get inputNames() {
          return this.handler.inputNames;
        }
        get outputNames() {
          return this.handler.outputNames;
        }
        get inputMetadata() {
          return this.handler.inputMetadata;
        }
        get outputMetadata() {
          return this.handler.outputMetadata;
        }
      };
    }
  });

  // common/dist/esm/inference-session.js
  var InferenceSession2;
  var init_inference_session = __esm({
    "common/dist/esm/inference-session.js"() {
      "use strict";
      init_inference_session_impl();
      InferenceSession2 = InferenceSession;
    }
  });

  // common/dist/esm/tensor-conversion.js
  var init_tensor_conversion = __esm({
    "common/dist/esm/tensor-conversion.js"() {
      "use strict";
    }
  });

  // common/dist/esm/tensor-factory.js
  var init_tensor_factory = __esm({
    "common/dist/esm/tensor-factory.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-model.js
  var init_onnx_model = __esm({
    "common/dist/esm/onnx-model.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-value.js
  var init_onnx_value = __esm({
    "common/dist/esm/onnx-value.js"() {
      "use strict";
    }
  });

  // common/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_EVENT_BEGIN: () => TRACE_EVENT_BEGIN,
    TRACE_EVENT_END: () => TRACE_EVENT_END,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  var init_esm = __esm({
    "common/dist/esm/index.js"() {
      "use strict";
      init_backend();
      init_env();
      init_inference_session();
      init_tensor();
      init_tensor_conversion();
      init_tensor_factory();
      init_trace();
      init_onnx_model();
      init_onnx_value();
    }
  });

  // web/lib/wasm/wasm-utils-env.ts
  var isNode;
  var init_wasm_utils_env = __esm({
    "web/lib/wasm/wasm-utils-env.ts"() {
      "use strict";
      isNode = false;
    }
  });

  // web/lib/wasm/proxy-worker/main.ts
  var main_exports = {};
  __export(main_exports, {
    default: () => main_default
  });
  var WORKER_NAME, isProxyWorker, main_default;
  var init_main = __esm({
    "web/lib/wasm/proxy-worker/main.ts"() {
      "use strict";
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      WORKER_NAME = "ort-wasm-proxy-worker";
      isProxyWorker = globalThis.self?.name === WORKER_NAME;
      if (isProxyWorker) {
        self.onmessage = (ev) => {
          const { type, in: message } = ev.data;
          try {
            switch (type) {
              case "init-wasm":
                initializeWebAssembly(message.wasm).then(
                  () => {
                    initRuntime(message).then(
                      () => {
                        postMessage({ type });
                      },
                      (err) => {
                        postMessage({ type, err });
                      }
                    );
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              case "init-ep": {
                const { epName, env: env3 } = message;
                initEp(env3, epName).then(
                  () => {
                    postMessage({ type });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "copy-from": {
                const { buffer } = message;
                const bufferData = copyFromExternalBuffer(buffer);
                postMessage({ type, out: bufferData });
                break;
              }
              case "create": {
                const { model, options } = message;
                createSession(model, options).then(
                  (sessionMetadata) => {
                    postMessage({ type, out: sessionMetadata });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "release":
                releaseSession(message);
                postMessage({ type });
                break;
              case "run": {
                const { sessionId, inputIndices, inputs, outputIndices, options } = message;
                run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                  (outputs) => {
                    if (outputs.some((o) => o[3] !== "cpu")) {
                      postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                    } else {
                      postMessage(
                        { type, out: outputs },
                        extractTransferableBuffers([...inputs, ...outputs])
                      );
                    }
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "end-profiling":
                endProfiling(message);
                postMessage({ type });
                break;
              default:
            }
          } catch (err) {
            postMessage({ type, err });
          }
        };
      }
      main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: false ? "module" : "classic", name: WORKER_NAME });
    }
  });

  // web/lib/wasm/wasm-utils-import.ts
  var origin, getScriptSrc, scriptSrc, inferWasmPathPrefixFromScriptSrc, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, embeddedWasmModule, importWasmModule;
  var init_wasm_utils_import = __esm({
    "web/lib/wasm/wasm-utils-import.ts"() {
      "use strict";
      init_wasm_utils_env();
      origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
      getScriptSrc = () => {
        if (isNode) {
          return void 0;
        }
        if (false) {
          if (isEsmImportMetaUrlHardcodedAsFileUri) {
            const URL2 = URL;
            return new URL(new URL2("ort.js", void 0).href, origin).href;
          }
          return void 0;
        }
        return typeof document !== "undefined" ? document.currentScript?.src : (
          // use `self.location.href` if available
          typeof self !== "undefined" ? self.location?.href : void 0
        );
      };
      scriptSrc = getScriptSrc();
      inferWasmPathPrefixFromScriptSrc = () => {
        if (scriptSrc && !scriptSrc.startsWith("blob:")) {
          return scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
        }
        return void 0;
      };
      isSameOrigin = (filename, prefixOverride) => {
        try {
          const baseUrl = prefixOverride ?? scriptSrc;
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.origin === origin;
        } catch {
          return false;
        }
      };
      normalizeUrl = (filename, prefixOverride) => {
        const baseUrl = prefixOverride ?? scriptSrc;
        try {
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.href;
        } catch {
          return void 0;
        }
      };
      fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
      preload = async (absoluteUrl) => {
        const response = await fetch(absoluteUrl, { credentials: "same-origin" });
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      };
      dynamicImportDefault = async (url) => (await import(
        /* webpackIgnore: true */
        url
      )).default;
      createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
      importProxyWorker = async () => {
        if (!scriptSrc) {
          throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
        }
        if (isSameOrigin(scriptSrc)) {
          return [void 0, createProxyWorker()];
        }
        const url = await preload(scriptSrc);
        return [url, createProxyWorker(url)];
      };
      embeddedWasmModule = false ? (
        // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
        (true ? null : false ? null : null).default
      ) : void 0;
      importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded, isWasmOverridden) => {
        let useEmbeddedModule = embeddedWasmModule && !(urlOverride || prefixOverride);
        if (useEmbeddedModule) {
          if (!scriptSrc) {
            if (isWasmOverridden && !isMultiThreaded) {
              useEmbeddedModule = true;
            } else {
              throw new Error("cannot determine the script source URL.");
            }
          } else {
            useEmbeddedModule = isSameOrigin(scriptSrc);
          }
        }
        if (useEmbeddedModule) {
          return [void 0, embeddedWasmModule];
        } else {
          const wasmModuleFilename = true ? "ort-wasm-simd-threaded.jsep.mjs" : false ? "ort-wasm-simd-threaded.asyncify.mjs" : "ort-wasm-simd-threaded.mjs";
          const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
          const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
          const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
          return [needPreload ? url : void 0, await dynamicImportDefault(url)];
        }
      };
    }
  });

  // web/lib/wasm/wasm-factory.ts
  var wasm, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, isRelaxedSimdSupported, initializeWebAssembly, getInstance;
  var init_wasm_factory = __esm({
    "web/lib/wasm/wasm-factory.ts"() {
      "use strict";
      init_wasm_utils_import();
      initialized = false;
      initializing = false;
      aborted = false;
      isMultiThreadSupported = () => {
        if (typeof SharedArrayBuffer === "undefined") {
          return false;
        }
        try {
          if (typeof MessageChannel !== "undefined") {
            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
          }
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              5,
              4,
              1,
              3,
              1,
              1,
              10,
              11,
              1,
              9,
              0,
              65,
              0,
              254,
              16,
              2,
              0,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      isSimdSupported = () => {
        try {
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              10,
              30,
              1,
              28,
              0,
              65,
              0,
              253,
              15,
              253,
              12,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              253,
              186,
              1,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      isRelaxedSimdSupported = () => {
        try {
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              5,
              1,
              96,
              0,
              1,
              123,
              3,
              2,
              1,
              0,
              10,
              19,
              1,
              17,
              0,
              65,
              1,
              253,
              15,
              65,
              2,
              253,
              15,
              65,
              3,
              253,
              15,
              253,
              147,
              2,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      initializeWebAssembly = async (flags) => {
        if (initialized) {
          return Promise.resolve();
        }
        if (initializing) {
          throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        }
        if (aborted) {
          throw new Error("previous call to 'initializeWebAssembly()' failed.");
        }
        initializing = true;
        const timeout = flags.initTimeout;
        let numThreads = flags.numThreads;
        if (flags.simd === false) {
        } else if (flags.simd === "relaxed") {
          if (!isRelaxedSimdSupported()) {
            throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.");
          }
        } else if (!isSimdSupported()) {
          throw new Error("WebAssembly SIMD is not supported in the current environment.");
        }
        const multiThreadSupported = isMultiThreadSupported();
        if (numThreads > 1 && !multiThreadSupported) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            console.warn(
              "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
            );
          }
          console.warn(
            "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
          );
          flags.numThreads = numThreads = 1;
        }
        const wasmPaths = flags.wasmPaths;
        const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
        const mjsPathOverrideFlag = wasmPaths?.mjs;
        const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
        const wasmPathOverrideFlag = wasmPaths?.wasm;
        const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
        const wasmBinaryOverride = flags.wasmBinary;
        const [objectUrl, ortWasmFactory] = await importWasmModule(
          mjsPathOverride,
          wasmPrefixOverride,
          numThreads > 1,
          !!wasmBinaryOverride || !!wasmPathOverride
        );
        let isTimeout = false;
        const tasks = [];
        if (timeout > 0) {
          tasks.push(
            new Promise((resolve) => {
              setTimeout(() => {
                isTimeout = true;
                resolve();
              }, timeout);
            })
          );
        }
        tasks.push(
          new Promise((resolve, reject) => {
            const config = {
              /**
               * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
               * created.
               */
              numThreads
            };
            if (wasmBinaryOverride) {
              config.wasmBinary = wasmBinaryOverride;
            } else if (wasmPathOverride || wasmPrefixOverride) {
              config.locateFile = (fileName) => wasmPathOverride ?? wasmPrefixOverride + fileName;
            } else if (mjsPathOverride && mjsPathOverride.indexOf("blob:") !== 0) {
              config.locateFile = (fileName) => new URL(fileName, mjsPathOverride).href;
            } else if (objectUrl) {
              const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();
              if (inferredWasmPathPrefix) {
                config.locateFile = (fileName) => inferredWasmPathPrefix + fileName;
              }
            }
            ortWasmFactory(config).then(
              // wasm module initialized successfully
              (module) => {
                initializing = false;
                initialized = true;
                wasm = module;
                resolve();
                if (objectUrl) {
                  URL.revokeObjectURL(objectUrl);
                }
              },
              // wasm module failed to initialize
              (what) => {
                initializing = false;
                aborted = true;
                reject(what);
              }
            );
          })
        );
        await Promise.race(tasks);
        if (isTimeout) {
          throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
        }
      };
      getInstance = () => {
        if (initialized && wasm) {
          return wasm;
        }
        throw new Error("WebAssembly is not initialized yet.");
      };
    }
  });

  // web/lib/wasm/wasm-utils.ts
  var allocWasmString, iterateExtraOptions, checkLastError;
  var init_wasm_utils = __esm({
    "web/lib/wasm/wasm-utils.ts"() {
      "use strict";
      init_wasm_factory();
      allocWasmString = (data, allocs) => {
        const wasm2 = getInstance();
        const dataLength = wasm2.lengthBytesUTF8(data) + 1;
        const dataOffset = wasm2._malloc(dataLength);
        wasm2.stringToUTF8(data, dataOffset, dataLength);
        allocs.push(dataOffset);
        return dataOffset;
      };
      iterateExtraOptions = (options, prefix, seen, handler) => {
        if (typeof options == "object" && options !== null) {
          if (seen.has(options)) {
            throw new Error("Circular reference in options");
          } else {
            seen.add(options);
          }
        }
        Object.entries(options).forEach(([key, value]) => {
          const name = prefix ? prefix + key : key;
          if (typeof value === "object") {
            iterateExtraOptions(value, name + ".", seen, handler);
          } else if (typeof value === "string" || typeof value === "number") {
            handler(name, value.toString());
          } else if (typeof value === "boolean") {
            handler(name, value ? "1" : "0");
          } else {
            throw new Error(`Can't handle extra config type: ${typeof value}`);
          }
        });
      };
      checkLastError = (message) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        try {
          const ptrSize = wasm2.PTR_SIZE;
          const paramsOffset = wasm2.stackAlloc(2 * ptrSize);
          wasm2._OrtGetLastError(paramsOffset, paramsOffset + ptrSize);
          const errorCode = Number(wasm2.getValue(paramsOffset, ptrSize === 4 ? "i32" : "i64"));
          const errorMessagePointer = wasm2.getValue(paramsOffset + ptrSize, "*");
          const errorMessage = errorMessagePointer ? wasm2.UTF8ToString(errorMessagePointer) : "";
          throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
        } finally {
          wasm2.stackRestore(stack);
        }
      };
    }
  });

  // web/lib/wasm/run-options.ts
  var setRunOptions;
  var init_run_options = __esm({
    "web/lib/wasm/run-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      setRunOptions = (options) => {
        const wasm2 = getInstance();
        let runOptionsHandle = 0;
        const allocs = [];
        const runOptions = options || {};
        try {
          if (options?.logSeverityLevel === void 0) {
            runOptions.logSeverityLevel = 2;
          } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error(`log severity level is not valid: ${options.logSeverityLevel}`);
          }
          if (options?.logVerbosityLevel === void 0) {
            runOptions.logVerbosityLevel = 0;
          } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
          }
          if (options?.terminate === void 0) {
            runOptions.terminate = false;
          }
          let tagDataOffset = 0;
          if (options?.tag !== void 0) {
            tagDataOffset = allocWasmString(options.tag, allocs);
          }
          runOptionsHandle = wasm2._OrtCreateRunOptions(
            runOptions.logSeverityLevel,
            runOptions.logVerbosityLevel,
            !!runOptions.terminate,
            tagDataOffset
          );
          if (runOptionsHandle === 0) {
            checkLastError("Can't create run options.");
          }
          if (options?.extra !== void 0) {
            iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm2._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
              }
            });
          }
          return [runOptionsHandle, allocs];
        } catch (e) {
          if (runOptionsHandle !== 0) {
            wasm2._OrtReleaseRunOptions(runOptionsHandle);
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/session-options.ts
  var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, appendSessionConfig, setExecutionProviders, setSessionOptions;
  var init_session_options = __esm({
    "web/lib/wasm/session-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      getGraphOptimzationLevel = (graphOptimizationLevel) => {
        switch (graphOptimizationLevel) {
          case "disabled":
            return 0;
          case "basic":
            return 1;
          case "extended":
            return 2;
          case "layout":
            return 3;
          case "all":
            return 99;
          default:
            throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
        }
      };
      getExecutionMode = (executionMode) => {
        switch (executionMode) {
          case "sequential":
            return 0;
          case "parallel":
            return 1;
          default:
            throw new Error(`unsupported execution mode: ${executionMode}`);
        }
      };
      appendDefaultOptions = (options) => {
        if (!options.extra) {
          options.extra = {};
        }
        if (!options.extra.session) {
          options.extra.session = {};
        }
        const session = options.extra.session;
        if (!session.use_ort_model_bytes_directly) {
          session.use_ort_model_bytes_directly = "1";
        }
        if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
          options.enableMemPattern = false;
        }
      };
      appendSessionConfig = (sessionOptionsHandle, key, value, allocs) => {
        const keyDataOffset = allocWasmString(key, allocs);
        const valueDataOffset = allocWasmString(value, allocs);
        if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
          checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
        }
      };
      setExecutionProviders = async (sessionOptionsHandle, executionProviders, allocs) => {
        for (const ep of executionProviders) {
          let epName = typeof ep === "string" ? ep : ep.name;
          const epOptions = [];
          switch (epName) {
            case "webnn":
              epName = "WEBNN";
              if (typeof ep !== "string") {
                const webnnOptions = ep;
                const deviceType = webnnOptions?.deviceType;
                if (deviceType) {
                  appendSessionConfig(sessionOptionsHandle, "deviceType", deviceType, allocs);
                }
              }
              break;
            case "webgpu":
              if (false) {
                epName = "WebGPU";
                let customDevice;
                if (typeof ep !== "string") {
                  const customOptions = ep;
                  if (customOptions.device) {
                    if (typeof GPUDevice !== "undefined" && customOptions.device instanceof GPUDevice) {
                      customDevice = customOptions.device;
                    } else {
                      throw new Error("Invalid GPU device set in WebGPU EP options.");
                    }
                  }
                }
                const info = getInstance().webgpuRegisterDevice(customDevice);
                if (info) {
                  const [deviceId, instanceHandle, deviceHandle] = info;
                  appendEpOption(epOptions, "deviceId", deviceId.toString(), allocs);
                  appendEpOption(epOptions, "webgpuInstance", instanceHandle.toString(), allocs);
                  appendEpOption(epOptions, "webgpuDevice", deviceHandle.toString(), allocs);
                }
              } else {
                epName = "JS";
                if (typeof ep !== "string") {
                  const webgpuOptions = ep;
                  if (webgpuOptions?.preferredLayout) {
                    if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                      throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                    }
                    appendSessionConfig(sessionOptionsHandle, "preferredLayout", webgpuOptions.preferredLayout, allocs);
                  }
                }
              }
              break;
            case "wasm":
            case "cpu":
              continue;
            default:
              throw new Error(`not supported execution provider: ${epName}`);
          }
          const epNameDataOffset = allocWasmString(epName, allocs);
          const epOptionsCount = epOptions.length;
          let keysOffset = 0;
          let valuesOffset = 0;
          if (epOptionsCount > 0) {
            keysOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);
            allocs.push(keysOffset);
            valuesOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);
            allocs.push(valuesOffset);
            for (let i = 0; i < epOptionsCount; i++) {
              getInstance().setValue(keysOffset + i * getInstance().PTR_SIZE, epOptions[i][0], "*");
              getInstance().setValue(valuesOffset + i * getInstance().PTR_SIZE, epOptions[i][1], "*");
            }
          }
          if (await getInstance()._OrtAppendExecutionProvider(
            sessionOptionsHandle,
            epNameDataOffset,
            keysOffset,
            valuesOffset,
            epOptionsCount
          ) !== 0) {
            checkLastError(`Can't append execution provider: ${epName}.`);
          }
        }
      };
      setSessionOptions = async (options) => {
        const wasm2 = getInstance();
        let sessionOptionsHandle = 0;
        const allocs = [];
        const sessionOptions = options || {};
        appendDefaultOptions(sessionOptions);
        try {
          const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
          const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
          const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
          const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
          if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
            throw new Error(`log severity level is not valid: ${logSeverityLevel}`);
          }
          const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
          if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
            throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
          }
          const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
          sessionOptionsHandle = wasm2._OrtCreateSessionOptions(
            graphOptimizationLevel,
            !!sessionOptions.enableCpuMemArena,
            !!sessionOptions.enableMemPattern,
            executionMode,
            !!sessionOptions.enableProfiling,
            0,
            logIdDataOffset,
            logSeverityLevel,
            logVerbosityLevel,
            optimizedModelFilePathOffset
          );
          if (sessionOptionsHandle === 0) {
            checkLastError("Can't create session options.");
          }
          if (sessionOptions.executionProviders) {
            await setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
          }
          if (sessionOptions.enableGraphCapture !== void 0) {
            if (typeof sessionOptions.enableGraphCapture !== "boolean") {
              throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
            }
            appendSessionConfig(
              sessionOptionsHandle,
              "enableGraphCapture",
              sessionOptions.enableGraphCapture.toString(),
              allocs
            );
          }
          if (sessionOptions.freeDimensionOverrides) {
            for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
              if (typeof name !== "string") {
                throw new Error(`free dimension override name must be a string: ${name}`);
              }
              if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
                throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
              }
              const nameOffset = allocWasmString(name, allocs);
              if (wasm2._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
                checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);
              }
            }
          }
          if (sessionOptions.extra !== void 0) {
            iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              appendSessionConfig(sessionOptionsHandle, key, value, allocs);
            });
          }
          return [sessionOptionsHandle, allocs];
        } catch (e) {
          if (sessionOptionsHandle !== 0) {
            if (wasm2._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {
              checkLastError("Can't release session options.");
            }
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/wasm-common.ts
  var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, calculateTensorSizeInBytes, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, isMLTensorSupportedType, dataLocationStringToEnum;
  var init_wasm_common = __esm({
    "web/lib/wasm/wasm-common.ts"() {
      "use strict";
      tensorDataTypeStringToEnum = (type) => {
        switch (type) {
          case "int8":
            return 3 /* int8 */;
          case "uint8":
            return 2 /* uint8 */;
          case "bool":
            return 9 /* bool */;
          case "int16":
            return 5 /* int16 */;
          case "uint16":
            return 4 /* uint16 */;
          case "int32":
            return 6 /* int32 */;
          case "uint32":
            return 12 /* uint32 */;
          case "float16":
            return 10 /* float16 */;
          case "float32":
            return 1 /* float */;
          case "float64":
            return 11 /* double */;
          case "string":
            return 8 /* string */;
          case "int64":
            return 7 /* int64 */;
          case "uint64":
            return 13 /* uint64 */;
          case "int4":
            return 22 /* int4 */;
          case "uint4":
            return 21 /* uint4 */;
          default:
            throw new Error(`unsupported data type: ${type}`);
        }
      };
      tensorDataTypeEnumToString = (typeProto) => {
        switch (typeProto) {
          case 3 /* int8 */:
            return "int8";
          case 2 /* uint8 */:
            return "uint8";
          case 9 /* bool */:
            return "bool";
          case 5 /* int16 */:
            return "int16";
          case 4 /* uint16 */:
            return "uint16";
          case 6 /* int32 */:
            return "int32";
          case 12 /* uint32 */:
            return "uint32";
          case 10 /* float16 */:
            return "float16";
          case 1 /* float */:
            return "float32";
          case 11 /* double */:
            return "float64";
          case 8 /* string */:
            return "string";
          case 7 /* int64 */:
            return "int64";
          case 13 /* uint64 */:
            return "uint64";
          case 22 /* int4 */:
            return "int4";
          case 21 /* uint4 */:
            return "uint4";
          default:
            throw new Error(`unsupported data type: ${typeProto}`);
        }
      };
      calculateTensorSizeInBytes = (dateType, dimsOrSize) => {
        const elementSize = [
          -1,
          // undefined = 0
          4,
          // float = 1
          1,
          // uint8 = 2
          1,
          // int8 = 3
          2,
          // uint16 = 4
          2,
          // int16 = 5
          4,
          // int32 = 6
          8,
          // int64 = 7
          -1,
          // string = 8
          1,
          // bool = 9
          2,
          // float16 = 10
          8,
          // double = 11
          4,
          // uint32 = 12
          8,
          // uint64 = 13
          -1,
          // complex64 = 14
          -1,
          // complex128 = 15
          -1,
          // bfloat16 = 16
          -1,
          // FLOAT8E4M3FN = 17
          -1,
          // FLOAT8E4M3FNUZ = 18
          -1,
          // FLOAT8E5M2 = 19
          -1,
          // FLOAT8E5M2FNUZ = 20
          0.5,
          // uint4 = 21
          0.5
          // int4 = 22
        ][dateType];
        const size = typeof dimsOrSize === "number" ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);
        return elementSize > 0 ? Math.ceil(size * elementSize) : void 0;
      };
      tensorTypeToTypedArrayConstructor = (type) => {
        switch (type) {
          case "float16":
            return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
          case "float32":
            return Float32Array;
          case "uint8":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "uint16":
            return Uint16Array;
          case "int16":
            return Int16Array;
          case "int32":
            return Int32Array;
          case "bool":
            return Uint8Array;
          case "float64":
            return Float64Array;
          case "uint32":
            return Uint32Array;
          case "int64":
            return BigInt64Array;
          case "uint64":
            return BigUint64Array;
          default:
            throw new Error(`unsupported type: ${type}`);
        }
      };
      logLevelStringToEnum = (logLevel) => {
        switch (logLevel) {
          case "verbose":
            return 0;
          case "info":
            return 1;
          case "warning":
            return 2;
          case "error":
            return 3;
          case "fatal":
            return 4;
          default:
            throw new Error(`unsupported logging level: ${logLevel}`);
        }
      };
      isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
      isMLTensorSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint64" || type === "int8" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
      dataLocationStringToEnum = (location2) => {
        switch (location2) {
          case "none":
            return 0;
          case "cpu":
            return 1;
          case "cpu-pinned":
            return 2;
          case "texture":
            return 3;
          case "gpu-buffer":
            return 4;
          case "ml-tensor":
            return 5;
          default:
            throw new Error(`unsupported data location: ${location2}`);
        }
      };
    }
  });

  // web/lib/wasm/wasm-utils-load-file.ts
  var loadFile;
  var init_wasm_utils_load_file = __esm({
    "web/lib/wasm/wasm-utils-load-file.ts"() {
      "use strict";
      init_wasm_utils_env();
      loadFile = async (file) => {
        if (typeof file === "string") {
          if (isNode) {
            try {
              const { readFile } = __require("node:fs/promises");
              return new Uint8Array(await readFile(file));
            } catch (e) {
              if (e.code === "ERR_FS_FILE_TOO_LARGE") {
                const { createReadStream } = __require("node:fs");
                const stream = createReadStream(file);
                const chunks = [];
                for await (const chunk of stream) {
                  chunks.push(chunk);
                }
                return new Uint8Array(Buffer.concat(chunks));
              }
              throw e;
            }
          } else {
            const response = await fetch(file);
            if (!response.ok) {
              throw new Error(`failed to load external data file: ${file}`);
            }
            const contentLengthHeader = response.headers.get("Content-Length");
            const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
            if (fileSize < 1073741824) {
              return new Uint8Array(await response.arrayBuffer());
            } else {
              if (!response.body) {
                throw new Error(`failed to load external data file: ${file}, no response body.`);
              }
              const reader = response.body.getReader();
              let buffer;
              try {
                buffer = new ArrayBuffer(fileSize);
              } catch (e) {
                if (e instanceof RangeError) {
                  const pages = Math.ceil(fileSize / 65536);
                  buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
                } else {
                  throw e;
                }
              }
              let offset = 0;
              while (true) {
                const { done, value } = await reader.read();
                if (done) {
                  break;
                }
                const chunkSize = value.byteLength;
                const chunk = new Uint8Array(buffer, offset, chunkSize);
                chunk.set(value);
                offset += chunkSize;
              }
              return new Uint8Array(buffer, 0, fileSize);
            }
          }
        } else if (file instanceof Blob) {
          return new Uint8Array(await file.arrayBuffer());
        } else if (file instanceof Uint8Array) {
          return file;
        } else {
          return new Uint8Array(file);
        }
      };
    }
  });

  // web/lib/wasm/jsep/log.ts
  var logLevelPrefix, doLog, configLogLevel, debug, configureLogger, LOG, LOG_DEBUG;
  var init_log = __esm({
    "web/lib/wasm/jsep/log.ts"() {
      "use strict";
      init_wasm_common();
      logLevelPrefix = ["V", "I", "W", "E", "F"];
      doLog = (level, message) => {
        console.log(`[${logLevelPrefix[level]},${(/* @__PURE__ */ new Date()).toISOString()}]${message}`);
      };
      configureLogger = ($configLogLevel, $debug) => {
        configLogLevel = $configLogLevel;
        debug = $debug;
      };
      LOG = (logLevel, msg) => {
        const messageLevel = logLevelStringToEnum(logLevel);
        const configLevel = logLevelStringToEnum(configLogLevel);
        if (messageLevel >= configLevel) {
          doLog(messageLevel, typeof msg === "function" ? msg() : msg);
        }
      };
      LOG_DEBUG = (...args) => {
        if (debug) {
          LOG(...args);
        }
      };
    }
  });

  // web/lib/wasm/jsep/util.ts
  var MatMulUtil, BroadcastUtil, ShapeUtil, PoolConvUtil, GemmUtil, MIN_CLIP, MAX_CLIP;
  var init_util = __esm({
    "web/lib/wasm/jsep/util.ts"() {
      "use strict";
      MatMulUtil = class {
        /**
         * Calculate the expected shape when matrix multiplication
         * @param a The shape of tensor A. Should be a tuple of 2 positive integers
         * @param b The shape of tensor B. Should be a tuple of 2 positive integers
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcMatMulShape(a, b) {
          return a[1] !== b[0] ? void 0 : [a[0], b[1]];
        }
      };
      BroadcastUtil = class {
        /**
         * Calculate the expected shape when broadcasting 2 tensors
         * @param a The shape of tensor A. Should be an array of positive integers
         * @param b The shape of tensor B. Should be an array of positive integers
         * @param isMatMul Whether the operation is MatMul
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcShape(adims, bdims, isMatMul = false) {
          const arank = adims.length;
          const brank = bdims.length;
          if (arank === 0) {
            return bdims;
          }
          if (brank === 0) {
            return adims;
          }
          const crank = Math.max(adims.length, bdims.length);
          const cdims = new Array(crank);
          if (isMatMul) {
            if (arank < 2 || brank < 2) {
              return void 0;
            }
            const cShapeMatMul = MatMulUtil.calcMatMulShape(
              [adims[arank - 2], adims[arank - 1]],
              [bdims[brank - 2], bdims[brank - 1]]
            );
            if (cShapeMatMul === void 0) {
              return void 0;
            }
            [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
          }
          for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
            const aLen = arank - i < 0 ? 1 : adims[arank - i];
            const bLen = brank - i < 0 ? 1 : bdims[brank - i];
            if (aLen !== bLen && aLen > 1 && bLen > 1) {
              return void 0;
            }
            const max = Math.max(aLen, bLen);
            if (aLen && bLen) {
              cdims[crank - i] = Math.max(aLen, bLen);
            } else {
              if (max > 1) {
                return void 0;
              }
              cdims[crank - i] = 0;
            }
          }
          return cdims;
        }
        /**
         * Determine if a shape is unidirectional broadcastable to another shape
         * @param shape The input shape
         * @param finalShape The desired shape after broadcasting
         */
        static isValidBroadcast(shape, finalShape) {
          const inputRank = shape.length;
          const finalRank = finalShape.length;
          if (inputRank > finalRank) {
            return false;
          }
          for (let i = 1; i <= inputRank; i++) {
            if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
              return false;
            }
          }
          return true;
        }
      };
      ShapeUtil = class _ShapeUtil {
        /**
         * calculate the size (number of elements)
         */
        static size(dims) {
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
        }
        /**
         * convert dims corresponding to type change to pack. ex. uint8 data to uint32
         */
        static convertShape(dims, size = 4) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          }
          const newDims = new Array(rank);
          let i = rank - 1;
          while (i >= 0) {
            if (dims[i] % size === 0) {
              newDims[i] = dims[i] / size;
              break;
            }
            if (size % dims[i] !== 0) {
              throw new Error("cannot convert shape");
            }
            newDims[i] = 1;
            size /= dims[i];
            i--;
          }
          for (i--; i >= 0; i--) {
            newDims[i] = dims[i];
          }
          return newDims;
        }
        /**
         * calculate the size (number of elements) from the given axis (inclusive)
         */
        static sizeFromDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
        }
        /**
         * calculate the size (number of elements) to the given axis (exclusive)
         */
        static sizeToDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
        }
        /**
         * calculate the size (number of elements) from and to the given axis [start, end)
         */
        static getSizeFromDimensionRange(dims, start, end) {
          let size = 1;
          for (let i = start; i < end; i++) {
            if (dims[i] < 0) {
              throw new Error(
                // eslint-disable-next-line max-len
                "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."
              );
            }
            size *= Number(dims[i]);
          }
          return size;
        }
        static computeStrides(dims) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          } else if (rank === 1) {
            return [1];
          }
          const strides = new Array(rank);
          strides[rank - 1] = 1;
          strides[rank - 2] = dims[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * dims[i + 1];
          }
          return strides;
        }
        /**
         * normalize axis of range [-r, r) into [0, r).
         */
        static normalizeAxis(axis, tensorRank) {
          if (axis < -tensorRank && axis >= tensorRank) {
            throw new Error("unsupported axis for this operation.");
          }
          return axis < 0 ? axis + tensorRank : axis;
        }
        static normalizeAxes(axes, tensorRank) {
          return axes.map((x) => this.normalizeAxis(x, tensorRank ?? axes.length));
        }
        /**
         * Sorts a given array based on the indices in the Perm array
         * Used in Transpose
         * @param a Array to be sorted such as dims or strides
         * @param perm Perm given; if null a will be reversed
         */
        static sortBasedOnPerm(a, perm) {
          if (perm) {
            return perm.map((v) => a[v]);
          } else {
            return a.slice().reverse();
          }
        }
        /**
         * Pads a given shape according to the padding values
         * @param dims shape of the Tensor to be padded
         * @param pad pad values
         */
        static padShape(dims, pad2) {
          const rank = dims.length;
          return dims.map((v, i) => v + pad2[i] + pad2[i + rank]);
        }
        /**
         * Determines if the two shapes are identical
         * @param shape1
         * @param shape2
         */
        static areEqual(shape1, shape2) {
          if (shape1.length !== shape2.length) {
            return false;
          }
          return shape1.every((v, i) => v === shape2[i]);
        }
      };
      PoolConvUtil = class _PoolConvUtil {
        /**
         * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension.
         * @param kernelShape The size of the kernel along each axis.
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         */
        static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
          if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
          }
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              if (dim >= kernelShape.length) {
                kernelShape.push(inputDims[dim + 2]);
              } else {
                kernelShape[dim] = inputDims[dim + 2];
              }
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < strides.length) {
              if (strides[dim] < 0) {
                throw new Error("strides should be greater than or equal to 1");
              }
            } else {
              strides.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < dilations.length) {
              if (dilations[dim] < 0) {
                throw new Error("dilations should be greater than or equal to 1");
              }
            } else {
              dilations.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length * 2; dim++) {
            if (dim < pads.length) {
              if (pads[dim] < 0) {
                throw new Error("pad should be greater than or equal to 1");
              }
            } else {
              pads.push(0);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (kernelShape[dim] <= 0) {
              throw new Error("kernel shapes need to be greater than 0");
            }
            if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
              throw new Error("pads should be smaller than kernel");
            }
          }
        }
        // adjust pad values based on 'autoPad' attribute
        static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, isChannelLast, autoPad) {
          if (!autoPad) {
            return;
          }
          if (pads.length !== 2 * (inputDims.length - 2)) {
            throw new Error("length of pads should be twice the length of data dimensions");
          }
          if (strides.length !== inputDims.length - 2) {
            throw new Error("length of strides should be the length of data dimensions");
          }
          if (kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of kernel shapes should be the length of data dimensions");
          }
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            _PoolConvUtil.adjustPadAndReturnShape(
              inputDims[dim + (isChannelLast ? 1 : 2)],
              strides[dim],
              dilations[dim],
              kernelShape[dim],
              pads,
              dim,
              dim + inputDims.length - 2,
              autoPad
            );
          }
        }
        /**
         * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0) {
            throw new Error("input shape must be of size greater than 0");
          }
          const outputDims = [inputDims[0], inputDims[1]];
          _PoolConvUtil.computeShapeHelper(
            isGlobalOperator,
            inputDims,
            outputDims,
            strides,
            dilations,
            kernelShape,
            pads,
            autoPad
          );
          return outputDims;
        }
        /**
         * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param filterDims The filter tensor dimension. (inputs[1].dims)
         * @param strides Stride along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0 || filterDims.length <= 0) {
            throw new Error("invalid input tensor dims or invalid filter tensor dims");
          }
          const outputDims = [inputDims[0], filterDims[0]];
          _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
          return outputDims;
        }
        // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
        // called by computePoolOutputShape() and computeConvOutputShape()
        // adjust pads based on 'autoPad' attribute prior to shape computation
        static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(1);
            }
          } else {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(
                _PoolConvUtil.adjustPadAndReturnShape(
                  inputDims[dim + 2],
                  strides[dim],
                  dilations[dim],
                  kernelShape[dim],
                  pads,
                  dim,
                  dim + inputDims.length - 2,
                  autoPad
                )
              );
            }
          }
        }
        // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
        // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
        static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
          const dkernel = dilation * (kernel - 1) + 1;
          if (autoPad && autoPad !== "NOTSET") {
            switch (autoPad) {
              case "VALID":
                pads[padHeadIndex] = 0;
                pads[padTailIndex] = 0;
                return Math.floor((inSize - dkernel) / stride + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (dilation !== 1) {
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                } else {
                  const legacyTargetSize = (inSize + stride - 1) / stride;
                  const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                  pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                  pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                  return Math.floor((inSize + padNeeded - kernel) / stride + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          } else {
            return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
          }
        }
      };
      GemmUtil = class {
        // will make sure input shapes are compatible for this op
        // and return back the shape of the output in the form of a tuple
        // will throw exception if the input shapes are not compatible
        static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
          if (leftShape.length !== 2 || rightShape.length !== 2) {
            throw new Error("shape need to be of size 2");
          }
          let M;
          let K;
          let N;
          if (transLeft) {
            M = leftShape[1];
            K = leftShape[0];
          } else {
            M = leftShape[0];
            K = leftShape[1];
          }
          let kDim = -1;
          if (transRight) {
            N = rightShape[0];
            kDim = 1;
          } else {
            N = rightShape[1];
            kDim = 0;
          }
          if (rightShape[kDim] !== K) {
            throw new Error("dimension mismatch");
          }
          if (M <= 0 || N <= 0 || K <= 0) {
            throw new Error("invalid shape specified");
          }
          if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
            throw new Error("gemm: invalid bias shape for broadcast");
          }
          return [M, N, K];
        }
      };
      MIN_CLIP = -34028234663852886e22;
      MAX_CLIP = 34028234663852886e22;
    }
  });

  // web/lib/wasm/jsep/tensor-view.ts
  var createView;
  var init_tensor_view = __esm({
    "web/lib/wasm/jsep/tensor-view.ts"() {
      "use strict";
      init_wasm_common();
      createView = (dataBuffer, type) => new (tensorTypeToTypedArrayConstructor(type))(dataBuffer);
    }
  });

  // web/lib/wasm/jsep/webnn/tensor-manager.ts
  var webnnDataTypeToSize, convertDataToInt32, convertInt32ToData, tensorGuid, createNewTensorId, webnnDataTypeToFallback, calculateByteLength, TensorWrapper, TensorIdTracker, TensorManagerImpl, createTensorManager;
  var init_tensor_manager = __esm({
    "web/lib/wasm/jsep/webnn/tensor-manager.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      webnnDataTypeToSize = /* @__PURE__ */ new Map([
        ["float32", 32],
        ["float16", 16],
        ["int32", 32],
        ["uint32", 32],
        ["int64", 64],
        ["uint64", 64],
        ["int8", 8],
        ["uint8", 8],
        ["int4", 4],
        ["uint4", 4]
      ]);
      convertDataToInt32 = (data, dataType) => {
        if (dataType === "int32") {
          return data;
        }
        const dataTypeSize = webnnDataTypeToSize.get(dataType);
        if (!dataTypeSize) {
          throw new Error(`WebNN backend does not support data type: ${dataType}`);
        }
        const bytesPerElement = dataTypeSize / 8;
        if (data.byteLength % bytesPerElement !== 0) {
          throw new Error(`Invalid Uint8Array length - must be a multiple of ${bytesPerElement}.`);
        }
        const numElements = data.byteLength / bytesPerElement;
        const originalArray = new (tensorTypeToTypedArrayConstructor(dataType))(data.buffer, data.byteOffset, numElements);
        switch (dataType) {
          case "int64":
          case "uint64": {
            const int32Array = new Int32Array(numElements);
            for (let i = 0; i < numElements; i++) {
              const value = originalArray[i];
              if (value > 2147483647n || value < -2147483648n) {
                throw new Error(`Can not convert int64 data to int32 - value out of range.`);
              }
              int32Array[i] = Number(value);
            }
            return new Uint8Array(int32Array.buffer);
          }
          case "int8":
          case "uint8":
          case "uint32": {
            if (dataType === "uint32") {
              if (originalArray.some((value) => value > 2147483647)) {
                throw new Error(`Can not convert uint32 data to int32 - value out of range.`);
              }
            }
            const int32Array = Int32Array.from(originalArray, Number);
            return new Uint8Array(int32Array.buffer);
          }
          default:
            throw new Error(`Unsupported data conversion from ${dataType} to 'int32'`);
        }
      };
      convertInt32ToData = (data, dataType) => {
        if (dataType === "int32") {
          return data;
        }
        if (data.byteLength % 4 !== 0) {
          throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");
        }
        const numElements = data.byteLength / 4;
        const int32Array = new Int32Array(data.buffer, data.byteOffset, numElements);
        switch (dataType) {
          case "int64": {
            const bigInt64Array = BigInt64Array.from(int32Array, BigInt);
            return new Uint8Array(bigInt64Array.buffer);
          }
          case "uint64": {
            if (int32Array.some((value) => value < 0)) {
              throw new Error("Can not convert int32 data to uin64 - negative value found.");
            }
            const bigUint64Array = BigUint64Array.from(int32Array, BigInt);
            return new Uint8Array(bigUint64Array.buffer);
          }
          case "int8": {
            if (int32Array.some((value) => value < -128 || value > 127)) {
              throw new Error("Can not convert int32 data to int8 - value out of range.");
            }
            const int8Array = Int8Array.from(int32Array, Number);
            return new Uint8Array(int8Array.buffer);
          }
          case "uint8": {
            if (int32Array.some((value) => value < 0 || value > 255)) {
              throw new Error("Can not convert int32 data to uint8 - value out of range.");
            }
            return Uint8Array.from(int32Array, Number);
          }
          case "uint32": {
            if (int32Array.some((value) => value < 0)) {
              throw new Error("Can not convert int32 data to uint32 - negative value found.");
            }
            const uint32Array = Uint32Array.from(int32Array, Number);
            return new Uint8Array(uint32Array.buffer);
          }
          default:
            throw new Error(`Unsupported data conversion from 'int32' to ${dataType}`);
        }
      };
      tensorGuid = 1;
      createNewTensorId = () => tensorGuid++;
      webnnDataTypeToFallback = /* @__PURE__ */ new Map([
        ["int8", "int32"],
        ["uint8", "int32"],
        ["uint32", "int32"],
        ["int64", "int32"]
      ]);
      calculateByteLength = (dataType, shape) => {
        const dataTypeSize = webnnDataTypeToSize.get(dataType);
        if (!dataTypeSize) {
          throw new Error(`WebNN backend does not support data type: ${dataType}`);
        }
        return shape.length > 0 ? Math.ceil(shape.reduce((a, b) => a * b) * dataTypeSize / 8) : 0;
      };
      TensorWrapper = class {
        constructor(descriptor) {
          // This flag is used to indicate whether the data has been converted to fallback data type.
          this.isDataConverted = false;
          const { sessionId, context, tensor, dataType, shape, fallbackDataType } = descriptor;
          this.sessionId = sessionId;
          this.mlContext = context;
          this.mlTensor = tensor;
          this.dataType = dataType;
          this.tensorShape = shape;
          this.fallbackDataType = fallbackDataType;
        }
        get tensor() {
          return this.mlTensor;
        }
        get type() {
          return this.dataType;
        }
        get fallbackType() {
          return this.fallbackDataType;
        }
        get shape() {
          return this.tensorShape;
        }
        get byteLength() {
          return calculateByteLength(this.dataType, this.tensorShape);
        }
        destroy() {
          LOG_DEBUG("verbose", () => "[WebNN] TensorWrapper.destroy");
          this.mlTensor.destroy();
        }
        write(data) {
          this.mlContext.writeTensor(this.mlTensor, data);
        }
        async read(dstBuffer) {
          if (this.fallbackDataType) {
            const data = await this.mlContext.readTensor(this.mlTensor);
            const originalData = convertInt32ToData(new Uint8Array(data), this.dataType);
            if (dstBuffer) {
              const targetBuffer = dstBuffer instanceof ArrayBuffer ? new Uint8Array(dstBuffer) : new Uint8Array(dstBuffer.buffer, dstBuffer.byteOffset, dstBuffer.byteLength);
              targetBuffer.set(originalData);
              return void 0;
            } else {
              return originalData.buffer;
            }
          } else {
            return dstBuffer ? this.mlContext.readTensor(this.mlTensor, dstBuffer) : this.mlContext.readTensor(this.mlTensor);
          }
        }
        canReuseTensor(context, dataType, shape) {
          return this.mlContext === context && this.dataType === dataType && this.tensorShape.length === shape.length && this.tensorShape.every((v, i) => v === shape[i]);
        }
        setIsDataConverted(isConverted) {
          this.isDataConverted = isConverted;
        }
      };
      TensorIdTracker = class {
        constructor(tensorManager, wrapper) {
          this.tensorManager = tensorManager;
          this.wrapper = wrapper;
        }
        get tensorWrapper() {
          return this.wrapper;
        }
        releaseTensor() {
          if (this.tensorWrapper) {
            this.tensorManager.releaseTensor(this.tensorWrapper);
            this.wrapper = void 0;
          }
        }
        async ensureTensor(sessionId, dataType, shape, copyOld) {
          const context = this.tensorManager.getMLContext(sessionId);
          const opLimits = this.tensorManager.getMLOpSupportLimits(sessionId);
          let fallbackDataType;
          if (!opLimits?.input.dataTypes.includes(dataType)) {
            fallbackDataType = webnnDataTypeToFallback.get(dataType);
            if (!fallbackDataType || opLimits?.input.dataTypes.includes(fallbackDataType)) {
              throw new Error(`WebNN backend does not support data type: ${dataType}`);
            }
            LOG_DEBUG(
              "verbose",
              () => `[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${dataType} to ${fallbackDataType}`
            );
          }
          if (this.wrapper) {
            if (this.wrapper.canReuseTensor(context, dataType, shape)) {
              return this.wrapper.tensor;
            } else {
              if (copyOld) {
                if (this.wrapper.byteLength !== calculateByteLength(dataType, shape)) {
                  throw new Error("Unable to copy data to tensor with different size.");
                }
                this.activeUpload = new Uint8Array(await this.wrapper.read());
              }
              this.tensorManager.releaseTensor(this.wrapper);
            }
          }
          const usage = typeof MLTensorUsage == "undefined" ? void 0 : MLTensorUsage.READ | MLTensorUsage.WRITE;
          this.wrapper = await this.tensorManager.getCachedTensor(
            sessionId,
            dataType,
            shape,
            usage,
            true,
            true,
            fallbackDataType
          );
          if (copyOld && this.activeUpload) {
            this.wrapper.write(this.activeUpload);
            this.activeUpload = void 0;
          }
          return this.wrapper.tensor;
        }
        upload(data) {
          let newData = data;
          if (this.wrapper) {
            if (this.wrapper.fallbackType) {
              if (this.wrapper.fallbackType === "int32") {
                newData = convertDataToInt32(data, this.wrapper.type);
                this.wrapper.setIsDataConverted(true);
              } else {
                throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);
              }
            }
            if (data.byteLength === this.wrapper.byteLength) {
              this.wrapper.write(newData);
              return;
            } else {
              LOG_DEBUG("verbose", () => "Data size does not match tensor size. Releasing tensor.");
              this.releaseTensor();
            }
          }
          if (this.activeUpload) {
            this.activeUpload.set(newData);
          } else {
            this.activeUpload = new Uint8Array(newData);
          }
        }
        async download(dstBuffer) {
          if (this.activeUpload) {
            const dstData = this.wrapper?.isDataConverted ? convertInt32ToData(this.activeUpload, this.wrapper?.type) : this.activeUpload;
            if (dstBuffer) {
              if (dstBuffer instanceof ArrayBuffer) {
                new Uint8Array(dstBuffer).set(dstData);
              } else {
                new Uint8Array(dstBuffer.buffer, dstBuffer.byteOffset, dstBuffer.byteLength).set(dstData);
              }
              return;
            } else {
              return dstData.buffer;
            }
          }
          if (!this.wrapper) {
            throw new Error("Tensor has not been created.");
          }
          if (!dstBuffer) {
            return this.wrapper.read();
          }
          return this.wrapper.read(dstBuffer);
        }
      };
      TensorManagerImpl = class {
        constructor(backend) {
          this.backend = backend;
          this.tensorTrackersById = /* @__PURE__ */ new Map();
          this.freeTensors = [];
          this.externalTensors = /* @__PURE__ */ new Set();
        }
        getMLContext(sessionId) {
          const context = this.backend.getMLContext(sessionId);
          if (!context) {
            throw new Error("MLContext not found for session.");
          }
          return context;
        }
        getMLOpSupportLimits(sessionId) {
          return this.backend.getMLOpSupportLimits(sessionId);
        }
        reserveTensorId() {
          const tensorId = createNewTensorId();
          this.tensorTrackersById.set(tensorId, new TensorIdTracker(this));
          return tensorId;
        }
        releaseTensorId(tensorId) {
          const tensorTracker = this.tensorTrackersById.get(tensorId);
          if (!tensorTracker) {
            return;
          }
          this.tensorTrackersById.delete(tensorId);
          if (tensorTracker.tensorWrapper) {
            this.releaseTensor(tensorTracker.tensorWrapper);
          }
        }
        async ensureTensor(sessionId, tensorId, dataType, shape, copyOld) {
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] TensorManager.ensureTensor {tensorId: ${tensorId}, dataType: ${dataType}, shape: ${shape}, copyOld: ${copyOld}}`
          );
          const tensor = this.tensorTrackersById.get(tensorId);
          if (!tensor) {
            throw new Error("Tensor not found.");
          }
          return tensor.ensureTensor(sessionId, dataType, shape, copyOld);
        }
        upload(tensorId, data) {
          const tensor = this.tensorTrackersById.get(tensorId);
          if (!tensor) {
            throw new Error("Tensor not found.");
          }
          tensor.upload(data);
        }
        async download(tensorId, dstBuffer) {
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] TensorManager.download {tensorId: ${tensorId}, dstBuffer: ${dstBuffer?.byteLength}}`
          );
          const tensorTracker = this.tensorTrackersById.get(tensorId);
          if (!tensorTracker) {
            throw new Error("Tensor not found.");
          }
          return tensorTracker.download(dstBuffer);
        }
        releaseTensorsForSession(sessionId) {
          for (const tensor of this.freeTensors) {
            if (tensor.sessionId === sessionId) {
              tensor.destroy();
            }
          }
          this.freeTensors = this.freeTensors.filter((tensor) => tensor.sessionId !== sessionId);
        }
        registerTensor(sessionId, mlTensor, dataType, shape) {
          const context = this.getMLContext(sessionId);
          const tensorId = createNewTensorId();
          const wrapper = new TensorWrapper({
            sessionId,
            context,
            tensor: mlTensor,
            dataType,
            shape
          });
          this.tensorTrackersById.set(tensorId, new TensorIdTracker(this, wrapper));
          this.externalTensors.add(wrapper);
          return tensorId;
        }
        /**
         * Get or create an MLTensor with the given data type and shape.
         */
        async getCachedTensor(sessionId, dataType, shape, usage, writable, readable, fallbackDataType) {
          const context = this.getMLContext(sessionId);
          for (const [index, tensor2] of this.freeTensors.entries()) {
            if (tensor2.canReuseTensor(context, dataType, shape)) {
              LOG_DEBUG(
                "verbose",
                () => `[WebNN] Reusing tensor {dataType: ${dataType}, ${fallbackDataType ? `fallbackDataType: ${fallbackDataType},` : ""} shape: ${shape}`
              );
              const wrapper = this.freeTensors.splice(index, 1)[0];
              wrapper.sessionId = sessionId;
              return wrapper;
            }
          }
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] MLContext.createTensor {dataType: ${dataType}, ${fallbackDataType ? `fallbackDataType: ${fallbackDataType},` : ""} shape: ${shape}}`
          );
          const tensor = await context.createTensor({
            dataType: fallbackDataType ?? dataType,
            // If fallback data type is provided, use it.
            shape,
            dimensions: shape,
            usage,
            writable,
            readable
          });
          return new TensorWrapper({ sessionId, context, tensor, dataType, shape, fallbackDataType });
        }
        /**
         * Release tensor for reuse unless external.
         */
        releaseTensor(tensorWrapper) {
          if (this.externalTensors.has(tensorWrapper)) {
            this.externalTensors.delete(tensorWrapper);
          }
          this.freeTensors.push(tensorWrapper);
        }
      };
      createTensorManager = (...args) => new TensorManagerImpl(...args);
    }
  });

  // web/lib/wasm/jsep/backend-webnn.ts
  var onnxDataTypeToWebnnDataType, compareMLContextOptions, WebNNBackend;
  var init_backend_webnn = __esm({
    "web/lib/wasm/jsep/backend-webnn.ts"() {
      "use strict";
      init_wasm_common();
      init_wasm_factory();
      init_tensor_view();
      init_tensor_manager();
      init_log();
      onnxDataTypeToWebnnDataType = /* @__PURE__ */ new Map([
        [1 /* float */, "float32"],
        [10 /* float16 */, "float16"],
        [6 /* int32 */, "int32"],
        [12 /* uint32 */, "uint32"],
        [7 /* int64 */, "int64"],
        [13 /* uint64 */, "uint64"],
        [22 /* int4 */, "int4"],
        [21 /* uint4 */, "uint4"],
        [3 /* int8 */, "int8"],
        [2 /* uint8 */, "uint8"],
        [9 /* bool */, "uint8"]
      ]);
      compareMLContextOptions = (a, b) => {
        if (a === b) {
          return true;
        }
        if (a === void 0 || b === void 0) {
          return false;
        }
        const aKeys = Object.keys(a).sort();
        const bKeys = Object.keys(b).sort();
        return aKeys.length === bKeys.length && aKeys.every((key, index) => key === bKeys[index] && a[key] === b[key]);
      };
      WebNNBackend = class {
        constructor(env3) {
          /**
           * Tensor managers for each session.
           */
          this.tensorManager = createTensorManager(this);
          /**
           * Maps from session id to MLContexts.
           */
          this.mlContextBySessionId = /* @__PURE__ */ new Map();
          /**
           * Maps from MLContext to session ids.
           */
          this.sessionIdsByMLContext = /* @__PURE__ */ new Map();
          /**
           * Cache of MLContexts.
           */
          this.mlContextCache = [];
          /**
           * Maps from session id to list of graph inputs.
           */
          this.sessionGraphInputs = /* @__PURE__ */ new Map();
          /**
           * Maps from session id to list of graph outputs.
           */
          this.sessionGraphOutputs = /* @__PURE__ */ new Map();
          /**
           * Temporary graph inputs for the current session.
           * These inputs will be registered when the session is created.
           */
          this.temporaryGraphInputs = [];
          /**
           * Temporary graph outputs for the current session.
           * These outputs will be registered when the session is created.
           */
          this.temporaryGraphOutputs = [];
          /**
           * Temporary tensors for the current session.
           */
          this.temporarySessionTensorIds = /* @__PURE__ */ new Map();
          /**
           * Maps from session id to MLOpSupportLimits.
           */
          this.mlOpSupportLimitsBySessionId = /* @__PURE__ */ new Map();
          configureLogger(env3.logLevel, !!env3.debug);
        }
        get currentSessionId() {
          if (this.activeSessionId === void 0) {
            throw new Error("No active session");
          }
          return this.activeSessionId;
        }
        onRunStart(sessionId) {
          LOG_DEBUG("verbose", () => `[WebNN] onRunStart {sessionId: ${sessionId}}`);
          this.activeSessionId = sessionId;
        }
        onRunEnd(sessionId) {
          LOG_DEBUG("verbose", () => `[WebNN] onRunEnd {sessionId: ${sessionId}}`);
          const tensorIds = this.temporarySessionTensorIds.get(sessionId);
          if (!tensorIds) {
            return;
          }
          for (const tensorId of tensorIds) {
            LOG_DEBUG("verbose", () => `[WebNN] releasing temporary tensor {tensorId: ${tensorId}}`);
            this.tensorManager.releaseTensorId(tensorId);
          }
          this.temporarySessionTensorIds.delete(sessionId);
          this.activeSessionId = void 0;
        }
        async createMLContext(optionsOrDevice) {
          if (optionsOrDevice instanceof GPUDevice) {
            const mlContextIndex2 = this.mlContextCache.findIndex((entry) => entry.gpuDevice === optionsOrDevice);
            if (mlContextIndex2 !== -1) {
              return this.mlContextCache[mlContextIndex2].mlContext;
            } else {
              const mlContext = await navigator.ml.createContext(optionsOrDevice);
              this.mlContextCache.push({ gpuDevice: optionsOrDevice, mlContext });
              return mlContext;
            }
          } else if (optionsOrDevice === void 0) {
            const mlContextIndex2 = this.mlContextCache.findIndex(
              (entry) => entry.options === void 0 && entry.gpuDevice === void 0
            );
            if (mlContextIndex2 !== -1) {
              return this.mlContextCache[mlContextIndex2].mlContext;
            } else {
              const mlContext = await navigator.ml.createContext();
              this.mlContextCache.push({ mlContext });
              return mlContext;
            }
          }
          const mlContextIndex = this.mlContextCache.findIndex(
            (entry) => compareMLContextOptions(entry.options, optionsOrDevice)
          );
          if (mlContextIndex !== -1) {
            return this.mlContextCache[mlContextIndex].mlContext;
          } else {
            const mlContext = await navigator.ml.createContext(optionsOrDevice);
            this.mlContextCache.push({ options: optionsOrDevice, mlContext });
            return mlContext;
          }
        }
        registerMLContext(sessionId, mlContext) {
          this.mlContextBySessionId.set(sessionId, mlContext);
          let sessionIds = this.sessionIdsByMLContext.get(mlContext);
          if (!sessionIds) {
            sessionIds = /* @__PURE__ */ new Set();
            this.sessionIdsByMLContext.set(mlContext, sessionIds);
          }
          sessionIds.add(sessionId);
          if (!this.mlOpSupportLimitsBySessionId.has(sessionId)) {
            this.mlOpSupportLimitsBySessionId.set(sessionId, mlContext.opSupportLimits());
          }
          if (this.temporaryGraphInputs.length > 0) {
            this.sessionGraphInputs.set(sessionId, this.temporaryGraphInputs);
            this.temporaryGraphInputs = [];
          }
          if (this.temporaryGraphOutputs.length > 0) {
            this.sessionGraphOutputs.set(sessionId, this.temporaryGraphOutputs);
            this.temporaryGraphOutputs = [];
          }
        }
        onReleaseSession(sessionId) {
          this.sessionGraphInputs.delete(sessionId);
          this.sessionGraphOutputs.delete(sessionId);
          const mlContext = this.mlContextBySessionId.get(sessionId);
          if (!mlContext) {
            return;
          }
          this.tensorManager.releaseTensorsForSession(sessionId);
          this.mlContextBySessionId.delete(sessionId);
          this.mlOpSupportLimitsBySessionId.delete(sessionId);
          const sessionIds = this.sessionIdsByMLContext.get(mlContext);
          sessionIds.delete(sessionId);
          if (sessionIds.size === 0) {
            this.sessionIdsByMLContext.delete(mlContext);
            const mlContextIndex = this.mlContextCache.findIndex((entry) => entry.mlContext === mlContext);
            if (mlContextIndex !== -1) {
              this.mlContextCache.splice(mlContextIndex, 1);
            }
          }
        }
        getMLContext(sessionId) {
          return this.mlContextBySessionId.get(sessionId);
        }
        getMLOpSupportLimits(sessionId) {
          return this.mlOpSupportLimitsBySessionId.get(sessionId);
        }
        reserveTensorId() {
          return this.tensorManager.reserveTensorId();
        }
        releaseTensorId(tensorId) {
          LOG_DEBUG("verbose", () => `[WebNN] releaseTensorId {tensorId: ${tensorId}}`);
          this.tensorManager.releaseTensorId(tensorId);
        }
        async ensureTensor(sessionId, tensorId, onnxDataType, dimensions, copyOld) {
          const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
          if (!webnnDataType) {
            throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
          }
          return this.tensorManager.ensureTensor(
            sessionId ?? this.currentSessionId,
            tensorId,
            webnnDataType,
            dimensions,
            copyOld
          );
        }
        async createTemporaryTensor(sessionId, onnxDataType, shape) {
          LOG_DEBUG("verbose", () => `[WebNN] createTemporaryTensor {onnxDataType: ${onnxDataType}, shape: ${shape}}`);
          const dataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
          if (!dataType) {
            throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
          }
          const tensorId = this.tensorManager.reserveTensorId();
          await this.tensorManager.ensureTensor(sessionId, tensorId, dataType, shape, false);
          const tensorIds = this.temporarySessionTensorIds.get(sessionId);
          if (!tensorIds) {
            this.temporarySessionTensorIds.set(sessionId, [tensorId]);
          } else {
            tensorIds.push(tensorId);
          }
          return tensorId;
        }
        uploadTensor(tensorId, data) {
          const wasm2 = getInstance();
          if (!wasm2.shouldTransferToMLTensor) {
            throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");
          }
          LOG_DEBUG("verbose", () => `[WebNN] uploadTensor {tensorId: ${tensorId}, data: ${data.byteLength}}`);
          this.tensorManager.upload(tensorId, data);
        }
        async downloadTensor(tensorId, dstBuffer) {
          return this.tensorManager.download(tensorId, dstBuffer);
        }
        createMLTensorDownloader(tensorId, type) {
          return async () => {
            const data = await this.tensorManager.download(tensorId);
            return createView(data, type);
          };
        }
        registerMLTensor(sessionId, tensor, onnxDataType, dimensions) {
          const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
          if (!webnnDataType) {
            throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
          }
          const id = this.tensorManager.registerTensor(sessionId, tensor, webnnDataType, dimensions);
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] registerMLTensor {tensor: ${tensor}, dataType: ${webnnDataType}, dimensions: ${dimensions}} -> {tensorId: ${id}}`
          );
          return id;
        }
        // Register a WebNN Constant operand from external data.
        registerMLConstant(externalFilePath, dataOffset, dataLength, builder, desc, mountedFiles, shouldConvertInt64ToInt32 = false) {
          if (!mountedFiles) {
            throw new Error("External mounted files are not available.");
          }
          let filePath = externalFilePath;
          if (externalFilePath.startsWith("./")) {
            filePath = externalFilePath.substring(2);
          }
          const fileData = mountedFiles.get(filePath);
          if (!fileData) {
            throw new Error(`File with name ${filePath} not found in preloaded files.`);
          }
          if (dataOffset + dataLength > fileData.byteLength) {
            throw new Error("Out of bounds: data offset and length exceed the external file data size.");
          }
          const buffer = fileData.slice(dataOffset, dataOffset + dataLength).buffer;
          let bufferView;
          switch (desc.dataType) {
            case "float32":
              bufferView = new Float32Array(buffer);
              break;
            case "float16":
              bufferView = typeof Float16Array !== "undefined" && Float16Array.from ? new Float16Array(buffer) : new Uint16Array(buffer);
              break;
            case "int32":
              bufferView = new Int32Array(buffer);
              break;
            case "uint32":
              bufferView = new Uint32Array(buffer);
              break;
            case "int64":
              if (shouldConvertInt64ToInt32) {
                const int32Buffer = convertDataToInt32(new Uint8Array(buffer), "int64");
                bufferView = new Int32Array(int32Buffer.buffer);
                desc.dataType = "int32";
              } else {
                bufferView = new BigInt64Array(buffer);
              }
              break;
            case "uint64":
              bufferView = new BigUint64Array(buffer);
              break;
            case "int8":
              bufferView = new Int8Array(buffer);
              break;
            case "int4":
            case "uint4":
            case "uint8":
              bufferView = new Uint8Array(buffer);
              break;
            default:
              throw new Error(`Unsupported data type: ${desc.dataType} in creating WebNN Constant from external data.`);
          }
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] registerMLConstant {dataType: ${desc.dataType}, shape: ${desc.shape}}} ${shouldConvertInt64ToInt32 ? "(Note: it was int64 data type and registered to int32 as workaround)" : ""}`
          );
          return builder.constant(desc, bufferView);
        }
        registerGraphInput(inputName) {
          this.temporaryGraphInputs.push(inputName);
        }
        registerGraphOutput(outputName) {
          this.temporaryGraphOutputs.push(outputName);
        }
        isGraphInput(sessionId, inputName) {
          const inputNames = this.sessionGraphInputs.get(sessionId);
          if (!inputNames) {
            return false;
          }
          return inputNames.includes(inputName);
        }
        isGraphOutput(sessionId, outputName) {
          const outputNames = this.sessionGraphOutputs.get(sessionId);
          if (!outputNames) {
            return false;
          }
          return outputNames.includes(outputName);
        }
        isGraphInputOutputTypeSupported(sessionId, type, isInput = true) {
          const dataType = onnxDataTypeToWebnnDataType.get(tensorDataTypeStringToEnum(type));
          const opLimits = this.mlOpSupportLimitsBySessionId.get(sessionId);
          if (typeof dataType === "undefined") {
            return false;
          }
          if (isInput) {
            return !!opLimits?.input.dataTypes.includes(dataType);
          } else {
            return !!opLimits?.output.dataTypes.includes(dataType);
          }
        }
        flush() {
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/types.ts
  var init_types = __esm({
    "web/lib/wasm/jsep/webgpu/types.ts"() {
      "use strict";
    }
  });

  // web/lib/wasm/jsep/webgpu/gpu-data-manager.ts
  var bucketFreelist, bucketArr, calcNormalizedBufferSize, calcBucketBufferSize, guid, createNewGpuDataId, downloadGpuData, GpuDataManagerImpl, createGpuDataManager;
  var init_gpu_data_manager = __esm({
    "web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"() {
      "use strict";
      init_log();
      init_types();
      bucketFreelist = /* @__PURE__ */ new Map([
        [64, 250],
        [128, 200],
        [256, 200],
        [512, 200],
        [2048, 230],
        [4096, 200],
        [8192, 50],
        [16384, 50],
        [32768, 50],
        [65536, 50],
        [131072, 50],
        [262144, 50],
        [524288, 50],
        [1048576, 50],
        [2097152, 30],
        [4194304, 20],
        [8388608, 10],
        [12582912, 10],
        [16777216, 10],
        [26214400, 15],
        [33554432, 22],
        [44236800, 2],
        [58982400, 6],
        // we don't want to cache the bucket sizes below but not caching them
        // results in some major performance hits for models like sd-turbo.
        [67108864, 6],
        [134217728, 6],
        [167772160, 6]
      ]);
      bucketArr = [];
      calcNormalizedBufferSize = (size) => Math.ceil(Number(size) / 16) * 16;
      calcBucketBufferSize = (size) => {
        for (let idx = 0; idx < bucketArr.length; idx++) {
          const sizeForBucket = bucketArr[idx];
          if (size <= sizeForBucket) {
            return sizeForBucket;
          }
        }
        return Math.ceil(size / 16) * 16;
      };
      guid = 1;
      createNewGpuDataId = () => guid++;
      downloadGpuData = async (backend, gpuBuffer, originalSize, getTargetBuffer) => {
        const bufferSize = calcNormalizedBufferSize(originalSize);
        const gpuReadBuffer = backend.device.createBuffer(
          // eslint-disable-next-line no-bitwise
          { size: bufferSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }
        );
        try {
          const commandEncoder = backend.getCommandEncoder();
          backend.endComputePass();
          commandEncoder.copyBufferToBuffer(
            gpuBuffer,
            0,
            gpuReadBuffer,
            0,
            bufferSize
          );
          backend.flush();
          await gpuReadBuffer.mapAsync(GPUMapMode.READ);
          const arrayBuffer = gpuReadBuffer.getMappedRange();
          if (getTargetBuffer) {
            const targetBuffer = getTargetBuffer();
            targetBuffer.set(new Uint8Array(arrayBuffer, 0, originalSize));
            return targetBuffer;
          } else {
            return new Uint8Array(arrayBuffer.slice(0, originalSize));
          }
        } finally {
          gpuReadBuffer.destroy();
        }
      };
      GpuDataManagerImpl = class {
        constructor(backend) {
          this.backend = backend;
          this.storageCache = /* @__PURE__ */ new Map();
          this.freeBuffers = /* @__PURE__ */ new Map();
          this.freeUniformBuffers = /* @__PURE__ */ new Map();
          this.buffersPending = [];
          this.capturedPendingBuffers = /* @__PURE__ */ new Map();
          for (const [key] of bucketFreelist) {
            bucketArr.push(key);
            this.freeBuffers.set(key, []);
            this.freeUniformBuffers.set(key, []);
          }
          this.sessionCount = 0;
        }
        upload(id, data) {
          const srcArrayBuffer = data.buffer;
          const srcOffset = data.byteOffset;
          const srcLength = data.byteLength;
          const size = calcNormalizedBufferSize(srcLength);
          const gpuDataCache = this.storageCache.get(id);
          if (!gpuDataCache) {
            throw new Error("gpu data for uploading does not exist");
          }
          if (Number(gpuDataCache.originalSize) !== srcLength) {
            throw new Error(`inconsistent data size. gpu data size=${gpuDataCache.originalSize}, data size=${srcLength}`);
          }
          const gpuBufferForUploading = this.backend.device.createBuffer(
            // eslint-disable-next-line no-bitwise
            { mappedAtCreation: true, size, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }
          );
          const arrayBuffer = gpuBufferForUploading.getMappedRange();
          new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer, srcOffset, srcLength));
          gpuBufferForUploading.unmap();
          const commandEncoder = this.backend.device.createCommandEncoder();
          commandEncoder.copyBufferToBuffer(gpuBufferForUploading, 0, gpuDataCache.gpuData.buffer, 0, size);
          this.backend.device.queue.submit([commandEncoder.finish()]);
          gpuBufferForUploading.destroy();
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.upload(id=${id})`);
        }
        memcpy(sourceId, destinationId) {
          const sourceGpuDataCache = this.storageCache.get(sourceId);
          if (!sourceGpuDataCache) {
            throw new Error("source gpu data for memcpy does not exist");
          }
          const destinationGpuDataCache = this.storageCache.get(destinationId);
          if (!destinationGpuDataCache) {
            throw new Error("destination gpu data for memcpy does not exist");
          }
          if (sourceGpuDataCache.originalSize !== destinationGpuDataCache.originalSize) {
            throw new Error("inconsistent source and destination gpu data size");
          }
          const size = calcNormalizedBufferSize(sourceGpuDataCache.originalSize);
          const commandEncoder = this.backend.getCommandEncoder();
          this.backend.endComputePass();
          commandEncoder.copyBufferToBuffer(
            sourceGpuDataCache.gpuData.buffer,
            0,
            destinationGpuDataCache.gpuData.buffer,
            0,
            size
          );
        }
        registerExternalBuffer(buffer, originalSize, previous) {
          let id;
          if (previous) {
            id = previous[0];
            if (buffer === previous[1]) {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, buffer is the same, skip.`
              );
              return id;
            } else if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) {
              throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
            }
          } else {
            id = createNewGpuDataId();
          }
          this.storageCache.set(id, { gpuData: { id, type: 0 /* default */, buffer }, originalSize });
          LOG_DEBUG(
            "verbose",
            () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, registered.`
          );
          return id;
        }
        unregisterExternalBuffer(id) {
          if (id !== void 0) {
            this.storageCache.delete(id);
            LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${id}`);
          }
        }
        // eslint-disable-next-line no-bitwise
        create(size, usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
          const bufferSize = calcBucketBufferSize(size);
          let gpuBuffer;
          const isStorage = (usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE;
          const isUniform = (usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
          if (isStorage || isUniform) {
            const freeBuffers = isStorage ? this.freeBuffers : this.freeUniformBuffers;
            const buffers = freeBuffers.get(bufferSize);
            if (!buffers) {
              gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
            } else {
              if (buffers.length > 0) {
                gpuBuffer = buffers.pop();
              } else {
                gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
              }
            }
          } else {
            gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
          }
          const gpuData = { id: createNewGpuDataId(), type: 0 /* default */, buffer: gpuBuffer };
          this.storageCache.set(gpuData.id, { gpuData, originalSize: Number(size) });
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.create(size=${size}) => id=${gpuData.id}`);
          return gpuData;
        }
        get(id) {
          return this.storageCache.get(id)?.gpuData;
        }
        release(idInput) {
          const id = typeof idInput === "bigint" ? Number(idInput) : idInput;
          const cachedData = this.storageCache.get(id);
          if (!cachedData) {
            if (this.storageCache.size === 0) {
              return 0;
            } else {
              throw new Error("releasing data does not exist");
            }
          }
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.release(id=${id}), gpuDataId=${cachedData.gpuData.id}`);
          this.storageCache.delete(id);
          this.buffersPending.push(cachedData.gpuData.buffer);
          return cachedData.originalSize;
        }
        async download(id, getTargetBuffer) {
          const cachedData = this.storageCache.get(Number(id));
          if (!cachedData) {
            throw new Error("data does not exist");
          }
          await downloadGpuData(this.backend, cachedData.gpuData.buffer, cachedData.originalSize, getTargetBuffer);
        }
        refreshPendingBuffers() {
          if (this.buffersPending.length === 0) {
            return;
          }
          if (this.backend.sessionStatus === "default") {
            for (const buffer of this.buffersPending) {
              const maxInFreeList = bucketFreelist.get(buffer.size);
              if ((buffer.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
                const freelist = this.freeBuffers.get(buffer.size) || [];
                if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                  buffer.destroy();
                } else {
                  freelist.push(buffer);
                }
              } else if ((buffer.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
                const freelist = this.freeUniformBuffers.get(buffer.size) || [];
                if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                  buffer.destroy();
                } else {
                  freelist.push(buffer);
                }
              } else {
                buffer.destroy();
              }
            }
            this.buffersPending = [];
          } else {
            let capturedBuffers = this.capturedPendingBuffers.get(this.backend.currentSessionId);
            if (!capturedBuffers) {
              capturedBuffers = [];
              this.capturedPendingBuffers.set(this.backend.currentSessionId, capturedBuffers);
            }
            for (const buffer of this.buffersPending) {
              capturedBuffers.push(buffer);
            }
            this.buffersPending = [];
          }
        }
        dispose() {
          this.freeBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.freeUniformBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.storageCache.forEach((storage) => {
            storage.gpuData.buffer.destroy();
          });
          this.capturedPendingBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.storageCache = /* @__PURE__ */ new Map();
          this.freeBuffers = /* @__PURE__ */ new Map();
          this.freeUniformBuffers = /* @__PURE__ */ new Map();
          this.capturedPendingBuffers = /* @__PURE__ */ new Map();
        }
        onCreateSession() {
          this.sessionCount += 1;
        }
        onReleaseSession(sessionId) {
          const pendingBuffers = this.capturedPendingBuffers.get(sessionId);
          if (pendingBuffers) {
            pendingBuffers.forEach((buffer) => {
              buffer.destroy();
            });
            this.capturedPendingBuffers.delete(sessionId);
          }
          this.sessionCount -= 1;
          if (this.sessionCount === 0) {
            LOG_DEBUG("warning", () => "[WebGPU] Clearing webgpu buffer cache");
            this.storageCache.forEach((storage) => {
              storage.gpuData.buffer.destroy();
            });
            this.storageCache = /* @__PURE__ */ new Map();
          }
        }
      };
      createGpuDataManager = (...args) => new GpuDataManagerImpl(...args);
    }
  });

  // web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts
  var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
  var init_attribute_with_cache_key = __esm({
    "web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"() {
      "use strict";
      AttributeWithCacheKeyImpl = class {
        constructor(attribute) {
          Object.assign(this, attribute);
        }
        get cacheKey() {
          if (!this.key) {
            this.key = Object.getOwnPropertyNames(this).sort().map((name) => `${this[name]}`).join(";");
          }
          return this.key;
        }
      };
      createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/common.ts
  var WORKGROUP_SIZE, getWgslMappedType, tensorTypeToWsglStorageType, tensorTypeToWsglValueType, createTensorShapeVariables, getMaxComponents, fillVector, castToF32, sumVector, getElementAt, createIndicesHelper, inputVariable, outputVariable, atomicOutputVariable, internalVariable, ShaderHelperImpl, createShaderHelper;
  var init_common = __esm({
    "web/lib/wasm/jsep/webgpu/ops/common.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      WORKGROUP_SIZE = 64;
      getWgslMappedType = (type, components) => {
        if (components === 3) {
          throw new Error("vec3 has same alignment as vec4, use vec4 instead");
        }
        switch (Number(type)) {
          case 10 /* float16 */:
            return components > 1 ? `vec${components}<f16>` : "f16";
          case 1 /* float */:
            return components > 1 ? `vec${components}<f32>` : "f32";
          case 6 /* int32 */:
            return components > 1 ? `vec${components}<i32>` : "i32";
          case 12 /* uint32 */:
            return components > 1 ? `vec${components}<u32>` : "u32";
          case 7 /* int64 */:
            if (components > 1) {
              throw new Error("currently not supported vecX of uint64 yet");
            }
            return ["vec2<u32>", "i32"];
          case 13 /* uint64 */:
            if (components > 1) {
              throw new Error("currently not supported vecX of uint64 yet");
            }
            return ["vec2<u32>", "u32"];
          case 9 /* bool */:
            if (components !== 4) {
              throw new Error("bool must be vec4");
            }
            return ["u32", "vec4<bool>"];
          case 22 /* int4 */:
            return "i32";
          case 21 /* uint4 */:
            return "u32";
          default:
            throw new Error(`Unknown data type: ${type}`);
        }
      };
      tensorTypeToWsglStorageType = (type, components = 1) => {
        const mappedType = getWgslMappedType(type, components);
        return typeof mappedType === "string" ? mappedType : mappedType[0];
      };
      tensorTypeToWsglValueType = (type, components = 1) => {
        const mappedType = getWgslMappedType(type, components);
        return typeof mappedType === "string" ? mappedType : mappedType[1];
      };
      createTensorShapeVariables = (...dims) => {
        const programUniforms = [];
        dims.forEach((dim) => {
          if (dim.length !== 0) {
            programUniforms.push(
              { type: 12 /* uint32 */, data: dim },
              { type: 12 /* uint32 */, data: ShapeUtil.computeStrides(dim) }
            );
          }
        });
        return programUniforms;
      };
      getMaxComponents = (size) => {
        if (size % 4 === 0) {
          return 4;
        } else if (size % 2 === 0) {
          return 2;
        }
        return 1;
      };
      fillVector = (dataType = "f32", components, value = "0") => {
        if (!components || components === 1) {
          return `${dataType}(${value})`;
        }
        return `vec${components}<${dataType}>(${value})`;
      };
      castToF32 = (dataType, components, value) => {
        if (dataType === "f32") {
          return value;
        }
        if (components === 1) {
          return `f32(${value})`;
        }
        return `vec${components}<f32>(${value})`;
      };
      sumVector = (name, components) => {
        if (components === 4) {
          return `(${name}.x + ${name}.y + ${name}.z + ${name}.w)`;
        } else if (components === 2) {
          return `(${name}.x + ${name}.y)`;
        } else if (components === 3) {
          return `(${name}.x + ${name}.y + ${name}.z)`;
        }
        return name;
      };
      getElementAt = (name, index, length, type) => {
        if (name.startsWith("uniforms.") && length > 4) {
          if (typeof index === "string") {
            if (type === "f16") {
              return `${name}[(${index}) / 8][(${index}) % 8 / 4][(${index}) % 8 % 4]`;
            } else {
              return `${name}[(${index}) / 4][(${index}) % 4]`;
            }
          } else {
            if (type === "f16") {
              return `${name}[${Math.floor(index / 8)}][${Math.floor(index % 8 / 4)}][${index % 8 % 4}]`;
            } else {
              return `${name}[${Math.floor(index / 4)}][${index % 4}]`;
            }
          }
        } else {
          return length > 1 ? `${name}[${index}]` : name;
        }
      };
      createIndicesHelper = (name, tensorType, shapeOrRank, usage, components) => {
        const useUniform = typeof shapeOrRank === "number";
        const rank = useUniform ? shapeOrRank : shapeOrRank.length;
        const rankIdentity = [...new Array(rank).keys()];
        const indicesType = rank < 2 ? "u32" : rank <= 4 ? `vec${rank}<u32>` : `array<u32, ${rank}>`;
        const mappedType = getWgslMappedType(tensorType, components);
        const valueType = typeof mappedType === "string" ? mappedType : mappedType[1];
        const storageType = typeof mappedType === "string" ? mappedType : mappedType[0];
        const type = { indices: indicesType, value: valueType, storage: storageType, tensor: tensorType };
        const normalizeDim = (dim) => typeof dim === "string" ? dim : `${dim}u`;
        const implementationUsed = {
          offsetToIndices: false,
          indicesToOffset: false,
          broadcastedIndicesToOffset: false,
          set: false,
          setByIndices: false,
          get: false,
          getByIndices: false
        };
        const uniformPrefix = useUniform ? "uniforms." : "";
        const shape = `${uniformPrefix}${name}_shape`;
        const strides = `${uniformPrefix}${name}_strides`;
        let o2iSnippet = "";
        for (let i = 0; i < rank - 1; i++) {
          o2iSnippet += `
    let dim${i} = current / ${getElementAt(strides, i, rank)};
    let rest${i} = current % ${getElementAt(strides, i, rank)};
    indices[${i}] = dim${i};
    current = rest${i};
    `;
        }
        o2iSnippet += `indices[${rank - 1}] = current;`;
        const offsetToIndicesImplementation = rank < 2 ? "" : `
  fn o2i_${name}(offset: u32) -> ${type.indices} {
    var indices: ${type.indices};
    var current = offset;
    ${o2iSnippet}
    return indices;
  }`;
        const offsetToIndices = (varOffset) => {
          implementationUsed.offsetToIndices = true;
          return rank < 2 ? varOffset : `o2i_${name}(${varOffset})`;
        };
        const offsets = [];
        if (rank >= 2) {
          for (let i = rank - 1; i >= 0; i--) {
            offsets.push(`${getElementAt(strides, i, rank)} * (indices[${i}])`);
          }
        }
        const indicesToOffsetImplementation = rank < 2 ? "" : `
  fn i2o_${name}(indices: ${type.indices}) -> u32 {
    return ${offsets.join("+")};
  }`;
        const indicesToOffset = (varIndices) => {
          implementationUsed.indicesToOffset = true;
          return rank < 2 ? varIndices : `i2o_${name}(${varIndices})`;
        };
        const indices = (...init2) => rank === 0 ? "0u" : `${type.indices}(${init2.map(normalizeDim).join(",")})`;
        const indicesGet = (varIndices, idx) => {
          if (rank < 2) {
            return `${varIndices}`;
          } else {
            return `${getElementAt(varIndices, idx, rank)}`;
          }
        };
        const indicesSet = (varIndices, idx, value) => {
          if (rank < 2) {
            return `${varIndices}=${value};`;
          } else {
            return `${getElementAt(varIndices, idx, rank)}=${value};`;
          }
        };
        const broadcastedIndicesToOffsetImplementation = {};
        const broadcastedIndicesToOffset = (varIndices, output) => {
          implementationUsed.broadcastedIndicesToOffset = true;
          const implKey = `${output.name}broadcastedIndicesTo${name}Offset`;
          if (implKey in broadcastedIndicesToOffsetImplementation) {
            return `${implKey}(${varIndices})`;
          }
          const offsets2 = [];
          for (let i = rank - 1; i >= 0; i--) {
            const idx = output.indicesGet("outputIndices", i + output.rank - rank);
            offsets2.push(`${indicesGet(strides, i)} * (${idx} % ${indicesGet(shape, i)})`);
          }
          broadcastedIndicesToOffsetImplementation[implKey] = `fn ${implKey}(outputIndices: ${output.type.indices}) -> u32 {
             return ${offsets2.length > 0 ? offsets2.join("+") : "0u"};
           }`;
          return `${implKey}(${varIndices})`;
        };
        const setByOffset = (offset, value) => (() => {
          if (type.storage === type.value) {
            return `${name}[${offset}]=${value};`;
          } else if (type.storage === "vec2<u32>" && type.value === "i32") {
            return `${name}[${offset}]=vec2<u32>(u32(${value}), select(0u, 0xFFFFFFFFu, ${value} < 0));`;
          } else if (type.storage === "vec2<u32>" && type.value === "u32") {
            return `${name}[${offset}]=vec2<u32>(u32(${value}), 0u);`;
          } else if (type.storage === "u32" && type.value === "vec4<bool>") {
            return `${name}[${offset}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${value}));`;
          } else {
            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
          }
        })();
        const getByOffset = (offset) => (() => {
          if (type.storage === type.value) {
            return `${name}[${offset}]`;
          } else if (type.storage === "vec2<u32>" && type.value === "i32") {
            return `i32(${name}[${offset}].x)`;
          } else if (type.storage === "vec2<u32>" && type.value === "u32") {
            return `u32(${name}[${offset}].x)`;
          } else if (type.storage === "u32" && type.value === "vec4<bool>") {
            return `vec4<bool>(bool(${name}[${offset}] & 0xFFu), bool(${name}[${offset}] & 0xFF00u), bool(${name}[${offset}] & 0xFF0000u), bool(${name}[${offset}] & 0xFF000000u))`;
          } else {
            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
          }
        })();
        const getByIndicesImplementation = rank < 2 ? "" : `
  fn get_${name}ByIndices(indices: ${type.indices}) -> ${valueType} {
    return ${getByOffset(`i2o_${name}(indices)`)};
  }`;
        const getImplementation = rank < 2 ? "" : (() => {
          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
          return `
  fn get_${name}(${functionParams}) -> ${valueType} {
    return get_${name}ByIndices(${indices(dimsParams)});
  }`;
        })();
        const get = (...indices2) => {
          if (indices2.length !== rank) {
            throw new Error(`indices length must be ${rank}`);
          }
          const normalizedIndices = indices2.map(normalizeDim).join(",");
          if (rank === 0) {
            return getByOffset("0u");
          } else if (rank === 1) {
            return getByOffset(normalizedIndices[0]);
          } else {
            implementationUsed.get = true;
            implementationUsed.getByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `get_${name}(${normalizedIndices})`;
          }
        };
        const getByIndices = (varIndices) => {
          if (rank < 2) {
            return getByOffset(varIndices);
          } else {
            implementationUsed.getByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `get_${name}ByIndices(${varIndices})`;
          }
        };
        const setByIndicesImplementation = rank < 2 ? "" : `
  fn set_${name}ByIndices(indices: ${type.indices}, value: ${valueType}) {
    ${setByOffset(`i2o_${name}(indices)`, "value")}
  }`;
        const setImplementation = rank < 2 ? "" : (() => {
          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
          return `
  fn set_${name}(${functionParams}, value: ${valueType}) {
    set_${name}ByIndices(${indices(dimsParams)}, value);
  }`;
        })();
        const set = (...indicesAndValue) => {
          if (indicesAndValue.length !== rank + 1) {
            throw new Error(`indices length must be ${rank}`);
          }
          const value = indicesAndValue[rank];
          if (typeof value !== "string") {
            throw new Error("value must be string");
          }
          const normalizedIndices = indicesAndValue.slice(0, rank).map(normalizeDim).join(",");
          if (rank === 0) {
            return setByOffset("0u", value);
          } else if (rank === 1) {
            return setByOffset(normalizedIndices[0], value);
          } else {
            implementationUsed.set = true;
            implementationUsed.setByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `set_${name}(${normalizedIndices}, ${value})`;
          }
        };
        const setByIndices = (varIndices, value) => {
          if (rank < 2) {
            return setByOffset(varIndices, value);
          } else {
            implementationUsed.setByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `set_${name}ByIndices(${varIndices}, ${value});`;
          }
        };
        const impl = () => {
          const impls = [];
          let needShapeStrides = false;
          if (implementationUsed.offsetToIndices) {
            impls.push(offsetToIndicesImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.indicesToOffset) {
            impls.push(indicesToOffsetImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.broadcastedIndicesToOffset) {
            Object.values(broadcastedIndicesToOffsetImplementation).forEach((impl2) => impls.push(impl2));
            needShapeStrides = true;
          }
          if (implementationUsed.set) {
            impls.push(setImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.setByIndices) {
            impls.push(setByIndicesImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.get) {
            impls.push(getImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.getByIndices) {
            impls.push(getByIndicesImplementation);
            needShapeStrides = true;
          }
          if (!useUniform && needShapeStrides) {
            impls.unshift(
              `const ${shape} = ${type.indices}(${shapeOrRank.join(",")});`,
              `const ${strides} = ${type.indices}(${ShapeUtil.computeStrides(shapeOrRank).join(",")});`
            );
          }
          return impls.join("\n");
        };
        return {
          impl,
          type,
          offsetToIndices,
          indicesToOffset,
          broadcastedIndicesToOffset,
          indices,
          indicesGet,
          indicesSet,
          set,
          setByOffset,
          setByIndices,
          get,
          getByOffset,
          getByIndices,
          // isVec4,
          usage,
          name,
          strides,
          shape,
          rank
        };
      };
      inputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "input", components);
      outputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "output", components);
      atomicOutputVariable = (name, type, shapeOrRank) => createIndicesHelper(name, type, shapeOrRank, "atomicOutput", 1);
      internalVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "internal", components);
      ShaderHelperImpl = class {
        constructor(normalizedDispatchGroup, limits) {
          this.normalizedDispatchGroup = normalizedDispatchGroup;
          this.limits = limits;
          this.internalVariables = [];
          this.variables = [];
          this.uniforms = [];
          this.variableIndex = 0;
        }
        guardAgainstOutOfBoundsWorkgroupSizes(size) {
          const sizeInCode = typeof size === "number" ? `${size}u` : size;
          return `if (global_idx >= ${sizeInCode}) { return; }`;
        }
        mainStart(workgroupSize = WORKGROUP_SIZE) {
          const workgroupSizeX = typeof workgroupSize === "number" ? workgroupSize : workgroupSize[0];
          const workgroupSizeY = typeof workgroupSize === "number" ? 1 : workgroupSize[1];
          const workgroupSizeZ = typeof workgroupSize === "number" ? 1 : workgroupSize[2];
          if (workgroupSizeX > this.limits.maxComputeWorkgroupSizeX || workgroupSizeY > this.limits.maxComputeWorkgroupSizeY || workgroupSizeZ > this.limits.maxComputeWorkgroupSizeZ) {
            throw new Error(
              `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`
            );
          }
          if (workgroupSizeX * workgroupSizeY * workgroupSizeZ > this.limits.maxComputeInvocationsPerWorkgroup) {
            throw new Error(
              `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`
            );
          }
          const is1DimensionDispatch = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;
          const paramList = is1DimensionDispatch ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`;
          const globalIdxDefinition = is1DimensionDispatch ? `let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;` : `let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${workgroupSizeX * workgroupSizeY * workgroupSizeZ}u + local_idx;`;
          return `@compute @workgroup_size(${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ})
  fn main(${paramList}) {
    ${globalIdxDefinition}
  `;
        }
        appendVariableUniforms(variable) {
          if (variable.rank !== 0) {
            if (variable.shape.startsWith("uniforms.")) {
              this.uniforms.push({ name: variable.shape.replace("uniforms.", ""), type: "u32", length: variable.rank });
            }
            if (variable.strides.startsWith("uniforms.")) {
              this.uniforms.push({ name: variable.strides.replace("uniforms.", ""), type: "u32", length: variable.rank });
            }
          }
        }
        declareVariable(variable, bindingIndex) {
          if (variable.usage === "internal") {
            throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
          }
          this.variables.push(variable);
          this.appendVariableUniforms(variable);
          const access = variable.usage === "input" ? "read" : "read_write";
          const storageType = variable.usage === "atomicOutput" ? `atomic<i32>` : variable.type.storage;
          return `@group(0) @binding(${bindingIndex}) var<storage, ${access}> ${variable.name}: array<${storageType}>;`;
        }
        declareVariables(...variables) {
          return variables.map((v) => this.declareVariable(v, this.variableIndex++)).join("\n");
        }
        registerInternalVariable(variable) {
          if (variable.usage !== "internal") {
            throw new Error(
              "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."
            );
          }
          this.internalVariables.push(variable);
          this.appendVariableUniforms(variable);
        }
        registerInternalVariables(...variables) {
          variables.forEach((v) => this.registerInternalVariable(v));
          return this;
        }
        registerUniform(name, type, length = 1) {
          this.uniforms.push({ name, type, length });
          return this;
        }
        registerUniforms(additionalUniforms) {
          this.uniforms = this.uniforms.concat(additionalUniforms);
          return this;
        }
        uniformDeclaration() {
          if (this.uniforms.length === 0) {
            return "";
          }
          const uniformSnippets = [];
          for (const { name, type, length } of this.uniforms) {
            if (length && length > 4) {
              if (type === "f16") {
                uniformSnippets.push(`@align(16) ${name}:array<mat2x4<${type}>, ${Math.ceil(length / 8)}>`);
              } else {
                uniformSnippets.push(`${name}:array<vec4<${type}>, ${Math.ceil(length / 4)}>`);
              }
            } else {
              const typeTemp = length == null || length === 1 ? type : `vec${length}<${type}>`;
              uniformSnippets.push(`${name}:${typeTemp}`);
            }
          }
          return `
      struct Uniforms { ${uniformSnippets.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
        }
        /**
         * Get additional implementation that needs to be added to the shader source.
         */
        get additionalImplementations() {
          return this.uniformDeclaration() + this.variables.map((i) => i.impl()).join("\n") + this.internalVariables.map((i) => i.impl()).join("\n");
        }
        /**
         * Get the variable info of the shader program.
         */
        get variablesInfo() {
          if (this.uniforms.length === 0) {
            return void 0;
          }
          const uniformWgslTypeToDataType = (type) => [12 /* uint32 */, 10 /* float16 */, 1 /* float */, 6 /* int32 */][["u32", "f16", "f32", "i32"].indexOf(type)];
          return this.uniforms.map((u) => [uniformWgslTypeToDataType(u.type), u.length ?? 1]);
        }
      };
      createShaderHelper = (dispatchGroup, limits) => new ShaderHelperImpl(dispatchGroup, limits);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/transpose.ts
  var validateInputs, getAdjustedPerm, getOutputShape, permFunctionBody, squeezeShape, isTransposeReshape, createTransposeProgramInfo, transpose, parseTransposeAttributes;
  var init_transpose = __esm({
    "web/lib/wasm/jsep/webgpu/ops/transpose.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs = (inputs, perm) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Transpose requires 1 input.");
        }
        if (perm.length !== 0 && perm.length !== inputs[0].dims.length) {
          throw new Error(`perm size ${perm.length} does not match input rank ${inputs[0].dims.length}`);
        }
      };
      getAdjustedPerm = (inputRank, perm) => perm.length !== 0 ? perm : [...new Array(inputRank).keys()].reverse();
      getOutputShape = (inputShape, perm) => ShapeUtil.sortBasedOnPerm(inputShape, getAdjustedPerm(inputShape.length, perm));
      permFunctionBody = (perm, rank, input, output) => {
        let reverseFunc = `fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`;
        for (let i = 0; i < rank; ++i) {
          reverseFunc += `a[${perm[i]}]=i[${i}];`;
        }
        return reverseFunc += "return a;}";
      };
      squeezeShape = (shape, adjustedPerm) => {
        const newShape = [];
        const newPerm = [];
        for (let i = 0; i < shape.length; ++i) {
          if (shape[i] !== 1) {
            newShape.push(shape[i]);
          }
          if (shape[adjustedPerm[i]] !== 1) {
            newPerm.push(adjustedPerm[i]);
          }
        }
        return { newShape, newPerm };
      };
      isTransposeReshape = (perm, shape) => {
        let lastPermutedAxis = 0;
        for (let i = 0; i < perm.length; ++i) {
          if (shape[perm[i]] === 1) {
            continue;
          }
          if (perm[i] < lastPermutedAxis) {
            return false;
          }
          lastPermutedAxis = perm[i];
        }
        return true;
      };
      createTransposeProgramInfo = (inputTensor, permAttr) => {
        const inputDataType = inputTensor.dataType;
        const inputRank = inputTensor.dims.length;
        const perm = getAdjustedPerm(inputRank, permAttr);
        const outputShape = getOutputShape(inputTensor.dims, perm);
        let newInputShape = inputTensor.dims;
        let newOutputShape = outputShape;
        const transposeAsReshape = inputRank < 2 || isTransposeReshape(perm, inputTensor.dims);
        let getShaderSource;
        if (transposeAsReshape) {
          getShaderSource = (shaderHelper) => {
            const input = inputVariable("input", inputDataType, newInputShape, 4);
            const output = outputVariable("output", inputDataType, newOutputShape, 4);
            return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`;
          };
          return {
            name: "TransposeCopy",
            shaderCache: { inputDependencies: ["type"] },
            getRunData: () => {
              const outputSize = ShapeUtil.size(outputShape);
              return {
                outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
                dispatchGroup: { x: Math.ceil(
                  outputSize / 64 / 4
                  /* components */
                ) },
                programUniforms: [{ type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) }]
              };
            },
            getShaderSource
          };
        }
        const { newShape, newPerm } = squeezeShape(inputTensor.dims, perm);
        const channelsLast = ShapeUtil.areEqual(newPerm, [2, 3, 1]);
        const channelsFirst = ShapeUtil.areEqual(newPerm, [3, 1, 2]);
        const useShared = newShape.length === 2 || channelsLast || channelsFirst;
        if (useShared) {
          newInputShape = channelsLast ? [newShape[0], newShape[1] * newShape[2]] : channelsFirst ? [newShape[0] * newShape[1], newShape[2]] : newShape;
          newOutputShape = [newInputShape[1], newInputShape[0]];
          const tileSize = 16;
          getShaderSource = (shaderHelper) => {
            const input = inputVariable("a", inputDataType, newInputShape.length);
            const output = outputVariable("output", inputDataType, newOutputShape.length);
            return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  var<workgroup> tile : array<array<${output.type.value}, ${tileSize + 1}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let stride = (uniforms.output_shape[1] - 1) / ${tileSize} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${tileSize}u + local_id.x;
    let input_row = workgroup_id_x * ${tileSize}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${input.getByIndices(`${input.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${tileSize}u + local_id.x;
    let output_row = workgroup_id_y * ${tileSize}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${output.setByIndices(`${output.type.indices}(output_row, output_col)`, "tile[local_id.x][local_id.y]")}
    }
  }`;
          };
          return {
            name: "TransposeShared",
            shaderCache: { inputDependencies: ["type"] },
            getRunData: () => {
              const outputSize = ShapeUtil.size(outputShape);
              return {
                outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
                dispatchGroup: { x: Math.ceil(newOutputShape[1] / tileSize), y: Math.ceil(newOutputShape[0] / tileSize) },
                programUniforms: [
                  { type: 12 /* uint32 */, data: outputSize },
                  ...createTensorShapeVariables(newInputShape, newOutputShape)
                ]
              };
            },
            getShaderSource
          };
        }
        getShaderSource = (shaderHelper) => {
          const input = inputVariable("a", inputDataType, newInputShape.length);
          const output = outputVariable("output", inputDataType, newOutputShape.length);
          return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

  ${permFunctionBody(perm, inputRank, input, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${output.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${output.setByOffset("global_idx", input.getByIndices("aIndices"))}
  }`;
        };
        return {
          name: "Transpose",
          shaderCache: { hint: `${permAttr}`, inputDependencies: ["rank"] },
          getRunData: () => {
            const outputSize = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(newInputShape, newOutputShape)
              ]
            };
          },
          getShaderSource
        };
      };
      transpose = (context, attributes) => {
        validateInputs(context.inputs, attributes.perm);
        context.compute(createTransposeProgramInfo(context.inputs[0], attributes.perm));
      };
      parseTransposeAttributes = (attributes) => createAttributeWithCacheKey({ perm: attributes.perm });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts
  var reduceOps, reduceSharedOps, reduceInitValues, reduceOutputValues, getInnerMostAxes, computeOutAndReduceShapes, expandShapeToKeepDim, areAxesInnerMostDims, getAxesPermutation, createReduceSharedProgramInfo, reduceCommon, reduceMeanShared, reduceL1Shared, reduceL2Shared, reduceLogSumExpShared, reduceMaxShared, reduceMinShared, reduceProdShared, reduceSumShared, reduceSumSquareShared, reduceLogSumShared;
  var init_reduce_shared = __esm({
    "web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_reduce();
      init_transpose();
      reduceOps = {
        max: "select(bestValue, candidate, candidate > bestValue)",
        min: "select(bestValue, candidate, candidate < bestValue)",
        mean: "bestValue + candidate",
        sum: "bestValue + candidate",
        prod: "bestValue * candidate",
        sumSquare: "bestValue + candidate * candidate",
        logSumExp: "bestValue + exp(candidate)",
        l1: "bestValue + abs(candidate)",
        l2: "bestValue + candidate * candidate",
        logSum: "bestValue + candidate"
      };
      reduceSharedOps = {
        max: "select(bestValue, candidate, candidate > bestValue)",
        min: "select(bestValue, candidate, candidate < bestValue)",
        mean: "bestValue + candidate",
        sum: "bestValue + candidate",
        prod: "bestValue * candidate",
        sumSquare: "bestValue + candidate",
        logSumExp: "bestValue + candidate",
        l1: "bestValue + candidate",
        l2: "bestValue + candidate",
        logSum: "bestValue + candidate"
      };
      reduceInitValues = {
        max: "_A[offset]",
        min: "_A[offset]",
        mean: "0",
        sum: "0",
        prod: "1",
        sumSquare: "0",
        logSumExp: "0",
        l1: "0",
        l2: "0",
        logSum: "0"
      };
      reduceOutputValues = {
        max: "bestValue",
        min: "bestValue",
        sum: "bestValue",
        prod: "bestValue",
        sumSquare: "bestValue",
        logSumExp: "log(bestValue)",
        l1: "bestValue",
        l2: "sqrt(bestValue)",
        logSum: "log(bestValue)"
      };
      getInnerMostAxes = (numInnerAxes, rank) => {
        const res = [];
        for (let i = rank - numInnerAxes; i < rank; ++i) {
          res.push(i);
        }
        return res;
      };
      computeOutAndReduceShapes = (shape, axes) => {
        const outputShape = [];
        const rank = shape.length;
        for (let dim = 0; dim < rank; dim++) {
          if (axes.indexOf(dim) === -1) {
            outputShape.push(shape[dim]);
          }
        }
        const reduceShape = axes.map((dim) => shape[dim]);
        return [outputShape, reduceShape];
      };
      expandShapeToKeepDim = (shape, axes) => {
        const rank = shape.length + axes.length;
        const expandShape = [];
        let shapeIdx = 0;
        for (let dim = 0; dim < rank; dim++) {
          if (axes.indexOf(dim) === -1) {
            expandShape.push(shape[shapeIdx++]);
          } else {
            expandShape.push(1);
          }
        }
        return expandShape;
      };
      areAxesInnerMostDims = (axes, rank) => {
        for (let i = 0; i < axes.length; ++i) {
          if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
          }
        }
        return true;
      };
      getAxesPermutation = (axes, rank) => {
        const res = [];
        if (!areAxesInnerMostDims(axes, rank)) {
          for (let i = 0; i < rank; ++i) {
            if (axes.indexOf(i) === -1) {
              res.push(i);
            }
          }
          axes.forEach((axis) => res.push(axis));
        }
        return res;
      };
      createReduceSharedProgramInfo = (name, cacheKey, inputs, reduceType, outputDataType, outputShape, reduceShape) => {
        const inputShape = inputs[0].dims;
        const outputSize = ShapeUtil.size(outputShape);
        const reduceSize = ShapeUtil.size(reduceShape);
        const input = inputVariable("_A", inputs[0].dataType, inputShape);
        const output = outputVariable("output", outputDataType, outputShape);
        let workgroupSize = 64;
        if (outputSize === 1) {
          workgroupSize = 256;
        }
        const sharedMemorySnippet = `
          var<workgroup> aBestValues : array<f32, ${workgroupSize}>;
       `;
        const getShaderSource = (shaderHelper) => `
        ${shaderHelper.registerUniform("reduceSize", "u32").declareVariables(input, output)}
        ${sharedMemorySnippet}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${shaderHelper.mainStart(workgroupSize)}

          let outputIndex = global_idx / ${workgroupSize};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${reduceInitValues[reduceType]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${workgroupSize}) {
           let candidate = f32(${input.getByOffset("offset + k")});
           bestValue = ${reduceOps[reduceType]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${workgroupSize}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${reduceSharedOps[reduceType]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${output.setByOffset(
          "outputIndex",
          `${reduceType === "mean" ? `${output.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${output.type.storage}(${reduceOutputValues[reduceType]})`}`
        )};
         }
        }`;
        return {
          name,
          // Note that in JSEP, WG size is not included in cache by default, but WebGPU EP it is.
          shaderCache: { hint: `${cacheKey};${workgroupSize}`, inputDependencies: ["type"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: outputSize },
            programUniforms: [{ type: 12 /* uint32 */, data: reduceSize }]
          })
        };
      };
      reduceCommon = (context, name, attributes, reduceType) => {
        const updatedAttributes = context.inputs.length === 1 ? attributes : createReduceAttributesFromInputs(context.inputs, attributes);
        let updatedAxes = updatedAttributes.axes;
        if (updatedAxes.length === 0 && !updatedAttributes.noopWithEmptyAxes) {
          updatedAxes = context.inputs[0].dims.map((_dim, i) => i);
        }
        const normalizeAxes = ShapeUtil.normalizeAxes(updatedAxes, context.inputs[0].dims.length);
        let axes = normalizeAxes;
        let input = context.inputs[0];
        const permutedAxes = getAxesPermutation(axes, context.inputs[0].dims.length);
        if (permutedAxes.length > 0) {
          input = context.compute(createTransposeProgramInfo(context.inputs[0], permutedAxes), {
            inputs: [0],
            outputs: [-1]
          })[0];
          axes = getInnerMostAxes(axes.length, input.dims.length);
        }
        const [outputShape, reduceShape] = computeOutAndReduceShapes(input.dims, axes);
        let finalOutputShape = outputShape;
        if (updatedAttributes.keepDims) {
          finalOutputShape = expandShapeToKeepDim(outputShape, normalizeAxes);
        }
        context.compute(
          createReduceSharedProgramInfo(
            name,
            updatedAttributes.cacheKey,
            [input],
            reduceType,
            context.inputs[0].dataType,
            finalOutputShape,
            reduceShape
          ),
          { inputs: [input] }
        );
      };
      reduceMeanShared = (context, attributes) => {
        reduceCommon(context, "ReduceMeanShared", attributes, "mean");
      };
      reduceL1Shared = (context, attributes) => {
        reduceCommon(context, "ReduceL1Shared", attributes, "l1");
      };
      reduceL2Shared = (context, attributes) => {
        reduceCommon(context, "ReduceL2Shared", attributes, "l2");
      };
      reduceLogSumExpShared = (context, attributes) => {
        reduceCommon(context, "ReduceLogSumExpShared", attributes, "logSumExp");
      };
      reduceMaxShared = (context, attributes) => {
        reduceCommon(context, "ReduceMaxShared", attributes, "max");
      };
      reduceMinShared = (context, attributes) => {
        reduceCommon(context, "ReduceMinShared", attributes, "min");
      };
      reduceProdShared = (context, attributes) => {
        reduceCommon(context, "ReduceProdShared", attributes, "prod");
      };
      reduceSumShared = (context, attributes) => {
        reduceCommon(context, "ReduceSumShared", attributes, "sum");
      };
      reduceSumSquareShared = (context, attributes) => {
        reduceCommon(context, "ReduceSumSquareShared", attributes, "sumSquare");
      };
      reduceLogSumShared = (context, attributes) => {
        reduceCommon(context, "ReduceLogSumShared", attributes, "logSum");
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/reduce.ts
  var validateInputs2, noOp, createReduceProgramInfo, createReduceAttributesFromInputs, runReduceProgram, reduceLogSumNaive, reduceL1Naive, reduceL2Naive, reduceLogSumExpNaive, reduceMaxNaive, reduceMeanNaive, reduceMinNaive, reduceProdNaive, reduceSumNaive, reduceSumSquareNaive, useNaiveReduceMethod, reduceMean, reduceL1, reduceL2, reduceLogSumExp, reduceMax, reduceMin, reduceProd, reduceSum, reduceSumSquare, reduceLogSum;
  var init_reduce = __esm({
    "web/lib/wasm/jsep/webgpu/ops/reduce.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      init_reduce_shared();
      validateInputs2 = (inputs) => {
        if (!inputs || inputs.length === 0 || inputs.length > 2) {
          throw new Error("Reduce op requires 1 or 2 inputs.");
        }
        if (inputs.length === 2 && inputs[1].dims.length !== 1) {
          throw new Error("Invalid axes input dims.");
        }
      };
      noOp = (input) => ["", "", `var value = ${input.getByIndices("input_indices")};`, ""];
      createReduceProgramInfo = (name, shaderCache, inputs, reduceOp, axesInput, outputDataType, keepDims = false, noopWithEmptyAxes = false) => {
        const outputShape = [];
        const inputShape = inputs[0].dims;
        const inputRank = inputShape.length;
        const axes = ShapeUtil.normalizeAxes(axesInput, inputRank);
        const reduceOnAllAxes = !noopWithEmptyAxes && axes.length === 0;
        inputShape.forEach((d, i) => {
          if (reduceOnAllAxes || axes.indexOf(i) >= 0) {
            if (keepDims) {
              outputShape.push(1);
            }
          } else {
            outputShape.push(d);
          }
        });
        const outputRank = outputShape.length;
        const outputSize = ShapeUtil.size(outputShape);
        const getShaderSource = (shaderHelper) => {
          const idxCopy = [];
          const input = inputVariable("_A", inputs[0].dataType, inputRank);
          const output = outputVariable("output", outputDataType, outputRank);
          const ops = reduceOp(input, output, axes);
          let reduceOps2 = ops[2];
          for (let k = 0, l = 0; k < inputRank; k++) {
            if (reduceOnAllAxes || axes.indexOf(k) >= 0) {
              if (keepDims) {
                l++;
              }
              reduceOps2 = `for(var j${k}: u32 = 0; j${k} < ${inputShape[k]}; j${k}++) {
                  ${ops[2].includes("last_index") ? `let last_index = j${k};` : ""}
                  ${input.indicesSet("input_indices", k, `j${k}`)}
                  ${reduceOps2}
                }`;
            } else {
              idxCopy.push(`${input.indicesSet("input_indices", k, output.indicesGet("output_indices", l))};`);
              l++;
            }
          }
          return `

        ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${input.type.indices};
          let output_indices = ${output.offsetToIndices("global_idx")};

          ${idxCopy.join("\n")}
          ${ops[0]}       // init ops for reduce max/min
          ${ops[1]}
          ${reduceOps2}
          ${ops[3]}
          ${ops.length === 4 ? output.setByOffset("global_idx", "value") : ops.slice(4).join("\n")}
        }`;
        };
        return {
          name,
          shaderCache,
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(inputShape, outputShape)
            ]
          })
        };
      };
      createReduceAttributesFromInputs = (inputs, attributes) => {
        const axes = [];
        if (inputs[1].dims[0] > 0) {
          inputs[1].getBigInt64Array().forEach((v) => axes.push(Number(v)));
        }
        return createAttributeWithCacheKey({
          axes,
          keepDims: attributes.keepDims,
          noopWithEmptyAxes: attributes.noopWithEmptyAxes
        });
      };
      runReduceProgram = (context, name, attributes, reduceOp) => {
        const inputs = context.inputs;
        const updatedAttributes = inputs.length === 1 ? attributes : createReduceAttributesFromInputs(inputs, attributes);
        context.compute(
          createReduceProgramInfo(
            name,
            { hint: updatedAttributes.cacheKey, inputDependencies: ["rank"] },
            [inputs[0]],
            updatedAttributes.noopWithEmptyAxes && updatedAttributes.axes.length === 0 ? noOp : reduceOp,
            updatedAttributes.axes,
            inputs[0].dataType,
            updatedAttributes.keepDims,
            updatedAttributes.noopWithEmptyAxes
          ),
          { inputs: [0] }
        );
      };
      reduceLogSumNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += ${input.getByIndices("input_indices")};`,
          "value = log(value);"
        ];
        runReduceProgram(context, "ReduceLogSum", attributes, reduceOp);
      };
      reduceL1Naive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += abs(${input.getByIndices("input_indices")});`,
          ""
        ];
        runReduceProgram(context, "ReduceL1", attributes, reduceOp);
      };
      reduceL2Naive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
          "",
          `t = ${input.getByIndices("input_indices")}; value += (t * t);`,
          "value = sqrt(value);"
        ];
        runReduceProgram(context, "ReduceL2", attributes, reduceOp);
      };
      reduceLogSumExpNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += exp(${input.getByIndices("input_indices")});`,
          "value = log(value);"
        ];
        runReduceProgram(context, "ReduceLogSumExp", attributes, reduceOp);
      };
      reduceMaxNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, _output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(input.indicesSet("input_indices", k, 0));
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};`,
            `value = max(value, ${input.getByIndices("input_indices")});`,
            ""
          ];
        };
        runReduceProgram(context, "ReduceMax", attributes, reduceOp);
      };
      reduceMeanNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output, axes) => {
          let size = 1;
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              size *= context.inputs[0].dims[k];
            }
          }
          return [
            "var sum = f32(0);",
            "",
            `sum += f32(${input.getByIndices("input_indices")});`,
            `let value = ${output.type.value}(sum / ${size});`
          ];
        };
        runReduceProgram(context, "ReduceMean", attributes, reduceOp);
      };
      reduceMinNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, _output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};`,
            `value = min(value, ${input.getByIndices("input_indices")});`,
            ""
          ];
        };
        runReduceProgram(context, "ReduceMin", attributes, reduceOp);
      };
      reduceProdNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(1);`,
          "",
          `value *= ${input.getByIndices("input_indices")};`,
          ""
        ];
        runReduceProgram(context, "ReduceProd", attributes, reduceOp);
      };
      reduceSumNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += ${input.getByIndices("input_indices")};`,
          ""
        ];
        runReduceProgram(context, "ReduceSum", attributes, reduceOp);
      };
      reduceSumSquareNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
          "",
          `t = ${input.getByIndices("input_indices")}; value += t * t;`,
          ""
        ];
        runReduceProgram(context, "ReduceSumSquare", attributes, reduceOp);
      };
      useNaiveReduceMethod = (shape, axes, noopWithEmptyAxes) => {
        if (axes.length === 0) {
          return noopWithEmptyAxes;
        }
        let outputSize = 1;
        let reduceSize = 1;
        for (let dim = 0; dim < axes.length; dim++) {
          if (axes.indexOf(dim) === -1) {
            outputSize *= shape[dim];
          } else {
            reduceSize *= shape[dim];
          }
        }
        return reduceSize < 32 && outputSize > 1024;
      };
      reduceMean = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMeanNaive(context, attributes);
        } else {
          reduceMeanShared(context, attributes);
        }
      };
      reduceL1 = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceL1Naive(context, attributes);
        } else {
          reduceL1Shared(context, attributes);
        }
      };
      reduceL2 = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceL2Naive(context, attributes);
        } else {
          reduceL2Shared(context, attributes);
        }
      };
      reduceLogSumExp = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceLogSumExpNaive(context, attributes);
        } else {
          reduceLogSumExpShared(context, attributes);
        }
      };
      reduceMax = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMaxNaive(context, attributes);
        } else {
          reduceMaxShared(context, attributes);
        }
      };
      reduceMin = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMinNaive(context, attributes);
        } else {
          reduceMinShared(context, attributes);
        }
      };
      reduceProd = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceProdNaive(context, attributes);
        } else {
          reduceProdShared(context, attributes);
        }
      };
      reduceSum = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceSumNaive(context, attributes);
        } else {
          reduceSumShared(context, attributes);
        }
      };
      reduceSumSquare = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceSumSquareNaive(context, attributes);
        } else {
          reduceSumSquareShared(context, attributes);
        }
      };
      reduceLogSum = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceLogSumNaive(context, attributes);
        } else {
          reduceLogSumShared(context, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/argminmax.ts
  var validateInputs3, argMin, argMax, parseArgMinMaxAttributes;
  var init_argminmax = __esm({
    "web/lib/wasm/jsep/webgpu/ops/argminmax.ts"() {
      "use strict";
      init_wasm_common();
      init_attribute_with_cache_key();
      init_reduce();
      validateInputs3 = (inputs) => {
        if (!inputs || inputs.length === 0 || inputs.length > 2) {
          throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
        }
        if (inputs[0].dataType !== 1 /* float */) {
          throw new Error("Invalid input type.");
        }
      };
      argMin = (context, attributes) => {
        validateInputs3(context.inputs);
        const argMinMaxOp = (input, output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
            "",
            output.setByOffset("global_idx", "best_index")
          ];
        };
        context.compute(
          createReduceProgramInfo(
            "ArgMin",
            { hint: attributes.cacheKey, inputDependencies: ["rank"] },
            [context.inputs[0]],
            argMinMaxOp,
            [attributes.axis],
            7 /* int64 */,
            attributes.keepDims
          ),
          { inputs: [0] }
        );
      };
      argMax = (context, attributes) => {
        validateInputs3(context.inputs);
        const argMinMaxOp = (input, output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
            "",
            output.setByOffset("global_idx", "best_index")
          ];
        };
        context.compute(
          createReduceProgramInfo(
            "argMax",
            { hint: attributes.cacheKey, inputDependencies: ["rank"] },
            [context.inputs[0]],
            argMinMaxOp,
            [attributes.axis],
            7 /* int64 */,
            attributes.keepDims
          ),
          { inputs: [0] }
        );
      };
      parseArgMinMaxAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/attention.ts
  var validateAttentionInputs, initVarStub, createInPlaceSoftmaxProgramInfo, createAttentionProbsProgramInfo, createVxAttentionScoreProgramInfo, applyAttention, prepare, attention;
  var init_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/attention.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_types();
      init_common();
      validateAttentionInputs = (inputs, attributes) => {
        const input = inputs[0];
        const weights = inputs[1];
        const bias = inputs[2];
        const maskIndex = inputs[3];
        const past = inputs[4];
        const attentionBias = inputs[5];
        if (past && attentionBias) {
          throw new Error("Attention cannot have both past and attention_bias");
        }
        if (input.dims.length !== 3) {
          throw new Error('Input "input" must have 3 dimensions');
        }
        const batchSize = input.dims[0];
        const sequenceLength = input.dims[1];
        const inputHiddenSize = input.dims[2];
        if (bias.dims.length !== 1) {
          throw new Error('Input "bias" is expected to have 1 dimensions');
        }
        if (weights.dims.length !== 2) {
          throw new Error('Input "weights" is expected to have 2 dimensions');
        }
        if (weights.dims[0] !== inputHiddenSize) {
          throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
        }
        if (bias.dims[0] !== weights.dims[1]) {
          throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
        }
        let qHiddenSize = bias.dims[0] / 3;
        let kHiddenSize = qHiddenSize;
        let vHiddenSize = kHiddenSize;
        if (attributes.qkvHiddenSizes.length > 0) {
          if (attributes.qkvHiddenSizes.length !== 3) {
            throw new Error("qkv_hidden_sizes attribute should have 3 elements");
          }
          for (const sz of attributes.qkvHiddenSizes) {
            if (sz % attributes.numHeads !== 0) {
              throw new Error("qkv_hidden_sizes should be divisible by num_heads");
            }
          }
          qHiddenSize = attributes.qkvHiddenSizes[0];
          kHiddenSize = attributes.qkvHiddenSizes[1];
          vHiddenSize = attributes.qkvHiddenSizes[2];
        }
        const kvSequenceLength = sequenceLength;
        if (qHiddenSize !== kHiddenSize) {
          throw new Error("qkv_hidden_sizes first element should be same as the second");
        }
        if (bias.dims[0] !== qHiddenSize + kHiddenSize + vHiddenSize) {
          throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
        }
        let pastSequenceLength = 0;
        if (past) {
          if (kHiddenSize !== vHiddenSize) {
            throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
          }
          if (past.dims.length !== 5) {
            throw new Error('Input "past" must have 5 dimensions');
          }
          if (past.dims[0] !== 2) {
            throw new Error('Input "past" first dimension must be 2');
          }
          if (past.dims[1] !== batchSize) {
            throw new Error('Input "past" second dimension must be batch_size');
          }
          if (past.dims[2] !== attributes.numHeads) {
            throw new Error('Input "past" third dimension must be num_heads');
          }
          if (past.dims[4] !== kHiddenSize / attributes.numHeads) {
            throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
          }
          if (!attributes.pastPresentShareBuffer) {
            pastSequenceLength = past.dims[3];
          }
        }
        const totalSequenceLength = kvSequenceLength + pastSequenceLength;
        const maxSequenceLength = -1;
        const maskType = 0 /* none */;
        if (maskIndex) {
          throw new Error("Mask not supported");
        }
        if (past) {
          throw new Error("past is not supported");
        }
        if (attentionBias) {
          if (attentionBias.dims.length !== 4) {
            throw new Error('Input "attention_bias" must have 4 dimensions');
          }
          if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
            throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
          }
        }
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize,
          hiddenSize: qHiddenSize,
          vHiddenSize,
          headSize: Math.floor(qHiddenSize / attributes.numHeads),
          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
          numHeads: attributes.numHeads,
          isUnidirectional: false,
          pastPresentShareBuffer: false,
          maskFilterValue: attributes.maskFilterValue,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias: false,
          passPastInKv: false,
          qkvFormat: 1 /* qkvBNSH */
        };
      };
      initVarStub = (seqLensInput, totalSequenceLengthInput, initPastSequenceLength) => {
        if (totalSequenceLengthInput && seqLensInput) {
          return `
      let total_sequence_length_input = u32(${totalSequenceLengthInput.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${seqLensInput?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `;
        } else {
          return `
    ${initPastSequenceLength ? "let past_sequence_length = uniforms.past_sequence_length" : ""};
    let present_sequence_length = total_sequence_length;
    `;
        }
      };
      createInPlaceSoftmaxProgramInfo = (input, batchSize, numHeads, pastSequenceLength, sequenceLength, totalSequenceLength, seqLens, totalSequenceLengthInput) => {
        const components = getMaxComponents(seqLens ? 1 : totalSequenceLength);
        let WG = 64;
        const totalSequenceLengthComp = totalSequenceLength / components;
        if (totalSequenceLengthComp < WG) {
          WG = 32;
        }
        const elementsPerThread = Math.ceil(totalSequenceLength / components / WG);
        const programUniforms = [
          { type: 12 /* uint32 */, data: batchSize },
          { type: 12 /* uint32 */, data: numHeads },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: sequenceLength },
          { type: 12 /* uint32 */, data: totalSequenceLengthComp },
          { type: 12 /* uint32 */, data: elementsPerThread }
        ];
        const dataType = tensorTypeToWsglStorageType(input.dataType, components);
        const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
        const inputDependencies = ["type"];
        if (seqLens) {
          inputDependencies.push("type");
        }
        if (totalSequenceLengthInput) {
          inputDependencies.push("type");
        }
        const getShaderSource = (shaderHelper) => {
          const inputHelper = outputVariable("x", input.dataType, input.dims, components);
          const inputHelpers = [inputHelper];
          const seqLensInputHelper = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
          if (seqLensInputHelper) {
            inputHelpers.push(seqLensInputHelper);
          }
          const totalSequenceLengthInputHelper = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
          if (totalSequenceLengthInputHelper) {
            inputHelpers.push(totalSequenceLengthInputHelper);
          }
          const elemValueType = tensorTypeToWsglValueType(input.dataType);
          const uniforms = [
            { name: "batch_size", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "sequence_length", type: "u32" },
            { name: "total_sequence_length", type: "u32" },
            { name: "elements_per_thread", type: "u32" }
          ];
          return `
  var<workgroup> thread_max: array<f32, ${WG}>;
  var<workgroup> thread_sum: array<f32, ${WG}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputHelpers)}
  ${shaderHelper.mainStart([WG, 1, 1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${initVarStub(seqLensInputHelper, totalSequenceLengthInputHelper, false)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${WG}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${seqLens ? "u32(past_sequence_length + workgroup_id.y + 1)" : "total_sequence_length"};
    var thread_max_vector = ${f32Type}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${f32Type}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
            switch (components) {
              case 1:
                return "thread_max_vector";
              case 2:
                return "max(thread_max_vector.x, thread_max_vector.y)";
              case 4:
                return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${WG}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f32Type}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${f32Type}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
            switch (components) {
              case 1:
                return "sum_vector";
              case 2:
                return "sum_vector.x + sum_vector.y";
              case 4:
                return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${WG}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${inputHelper.type.value}(${elemValueType}(1.0) / ${elemValueType}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${f32Type}(x[offset + i]);
        x[offset + i] = ${inputHelper.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${seqLens ? `
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${inputHelper.type.value}(${elemValueType}(0));
        }` : ""};
  }`;
        };
        return {
          name: "AttentionProbsSoftmax",
          shaderCache: { hint: `${WG};${dataType};${components}`, inputDependencies },
          getShaderSource,
          getRunData: () => ({
            outputs: [],
            dispatchGroup: { x: 1, y: sequenceLength, z: batchSize * numHeads },
            programUniforms
          })
        };
      };
      createAttentionProbsProgramInfo = (outputCount, q, key, pastKey, attentionBias, parameters, pastSequenceLength, seqLens, totalSequenceLengthInput) => {
        const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
        const probsShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, totalSequenceLength];
        const presentKey = outputCount > 1 && pastKey;
        const kvNumHeads = parameters.kvNumHeads ? parameters.kvNumHeads : parameters.numHeads;
        const presentKeyShape = presentKey ? [parameters.batchSize, kvNumHeads, totalSequenceLength, parameters.headSize] : void 0;
        const nReps = parameters.nReps ? parameters.nReps : 1;
        const alpha = parameters.scale === 0 ? 1 / Math.sqrt(parameters.headSize) : parameters.scale;
        const components = getMaxComponents(parameters.headSize);
        const vectorizedHeadSize = parameters.headSize / components;
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(totalSequenceLength / TILE_SIZE),
          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
          z: parameters.batchSize * parameters.numHeads
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: parameters.sequenceLength },
          { type: 12 /* uint32 */, data: vectorizedHeadSize },
          { type: 12 /* uint32 */, data: totalSequenceLength },
          { type: 12 /* uint32 */, data: parameters.numHeads },
          { type: 12 /* uint32 */, data: parameters.headSize },
          { type: 1 /* float */, data: alpha },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: parameters.kvSequenceLength },
          { type: 12 /* uint32 */, data: nReps }
        ];
        const feedPastKey = presentKey && pastKey && ShapeUtil.size(pastKey.dims) > 0;
        const inputDependencies = ["type", "type"];
        if (feedPastKey) {
          inputDependencies.push("type");
        }
        if (attentionBias) {
          inputDependencies.push("type");
        }
        if (seqLens) {
          inputDependencies.push("type");
        }
        if (totalSequenceLengthInput) {
          inputDependencies.push("type");
        }
        const outputs = [{ dims: probsShape, dataType: q.dataType, gpuDataType: 0 /* default */ }];
        if (presentKey) {
          outputs.push({ dims: presentKeyShape, dataType: q.dataType, gpuDataType: 0 /* default */ });
        }
        const getShaderSource = (shaderHelper) => {
          const qInput = inputVariable("q", q.dataType, q.dims, components);
          const kInput = inputVariable("key", key.dataType, key.dims, components);
          const inputVars = [qInput, kInput];
          if (feedPastKey) {
            const pastKeyInput = inputVariable("past_key", pastKey.dataType, pastKey.dims, components);
            inputVars.push(pastKeyInput);
          }
          if (attentionBias) {
            inputVars.push(inputVariable("attention_bias", attentionBias.dataType, attentionBias.dims));
          }
          const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
          if (seqLensInputVariable) {
            inputVars.push(seqLensInputVariable);
          }
          const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
          if (totalSequenceLengthInputVariable) {
            inputVars.push(totalSequenceLengthInputVariable);
          }
          const output = outputVariable("output", q.dataType, probsShape);
          const outputVars = [output];
          if (presentKey) {
            outputVars.push(outputVariable("present_key", q.dataType, presentKeyShape, components));
          }
          const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "head_size", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "kv_sequence_length", type: "u32" },
            { name: "n_reps", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;

  var<workgroup> tileQ: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
    let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${feedPastKey && presentKey ? "let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;" : ""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${presentKey ? "let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${f32Type}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${(() => {
            if (feedPastKey && presentKey) {
              return `
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`;
            } else {
              return `
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`;
            }
          })()}
      ${presentKey ? `if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }` : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${f32Type}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
            switch (components) {
              case 1:
                return "value";
              case 2:
                return "value.x + value.y";
              case 4:
                return "value.x + value.y + value.z + value.w";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
        output[outputIdx] = ${output.type.value} (sum * uniforms.alpha) + ${attentionBias ? "attention_bias[outputIdx]" : "0.0"};
    }
  }`;
        };
        return {
          name: "AttentionProbs",
          shaderCache: {
            hint: `${components};${attentionBias !== void 0};${pastKey !== void 0};${outputCount}`,
            inputDependencies
          },
          getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
          getShaderSource
        };
      };
      createVxAttentionScoreProgramInfo = (outputCount, probs, v, pastValue, params, pastSequenceLength, seqLens = void 0, totalSequenceLengthInput = void 0) => {
        const totalSequenceLength = pastSequenceLength + params.kvSequenceLength;
        const nReps = params.nReps ? params.nReps : 1;
        const repeatedVHiddenSize = params.vHiddenSize * nReps;
        const presentValue = outputCount > 1 && pastValue;
        const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
        const presentValueShape = presentValue ? [params.batchSize, kvNumHeads, totalSequenceLength, params.headSize] : void 0;
        const outputShape = [params.batchSize, params.sequenceLength, repeatedVHiddenSize];
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(params.vHeadSize / TILE_SIZE),
          y: Math.ceil(params.sequenceLength / TILE_SIZE),
          z: params.batchSize * params.numHeads
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: params.sequenceLength },
          { type: 12 /* uint32 */, data: totalSequenceLength },
          { type: 12 /* uint32 */, data: params.vHeadSize },
          { type: 12 /* uint32 */, data: params.numHeads },
          { type: 12 /* uint32 */, data: params.headSize },
          { type: 12 /* uint32 */, data: repeatedVHiddenSize },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: params.kvSequenceLength },
          { type: 12 /* uint32 */, data: nReps }
        ];
        const feedPastValue = presentValue && pastValue && ShapeUtil.size(pastValue.dims) > 0;
        const inputDependencies = ["type", "type"];
        if (feedPastValue) {
          inputDependencies.push("type");
        }
        if (seqLens) {
          inputDependencies.push("type");
        }
        if (totalSequenceLengthInput) {
          inputDependencies.push("type");
        }
        const outputs = [{ dims: outputShape, dataType: probs.dataType, gpuDataType: 0 /* default */ }];
        if (presentValue) {
          outputs.push({ dims: presentValueShape, dataType: probs.dataType, gpuDataType: 0 /* default */ });
        }
        const getShaderSource = (shaderHelper) => {
          const probsHelper = inputVariable("probs", probs.dataType, probs.dims);
          const vHelper = inputVariable("v", v.dataType, v.dims);
          const inputVars = [probsHelper, vHelper];
          if (feedPastValue) {
            inputVars.push(inputVariable("past_value", pastValue.dataType, pastValue.dims));
          }
          const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
          if (seqLens) {
            inputVars.push(seqLensInputVariable);
          }
          const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
          if (totalSequenceLengthInput) {
            inputVars.push(totalSequenceLengthInputVariable);
          }
          const output = outputVariable("output", probs.dataType, outputShape);
          const outputVars = [output];
          if (presentValue) {
            outputVars.push(outputVariable("present_value", probs.dataType, presentValueShape));
          }
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "head_size", type: "u32" },
            { name: "v_hidden_size", type: "u32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "kv_sequence_length", type: "u32" },
            { name: "n_reps", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileQ: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileV: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
   let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${feedPastValue && presentValue ? "let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;" : ""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${presentValue ? "let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${probsHelper.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${(() => {
            if (feedPastValue && presentValue) {
              return `
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `;
            } else {
              return `
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`;
            }
          })()}
        ${presentValue ? `
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }` : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
        };
        return {
          name: "AttentionScore",
          shaderCache: { hint: `${pastValue !== void 0};${outputCount}`, inputDependencies },
          getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
          getShaderSource
        };
      };
      applyAttention = (context, q, k, v, _maskIndex, _past, pastKey, pastValue, attentionBiasInput, parameters, seqLens = void 0, totalSequenceLengthInput = void 0) => {
        const outputCount = Math.min(context.outputCount, 1 + (pastKey ? 1 : 0) + (pastValue ? 1 : 0));
        const pastSequenceLength = outputCount > 1 ? parameters.pastSequenceLength : 0;
        const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
        const attentionBias = attentionBiasInput && ShapeUtil.size(attentionBiasInput.dims) > 0 ? attentionBiasInput : void 0;
        const inputsK = [q, k];
        if (outputCount > 1 && pastKey && ShapeUtil.size(pastKey.dims) > 0) {
          inputsK.push(pastKey);
        }
        if (attentionBias) {
          inputsK.push(attentionBias);
        }
        if (seqLens) {
          inputsK.push(seqLens);
        }
        if (totalSequenceLengthInput) {
          inputsK.push(totalSequenceLengthInput);
        }
        const probs = context.compute(
          createAttentionProbsProgramInfo(
            outputCount,
            q,
            k,
            pastKey,
            attentionBias,
            parameters,
            pastSequenceLength,
            seqLens,
            totalSequenceLengthInput
          ),
          { inputs: inputsK, outputs: outputCount > 1 ? [-1, 1] : [-1] }
        )[0];
        context.compute(
          createInPlaceSoftmaxProgramInfo(
            probs,
            parameters.batchSize,
            parameters.numHeads,
            pastSequenceLength,
            parameters.sequenceLength,
            totalSequenceLength,
            seqLens,
            totalSequenceLengthInput
          ),
          { inputs: seqLens && totalSequenceLengthInput ? [probs, seqLens, totalSequenceLengthInput] : [probs], outputs: [] }
        );
        const inputsV = [probs, v];
        if (outputCount > 1 && pastValue && ShapeUtil.size(pastValue.dims) > 0) {
          inputsV.push(pastValue);
        }
        if (seqLens) {
          inputsV.push(seqLens);
        }
        if (totalSequenceLengthInput) {
          inputsV.push(totalSequenceLengthInput);
        }
        context.compute(
          createVxAttentionScoreProgramInfo(
            outputCount,
            probs,
            v,
            pastValue,
            parameters,
            pastSequenceLength,
            seqLens,
            totalSequenceLengthInput
          ),
          {
            inputs: inputsV,
            outputs: outputCount > 1 ? [0, 2] : [0]
          }
        );
      };
      prepare = (context, parameters) => {
        const outputShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, parameters.headSize];
        const M = parameters.sequenceLength;
        const K = parameters.inputHiddenSize;
        const N = parameters.headSize;
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(parameters.headSize / TILE_SIZE),
          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
          z: parameters.batchSize * parameters.numHeads
        };
        const inputs = [context.inputs[0], context.inputs[1], context.inputs[2]];
        const programUniforms = [
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: K },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: parameters.numHeads },
          { type: 12 /* uint32 */, data: parameters.headSize },
          { type: 12 /* uint32 */, data: parameters.hiddenSize },
          { type: 12 /* uint32 */, data: parameters.hiddenSize + parameters.hiddenSize + parameters.vHiddenSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const outputQ = outputVariable("output_q", inputs[0].dataType, outputShape);
          const outputK = outputVariable("output_k", inputs[0].dataType, outputShape);
          const outputV = outputVariable("output_v", inputs[0].dataType, outputShape);
          const input = inputVariable("input", inputs[0].dataType, inputs[0].dims);
          const weight = inputVariable("weight", inputs[1].dataType, inputs[1].dims);
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
          const dataType = input.type.storage;
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "head_size", type: "u32" },
            { name: "hidden_size", type: "u32" },
            { name: "ldb", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileInput: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightQ: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightK: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightV: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(input, weight, bias, outputQ, outputK, outputV)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${dataType}(0);
    var valueK = ${dataType}(0);
    var valueV = ${dataType}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
        };
        return context.compute(
          {
            name: "AttentionPrepare",
            shaderCache: { inputDependencies: ["type", "type", "type"] },
            getRunData: () => ({
              outputs: [
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ }
              ],
              dispatchGroup: dispatch,
              programUniforms
            }),
            getShaderSource
          },
          { inputs, outputs: [-1, -1, -1] }
        );
      };
      attention = (context, attributes) => {
        const params = validateAttentionInputs(context.inputs, attributes);
        const [q, k, v] = prepare(context, params);
        return applyAttention(
          context,
          q,
          k,
          v,
          context.inputs[4],
          void 0,
          void 0,
          void 0,
          context.inputs[5],
          params
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/batch-norm.ts
  var validateInputs4, createBatchNormInferenceProgramInfo, parseBatchNormAttributes, batchNorm;
  var init_batch_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs4 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 5) {
          throw new Error("BatchNormalization requires 5 inputs");
        }
        const checkShapeEqual = (actual, expected, message) => {
          const r = expected.length;
          if (r !== actual.length) {
            throw new Error(`${message}: num dimensions != ${r}`);
          }
          expected.forEach((v, i) => {
            if (v !== actual[i]) {
              throw new Error(`${message}: dim[${i}] do not match`);
            }
          });
        };
        if (inputs[0].dims.length > 1) {
          const shape = attributes.format === "NHWC" ? attributes.spatial ? inputs[0].dims.slice(-1) : inputs[0].dims.slice(-1).concat(inputs[0].dims.slice(1, inputs[0].dims.length - 1)) : inputs[0].dims.slice(1, attributes.spatial ? 2 : void 0);
          checkShapeEqual(inputs[1].dims, shape, "Invalid input scale");
          checkShapeEqual(inputs[2].dims, shape, "Invalid input B");
          checkShapeEqual(inputs[3].dims, shape, "Invalid input mean");
          checkShapeEqual(inputs[4].dims, shape, "Invalid input var");
        } else {
          checkShapeEqual(inputs[1].dims, [1], "Invalid input scale");
          checkShapeEqual(inputs[2].dims, [1], "Invalid input B");
          checkShapeEqual(inputs[3].dims, [1], "Invalid input mean");
          checkShapeEqual(inputs[4].dims, [1], "Invalid input var");
        }
      };
      createBatchNormInferenceProgramInfo = (inputs, attributes) => {
        const { epsilon, spatial, format } = attributes;
        const yShape = inputs[0].dims;
        const components = spatial ? getMaxComponents(yShape[yShape.length - 1]) : 1;
        const cComponents = format === "NHWC" && yShape.length > 1 ? components : 1;
        const outputSize = ShapeUtil.size(yShape) / components;
        const useShapesUniforms = spatial;
        const shapeOrRank = useShapesUniforms ? yShape.length : yShape;
        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims, components);
        const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims, cComponents);
        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims, cComponents);
        const inputMean = inputVariable("inputMean", inputs[3].dataType, inputs[3].dims, cComponents);
        const inputVar = inputVariable("inputVar", inputs[4].dataType, inputs[4].dims, cComponents);
        const y = outputVariable("y", inputs[0].dataType, shapeOrRank, components);
        const calcCOffset = () => {
          let cOffset = "";
          if (spatial) {
            cOffset = `let cOffset = ${yShape.length === 1 ? "0u" : format === "NHWC" ? `outputIndices[${yShape.length - 1}] / ${components}` : "outputIndices[1]"};`;
          } else {
            if (format === "NCHW") {
              cOffset = `
            ${y.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${y.indicesToOffset("outputIndices")};`;
            } else {
              cOffset = `var cIndices = ${scale.type.indices}(0);
                       cIndices[0] = outputIndices[${yShape.length - 1}];`;
              for (let i = 1; i < scale.rank; i++) {
                cOffset += `cIndices[${i}] = outputIndices[${i}];`;
              }
              cOffset += `let cOffset = ${scale.indicesToOffset("cIndices")};`;
            }
          }
          return cOffset;
        };
        const getInferenceModeShaderSource = (helper) => `
  const epsilon = ${epsilon};
  ${helper.registerUniform("outputSize", "u32").declareVariables(x, scale, bias, inputMean, inputVar, y)}
  ${helper.mainStart()}
  ${helper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${y.offsetToIndices(`global_idx * ${components}`)};
    ${calcCOffset()}
    let scale = ${scale.getByOffset("cOffset")};
    let bias = ${bias.getByOffset("cOffset")};
    let inputMean = ${inputMean.getByOffset("cOffset")};
    let inputVar = ${inputVar.getByOffset("cOffset")};
    let x = ${x.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${y.setByOffset("global_idx", "value")}
  }`;
        return {
          name: "BatchNormalization",
          shaderCache: {
            hint: `${attributes.epsilon}_${attributes.format}_${spatial}_${components}`,
            inputDependencies: useShapesUniforms ? ["rank", "type", "type", "type", "type"] : void 0
          },
          getShaderSource: getInferenceModeShaderSource,
          getRunData: () => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: useShapesUniforms ? [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(yShape)] : [{ type: 12 /* uint32 */, data: outputSize }]
          })
        };
      };
      parseBatchNormAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      batchNorm = (context, attributes) => {
        const { inputs, outputCount } = context;
        const updatedAttributes = parseBatchNormAttributes({ ...attributes, outputCount });
        if (env2.webgpu.validateInputContent) {
          validateInputs4(inputs, updatedAttributes);
        }
        if (attributes.trainingMode) {
          throw new Error("BatchNormalization trainingMode is not supported yet.");
        } else {
          context.compute(createBatchNormInferenceProgramInfo(inputs, updatedAttributes));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/bias-add.ts
  var validateInputs5, createBiasAddProgramInfo, biasAdd;
  var init_bias_add = __esm({
    "web/lib/wasm/jsep/webgpu/ops/bias-add.ts"() {
      "use strict";
      init_util();
      init_common();
      validateInputs5 = (inputs) => {
        if (inputs[0].dims.length !== 3) {
          throw new Error("input should have 3 dimensions");
        }
        if (![320, 640, 1280].includes(inputs[0].dims[2])) {
          throw new Error("number of channels should be 320, 640 or 1280");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("bias is expected to have 1 dimensions");
        }
        if (inputs[0].dims[2] !== inputs[1].dims[0]) {
          throw new Error("last dimension of input and bias are not the same");
        }
      };
      createBiasAddProgramInfo = (inputs) => {
        const outputShape = inputs[0].dims;
        const channels = inputs[0].dims[2];
        const outputSize = ShapeUtil.size(outputShape) / 4;
        const dataType = inputs[0].dataType;
        const input = inputVariable("input", dataType, outputShape, 4);
        const bias = inputVariable("bias", dataType, [channels], 4);
        const residual = inputVariable("residual", dataType, outputShape, 4);
        const output = outputVariable("output", dataType, outputShape, 4);
        const getShaderSource = (shaderHelper) => `
  const channels = ${channels}u / 4;
  ${shaderHelper.declareVariables(input, bias, residual, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let value = ${input.getByOffset("global_idx")}
      + ${bias.getByOffset("global_idx % channels")} + ${residual.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", "value")}
  }`;
        return {
          name: "BiasAdd",
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) }
          }),
          getShaderSource
        };
      };
      biasAdd = (context) => {
        validateInputs5(context.inputs);
        context.compute(createBiasAddProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/unary-op.ts
  var createElementwiseProgramShader, createElementwiseProgramInfo, abs, acos, acosh, asin, asinh, atan, atanh, parseCastAttributes, cast, generateClipAttributesFromInputs, clip, ceil, cos, cosh, parseAlphaAttributes, elu, erfImpl, erf, exp, floor, gelu, leakyRelu, not, neg, reciprocal, relu, sigmoid, parseHardSigmoidAttributes, hardSigmoid, sin, sinh, sqrt, tan, tanhExpression, tanh, fastGeluImpl, fastGeluExpression, fastGelu, thresholdedRelu, log, quickGeluImpl, quickGeluExpression, quickgelu;
  var init_unary_op = __esm({
    "web/lib/wasm/jsep/webgpu/ops/unary-op.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      createElementwiseProgramShader = (shaderHelper, datasize, inputDataType, outputDataType, funcCall, additionalImplementation, additionalUniformsType) => {
        const vecSize = Math.ceil(datasize / 4);
        let expression = "";
        if (typeof funcCall === "string") {
          expression = `${funcCall}(a)`;
        } else {
          expression = funcCall("a");
        }
        const input = inputVariable("inputData", inputDataType, [vecSize], 4);
        const output = outputVariable("outputData", outputDataType, [vecSize], 4);
        const uniforms = [{ name: "vec_size", type: "u32" }];
        if (additionalUniformsType) {
          uniforms.push(...additionalUniformsType);
        }
        return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}

  ${additionalImplementation ?? ""}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${input.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", expression)}
  }`;
      };
      createElementwiseProgramInfo = (input, name, funcCall, additionalImplementation, cacheKey, outputDataType = input.dataType, additionalUniforms, additionalUniformsType) => {
        const programUniforms = [
          { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(input.dims) / 4) }
        ];
        if (additionalUniforms) {
          programUniforms.push(...additionalUniforms);
        }
        return {
          name,
          shaderCache: { hint: cacheKey, inputDependencies: ["type"] },
          getShaderSource: (shaderHelper) => createElementwiseProgramShader(
            shaderHelper,
            ShapeUtil.size(input.dims),
            input.dataType,
            outputDataType,
            funcCall,
            additionalImplementation,
            additionalUniformsType
          ),
          getRunData: (inputTensors) => ({
            outputs: [{ dims: input.dims, dataType: outputDataType }],
            dispatchGroup: {
              x: Math.ceil(
                ShapeUtil.size(inputTensors[0].dims) / 64 / 4
                /* vec size */
              )
            },
            programUniforms
          })
        };
      };
      abs = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Abs", "abs"));
      };
      acos = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acos", "acos"));
      };
      acosh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acosh", "acosh"));
      };
      asin = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asin", "asin"));
      };
      asinh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asinh", "asinh"));
      };
      atan = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atan", "atan"));
      };
      atanh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atanh", "atanh"));
      };
      parseCastAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      cast = (context, attributes) => {
        let func;
        switch (attributes.to) {
          case 10 /* float16 */:
            func = "vec4<f16>";
            break;
          case 1 /* float */:
            func = "vec4<f32>";
            break;
          case 12 /* uint32 */:
            func = "vec4<u32>";
            break;
          case 6 /* int32 */:
            func = "vec4<i32>";
            break;
          case 9 /* bool */:
            func = "vec4<bool>";
            break;
          default:
            throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${attributes.to}`);
        }
        context.compute(
          createElementwiseProgramInfo(context.inputs[0], "Cast", func, void 0, attributes.cacheKey, attributes.to)
        );
      };
      generateClipAttributesFromInputs = (inputs) => {
        let min;
        let max;
        const hasMin = inputs.length >= 2 && inputs[1].data !== 0;
        const hasMax = inputs.length >= 3 && inputs[2].data !== 0;
        switch (inputs[0].dataType) {
          case 1 /* float */:
            min = hasMin ? inputs[1].getFloat32Array()[0] : -34028234663852886e22;
            max = hasMax ? inputs[2].getFloat32Array()[0] : 34028234663852886e22;
            break;
          case 10 /* float16 */:
            min = hasMin ? inputs[1].getUint16Array()[0] : 64511;
            max = hasMax ? inputs[2].getUint16Array()[0] : 31743;
            break;
          default:
            throw new Error("Unsupport data type");
        }
        return createAttributeWithCacheKey({ min, max });
      };
      clip = (context, clipAttributes) => {
        const attributes = clipAttributes ? clipAttributes : generateClipAttributesFromInputs(context.inputs);
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Clip",
            (a) => `clamp(${a}, vec4<${dataType}>(uniforms.min), vec4<${dataType}>(uniforms.max))`,
            void 0,
            attributes.cacheKey,
            void 0,
            [
              { type: context.inputs[0].dataType, data: attributes.min },
              { type: context.inputs[0].dataType, data: attributes.max }
            ],
            [
              { name: "min", type: dataType },
              { name: "max", type: dataType }
            ]
          ),
          { inputs: [0] }
        );
      };
      ceil = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Ceil", "ceil"));
      };
      cos = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cos", "cos"));
      };
      cosh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cosh", "cosh"));
      };
      parseAlphaAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      elu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Elu",
            (a) => `elu_vf32(${a})`,
            `
  const elu_alpha_ = ${dataType}(${attributes.alpha});

  fn elu_f32(a: ${dataType}) -> ${dataType} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${dataType}>) -> vec4<${dataType}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,
            attributes.cacheKey
          )
        );
      };
      erfImpl = (varType = "f32") => `
const r0: ${varType} = 0.3275911;
const r1: ${varType} = 0.254829592;
const r2: ${varType} = -0.284496736;
const r3: ${varType} = 1.421413741;
const r4: ${varType} = -1.453152027;
const r5: ${varType} = 1.061405429;

fn erf_vf32(v: vec4<${varType}>) -> vec4<${varType}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`;
      erf = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Erf", (a) => `erf_vf32(${a})`, erfImpl(dataType)));
      };
      exp = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Exp", "exp"));
      };
      floor = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Floor", "floor"));
      };
      gelu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Gelu",
            (a) => `0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,
            erfImpl(dataType)
          )
        );
      };
      leakyRelu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "LeakyRelu",
            (a) => `select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${dataType}>(0.0))`,
            `const leaky_relu_alpha_ = ${dataType}(${attributes.alpha});`,
            attributes.cacheKey
          )
        );
      };
      not = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Not", (a) => `!${a}`));
      };
      neg = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Neg", (a) => `-${a}`));
      };
      reciprocal = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Reciprocal", (a) => `1.0/${a}`));
      };
      relu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Relu",
            (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > vec4<${dataType}>(0.0))`
          )
        );
      };
      sigmoid = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sigmoid", (a) => `(1.0 / (1.0 + exp(-${a})))`));
      };
      parseHardSigmoidAttributes = (attributes) => createAttributeWithCacheKey(
        attributes
      );
      hardSigmoid = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "HardSigmoid",
            (a) => `max(vec4<${dataType}>(0.0), min(vec4<${dataType}>(1.0), ${attributes.alpha} * ${a} + vec4<${dataType}>(${attributes.beta})))`,
            void 0,
            attributes.cacheKey
          )
        );
      };
      sin = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sin", "sin"));
      };
      sinh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sinh", "sinh"));
      };
      sqrt = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sqrt", "sqrt"));
      };
      tan = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tan", "tan"));
      };
      tanhExpression = (a) => `sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`;
      tanh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tanh", tanhExpression));
      };
      fastGeluImpl = (varType = "f32") => `
const fast_gelu_a: ${varType} = 0.5;
const fast_gelu_b: ${varType} = 0.7978845608028654;
const fast_gelu_c: ${varType} = 0.035677408136300125;

fn tanh_v(v: vec4<${varType}>) -> vec4<${varType}> {
  return ${tanhExpression("v")};
}
`;
      fastGeluExpression = (x) => `(fast_gelu_a + fast_gelu_a * tanh_v(${x} * (fast_gelu_c * ${x} * ${x} + fast_gelu_b))) * ${x}`;
      fastGelu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "FastGelu",
            fastGeluExpression,
            fastGeluImpl(dataType),
            void 0,
            context.inputs[0].dataType
          )
        );
      };
      thresholdedRelu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "ThresholdedRelu",
            (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,
            `const thresholded_relu_alpha_ = vec4<${dataType}>(${attributes.alpha});`,
            attributes.cacheKey
          )
        );
        return 0;
      };
      log = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Log", "log"));
      };
      quickGeluImpl = (varType, alpha) => `
const alpha = vec4<${varType}>(${alpha});
const one = ${varType}(1.0);
const zero = ${varType}(0.0);

fn quick_gelu_impl(x: vec4<${varType}>) -> vec4<${varType}> {
  let v = x *alpha;
  var x1 : vec4<${varType}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`;
      quickGeluExpression = (x) => `quick_gelu_impl(${x})`;
      quickgelu = (context, attributes) => {
        const dType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "QuickGelu",
            quickGeluExpression,
            quickGeluImpl(dType, attributes.alpha),
            attributes.cacheKey,
            context.inputs[0].dataType
          )
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts
  var validateInputs6, createBiasSplitGeluProgramInfo, biasSplitGelu;
  var init_bias_split_gelu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"() {
      "use strict";
      init_util();
      init_common();
      init_unary_op();
      validateInputs6 = (inputs) => {
        if (inputs[0].dims.length !== 3) {
          throw new Error("input should have 3 dimensions");
        }
        if (![2560, 5120, 10240].includes(inputs[0].dims[2])) {
          throw new Error("hidden state should be 2560, 5120 or 10240");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("bias is expected to have 1 dimensions");
        }
        if (inputs[0].dims[2] !== inputs[1].dims[0]) {
          throw new Error("last dimension of input and bias are not the same");
        }
      };
      createBiasSplitGeluProgramInfo = (inputs) => {
        const outputShape = inputs[0].dims.slice();
        outputShape[2] = outputShape[2] / 2;
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims, 4);
        const bias = inputVariable("bias", inputs[0].dataType, [inputs[0].dims[2]], 4);
        const output = outputVariable("output", inputs[0].dataType, outputShape, 4);
        const outputSize = ShapeUtil.size(outputShape) / 4;
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const getShaderSource = (shaderHelper) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${inputs[0].dims[2] / 4 / 2}u;

  ${shaderHelper.declareVariables(input, bias, output)}

  ${erfImpl(dataType)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${output.setByOffset("global_idx", "valueLeft * geluRight")}
  }`;
        return {
          name: "BiasSplitGelu",
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) }
          }),
          getShaderSource
        };
      };
      biasSplitGelu = (context) => {
        validateInputs6(context.inputs);
        context.compute(createBiasSplitGeluProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/binary-op.ts
  var createBinaryOpProgramShader, createBinaryOpProgramInfo, runBinaryOp, add, div, equal, mul, pow, sub, greater, less, greaterOrEqual, lessOrEqual;
  var init_binary_op = __esm({
    "web/lib/wasm/jsep/webgpu/ops/binary-op.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      createBinaryOpProgramShader = (shaderHelper, dimsA, dimsB, dimsOutput, vectorize, doBroadcast, sharedDimensionDivisibleBy4, funcCall, typeA, typeB, typeOutput, additionalImplementation) => {
        let expressionScalar;
        let expressionVector;
        if (typeof funcCall === "string") {
          expressionScalar = expressionVector = (a2, b2) => `${funcCall}((${a2}),(${b2}))`;
        } else if (typeof funcCall === "function") {
          expressionScalar = expressionVector = funcCall;
        } else {
          expressionScalar = funcCall.scalar;
          expressionVector = funcCall.vector;
        }
        const output = outputVariable("outputData", typeOutput, dimsOutput.length, 4);
        const a = inputVariable("aData", typeA, dimsA.length, 4);
        const b = inputVariable("bData", typeB, dimsB.length, 4);
        let assignment;
        if (vectorize) {
          if (doBroadcast) {
            const isAOneElement = ShapeUtil.size(dimsA) === 1;
            const isBOneElement = ShapeUtil.size(dimsB) === 1;
            const aLastDimDivisibleBy4 = dimsA.length > 0 && dimsA[dimsA.length - 1] % 4 === 0;
            const bLastDimDivisibleBy4 = dimsB.length > 0 && dimsB[dimsB.length - 1] % 4 === 0;
            if (isAOneElement || isBOneElement) {
              assignment = output.setByOffset(
                "global_idx",
                expressionVector(
                  isAOneElement ? `${a.type.value}(${a.getByOffset("0")}.x)` : a.getByOffset("global_idx"),
                  isBOneElement ? `${b.type.value}(${b.getByOffset("0")}.x)` : b.getByOffset("global_idx")
                )
              );
            } else {
              assignment = `
            let outputIndices = ${output.offsetToIndices("global_idx * 4u")};
            let offsetA = ${a.broadcastedIndicesToOffset("outputIndices", output)};
            let offsetB = ${b.broadcastedIndicesToOffset("outputIndices", output)};
            ${output.setByOffset(
                "global_idx",
                expressionVector(
                  sharedDimensionDivisibleBy4 || aLastDimDivisibleBy4 ? a.getByOffset("offsetA / 4u") : `${a.type.value}(${a.getByOffset("offsetA / 4u")}[offsetA % 4u])`,
                  sharedDimensionDivisibleBy4 || bLastDimDivisibleBy4 ? b.getByOffset("offsetB / 4u") : `${b.type.value}(${b.getByOffset("offsetB / 4u")}[offsetB % 4u])`
                )
              )}
          `;
            }
          } else {
            assignment = output.setByOffset(
              "global_idx",
              expressionVector(a.getByOffset("global_idx"), b.getByOffset("global_idx"))
            );
          }
        } else {
          if (!doBroadcast) {
            throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
          }
          const singleAssignment = (resStr, x, typeCast = "") => {
            const expressionA = `aData[indexA${x}][componentA${x}]`;
            const expressionB = `bData[indexB${x}][componentB${x}]`;
            return `
            let outputIndices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${a.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let offsetB${x} = ${b.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expressionScalar(expressionA, expressionB)});
          `;
          };
          if (typeOutput === 9 /* bool */) {
            assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
          } else {
            assignment = `
            ${singleAssignment("outputData[global_idx]", 0)}
            ${singleAssignment("outputData[global_idx]", 1)}
            ${singleAssignment("outputData[global_idx]", 2)}
            ${singleAssignment("outputData[global_idx]", 3)}
          `;
          }
        }
        return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(a, b, output)}

        ${additionalImplementation ?? ""}

        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
      };
      createBinaryOpProgramInfo = (name, cacheKey, a, b, funcCall, additionalImplementation, outputDataType = a.dataType) => {
        const aDims = a.dims.map((x) => Number(x) ?? 1);
        const bDims = b.dims.map((x) => Number(x) ?? 1);
        const isBroadcast = !ShapeUtil.areEqual(aDims, bDims);
        let outputShape = aDims;
        let outputSize = ShapeUtil.size(aDims);
        let vectorize = false;
        let sharedDimensionDivisibleBy4 = false;
        const cacheKeyAux = [isBroadcast];
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(aDims, bDims, false);
          if (!calculatedShape) {
            throw new Error("Can't perform binary op on the given tensors");
          }
          outputShape = calculatedShape.slice();
          outputSize = ShapeUtil.size(outputShape);
          const isAOneElement = ShapeUtil.size(aDims) === 1;
          const isBOneElement = ShapeUtil.size(bDims) === 1;
          const aLastDimDivisibleBy4 = aDims.length > 0 && aDims[aDims.length - 1] % 4 === 0;
          const bLastDimDivisibleBy4 = bDims.length > 0 && bDims[bDims.length - 1] % 4 === 0;
          cacheKeyAux.push(isAOneElement);
          cacheKeyAux.push(isBOneElement);
          cacheKeyAux.push(aLastDimDivisibleBy4);
          cacheKeyAux.push(bLastDimDivisibleBy4);
          let sharedDimension = 1;
          for (let i = 1; i < outputShape.length; i++) {
            const dimA = aDims[aDims.length - i];
            const dimB = bDims[bDims.length - i];
            if (dimA === dimB) {
              sharedDimension *= dimA;
            } else {
              break;
            }
          }
          if (sharedDimension % 4 === 0) {
            sharedDimensionDivisibleBy4 = true;
            vectorize = true;
          } else if (isAOneElement || isBOneElement || aLastDimDivisibleBy4 || bLastDimDivisibleBy4) {
            vectorize = true;
          }
        } else {
          vectorize = true;
        }
        cacheKeyAux.push(vectorize);
        return {
          name,
          shaderCache: {
            hint: cacheKey + cacheKeyAux.map((x) => x.toString()).join("_"),
            inputDependencies: ["rank", "rank"]
          },
          getShaderSource: (shaderHelper) => createBinaryOpProgramShader(
            shaderHelper,
            aDims,
            bDims,
            outputShape,
            vectorize,
            isBroadcast,
            sharedDimensionDivisibleBy4,
            funcCall,
            a.dataType,
            b.dataType,
            outputDataType,
            additionalImplementation
          ),
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64 / 4
              /* component size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(outputShape) / 4) },
              ...createTensorShapeVariables(aDims, bDims, outputShape)
            ]
          })
        };
      };
      runBinaryOp = (context, name, funcCall, additionalImplementation, cacheKey, outputDataType) => {
        context.compute(
          createBinaryOpProgramInfo(
            name,
            cacheKey ?? "",
            context.inputs[0],
            context.inputs[1],
            funcCall,
            additionalImplementation,
            outputDataType
          )
        );
      };
      add = (context) => {
        runBinaryOp(context, "Add", (a, b) => `${a}+${b}`);
      };
      div = (context) => {
        runBinaryOp(context, "Div", (a, b) => `${a}/${b}`);
      };
      equal = (context) => {
        runBinaryOp(
          context,
          "Equal",
          { scalar: (a, b) => `u32(${a}==${b})`, vector: (a, b) => `vec4<u32>(${a}==${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      mul = (context) => {
        runBinaryOp(context, "Mul", (a, b) => `${a}*${b}`);
      };
      pow = (context) => {
        const type = inputVariable("input", context.inputs[0].dataType, context.inputs[0].dims).type.value;
        const roundStr = type === "i32" ? "round" : "";
        runBinaryOp(
          context,
          "Pow",
          { scalar: (a, b) => `pow_custom(${a},${b})`, vector: (a, b) => `pow_vector_custom(${a},${b})` },
          `
    fn pow_custom(a : ${type}, b : ${type}) -> ${type} {
      if (b == ${type}(0.0)) {
        return ${type}(1.0);
      } else if (a < ${type}(0.0) && f32(b) != floor(f32(b))) {
        return ${type}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${type}(1.0), round(f32(abs(b) % ${type}(2.0))) != 1.0) * ${type}(${roundStr}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${type}>, b : vec4<${type}>) -> vec4<${type}> {
      // TODO: implement vectorized pow
      return vec4<${type}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `
        );
      };
      sub = (context) => {
        runBinaryOp(context, "Sub", (a, b) => `${a}-${b}`);
      };
      greater = (context) => {
        runBinaryOp(
          context,
          "Greater",
          { scalar: (a, b) => `u32(${a}>${b})`, vector: (a, b) => `vec4<u32>(${a}>${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      less = (context) => {
        runBinaryOp(
          context,
          "Less",
          { scalar: (a, b) => `u32(${a}<${b})`, vector: (a, b) => `vec4<u32>(${a}<${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      greaterOrEqual = (context) => {
        runBinaryOp(
          context,
          "GreaterOrEqual",
          { scalar: (a, b) => `u32(${a}>=${b})`, vector: (a, b) => `vec4<u32>(${a}>=${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      lessOrEqual = (context) => {
        runBinaryOp(
          context,
          "LessOrEqual",
          { scalar: (a, b) => `u32(${a}<=${b})`, vector: (a, b) => `vec4<u32>(${a}<=${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/concat.ts
  var validateInputs7, calculateInputIndexImpl, assignOutputData, createConcatProgramInfo, concat, parseConcatAttributes;
  var init_concat = __esm({
    "web/lib/wasm/jsep/webgpu/ops/concat.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs7 = (inputs, axis) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        const referenceIndex = 0;
        const referenceInput = inputs[referenceIndex];
        const inputType = referenceInput.dataType;
        const inputRank = referenceInput.dims.length;
        inputs.forEach((input, i) => {
          if (i === referenceIndex) {
            return;
          }
          if (input.dataType !== inputType) {
            throw new Error("input tensors should be one type");
          }
          if (input.dims.length !== inputRank) {
            throw new Error("input tensors should have the same shape");
          }
          input.dims.forEach((dim, i2) => {
            if (i2 !== axis && dim !== referenceInput.dims[i2]) {
              throw new Error("non concat dimensions must match");
            }
          });
        });
      };
      calculateInputIndexImpl = (numberOfTensors, sizeInConcatAxisStr) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${numberOfTensors}u>(${sizeInConcatAxisStr});
    for (var i: u32 = 0u; i < ${numberOfTensors}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${numberOfTensors}u;
  }`;
      assignOutputData = (inputs, output) => {
        const numberOfTensors = inputs.length;
        const codeLines = [];
        for (let i = 0; i < numberOfTensors; ++i) {
          const returnSnippet = output.setByOffset("global_idx", inputs[i].getByIndices("indices"));
          if (numberOfTensors === 1) {
            codeLines.push(returnSnippet);
          } else if (i === 0) {
            codeLines.push(`if (inputIndex == ${i}u) { ${returnSnippet} }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`else { ${returnSnippet} }`);
          } else {
            codeLines.push(`else if (inputIndex == ${i}) { ${returnSnippet} }`);
          }
        }
        return codeLines.join("\n");
      };
      createConcatProgramInfo = (inputs, adjustedAxis, outputShape, dataType) => {
        const outputSize = ShapeUtil.size(outputShape);
        const sizeInConcatAxis = new Array(inputs.length);
        const inputVars = new Array(inputs.length);
        let previousSum = 0;
        const inputDependencies = [];
        const inputRanks = [];
        const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }];
        for (let i = 0; i < inputs.length; ++i) {
          previousSum += inputs[i].dims[adjustedAxis];
          sizeInConcatAxis[i] = previousSum;
          inputRanks.push(inputs[i].dims.length);
          inputVars[i] = inputVariable(`input${i}`, dataType, inputRanks[i]);
          inputDependencies.push("rank");
          programUniforms.push({ type: 12 /* uint32 */, data: sizeInConcatAxis[i] });
        }
        for (let i = 0; i < inputs.length; ++i) {
          programUniforms.push(...createTensorShapeVariables(inputs[i].dims));
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const output = outputVariable("output", dataType, outputShape.length);
        const indicesAxis = output.indicesGet("indices", adjustedAxis);
        const sizeInConcatAxisStr = Array.from(Array(sizeInConcatAxis.length).keys()).map((i) => `uniforms.sizeInConcatAxis${i}`).join(",");
        const getShaderSource = (shaderHelper) => `

  ${(() => {
          shaderHelper.registerUniform("outputSize", "u32");
          for (let i = 0; i < inputs.length; i++) {
            shaderHelper.registerUniform(`sizeInConcatAxis${i}`, "u32");
          }
          return shaderHelper.declareVariables(...inputVars, output);
        })()}

  ${calculateInputIndexImpl(sizeInConcatAxis.length, sizeInConcatAxisStr)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${output.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${indicesAxis});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${sizeInConcatAxis.length}u>(${sizeInConcatAxisStr});
      ${indicesAxis} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${assignOutputData(inputVars, output)}
  }`;
        return {
          name: "Concat",
          shaderCache: { hint: `${adjustedAxis}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      concat = (context, attributes) => {
        const inputs = context.inputs;
        const inputShape = inputs[0].dims;
        const adjustedAxis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        validateInputs7(inputs, adjustedAxis);
        const outputShape = inputShape.slice();
        outputShape[adjustedAxis] = inputs.reduce(
          (sum, input) => sum + (input.dims.length > adjustedAxis ? input.dims[adjustedAxis] : 0),
          0
        );
        const nonEmptyInputs = inputs.filter((input) => ShapeUtil.size(input.dims) > 0);
        context.compute(createConcatProgramInfo(nonEmptyInputs, adjustedAxis, outputShape, inputs[0].dataType), {
          inputs: nonEmptyInputs
        });
      };
      parseConcatAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts
  var getActivationSnippet, appendActivationUniformsData, appendActivationUniforms, parseInternalActivationAttributes;
  var init_fuse_utils = __esm({
    "web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      getActivationSnippet = (attributes, valueType, baseType = "f32") => {
        switch (attributes.activation) {
          case "Relu":
            return `value = max(value, ${valueType}(0.0));`;
          case "Sigmoid":
            return `value = (${valueType}(1.0) / (${valueType}(1.0) + exp(-value)));`;
          case "Clip":
            return `value = clamp(value, ${valueType}(${baseType}(uniforms.clip_min)), ${valueType}(${baseType}(uniforms.clip_max)));`;
          case "HardSigmoid":
            return `value = max(${valueType}(0.0), min(${valueType}(1.0), ${baseType}(uniforms.alpha) * value + ${baseType}(uniforms.beta)));`;
          case "LeakyRelu":
            return `value = select(${baseType}(uniforms.alpha) * value, value, value >= ${valueType}(0.0));`;
          case "Tanh":
            return `let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;
          case "":
            return "";
          // TODO: adding other activations that can be fused.
          default:
            throw new Error(`Unsupported activation ${attributes.activation}`);
        }
      };
      appendActivationUniformsData = (attributes, programUniform) => {
        if (attributes.activation === "Clip") {
          programUniform.push(
            { type: 1 /* float */, data: attributes.clipMax },
            { type: 1 /* float */, data: attributes.clipMin }
          );
        } else if (attributes.activation === "HardSigmoid") {
          programUniform.push(
            { type: 1 /* float */, data: attributes.alpha },
            { type: 1 /* float */, data: attributes.beta }
          );
        } else if (attributes.activation === "LeakyRelu") {
          programUniform.push({ type: 1 /* float */, data: attributes.alpha });
        }
      };
      appendActivationUniforms = (attributes, uniforms) => {
        if (attributes.activation === "Clip") {
          uniforms.push({ name: "clip_max", type: "f32" }, { name: "clip_min", type: "f32" });
        } else if (attributes.activation === "HardSigmoid") {
          uniforms.push({ name: "alpha", type: "f32" }, { name: "beta", type: "f32" });
        } else if (attributes.activation === "LeakyRelu") {
          uniforms.push({ name: "alpha", type: "f32" });
        }
      };
      parseInternalActivationAttributes = (attributes) => {
        const activation = attributes?.activation || "";
        if (activation === "HardSigmoid") {
          const [alpha, beta] = attributes?.activation_params || [0.2, 0.5];
          return { activation, alpha, beta };
        } else if (activation === "Clip") {
          const [clipMin, clipMax] = attributes?.activation_params || [MIN_CLIP, MAX_CLIP];
          return { activation, clipMax, clipMin };
        } else if (activation === "LeakyRelu") {
          const [alpha] = attributes?.activation_params || [0.01];
          return { activation, alpha };
        }
        return { activation };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts
  var typeSnippet, biasSnippet;
  var init_activation_util = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"() {
      "use strict";
      typeSnippet = (component, dataType) => {
        switch (component) {
          case 1:
            return dataType;
          case 2:
            return `vec2<${dataType}>`;
          case 3:
            return `vec3<${dataType}>`;
          case 4:
            return `vec4<${dataType}>`;
          default:
            throw new Error(`${component}-component is not supported.`);
        }
      };
      biasSnippet = (hasBias) => `
      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts
  var utilFunctions;
  var init_conv_util = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"() {
      "use strict";
      utilFunctions = (strideStr) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${strideStr}.x), i32(${strideStr}.y), i32(${strideStr}.z), 1));
}
`;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmul-shaders.ts
  var convertOutputBatchIndicesToInputBatchIndices, createNaiveMatmulProgramInfo;
  var init_matmul_shaders = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmul-shaders.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_fuse_utils();
      convertOutputBatchIndicesToInputBatchIndices = (targetIndicesName, inputVariable2, inputBatchRank, outputBatchRank, batchIndicesName) => {
        const extendingInputRank = outputBatchRank - inputBatchRank;
        return `
      ${Array.from({ length: inputBatchRank }).map(
          (_, i) => `
      if (${getElementAt(inputVariable2.shape, i, inputVariable2.rank)} != 1) {
        ${inputVariable2.indicesSet(targetIndicesName, i, getElementAt(batchIndicesName, i + extendingInputRank, outputBatchRank))}
      } else {
        ${inputVariable2.indicesSet(targetIndicesName, i, 0)}
      }`
        ).join("")}
`;
      };
      createNaiveMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const M = aShape[aShape.length - 2];
        const N = bShape[bShape.length - 1];
        const K = aShape[aShape.length - 1];
        const components = getMaxComponents(N);
        const aComponents = getMaxComponents(K);
        const outputNumber = getMaxComponents(M);
        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const hasBias = inputs.length > 2;
        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
        const batchSize = ShapeUtil.size(outerDims);
        const outputShapeInShader = [batchSize, M, N];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: K }
        ];
        appendActivationUniformsData(activationAttributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(outerDims, aShape, bShape));
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        }
        programUniforms.push(...createTensorShapeVariables(outputShapeInShader));
        const getShaderSource = (shaderHelper) => {
          const batchDims = internalVariable("batch_dims", inputs[0].dataType, outerDims.length);
          const a = inputVariable("a", inputs[0].dataType, aShape.length, aComponents);
          const b = inputVariable("b", inputs[1].dataType, bShape.length, components);
          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
          const inputVariables = [a, b];
          let processBias = "";
          if (hasBias) {
            const biasComponents = isChannelsLast ? components : 1;
            inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
            processBias = `${isChannelsLast ? `value += bias[col / ${biasComponents}];` : `value += ${output.type.value}(bias[row + i]);`}`;
          }
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" }
          ];
          appendActivationUniforms(activationAttributes, uniforms);
          const calcResult = () => {
            let calcStr = `var a_data: ${a.type.value};`;
            for (let i = 0; i < aComponents; i++) {
              calcStr += `
              let b_data${i} = b[(b_offset + (k + ${i}) * uniforms.N + col) / ${components}];`;
            }
            for (let i = 0; i < outputNumber; i++) {
              calcStr += `a_data = a[(a_offset + (row + ${i}) * uniforms.K + k) / ${aComponents}];`;
              for (let j = 0; j < aComponents; j++) {
                calcStr += `
            values[${i}] = fma(${b.type.value}(a_data${aComponents === 1 ? "" : `[${j}]`}), b_data${j}, values[${i}]);
`;
              }
            }
            return calcStr;
          };
          return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${components})) * ${components};
    var index1 = global_idx / (uniforms.N / ${components});
    let stride1 = uniforms.M / ${outputNumber};
    let row = (index1 % stride1) * ${outputNumber};
    let batch = index1 / stride1;

    ${outputShape.length === 2 ? "" : `let batch_indices = ${batchDims.offsetToIndices("batch")};`}

    var a_indices: ${a.type.indices};
    ${convertOutputBatchIndicesToInputBatchIndices("a_indices", a, a.rank - 2, batchDims.rank, "batch_indices")}
    ${a.indicesSet("a_indices", a.rank - 2, 0)}
    ${a.indicesSet("a_indices", a.rank - 1, 0)}
    let a_offset = ${a.indicesToOffset("a_indices")};

    var b_indices: ${b.type.indices};
    ${convertOutputBatchIndicesToInputBatchIndices("b_indices", b, b.rank - 2, batchDims.rank, "batch_indices")}
    ${b.indicesSet("b_indices", b.rank - 2, 0)}
    ${b.indicesSet("b_indices", b.rank - 1, 0)}
    let b_offset = ${b.indicesToOffset("b_indices")};
    var values: array<${output.type.value}, ${outputNumber}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${aComponents}) {
      ${calcResult()}
    }
    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      let cur_indices = ${output.type.indices}(batch, row + i, col);
      let offset = ${output.indicesToOffset("cur_indices")};
      ${output.setByOffset(`offset / ${components}`, "value")};
    }
  }
  `;
        };
        return {
          name: "MatMulNaive",
          shaderCache: {
            hint: `${activationAttributes.activation};${components};${aComponents};${outputNumber};${isChannelsLast}`,
            inputDependencies: hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts
  var writeDataToSubAVec4Snippet, calculateResultSnippet, makeMatMulPackedVec4Source, writeDataToSubASnippet, readDataFromSubASnippet, makeMatMulPackedSource, matMulReadWriteFnSource, createMatmulProgramInfo;
  var init_matmul_packed_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_fuse_utils();
      init_matmul_shaders();
      init_activation_util();
      writeDataToSubAVec4Snippet = (transpose2, batchDims) => {
        if (transpose2) {
          return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
        } else {
          return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
        }
      };
      calculateResultSnippet = (transposeA, innerElementSize) => {
        if (transposeA) {
          return `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${innerElementSize === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`;
        } else {
          return `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;
        }
      };
      makeMatMulPackedVec4Source = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32) => {
        const tileAOuter = workgroupSize[1] * workPerThread[1];
        const tileBOuter = workgroupSize[0] * workPerThread[0];
        const tileAWidth = transposeA ? tileAOuter : tileInner;
        const tileAHight = transposeA ? tileInner : tileAOuter;
        const innerElementSize = tileAWidth / workgroupSize[0];
        const rowPerThreadB = tileInner / workgroupSize[1];
        if (!((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4)) {
          throw new Error(`If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
      Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
  tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);
        }
        return `
var<workgroup> mm_Asub: array<array<vec${innerElementSize}<${type}>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
var<workgroup> mm_Bsub: array<array<vec4<${type}>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

const rowPerThread = ${workPerThread[1]};
const colPerThread = ${workPerThread[0]};
const innerElementSize = ${innerElementSize};
const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${splitK ? "0" : "i32(globalId.z)"};
  ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

  var acc: array<vec4<${type}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${rowPerThreadB};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${writeDataToSubAVec4Snippet(transposeA, batchDims)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${batchDims ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${innerElementSize === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${calculateResultSnippet(transposeA, innerElementSize)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
      };
      writeDataToSubASnippet = (transpose2, batchDims) => {
        if (transpose2) {
          return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
        } else {
          return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
        }
      };
      readDataFromSubASnippet = (transposeA) => transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
      makeMatMulPackedSource = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) => {
        const tileAOuter = workPerThread[1] * workgroupSize[1];
        const tileBOuter = workPerThread[0] * workgroupSize[0];
        const tileAWidth = transposeA ? tileAOuter : tileInner;
        const tileAHight = transposeA ? tileInner : tileAOuter;
        if (!(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0)) {
          throw new Error(
            `tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`
          );
        }
        const rowPerThreadA = tileAHight / workgroupSize[1];
        const colPerThreadA = tileAWidth / workgroupSize[0];
        const rowPerThreadB = tileInner / workgroupSize[1];
        const matmulSnippet = sequentialAccessByThreads ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
    let globalColStart = i32(workgroupId.x) * ${tileBOuter};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {
        for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {
          ${writeDataToSubASnippet(transposeA, batchDims)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {
            for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${batchDims ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${type}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

let tileRowA = i32(localId.y) * ${rowPerThreadA};
let tileColA = i32(localId.x) * ${colPerThreadA};
let tileRowB = i32(localId.y) * ${rowPerThreadB};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${writeDataToSubASnippet(transposeA, batchDims)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${batchDims ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${type}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${readDataFromSubASnippet(transposeA)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
        return `
  var<workgroup> mm_Asub : array<array<${type}, ${tileAWidth}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<${type}, ${tileBOuter}>, ${tileInner}>;
  const rowPerThread = ${workPerThread[1]};
  const colPerThread = ${workPerThread[0]};
  const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${splitK ? "0" : "i32(globalId.z)"};
    ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

    var acc : array<array<${type}, colPerThread>, rowPerThread>;
    ${matmulSnippet}
  }
`;
      };
      matMulReadWriteFnSource = (component, hasBias, applyActivation, variables, isChannelsLast = false) => {
        const [batchVariable, aVariable, bVariable, outputVariable2] = variables;
        const dataType = tensorTypeToWsglStorageType(variables[0].type.tensor);
        const source = `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
          component,
          dataType
        )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${aVariable.type.indices};
        ${convertOutputBatchIndicesToInputBatchIndices(
          "aIndices",
          aVariable,
          aVariable.rank - 2,
          batchVariable.rank,
          "batchIndices"
        )}
        ${aVariable.indicesSet("aIndices", aVariable.rank - 2, "u32(row)")}
        ${aVariable.indicesSet("aIndices", aVariable.rank - 1, "u32(colIn)")}
        value = ${aVariable.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
          component,
          dataType
        )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${bVariable.type.indices};
        ${convertOutputBatchIndicesToInputBatchIndices(
          "bIndices",
          bVariable,
          bVariable.rank - 2,
          batchVariable.rank,
          "batchIndices"
        )}
        ${bVariable.indicesSet("bIndices", bVariable.rank - 2, "u32(row)")}
        ${bVariable.indicesSet("bIndices", bVariable.rank - 1, "u32(colIn)")}
        value = ${bVariable.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component, dataType)}) {
      let col = colIn * ${component};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${hasBias ? `value = value + ${isChannelsLast ? "bias[colIn]" : `${typeSnippet(component, dataType)}(bias[row])`};` : ""}
        ${applyActivation}
        ${outputVariable2.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
        return source;
      };
      createMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const outerDimsA = aShape.slice(0, -2);
        const outerDimsB = bShape.slice(0, -2);
        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
        const batchSize = ShapeUtil.size(outerDims);
        const dimAOuter = aShape[aShape.length - 2];
        const dimInner = aShape[aShape.length - 1];
        const dimBOuter = bShape[bShape.length - 1];
        const isVec4 = dimInner % 4 === 0 && dimBOuter % 4 === 0;
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const workgroupSize = [8, 8, 1];
        const dispatch = [
          Math.ceil(dimBOuter / workgroupSize[0] / elementsPerThread[0]),
          Math.ceil(dimAOuter / workgroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workgroupSize[2] / elementsPerThread[2])
        ];
        const components = isVec4 ? 4 : 1;
        const aShapeTemp = [...outerDimsA, dimAOuter, dimInner / components];
        const aRank = aShapeTemp.length;
        const bShapeTemp = [...outerDimsB, dimInner, dimBOuter / components];
        const bRank = bShapeTemp.length;
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner }
        ];
        appendActivationUniformsData(activationAttributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(outerDims, aShapeTemp, bShapeTemp));
        const inputDependencies = ["rank", "rank"];
        const hasBias = inputs.length > 2;
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const batchRank = outerDims.length;
          const batchDims = internalVariable("batchDims", inputs[0].dataType, batchRank, 1);
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const A = inputVariable("a", inputs[0].dataType, aRank, components);
          const B = inputVariable("b", inputs[1].dataType, bRank, components);
          const output = outputVariable("result", inputs[0].dataType, outputShapeTemp.length, components);
          const inputVariables = [A, B];
          if (hasBias) {
            const biasComponents = isChannelsLast ? components : 1;
            inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
          }
          const uniforms = [
            { name: "dim_a_outer", type: "i32" },
            { name: "dim_b_outer", type: "i32" },
            { name: "dim_inner", type: "i32" }
          ];
          appendActivationUniforms(activationAttributes, uniforms);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
          const declareFunctions = matMulReadWriteFnSource(
            components,
            hasBias,
            applyActivation,
            [batchDims, A, B, output],
            isChannelsLast
          );
          return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${declareFunctions}
  ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workgroupSize, dataType, batchDims) : makeMatMulPackedSource(elementsPerThread, workgroupSize, dataType, batchDims)}
                   `;
        };
        return {
          name: "MatMul",
          shaderCache: {
            hint: `${elementsPerThread};${activationAttributes.activation};${isVec4};${isChannelsLast}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts
  var conv2dCommonSnippet, createConv2DMatMulProgramInfo;
  var init_conv2d_mm_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_common();
      init_fuse_utils();
      init_activation_util();
      init_conv_util();
      init_matmul_packed_webgpu();
      conv2dCommonSnippet = (isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, attributes, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4, dataType = "f32") => {
        const getXSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "resData = x[xIndex];";
            case 3:
              return `resData = vec3<${dataType}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
            case 4:
              return "resData = x[xIndex / 4];";
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const getWSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
            case 4:
              return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const coordASnippet = isChannelsLast ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `;
        const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
        const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
        const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
        const row = isChannelsLast ? "row" : "col";
        const col = isChannelsLast ? "col" : "row";
        const readXSnippet = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${row} / outWidth;
    let outCol = ${row} % outWidth;

    let WRow = ${col} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${col} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${col} % inChannels;
    var resData = ${typeSnippet(innerElementSizeX, dataType)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${xHeight} && xCol >= 0 && xCol < ${xWidth}) {
      ${coordASnippet}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${getXSnippet(innerElementSizeX)}
    }
    return resData;`;
        const sampleX = isChannelsLast ? fitAOuter && fitInner ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);` : fitInner && fitBOuter ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);`;
        const sampleW = isChannelsLast ? fitInner && fitBOuter ? getWSnippet(innerElementSizeW) : `
    let col = colIn * ${innerElementSizeW};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${getWSnippet(innerElementSizeW)}
    }
    return ${typeSnippet(innerElementSizeW, dataType)}(0.0);` : `
    let col = colIn * ${innerElementSizeW};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${getWSnippet(innerElementSizeW)}
    }
    return ${typeSnippet(innerElementSizeW, dataType)}(0.0);`;
        const resType = typeSnippet(innerElementSize, dataType);
        const aType = isChannelsLast ? typeSnippet(innerElementSizeX, dataType) : typeSnippet(innerElementSizeW, dataType);
        const bType = isChannelsLast ? typeSnippet(innerElementSizeW, dataType) : typeSnippet(innerElementSizeX, dataType);
        const applyActivation = getActivationSnippet(attributes, resType, dataType);
        const userCode = `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${aType} {
      ${isChannelsLast ? sampleX : sampleW}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${bType} {
      ${isChannelsLast ? sampleW : sampleX}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${resType}) {
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
        return userCode;
      };
      createConv2DMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads, squeezeOutputShapeFunction) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const batchSize = outputShape[0];
        const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
        const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
        const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
        const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
        const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
        const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
        const workGroupSize = [8, 8, 1];
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const dispatch = [
          Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
          Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
        ];
        LOG_DEBUG("verbose", () => `[conv2d_mm_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
        const tileAOuter = workGroupSize[1] * elementsPerThread[1];
        const tileBOuter = workGroupSize[0] * elementsPerThread[0];
        const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
        const fitAOuter = dimAOuter % tileAOuter === 0;
        const fitBOuter = dimBOuter % tileBOuter === 0;
        const fitInner = dimInner % tileInner === 0;
        const elementsSize = isVec4 ? [innerElementSize, 4, 4] : [1, 1, 1];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner },
          { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] },
          { type: 6 /* int32 */, data: attributes.strides },
          { type: 6 /* int32 */, data: attributes.dilations }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "dim_a_outer", type: "i32" },
            { name: "dim_b_outer", type: "i32" },
            { name: "dim_inner", type: "i32" },
            { name: "pad", type: "i32", length: 2 },
            { name: "stride", type: "i32", length: 2 },
            { name: "dilation", type: "i32", length: 2 }
          ];
          appendActivationUniforms(attributes, uniforms);
          const components = isVec4 ? 4 : 1;
          const t = tensorTypeToWsglStorageType(inputs[0].dataType);
          let declareFunctions = `
      fn setOutputAtIndex(flatIndex : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        result[flatIndex] = ${isVec4 ? `vec4<${t}>` : t}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${isVec4 ? "/ 4" : ""}, value);
      }`;
          const x = inputVariable(
            "x",
            inputs[0].dataType,
            inputs[0].dims.length,
            innerElementSize === 3 ? 1 : innerElementSize
          );
          const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, components);
          const inputVariables = [x, w];
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
        }`;
          }
          return `
        ${utilFunctions("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${declareFunctions}
        ${conv2dCommonSnippet(
            isChannelsLast,
            fitAOuter,
            fitBOuter,
            fitInner,
            hasBias,
            attributes,
            elementsSize[0],
            elementsSize[1],
            elementsSize[2],
            t
          )}
        ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workGroupSize, t, void 0, !isChannelsLast, tileInner) : makeMatMulPackedSource(
            elementsPerThread,
            workGroupSize,
            t,
            void 0,
            !isChannelsLast,
            tileInner,
            false,
            void 0,
            sequentialAccessByThreads
          )}`;
        };
        return {
          name: "Conv2DMatMul",
          shaderCache: {
            hint: `${attributes.cacheKey};${innerElementSize};${isVec4};${fitAOuter};${fitBOuter};${fitInner};${tileAOuter};${tileBOuter};${tileInner}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
  var arrayProduct, parse3TupleParam, getEffectiveFilterSize, computeDefaultPad, computeOutputShape4D, get3DPadAndOutInfo, computeConv3DInfo, createConv3DNaiveProgramInfo;
  var init_conv3d_naive_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_common();
      init_fuse_utils();
      init_activation_util();
      arrayProduct = (arr) => {
        let product = 1;
        for (let i = 0; i < arr.length; i++) {
          product *= arr[i];
        }
        return product;
      };
      parse3TupleParam = (param) => typeof param === "number" ? [param, param, param] : param;
      getEffectiveFilterSize = (filterSize, dilation) => {
        if (dilation <= 1) {
          return filterSize;
        }
        return filterSize + (filterSize - 1) * (dilation - 1);
      };
      computeDefaultPad = (inputShape, fieldSize, stride, dilation = 1) => {
        const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
        return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
      };
      computeOutputShape4D = (inShape, filterShape, outChannels, strides, zeroPad) => {
        if (zeroPad == null) {
          zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
        }
        const outShape = [0, 0, 0, outChannels];
        for (let index = 0; index < 3; index++) {
          if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
            outShape[index] = Math.trunc((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1);
          }
        }
        return outShape;
      };
      get3DPadAndOutInfo = (pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth) => {
        let padInfo;
        let outDepth;
        let outHeight;
        let outWidth;
        if (pad2 === "VALID") {
          pad2 = 0;
        }
        if (typeof pad2 === "number") {
          padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, front: pad2, back: pad2 };
          const outShape = computeOutputShape4D(
            [inDepth, inHeight, inWidth, 1],
            [filterDepth, filterHeight, filterWidth],
            1,
            [strideDepth, strideHeight, strideWidth],
            pad2
          );
          outDepth = outShape[0];
          outHeight = outShape[1];
          outWidth = outShape[2];
        } else if (Array.isArray(pad2)) {
          if (!pad2.every((val, _, arr) => val === arr[0])) {
            throw Error(`Unsupported padding parameter: ${pad2}`);
          }
          padInfo = { top: pad2[0], bottom: pad2[1], left: pad2[2], right: pad2[3], front: pad2[4], back: pad2[5] };
          const outShape = computeOutputShape4D(
            [inDepth, inHeight, inWidth, 1],
            [filterDepth, filterHeight, filterWidth],
            1,
            [strideDepth, strideHeight, strideWidth],
            pad2[0]
          );
          outDepth = outShape[0];
          outHeight = outShape[1];
          outWidth = outShape[2];
        } else if (pad2 === "SAME_UPPER") {
          outDepth = Math.ceil(inDepth / strideDepth);
          outHeight = Math.ceil(inHeight / strideHeight);
          outWidth = Math.ceil(inWidth / strideWidth);
          const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
          const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
          const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
          const front = Math.floor(padAlongDepth / 2);
          const back = padAlongDepth - front;
          const top = Math.floor(padAlongHeight / 2);
          const bottom = padAlongHeight - top;
          const left = Math.floor(padAlongWidth / 2);
          const right = padAlongWidth - left;
          padInfo = { top, bottom, left, right, front, back };
        } else {
          throw Error(`Unknown padding parameter: ${pad2}`);
        }
        return { padInfo, outDepth, outHeight, outWidth };
      };
      computeConv3DInfo = (inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast") => {
        let batchSize, inDepth, inHeight, inWidth, inChannels;
        if (dataFormat === "channelsLast") {
          [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
        } else if (dataFormat === "channelsFirst") {
          [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
        } else {
          throw new Error(`Unknown dataFormat ${dataFormat}`);
        }
        const [filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
        const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
        const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
        const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
        const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
        const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
        const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(
          pad2,
          inDepth,
          inHeight,
          inWidth,
          strideDepth,
          strideHeight,
          strideWidth,
          effectiveFilterDepth,
          effectiveFilterHeight,
          effectiveFilterWidth
        );
        const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
        let outShape = [0, 0, 0, 0, 0];
        if (dataFormat === "channelsFirst") {
          outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
        } else if (dataFormat === "channelsLast") {
          outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
        }
        return {
          batchSize,
          dataFormat,
          inDepth,
          inHeight,
          inWidth,
          inChannels,
          outDepth,
          outHeight,
          outWidth,
          outChannels,
          padInfo,
          strideDepth,
          strideHeight,
          strideWidth,
          filterDepth,
          filterHeight,
          filterWidth,
          effectiveFilterDepth,
          effectiveFilterHeight,
          effectiveFilterWidth,
          dilationDepth,
          dilationHeight,
          dilationWidth,
          inShape,
          outShape,
          filterShape
        };
      };
      createConv3DNaiveProgramInfo = (inputs, attributes, outputShape, filterDims, pads, dataFormat) => {
        const isChannelLast = dataFormat === "channelsLast";
        const inChannels = isChannelLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const isVec4 = false;
        const workGroupSize = [64, 1, 1];
        const dispatchLayout = { x: outputShape.map((_, i) => i) };
        const dispatch = [Math.ceil(arrayProduct(dispatchLayout.x.map((d) => outputShape[d])) / workGroupSize[0]), 1, 1];
        LOG_DEBUG("verbose", () => `[conv3d_naive_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? isChannelLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: filterDims },
          { type: 12 /* uint32 */, data: pads },
          { type: 12 /* uint32 */, data: attributes.strides },
          { type: 12 /* uint32 */, data: attributes.dilations }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        const hasBias = inputs.length === 3;
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "filter_dims", type: "u32", length: filterDims.length },
            { name: "pads", type: "u32", length: pads.length },
            { name: "strides", type: "u32", length: attributes.strides.length },
            { name: "dilations", type: "u32", length: attributes.dilations.length }
          ];
          appendActivationUniforms(attributes, uniforms);
          const components = isVec4 ? 4 : 1;
          const t = tensorTypeToWsglStorageType(inputs[0].dataType);
          const x = inputVariable(
            "x",
            inputs[0].dataType,
            inputs[0].dims.length,
            innerElementSize === 3 ? 1 : innerElementSize
          );
          const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
          const inputVariables = [x, w];
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          let declareFunctions = "";
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[${isChannelLast ? getElementAt("coords", 4, 5) : getElementAt("coords", 1, 5)}${isVec4 ? "/ 4" : ""}];
        }`;
          }
          const resType = typeSnippet(innerElementSize, t);
          const applyActivation = getActivationSnippet(attributes, resType, t);
          return `
            ${declareFunctions}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
          ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
          ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${output.offsetToIndices("global_idx")};
              let batch = ${getElementAt("coords", 0, x.rank)};
              let d2 = ${isChannelLast ? getElementAt("coords", x.rank - 1, x.rank) : getElementAt("coords", 1, x.rank)};
              let xFRCCorner = vec3<u32>(${isChannelLast ? getElementAt("coords", 1, x.rank) : getElementAt("coords", 2, x.rank)},
              ${isChannelLast ? getElementAt("coords", 2, x.rank) : getElementAt("coords", 3, x.rank)},
              ${isChannelLast ? getElementAt("coords", 3, x.rank) : getElementAt("coords", 4, x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${isChannelLast ? getElementAt("uniforms.x_shape", 1, x.rank) : getElementAt("uniforms.x_shape", 2, x.rank)};
              let xShapeZ = ${isChannelLast ? getElementAt("uniforms.x_shape", 2, x.rank) : getElementAt("uniforms.x_shape", 3, x.rank)};
              let xShapeW = ${isChannelLast ? getElementAt("uniforms.x_shape", 3, x.rank) : getElementAt("uniforms.x_shape", 4, x.rank)};
              let xShapeU = ${isChannelLast ? getElementAt("uniforms.x_shape", 4, x.rank) : getElementAt("uniforms.x_shape", 1, x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${isChannelLast ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            ` : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${isChannelLast ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${isChannelLast ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      ` : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${isChannelLast ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      ` : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${hasBias ? "value = value + getBiasByOutputCoords(coords)" : ""};
              ${applyActivation}
              result[global_idx] = f32(value);
          }`;
        };
        return {
          name: "Conv3DNaive",
          shaderCache: { hint: `${attributes.cacheKey};${isChannelLast};${innerElementSize};${hasBias}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts
  var createGroupedConvProgramInfo, createGroupedConvVectorizeProgramInfo;
  var init_conv_grouped = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_fuse_utils();
      createGroupedConvProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? "value += b[output_channel];" : "";
        const xShape = inputs[0].dims;
        const wShape = inputs[1].dims;
        const isChannelLast = attributes.format === "NHWC";
        const outputChannels = isChannelLast ? outputShape[3] : outputShape[1];
        const outputChannelsPerGroup = outputChannels / attributes.group;
        const components = isChannelLast && outputChannelsPerGroup >= 4 ? getMaxComponents(outputChannels) : 1;
        const outputSize = ShapeUtil.size(outputShape) / components;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: attributes.dilations },
          { type: 12 /* uint32 */, data: [attributes.strides[0], attributes.strides[1]] },
          { type: 12 /* uint32 */, data: [attributes.pads[0], attributes.pads[1]] },
          { type: 12 /* uint32 */, data: outputChannelsPerGroup }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(
          ...createTensorShapeVariables(xShape, [wShape[0], wShape[1], wShape[2], wShape[3] / components])
        );
        const inputDependencies = hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"];
        programUniforms.push(
          ...createTensorShapeVariables([outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components])
        );
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
          const x = inputVariable("x", inputs[0].dataType, xShape.length);
          const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
          const inputVars = [x, w];
          if (hasBias) {
            inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
          }
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "dilations", type: "u32", length: attributes.dilations.length },
            { name: "strides", type: "u32", length: 2 },
            { name: "pads", type: "u32", length: 2 },
            { name: "output_channels_per_group", type: "u32" }
          ];
          appendActivationUniforms(attributes, uniforms);
          const calculateResult = isChannelLast ? `
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${x.get("batch", "xHeight", "xWidth", "input_channel")};
            let wVal = ${w.get("wHeight", "wWidth", "wInChannel", "output_channel")};
            value += xVal * wVal;
          }
        }
      }
      ` : `
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${x.get("batch", "input_channel", "xHeight", "xWidth")};
            let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${output.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${isChannelLast ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${isChannelLast ? 1 : 2}], outputIndices[${isChannelLast ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${components} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${isChannelLast ? 2 : 1}];

    var value: ${output.type.value} = ${output.type.value}(0);
    ${calculateResult}
    ${processBias}
    ${applyActivation}
    ${output.setByOffset("global_idx", "value")}
  }`;
        };
        return {
          name: "GroupedConv",
          shaderCache: { hint: `${attributes.cacheKey}_${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      createGroupedConvVectorizeProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const components = getMaxComponents(outputShape[3]);
        const outputNumber = getMaxComponents(outputShape[2]);
        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const xShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[0].dims[2], inputs[0].dims[3] / components];
        const wShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[1].dims[3] / components];
        const outputShapeInShader = [outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: [attributes.strides[0], attributes.strides[1]] },
          { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(xShape, wShape, outputShapeInShader));
        const xNumber = (outputNumber - 1) * attributes.strides[1] + wShape[1];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
          const x = inputVariable("x", inputs[0].dataType, xShape.length, components);
          const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
          const inputVars = [x, w];
          if (hasBias) {
            inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
          }
          const processBias = hasBias ? "value += b[output_channel];" : "";
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "strides", type: "i32", length: 2 },
            { name: "pads", type: "i32", length: 2 }
          ];
          appendActivationUniforms(attributes, uniforms);
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${outputNumber}u;
    let col = (index1 % width1) * ${outputNumber}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${xNumber}>;
    var values: array<${output.type.value}, ${outputNumber}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${wShape[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${xNumber}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${wShape[1]}; w_width++) {
          let w_val = ${w.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${outputNumber}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      ${output.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
        };
        return {
          name: "GroupedConv-Vectorize",
          shaderCache: {
            hint: `${attributes.cacheKey};${components};${outputNumber};${xNumber};${wShape[0]};${wShape[1]}`,
            inputDependencies: hasBias ? ["rank", "rank", "type"] : ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv.ts
  var calculateOutputShape, weightTransposeAttribute, validateInputs8, getAdjustedConvAttributes, parseConvAttributes, conv2d, conv1d, conv3d, conv;
  var init_conv = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv.ts"() {
      "use strict";
      init_util();
      init_conv2d_mm_webgpu();
      init_conv3d_naive_webgpu();
      init_matmul_packed_webgpu();
      init_conv_grouped();
      init_fuse_utils();
      init_matmul_shaders();
      init_transpose();
      calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides, isChannelLast) => {
        const batchSize = inputShape[0];
        const inputSpatialShape = inputShape.slice(isChannelLast ? 1 : 2, isChannelLast ? 3 : 4);
        const spatialRank = inputSpatialShape.length;
        const outChannels = kernelShape[0];
        const kernelSpatialShape = kernelShape.slice(2);
        const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
        const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
        const outputShape = inputSpatialShapeWithPad.map(
          (v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i])
        );
        outputShape.splice(0, 0, batchSize);
        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
        return outputShape;
      };
      weightTransposeAttribute = [2, 3, 1, 0];
      validateInputs8 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length > 5) {
          throw new Error("greater than 5D is not supported");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("filter does not have same dimension as input");
        }
        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
        const filterInChannel = inputs[1].dims[1] * attributes.group;
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        if (attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        if (attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        if (attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
      };
      getAdjustedConvAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (kernelShape.length < inputs[1].dims.length - 2) {
          kernelShape.push(...Array(inputs[1].dims.length - 2 - kernelShape.length).fill(0));
        }
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          if (kernelShape[i - 2] === 0) {
            kernelShape[i - 2] = inputs[1].dims[i];
          }
        }
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPadsBasedOnAutoPad(
          inputs[0].dims,
          attributes.strides,
          attributes.dilations,
          kernelShape,
          pads,
          attributes.format === "NHWC",
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads });
        return newAttributes;
      };
      parseConvAttributes = (attributes) => {
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const format = attributes.format;
        const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad];
        const dilations = attributes.dilations;
        const group = attributes.group;
        const kernelShape = attributes.kernel_shape;
        const pads = attributes.pads;
        const strides = attributes.strides;
        const wIsConst = attributes.w_is_const();
        return {
          autoPad,
          format,
          dilations,
          group,
          kernelShape,
          pads,
          strides,
          wIsConst,
          ...activationAttributes,
          cacheKey: `${attributes.format};${activationAttributes.activation};`
        };
      };
      conv2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
        const isChannelsLast = attributes.format === "NHWC";
        const outputShape = calculateOutputShape(
          inputs[0].dims,
          inputs[1].dims,
          attributes.dilations,
          attributes.pads,
          attributes.strides,
          isChannelsLast
        );
        if (attributes.group !== 1) {
          const convInputs2 = [inputs[0]];
          if (isChannelsLast) {
            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
              inputs: [1],
              outputs: [attributes.wIsConst ? -2 : -1]
            })[0];
            if (attributes.wIsConst && !context.kernelCustomData.wT) {
              context.kernelCustomData.wT = transposedWeight2;
            }
            convInputs2.push(transposedWeight2);
          } else {
            convInputs2.push(inputs[1]);
          }
          if (inputs.length === 3) {
            convInputs2.push(inputs[2]);
          }
          const enableGroupedConvVectorize = !context.adapterInfo.isArchitecture("ampere");
          if (enableGroupedConvVectorize && isChannelsLast && inputs[1].dims[0] === attributes.group && inputs[1].dims[1] === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1) {
            context.compute(
              createGroupedConvVectorizeProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction),
              { inputs: convInputs2 }
            );
          } else {
            context.compute(createGroupedConvProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction), {
              inputs: convInputs2
            });
          }
          return;
        }
        const hasBias = inputs.length === 3;
        const inputHeight = inputs[0].dims[isChannelsLast ? 1 : 2];
        const inputWidth = inputs[0].dims[isChannelsLast ? 2 : 3];
        const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
        const weightHeight = inputs[1].dims[2];
        const weightWidth = inputs[1].dims[3];
        const outHeight = outputShape[isChannelsLast ? 1 : 2];
        const outWidth = outputShape[isChannelsLast ? 2 : 3];
        const outChannels = outputShape[isChannelsLast ? 3 : 1];
        const sameSize = isChannelsLast && weightHeight === inputHeight && weightWidth === inputWidth && attributes.pads[0] === 0 && attributes.pads[1] === 0;
        if (sameSize || weightHeight === 1 && weightWidth === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1 && attributes.strides[0] === 1 && attributes.strides[1] === 1 && attributes.pads[0] === 0 && attributes.pads[1] === 0) {
          const batch = outputShape[0];
          let xReshaped, wReshaped, matmulOutputShape;
          const matmulInputs = [];
          if (isChannelsLast) {
            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
              inputs: [1],
              outputs: [attributes.wIsConst ? -2 : -1]
            })[0];
            if (attributes.wIsConst && !context.kernelCustomData.wT) {
              context.kernelCustomData.wT = transposedWeight2;
            }
            if (sameSize) {
              const sharedDim = inputHeight * inputWidth * inputChannels;
              xReshaped = inputs[0].reshape([1, batch, sharedDim]);
              wReshaped = transposedWeight2.reshape([1, sharedDim, outChannels]);
              matmulOutputShape = [1, batch, outChannels];
            } else {
              xReshaped = inputs[0].reshape([batch, inputHeight * inputWidth, inputChannels]);
              wReshaped = transposedWeight2.reshape([1, inputChannels, outChannels]);
              matmulOutputShape = [batch, outHeight * outWidth, outChannels];
            }
            matmulInputs.push(xReshaped);
            matmulInputs.push(wReshaped);
          } else {
            xReshaped = inputs[0].reshape([batch, inputChannels, inputHeight * inputWidth]);
            wReshaped = inputs[1].reshape([1, outChannels, inputChannels]);
            matmulOutputShape = [batch, outChannels, outHeight * outWidth];
            matmulInputs.push(wReshaped);
            matmulInputs.push(xReshaped);
          }
          if (hasBias) {
            matmulInputs.push(inputs[2]);
          }
          const N = matmulOutputShape[2];
          const K = matmulInputs[0].dims[matmulInputs[0].dims.length - 1];
          if (N < 8 && K < 8) {
            context.compute(
              createNaiveMatmulProgramInfo(
                matmulInputs,
                attributes,
                outputShape,
                matmulOutputShape,
                isChannelsLast,
                squeezeOutputShapeFunction
              ),
              { inputs: matmulInputs }
            );
          } else {
            context.compute(
              createMatmulProgramInfo(
                matmulInputs,
                attributes,
                outputShape,
                matmulOutputShape,
                isChannelsLast,
                squeezeOutputShapeFunction
              ),
              { inputs: matmulInputs }
            );
          }
          return;
        }
        const sequentialAccessByThreads = (
          /* backend.adapterInfo.isIntel() */
          true
        );
        const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
          inputs: [1],
          outputs: [attributes.wIsConst ? -2 : -1]
        })[0];
        if (attributes.wIsConst && !context.kernelCustomData.wT) {
          context.kernelCustomData.wT = transposedWeight;
        }
        const convInputs = [inputs[0], transposedWeight];
        if (hasBias) {
          convInputs.push(inputs[2]);
        }
        const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
        const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
        const dimInner = weightHeight * weightWidth * inputChannels;
        context.compute(
          createConv2DMatMulProgramInfo(
            convInputs,
            attributes,
            outputShape,
            dimAOuter,
            dimBOuter,
            dimInner,
            hasBias,
            sequentialAccessByThreads,
            squeezeOutputShapeFunction
          ),
          { inputs: convInputs }
        );
      };
      conv1d = (context, attributes) => {
        const isChannelLast = attributes.format === "NHWC";
        const inputs = [
          context.inputs[0].reshape(
            isChannelLast ? (
              // [N, W, C] -> [N, H=1, W, C]
              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
            ) : (
              // [N, C, W] -> [N, C, H=1, W]
              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
            )
          ),
          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
        ];
        if (context.inputs.length === 3) {
          inputs.push(context.inputs[2]);
        }
        const pads = [0, attributes.pads[0], 0, attributes.pads[1]];
        const strides = [1].concat(attributes.strides);
        const dilations = [1].concat(attributes.dilations);
        const kernelShape = [1].concat(attributes.kernelShape);
        const adjustedAttributes = getAdjustedConvAttributes(
          { ...attributes, pads, strides, dilations, kernelShape },
          inputs
        );
        conv2d(
          context,
          inputs,
          adjustedAttributes,
          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
        );
      };
      conv3d = (context, inputs, attributes) => {
        const format = attributes.format === "NHWC" ? "channelsLast" : "channelsFirst";
        const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
        const pads = attributes.autoPad === "NOTSET" ? attributes.pads : attributes.autoPad;
        const convInfo = computeConv3DInfo(
          inputs[0].dims,
          inputs[1].dims,
          attributes.strides,
          attributes.dilations,
          pads,
          false,
          format
        );
        context.compute(
          createConv3DNaiveProgramInfo(
            inputs,
            adjustedAttributes,
            convInfo.outShape,
            [convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth],
            [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left],
            format
          )
        );
      };
      conv = (context, attributes) => {
        validateInputs8(context.inputs, attributes);
        if (context.inputs[0].dims.length === 3) {
          conv1d(context, attributes);
        } else if (context.inputs[0].dims.length === 5) {
          conv3d(context, context.inputs, attributes);
        } else {
          const adjustedAttributes = getAdjustedConvAttributes(attributes, context.inputs);
          conv2d(context, context.inputs, adjustedAttributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts
  var createConvTranspose2DProgramInfo;
  var init_conv_backprop_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_common();
      createConvTranspose2DProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const outputShape = attributes.outputShape;
        const isChannelsLast = attributes.format === "NHWC";
        const group = attributes.group;
        const wShape = inputs[1].dims;
        const inputChannelsPerGroup = wShape[2] / group;
        const outputChannelsPerGroup = wShape[3];
        const aComponents = isChannelsLast ? getMaxComponents(inputChannelsPerGroup) : 1;
        const packInputAs4 = isChannelsLast && outputChannelsPerGroup === 1 && inputChannelsPerGroup >= 4;
        const inputChannelsPerGroupInt = packInputAs4 ? Math.floor(inputChannelsPerGroup / 4) * 4 : Math.floor(inputChannelsPerGroup / aComponents) * aComponents;
        const inputChannelsRemainder = inputChannelsPerGroup - inputChannelsPerGroupInt;
        const components = isChannelsLast ? getMaxComponents(outputChannelsPerGroup) : 1;
        const bComponents = isChannelsLast ? outputChannelsPerGroup === 1 ? aComponents : components : 1;
        const outputSize = ShapeUtil.size(outputShape) / components;
        const dispatch = [Math.ceil(outputSize / 64), 1, 1];
        LOG_DEBUG("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${dispatch}`);
        const inputDependencies = ["rank", "rank"];
        const strides = [attributes.strides[0], attributes.strides[1]];
        const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
        const dilations = [attributes.dilations[0], attributes.dilations[1]];
        const effectiveFilterDims = [
          filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)),
          filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1))
        ];
        const pads = [
          effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
          effectiveFilterDims[1] - 1 - Math.floor((attributes.pads[1] + attributes.pads[3]) / 2)
        ];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: strides },
          { type: 12 /* uint32 */, data: filterDims },
          { type: 12 /* uint32 */, data: dilations },
          { type: 12 /* uint32 */, data: effectiveFilterDims },
          { type: 6 /* int32 */, data: pads },
          { type: 12 /* uint32 */, data: inputChannelsPerGroupInt },
          { type: 12 /* uint32 */, data: inputChannelsPerGroup },
          { type: 12 /* uint32 */, data: outputChannelsPerGroup },
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims)
        ];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "strides", type: "u32", length: strides.length },
            { name: "filter_dims", type: "u32", length: filterDims.length },
            { name: "dilations", type: "u32", length: filterDims.length },
            { name: "effective_filter_dims", type: "u32", length: effectiveFilterDims.length },
            { name: "pads", type: "i32", length: pads.length },
            { name: "input_channels_per_group_int", type: "u32" },
            { name: "input_channels_per_group", type: "u32" },
            { name: "output_channels_per_group", type: "u32" }
          ];
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const rowDim = isChannelsLast ? 1 : 2;
          const colDim = isChannelsLast ? 2 : 3;
          const channelDim = isChannelsLast ? 3 : 1;
          const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, bComponents);
          const dy = inputVariable("Dy", inputs[0].dataType, inputs[0].dims.length, aComponents);
          const inputVariables = [dy, w];
          if (hasBias) {
            inputVariables.push(inputVariable("bias", inputs[2].dataType, [outputShape[channelDim]].length, components));
          }
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          const calculateResult = () => {
            let calcStr = "";
            if (packInputAs4) {
              if (aComponents === 4) {
                calcStr += `
        let xValue = ${dy.getByOffset("x_offset")};
        let wValue = ${w.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`;
              } else if (aComponents === 2) {
                calcStr += `
          dotProd = dotProd + dot(vec4<${dataType}>(${dy.getByOffset("x_offset")}, ${dy.getByOffset("x_offset + 1u")}), vec4<${dataType}>(${w.getByOffset("w_offset")}, ${w.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`;
              } else if (aComponents === 1) {
                calcStr += `
          dotProd = dotProd + dot(vec4<${dataType}>(${dy.getByOffset("x_offset")}, ${dy.getByOffset("x_offset + 1u")}, ${dy.getByOffset("x_offset + 2u")}, ${dy.getByOffset("x_offset + 3u")}), vec4<${dataType}>(${w.getByOffset("w_offset")}, ${w.getByOffset("w_offset + 1u")}, ${w.getByOffset("w_offset + 2u")}, ${w.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`;
              }
            } else {
              calcStr += `
                  let xValue = ${isChannelsLast ? dy.getByOffset(
                `${dy.indicesToOffset(`${dy.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${aComponents}`
              ) : dy.get("batch", "inputChannel", "idyR", "idyC")};
        `;
              if (aComponents === 1) {
                calcStr += `
          let w_offset = ${w.indicesToOffset(`${w.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${w.getByOffset(`w_offset / ${bComponents}`)};
          dotProd = dotProd + xValue * wValue;`;
              } else {
                for (let c = 0; c < aComponents; c++) {
                  calcStr += `
            let wValue${c} = ${w.getByOffset(`${w.indicesToOffset(`${w.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${c}, wOutChannel)`)} / ${bComponents}`)};
            dotProd = dotProd + xValue[${c}] * wValue${c};`;
                }
              }
            }
            return calcStr;
          };
          const calculateRemainder = () => {
            if (inputChannelsRemainder === 0) {
              return "";
            }
            if (!packInputAs4) {
              throw new Error(`packInputAs4 ${packInputAs4} is not true.`);
            }
            let calcStr = "";
            if (aComponents === 1) {
              calcStr += "dotProd = dotProd";
              for (let i = 0; i < inputChannelsRemainder; i++) {
                calcStr += `
            + ${dy.getByOffset(`x_offset + ${i}`)} * ${w.getByOffset(`w_offset + ${i}`)}`;
              }
              calcStr += ";";
            } else if (aComponents === 2) {
              if (inputChannelsRemainder !== 2) {
                throw new Error(`Invalid inputChannelsRemainder ${inputChannelsRemainder}.`);
              }
              calcStr += `
          let xValue = ${dy.getByOffset("x_offset")};
          let wValue = ${w.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`;
            }
            return calcStr;
          };
          const codeSnippet = `
            let outputIndices = ${output.offsetToIndices(`global_idx * ${components}`)};
            let batch = ${output.indicesGet("outputIndices", 0)};
            let d1 = ${output.indicesGet("outputIndices", channelDim)};
            let r = ${output.indicesGet("outputIndices", rowDim)};
            let c = ${output.indicesGet("outputIndices", colDim)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${output.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${dataType}(dyRCorner) + ${dataType}(wR)) / ${dataType}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[${rowDim}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${dataType}(dyCCorner) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[${colDim}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${packInputAs4 ? `
                var x_offset = ${dy.indicesToOffset(`${dy.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${aComponents};
                var w_offset = ${w.indicesToOffset(`${w.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${bComponents};
                  ` : ""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${packInputAs4 ? 4 : aComponents}) {
                  ${calculateResult()}
                  inputChannel = inputChannel + ${packInputAs4 ? 4 : aComponents};
                }
                ${calculateRemainder()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${hasBias ? ` + bias[d1 / ${components}]` : ""};
            ${output.setByOffset("global_idx", "value")};
          `;
          return `
    ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${codeSnippet}}`;
        };
        return {
          name: "ConvTranspose2D",
          shaderCache: {
            hint: `${attributes.cacheKey};${aComponents}${bComponents}${components}${packInputAs4}${inputChannelsRemainder}`,
            inputDependencies
          },
          getRunData: () => ({
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts
  var computeTotalPad, distributePadding, calculateOutputShapeAndPads, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs9, convTranspose2d, convTranspose1d, convTranspose;
  var init_conv_transpose = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"() {
      "use strict";
      init_conv_backprop_webgpu();
      init_fuse_utils();
      init_transpose();
      computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
      distributePadding = (totalPad, autoPad, pads, head, tail) => {
        const smallPad = Math.floor(totalPad / 2);
        if (autoPad === "SAME_UPPER") {
          pads[head] = smallPad;
          pads[tail] = totalPad - smallPad;
        } else if (autoPad === "SAME_LOWER") {
          pads[head] = totalPad - smallPad;
          pads[tail] = smallPad;
        }
      };
      calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, group, pads, strides, isChannelLast, outputPadding, outputShape) => {
        const spatialRank = inputShape.length - 2;
        const updateOutputShape = outputShape.length === 0;
        if (outputPadding.length < spatialRank) {
          outputPadding.push(...Array(spatialRank - outputPadding.length).fill(0));
        }
        const batchSize = inputShape[0];
        const outChannels = kernelShape[isChannelLast ? 3 : 1] * group;
        for (let i = 0, j = inputShape.length - spatialRank - (isChannelLast ? 1 : 0); i < spatialRank; ++i, ++j) {
          const inSize = inputShape[j];
          const outSize = updateOutputShape ? inSize * strides[i] : outputShape[i];
          const totalPad = computeTotalPad(inSize, strides[i], pads[i], kernelShape[j], dilations[i], outSize);
          distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
          if (updateOutputShape) {
            outputShape.push(
              strides[i] * (inSize - 1) + outputPadding[i] + (kernelShape[j] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
            );
          }
        }
        outputShape.splice(0, 0, batchSize);
        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
      };
      getAdjustedConvTransposeAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (attributes.kernelShape.length === 0 || attributes.kernelShape.reduce((a, b) => a * b, 1) === 0) {
          kernelShape.length = 0;
          for (let i = 2; i < inputs[1].dims.length; ++i) {
            kernelShape.push(inputs[1].dims[i]);
          }
        }
        const isChannelsLast = attributes.format === "NHWC";
        kernelShape.splice(0, 0, inputs[1].dims[0]);
        kernelShape.splice(isChannelsLast ? 3 : 1, 0, inputs[1].dims[1]);
        const pads = attributes.pads.slice();
        const outputShape = attributes.outputShape.slice();
        const outputPadding = attributes.outputPadding.slice();
        const inputShape = inputs[0].dims;
        let dilations = attributes.dilations.slice();
        if (dilations.reduce((a, b) => a + b, 0) === 0) {
          const spatialRank = inputs[0].dims.length - 2;
          dilations = new Array(spatialRank).fill(1);
        }
        let strides = attributes.strides.slice();
        if (strides.reduce((a, b) => a + b, 0) === 0) {
          const spatialRank = inputs[0].dims.length - 2;
          strides = new Array(spatialRank).fill(1);
        }
        calculateOutputShapeAndPads(
          inputShape,
          kernelShape,
          dilations,
          attributes.autoPad,
          attributes.group,
          pads,
          strides,
          isChannelsLast,
          outputPadding,
          outputShape
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads, outputPadding, outputShape, dilations, strides });
        return newAttributes;
      };
      parseConvTransposeAttributes = (attributes) => {
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const format = attributes.format;
        const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][typeof attributes.autoPad == "undefined" ? 0 : attributes.autoPad];
        const dilations = attributes.dilations;
        const group = attributes.group;
        const kernelShape = attributes.kernelShape;
        const pads = attributes.pads;
        const strides = attributes.strides;
        const wIsConst = attributes.wIsConst();
        const outputPadding = attributes.outputPadding;
        const outputShape = attributes.outputShape;
        return {
          autoPad,
          format,
          dilations,
          group,
          kernelShape,
          outputPadding,
          outputShape,
          pads,
          strides,
          wIsConst,
          ...activationAttributes,
          cacheKey: `${attributes.format};${activationAttributes.activation};`
        };
      };
      validateInputs9 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {
          throw new Error("currently only support 2-dimensional conv");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("filter does not have same dimension as input");
        }
        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
        const filterInChannel = inputs[1].dims[0];
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        const featureMaps = inputs[1].dims[1] * attributes.group;
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        const dilationsSet = attributes.dilations.reduce((a, b) => a + b, 0) > 0;
        if (dilationsSet && attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        const stridesSet = attributes.strides.reduce((a, b) => a + b, 0) > 0;
        if (stridesSet && attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        const padsSet = attributes.pads.reduce((a, b) => a + b, 0) > 0;
        if (padsSet && attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.outputPadding.length !== spatialRank && attributes.outputPadding.length !== 0) {
          throw new Error(`output_padding should be ${spatialRank}D`);
        }
        const kernelShapeSet = attributes.kernelShape.reduce((a, b) => a + b, 0) > 0;
        if (kernelShapeSet && attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
        if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
          throw new Error("invalid output shape");
        }
      };
      convTranspose2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
        const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], [2, 3, 0, 1]), {
          inputs: [1],
          outputs: [attributes.wIsConst ? -2 : -1]
        })[0];
        if (attributes.wIsConst && !context.kernelCustomData.wT) {
          context.kernelCustomData.wT = transposedWeight;
        }
        const convTransposeInputs = [inputs[0], transposedWeight];
        if (inputs.length === 3) {
          convTransposeInputs.push(inputs[2]);
        }
        context.compute(createConvTranspose2DProgramInfo(convTransposeInputs, attributes, squeezeOutputShapeFunction), {
          inputs: convTransposeInputs
        });
      };
      convTranspose1d = (context, attributes) => {
        const isChannelLast = attributes.format === "NHWC";
        const inputs = [
          context.inputs[0].reshape(
            isChannelLast ? (
              // [N, W, C] -> [N, H=1, W, C]
              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
            ) : (
              // [N, C, W] -> [N, C, H=1, W]
              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
            )
          ),
          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
        ];
        if (context.inputs.length === 3) {
          inputs.push(context.inputs[2]);
        }
        let kernelShape = attributes.kernelShape;
        if (kernelShape.length === 0 || kernelShape[0] === 0) {
          kernelShape = [context.inputs[1].dims[2]];
        }
        let dilations = attributes.dilations;
        if (dilations.length === 0 || dilations[0] === 0) {
          dilations = [1];
        }
        let strides = attributes.strides;
        if (strides.length === 0 || strides[0] === 0) {
          strides = [1];
        }
        let pads = attributes.pads;
        if (pads.length === 0) {
          pads = [0, 0];
        }
        pads = [0, pads[0], 0, pads[1]];
        strides = [1].concat(strides);
        dilations = [1].concat(dilations);
        kernelShape = [1].concat(kernelShape);
        let outputPadding = attributes.outputPadding;
        outputPadding = [0].concat(outputPadding);
        const adjustedAttributes = getAdjustedConvTransposeAttributes(
          { ...attributes, pads, strides, dilations, kernelShape, outputPadding },
          inputs
        );
        convTranspose2d(
          context,
          inputs,
          adjustedAttributes,
          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
        );
      };
      convTranspose = (context, attributes) => {
        validateInputs9(context.inputs, attributes);
        if (context.inputs[0].dims.length === 3) {
          convTranspose1d(context, attributes);
        } else {
          const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, context.inputs);
          convTranspose2d(context, context.inputs, adjustedAttributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/cumsum.ts
  var createCumsumProgramInfo, cumsum, parseCumSumAttributes;
  var init_cumsum = __esm({
    "web/lib/wasm/jsep/webgpu/ops/cumsum.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      createCumsumProgramInfo = (inputType, inputShape, axisInput, attributes) => {
        const outputSize = ShapeUtil.size(inputShape);
        const rank = inputShape.length;
        const input = inputVariable("input", inputType, rank);
        const output = outputVariable("output", inputType, rank);
        const axisValue = axisInput.dataType === 6 /* int32 */ ? axisInput.getInt32Array()[0] : Number(axisInput.getBigInt64Array()[0]);
        const axis = ShapeUtil.normalizeAxis(axisValue, rank);
        const getShaderSource = (shaderHelper) => {
          const index = ` i32(${input.indicesGet("inputIndices", "uniforms.axis")}) `;
          const max = getElementAt("uniforms.input_shape", "uniforms.axis", rank);
          const lowerLimit = attributes.reverse ? index + (attributes.exclusive ? " + 1" : "") : "0";
          const upperLimit = attributes.reverse ? max : index + (attributes.exclusive ? "" : " + 1");
          return `
                ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(input, output)}
                ${shaderHelper.mainStart()}
                  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${output.offsetToIndices("global_idx")};
                  var sum = ${output.type.value}(0);
                  let first : i32 = ${lowerLimit};
                  let last : i32 = ${upperLimit};
                  for (var i : i32 = first; i < last; i++) {
                    ${input.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${input.getByIndices("inputIndices")};
                  }
                  ${output.setByOffset("global_idx", "sum")};
                }`;
        };
        return {
          name: "CumSum",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: inputShape, dataType: inputType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              { type: 12 /* uint32 */, data: axis },
              ...createTensorShapeVariables(inputShape, inputShape)
            ]
          }),
          getShaderSource
        };
      };
      cumsum = (context, attributes) => {
        const inputShape = context.inputs[0].dims;
        const inputType = context.inputs[0].dataType;
        const axis = context.inputs[1];
        context.compute(createCumsumProgramInfo(inputType, inputShape, axis, attributes), { inputs: [0] });
      };
      parseCumSumAttributes = (attributes) => {
        const exclusive = attributes.exclusive === 1;
        const reverse = attributes.reverse === 1;
        return createAttributeWithCacheKey({ exclusive, reverse });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts
  var validateInputs10, permFunctionBody2, createDepthToSpaceProgramInfo, depthToSpace, parseDepthToSpaceAttributes;
  var init_depth_to_space = __esm({
    "web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs10 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("DepthToSpace requires 1 input.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error("DepthToSpace requires 4D input.");
        }
      };
      permFunctionBody2 = (perm, rank, input, output) => {
        const reverseFunc = [];
        reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
        for (let i = 0; i < rank; ++i) {
          reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
        }
        reverseFunc.push("return a;}");
        return reverseFunc.join("\n");
      };
      createDepthToSpaceProgramInfo = (inputTensor, attributes) => {
        let n, h, w, c;
        let shape;
        let perm;
        const isChannelLast = attributes.format === "NHWC";
        const blocksize = attributes.blocksize;
        const isDCRmode = attributes.mode === "DCR";
        if (isChannelLast) {
          [n, h, w, c] = inputTensor.dims;
          shape = isDCRmode ? [n, h, w, blocksize, blocksize, c / blocksize ** 2] : [n, h, w, c / blocksize ** 2, blocksize, blocksize];
          perm = isDCRmode ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3];
        } else {
          [n, h, w, c] = [inputTensor.dims[0], inputTensor.dims[2], inputTensor.dims[3], inputTensor.dims[1]];
          shape = isDCRmode ? [n, blocksize, blocksize, c / blocksize ** 2, h, w] : [n, c / blocksize ** 2, blocksize, blocksize, h, w];
          perm = isDCRmode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
        }
        const reshapedInputTensor = inputTensor.reshape(shape);
        const reshapedInputRank = reshapedInputTensor.dims.length;
        const inputDataType = inputTensor.dataType;
        const reshapedInput = inputVariable("a", inputDataType, reshapedInputRank);
        const permedOutput = outputVariable("output", inputDataType, reshapedInputRank);
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(reshapedInput, permedOutput)}

  ${permFunctionBody2(perm, reshapedInputRank, reshapedInput, permedOutput)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${permedOutput.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${permedOutput.setByOffset("global_idx", reshapedInput.getByIndices("aIndices"))}
  }`;
        return {
          name: "DepthToSpace",
          shaderCache: {
            hint: `${inputTensor.dims};${attributes.blocksize};${attributes.mode}`,
            inputDependencies: ["rank"]
          },
          getRunData: (inputs) => {
            const outputShape = isChannelLast ? [n, h * blocksize, w * blocksize, c / blocksize ** 2] : [n, c / blocksize ** 2, h * blocksize, w * blocksize];
            const outputSize = ShapeUtil.size(outputShape);
            const shapeBeforePerm = reshapedInputTensor.dims;
            const shapeAfterPerm = ShapeUtil.sortBasedOnPerm(shapeBeforePerm, perm);
            return {
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(shapeBeforePerm, shapeAfterPerm)
              ]
            };
          },
          getShaderSource
        };
      };
      depthToSpace = (context, attributes) => {
        validateInputs10(context.inputs);
        context.compute(createDepthToSpaceProgramInfo(context.inputs[0], attributes));
      };
      parseDepthToSpaceAttributes = (attributes) => createAttributeWithCacheKey({
        blocksize: attributes.blocksize,
        mode: attributes.mode,
        format: attributes.format
      });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/einsum.ts
  var symbolPattern, termPattern, termPatternOnly, lhsPattern, lhsPatternOnly, EinsumTerm, EinsumEquation, appendMax, createEinsumProgramInfo, einsum, parseEinsumAttributes;
  var init_einsum = __esm({
    "web/lib/wasm/jsep/webgpu/ops/einsum.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      symbolPattern = "[a-zA-Z]|\\.\\.\\.";
      termPattern = "(" + symbolPattern + ")+";
      termPatternOnly = "^" + termPattern + "$";
      lhsPattern = "(" + termPattern + ",)*" + termPattern;
      lhsPatternOnly = "^" + lhsPattern + "$";
      EinsumTerm = class {
        constructor(inputIndex = -1) {
          this.symbolToIndices = /* @__PURE__ */ new Map();
          this.inputIndex = inputIndex;
        }
        // Add a symbol to the term
        addSymbol(symbol, index) {
          let value = this.symbolToIndices.get(symbol);
          if (value === void 0) {
            value = [index];
          } else {
            value.push(index);
          }
          this.symbolToIndices.set(symbol, value);
        }
        // -1 for output and 0, 1, 2, ... for inputs
      };
      EinsumEquation = class {
        constructor(inputs, equation) {
          this.equation = equation;
          this.hasEllipsis = false;
          this.symbolToInfo = /* @__PURE__ */ new Map();
          this.lhs = new Array();
          this.outputDims = [];
          let [lhs, rhs] = equation.includes("->") ? equation.split("->", 2) : [equation, ""];
          if (!lhs.match(RegExp(lhsPatternOnly))) {
            throw new Error("Invalid LHS term");
          }
          const inputTerms = lhs.split(",");
          inputTerms.forEach((inputTerm, index) => {
            const dims = inputs[index].dims.slice();
            if (!inputTerm.match(RegExp(termPatternOnly))) {
              throw new Error("Invalid LHS term");
            }
            const einsumTerm = this.processTerm(inputTerm, true, dims, index);
            this.lhs.push(einsumTerm);
          });
          if (rhs === "") {
            rhs += [...this.symbolToInfo.entries()].filter(([sym, info]) => info.count === 1 || sym === "...").map(([sym]) => sym).join("");
          } else {
            if (!rhs.match(RegExp(termPattern))) {
              throw new Error("Invalid RHS");
            }
          }
          const rhsSymbols = rhs.match(RegExp(symbolPattern, "g"));
          rhsSymbols?.forEach((symbol) => {
            if (symbol === "...") {
              this.outputDims = this.outputDims.concat(this.ellipsisDims);
            } else {
              const info = this.symbolToInfo.get(symbol);
              if (info === void 0) {
                throw new Error("Invalid RHS symbol");
              }
              this.outputDims.push(info.dimValue);
            }
          });
          this.rhs = this.processTerm(rhs, false, this.outputDims);
        }
        // End of EinsumEqation constructor
        // Add a symbol to the equation
        addSymbol(symbol, dimValue, inputIndex) {
          let info = this.symbolToInfo.get(symbol);
          if (info !== void 0) {
            if (info.dimValue !== dimValue && info.count !== 1) {
              throw new Error("Dimension mismatch");
            } else {
              info.count++;
              info.inputIndices.push(inputIndex);
            }
          } else {
            info = { count: 1, dimValue, inputIndices: [inputIndex] };
          }
          this.symbolToInfo.set(symbol, info);
        }
        // Process one input/output term
        processTerm(term, isInput, dims, index = -1) {
          const rank = dims.length;
          let ellipsis = false;
          let ellipsisDims = [];
          let nextDim = 0;
          if (!term.match(RegExp(termPatternOnly)) && !isInput && term !== "") {
            throw new Error("Invalid LHS term");
          }
          const indexSymbols = term.match(RegExp(symbolPattern, "g"));
          const einsumTerm = new EinsumTerm(index);
          indexSymbols?.forEach((symbol, i) => {
            if (symbol === "...") {
              if (ellipsis) {
                throw new Error("Only one ellipsis is allowed per input term");
              }
              ellipsis = true;
              const ellipsisDimLength = rank - indexSymbols.length + 1;
              if (ellipsisDimLength < 0) {
                throw new Error("Ellipsis out of bounds");
              }
              ellipsisDims = dims.slice(nextDim, nextDim + ellipsisDimLength);
              if (this.hasEllipsis) {
                if (this.ellipsisDims.length !== ellipsisDims.length || this.ellipsisDims.toString() !== ellipsisDims.toString()) {
                  throw new Error("Ellipsis dimensions mismatch");
                }
              } else if (isInput) {
                this.hasEllipsis = true;
                this.ellipsisDims = ellipsisDims;
              } else {
                throw new Error("Ellipsis must be specified in the LHS");
              }
              for (let j = 0; j < ellipsisDims.length; j++) {
                const symbol2 = String.fromCharCode("0".charCodeAt(0) + j);
                einsumTerm.addSymbol(symbol2, i + j);
                this.addSymbol(symbol2, dims[nextDim++], index);
              }
            } else {
              einsumTerm.addSymbol(symbol, i + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0));
              this.addSymbol(symbol, dims[nextDim++], index);
            }
          });
          return einsumTerm;
        }
        // Output dimensions of the equation
      };
      appendMax = (name) => name + "_max";
      createEinsumProgramInfo = (inputShapes, dataType, einsumEquation, outputShape) => {
        const ranks = inputShapes.map((dims) => dims.length);
        const inputVars = ranks.map((rank, index) => inputVariable(`input${index}`, dataType, rank));
        const outputSize = ShapeUtil.size(outputShape);
        const output = outputVariable("output", dataType, outputShape.length);
        const uniformsSymbols = [...einsumEquation.symbolToInfo.keys()].filter(
          (symbol) => !einsumEquation.rhs.symbolToIndices.has(symbol)
        );
        const getShaderSource = (shaderHelper) => {
          const idxCopy = [];
          const initProd = "var prod = 1.0;";
          const initSum = "var sum = 0.0;";
          const updateSum = "sum += prod;";
          const reduceOpsSetIndices = [];
          const reduceOpsLoopHeaders = [];
          const reduceOpsLoopFooters = [];
          const reduceOpCompute = [];
          const isReduceOpsWithoutLoop = einsumEquation.symbolToInfo.size === einsumEquation.rhs.symbolToIndices.size;
          einsumEquation.symbolToInfo.forEach((info, symbol) => {
            if (einsumEquation.rhs.symbolToIndices.has(symbol)) {
              const outputIndex = einsumEquation.rhs.symbolToIndices.get(symbol)?.[0];
              if (outputIndex !== void 0) {
                einsumEquation.lhs.forEach((term, i) => {
                  if (info.inputIndices.includes(i)) {
                    const indices = term.symbolToIndices.get(symbol);
                    if (indices === void 0) {
                      throw new Error("Invalid symbol error");
                    }
                    indices.forEach((index) => {
                      idxCopy.push(
                        `${inputVars[i].indicesSet(
                          `input${i}Indices`,
                          index,
                          output.indicesGet("outputIndices", outputIndex)
                        )}`
                      );
                    });
                  }
                });
              }
            } else {
              einsumEquation.lhs.forEach((term, i) => {
                if (info.inputIndices.includes(i)) {
                  const indices = term.symbolToIndices.get(symbol);
                  if (indices === void 0) {
                    throw new Error("Invalid symbol error");
                  }
                  indices.forEach((index) => {
                    reduceOpsSetIndices.push(`${inputVars[i].indicesSet(`input${i}Indices`, index, `${symbol}`)}`);
                  });
                  reduceOpCompute.push(`prod *= ${inputVars[i].getByIndices(`input${i}Indices`)};`);
                }
              });
              reduceOpsLoopHeaders.push(
                `for(var ${symbol}: u32 = 0; ${symbol} < uniforms.${appendMax(symbol)}; ${symbol}++) {`
              );
              reduceOpsLoopFooters.push("}");
            }
          });
          const reduceOps2 = isReduceOpsWithoutLoop ? [
            ...idxCopy,
            `let sum = ${inputVars.map((inputVar, i) => inputVar.getByIndices(`input${i}Indices`)).join(" * ")};`
          ] : [
            ...idxCopy,
            initSum,
            ...reduceOpsLoopHeaders,
            ...reduceOpsSetIndices,
            initProd,
            ...reduceOpCompute,
            updateSum,
            ...reduceOpsLoopFooters
          ];
          return `
            ${shaderHelper.registerUniforms(uniformsSymbols.map((symbol) => ({ name: `${appendMax(symbol)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...inputVars, output)}

            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${output.offsetToIndices("global_idx")};
            ${inputVars.map((_var, i) => `var input${i}Indices: ${inputVars[i].type.indices};`).join("\n")}
            ${reduceOps2.join("\n")};
            ${output.setByOffset("global_idx", "sum")};
          }`;
        };
        return {
          name: "Einsum",
          shaderCache: { hint: einsumEquation.equation, inputDependencies: inputShapes.map(() => "rank") },
          getRunData: () => {
            const programUniformsInit = uniformsSymbols.filter((symbol) => einsumEquation.symbolToInfo.has(symbol)).map((symbol) => ({ type: 12 /* uint32 */, data: einsumEquation.symbolToInfo.get(symbol)?.dimValue || 0 }));
            programUniformsInit.push({ type: 12 /* uint32 */, data: outputSize });
            const programUniforms = inputShapes.map((dims, _) => [...createTensorShapeVariables(dims)]).reduce((acc, inputProgramUniforms) => acc.concat(inputProgramUniforms), programUniformsInit);
            programUniforms.push(...createTensorShapeVariables(outputShape));
            return {
              outputs: [{ dims: outputShape, dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            };
          },
          getShaderSource
        };
      };
      einsum = (context, attributes) => {
        const einsumEquation = new EinsumEquation(context.inputs, attributes.equation);
        const outputShape = einsumEquation.outputDims;
        const inputShapes = context.inputs.map((input, _) => input.dims);
        context.compute(createEinsumProgramInfo(inputShapes, context.inputs[0].dataType, einsumEquation, outputShape));
      };
      parseEinsumAttributes = (attributes) => {
        const equation = attributes.equation.replace(/\s+/g, "");
        return createAttributeWithCacheKey({ equation });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/expand.ts
  var validateInputs11, getAdjustedShape, calculateOutputShape2, createExpandProgramInfo, expand;
  var init_expand = __esm({
    "web/lib/wasm/jsep/webgpu/ops/expand.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs11 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Expand requires 2 input.");
        }
        const inputShape = inputs[0].dims;
        const shape = Array.from(inputs[1].getBigInt64Array(), Number);
        let shapeIndex = shape.length < inputShape.length ? 0 : shape.length - inputShape.length;
        let inputShapeIndex = inputShape.length < shape.length ? 0 : inputShape.length - shape.length;
        for (; shapeIndex < shape.length && inputShapeIndex < inputShape.length; ++shapeIndex, ++inputShapeIndex) {
          if (shape[shapeIndex] !== inputShape[inputShapeIndex] && shape[shapeIndex] !== 1 && inputShape[inputShapeIndex] !== 1) {
            throw new Error("Expand requires shape to be broadcastable to input");
          }
        }
      };
      getAdjustedShape = (shape1, shape2) => {
        const diff = shape1.length - shape2.length;
        const shape = [];
        for (let i = 0; i < diff; ++i) {
          shape.push(shape1[i]);
        }
        for (let i = 0; i < shape2.length; ++i) {
          shape.push(shape2[i] === 1 ? shape1[i + diff] : shape2[i]);
        }
        return shape;
      };
      calculateOutputShape2 = (inputShape, shape) => inputShape.length > shape.length ? getAdjustedShape(inputShape, shape) : getAdjustedShape(shape, inputShape);
      createExpandProgramInfo = (inputs) => {
        const inputShape = inputs[0].dims;
        const shape = Array.from(inputs[1].getBigInt64Array(), Number);
        const outputShape = calculateOutputShape2(inputShape, shape);
        const dataType = inputs[0].dataType;
        const isBoolOrScalar = dataType === 9 /* bool */ || ShapeUtil.size(inputShape) === 1;
        const iComponents = dataType === 9 /* bool */ ? 4 : inputShape.length > 0 && inputShape[inputShape.length - 1] % 4 === 0 ? 4 : 1;
        const components = isBoolOrScalar ? 4 : outputShape.length > 0 && outputShape[outputShape.length - 1] % 4 === 0 ? 4 : 1;
        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", dataType, inputShape.length, iComponents);
          const output = outputVariable("output", dataType, outputShape.length, components);
          let assignment;
          if (dataType === 9 /* bool */) {
            const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          let offset${x} = ${input.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${input.getByOffset(`index${x}`)}[component${x}]);
        `;
            assignment = `
        let outputOffset = global_idx * ${components};
        var data = vec4<u32>(0);
        ${singleAssignment("data", 0, "u32")}
        ${singleAssignment("data", 1, "u32")}
        ${singleAssignment("data", 2, "u32")}
        ${singleAssignment("data", 3, "u32")}
        ${output.setByOffset("global_idx", "data")}
      }`;
          } else {
            assignment = `
        let outputIndices = ${output.offsetToIndices(`global_idx * ${components}`)};
        let inputOffset = ${input.broadcastedIndicesToOffset("outputIndices", output)};
        let data = ${output.type.value}(${input.getByOffset(`inputOffset / ${iComponents}`)});
        ${output.setByOffset("global_idx", "data")}
      }`;
          }
          return `
    ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}
    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${assignment}`;
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          ...createTensorShapeVariables(inputShape, outputShape)
        ];
        return {
          name: "Expand",
          shaderCache: { hint: `${outputShape.length};${iComponents}${components}`, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      expand = (context) => {
        validateInputs11(context.inputs);
        context.compute(createExpandProgramInfo(context.inputs), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts
  var createFastGeluProgramInfo, fastGelu2;
  var init_fast_gelu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_unary_op();
      createFastGeluProgramInfo = (inputTensors) => {
        const dataType = inputTensors[0].dataType;
        const outputSize = ShapeUtil.size(inputTensors[0].dims);
        const biasLength = ShapeUtil.size(inputTensors[1].dims);
        const useVec4 = biasLength % 4 === 0;
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", dataType, [1], 4);
          const bias = inputVariable("bias", dataType, [1], 4);
          const y = outputVariable("y", dataType, [1], 4);
          const uniforms = [
            { name: "output_vec_size", type: "u32" },
            { name: "bias_size", type: "u32" }
          ];
          const singleElementBias = (i) => `
      let bias${i}_offset: u32 = (global_idx * 4 + ${i}) % uniforms.bias_size;
      let bias${i} = ${bias.getByOffset(`bias${i}_offset / 4`)}[bias${i}_offset % 4];`;
          const biasGetExpression = useVec4 ? `
      let bias = ${bias.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${singleElementBias(0)}${singleElementBias(1)}${singleElementBias(2)}${singleElementBias(3)}
      let bias = ${x.type.value}(bias0, bias1, bias2, bias3);`;
          return `${shaderHelper.registerUniforms(uniforms).declareVariables(x, bias, y)}

    ${fastGeluImpl(tensorTypeToWsglValueType(dataType))}

    ${shaderHelper.mainStart(WORKGROUP_SIZE)}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${x.getByOffset("global_idx")};
      ${biasGetExpression}
      let x_in = x + bias;
      ${y.setByOffset("global_idx", fastGeluExpression("x_in"))}
    }`;
        };
        return {
          name: "FastGeluWithBias",
          shaderCache: { hint: `${useVec4}`, inputDependencies: ["type", "type"] },
          getShaderSource,
          getRunData: (inputs) => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            programUniforms: [
              { type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) },
              { type: 12 /* uint32 */, data: biasLength }
            ],
            dispatchGroup: { x: Math.ceil(outputSize / WORKGROUP_SIZE / 4) }
          })
        };
      };
      fastGelu2 = (context) => {
        if (context.inputs.length < 2 || ShapeUtil.size(context.inputs[1].dims) === 0) {
          fastGelu(context);
        } else {
          context.compute(createFastGeluProgramInfo(context.inputs));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather.ts
  var validateInputs12, createGatherProgramInfo, parseGatherAttributes, gather;
  var init_gather = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs12 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Gather requires 2 inputs.");
        }
      };
      createGatherProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const indicesShape = inputs[1].dims;
        const inputRank = inputShape.length;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const outputShape = inputShape.slice(0);
        outputShape.splice(axis, 1, ...indicesShape);
        const axisDimLimit = inputShape[axis];
        const components = inputs[0].dataType === 9 /* bool */ ? 4 : 1;
        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: axisDimLimit },
          { type: 12 /* uint32 */, data: axis },
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length, components);
          const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
          const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
          const calcDataIndices = (x) => {
            const indicesRank = indicesShape.length;
            let calcStr = `var indicesIndices${x}  = ${indices.type.indices}(0);`;
            for (let i = 0; i < indicesRank; i++) {
              calcStr += `${indicesRank > 1 ? `indicesIndices${x}[${i}]` : `indicesIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[uniforms.axis + ${i}]` : `outputIndices${x}`};`;
            }
            calcStr += `
          var idx${x} = ${indices.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${data.type.indices};
        `;
            for (let i = 0, j = 0; i < inputRank; i++) {
              if (i === axis) {
                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = u32(idx${x});`;
                j += indicesRank;
              } else {
                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[${j}]` : `outputIndices${x}`};`;
                j++;
              }
            }
            return calcStr;
          };
          let assignment;
          if (inputs[0].dataType === 9 /* bool */) {
            const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          ${calcDataIndices(x)};
          let offset${x} = ${data.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${data.getByOffset(`index${x}`)}[component${x}]);
        `;
            assignment = `
        let outputOffset = global_idx * ${components};
        var value = vec4<u32>(0);
        ${singleAssignment("value", 0, "u32")}
        ${singleAssignment("value", 1, "u32")}
        ${singleAssignment("value", 2, "u32")}
        ${singleAssignment("value", 3, "u32")}
        ${output.setByOffset("global_idx", "value")}
      `;
          } else {
            assignment = `
      let outputIndices = ${output.offsetToIndices("global_idx")};
      ${calcDataIndices("")};
      let value = ${data.getByIndices("dataIndices")};
      ${output.setByOffset("global_idx", "value")};
      `;
          }
          return `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(data, indices, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${assignment}
      }`;
        };
        return {
          name: "Gather",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGatherAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
      gather = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs12(inputs);
        context.compute(createGatherProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather-nd.ts
  var computeSliceOffsets, gatherND, parseGatherNDAttributes;
  var init_gather_nd = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather-nd.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      computeSliceOffsets = (context, indicesData, sizesFromSliceDimsData, batchDims, inputDims, numSlices, numSlicesPerBatch, inputBatchStride, numSliceDims) => {
        const programUniforms = [
          { type: 12 /* uint32 */, data: numSlices },
          { type: 12 /* uint32 */, data: batchDims },
          { type: 12 /* uint32 */, data: inputDims },
          { type: 12 /* uint32 */, data: sizesFromSliceDimsData },
          { type: 12 /* uint32 */, data: numSlicesPerBatch },
          { type: 12 /* uint32 */, data: inputBatchStride },
          { type: 12 /* uint32 */, data: numSliceDims }
        ];
        const outputShape = [numSlices];
        programUniforms.push(...createTensorShapeVariables(indicesData.dims, outputShape));
        const getShaderSource = (shaderHelper) => {
          const indices = inputVariable("indices_data", indicesData.dataType, indicesData.dims.length);
          const output = outputVariable("input_slice_offsets_data", 12 /* uint32 */, 1, 1);
          const variables = [indices, output];
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "batch_dims", type: "u32" },
            { name: "input_dims", type: "u32", length: inputDims.length },
            { name: "sizes_from_slice_dims_data", type: "u32", length: sizesFromSliceDimsData.length },
            { name: "num_slices_per_batch", type: "u32" },
            { name: "input_batch_stride", type: "u32" },
            { name: "num_slice_dims", type: "u32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${inputDims.length === 1 ? "index += i32(uniforms.input_dims);" : "index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${sizesFromSliceDimsData.length === 1 ? "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);" : "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`;
        };
        return context.compute(
          {
            name: "computeSliceOffsets",
            shaderCache: { hint: `${inputDims.length}_${sizesFromSliceDimsData.length}`, inputDependencies: ["rank"] },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: context.inputs[1].dataType }],
              dispatchGroup: { x: Math.ceil(numSlices / 64) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [indicesData], outputs: [-1] }
        )[0];
      };
      gatherND = (context, attributes) => {
        const inputs = context.inputs;
        const inputShape = inputs[0].dims;
        const inputType = inputs[0].dataType;
        const indicesShape = inputs[1].dims;
        const numSliceDims = indicesShape[indicesShape.length - 1];
        const numSlices = ShapeUtil.sizeToDimension(indicesShape, indicesShape.length - 1);
        const sliceSize = ShapeUtil.sizeFromDimension(inputShape, attributes.batchDims + numSliceDims);
        const numBatches = ShapeUtil.sizeToDimension(inputShape, attributes.batchDims);
        const inputBatchStride = ShapeUtil.sizeFromDimension(inputShape, attributes.batchDims);
        const numSlicesPerBatch = numSlices / numBatches;
        const sizesFromSliceDims = new Array(numSliceDims);
        let runningProduct = sliceSize;
        for (let i = 0; i < numSliceDims; ++i) {
          sizesFromSliceDims[numSliceDims - 1 - i] = runningProduct;
          runningProduct *= inputShape[attributes.batchDims + numSliceDims - 1 - i];
        }
        const inputSliceOffsets = computeSliceOffsets(
          context,
          inputs[1],
          sizesFromSliceDims,
          attributes.batchDims,
          inputShape,
          numSlices,
          numSlicesPerBatch,
          inputBatchStride,
          numSliceDims
        );
        const lastIndicesDimension = attributes.batchDims + numSliceDims;
        if (lastIndicesDimension > inputShape.length) {
          throw new Error("last dimension of indices must not be larger than rank of input tensor");
        }
        const outputShape = indicesShape.slice(0, -1).concat(inputShape.slice(lastIndicesDimension));
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: sliceSize },
          ...createTensorShapeVariables(inputs[0].dims, inputSliceOffsets.dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
          const indices = inputVariable("slice_offsets", 12 /* uint32 */, inputSliceOffsets.dims.length);
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          return `
          ${shaderHelper.registerUniform("output_size", "u32").registerUniform("slice_size", "u32").declareVariables(input, indices, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`;
        };
        context.compute(
          {
            name: "GatherND",
            shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [inputs[0], inputSliceOffsets] }
        );
      };
      parseGatherNDAttributes = (attributes) => {
        const batchDims = attributes.batch_dims;
        return {
          batchDims,
          cacheKey: ""
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts
  var validateInputs13, createGatherBlockQuantizedProgramInfo, gatherBlockQuantized, parseGatherBlockQuantizedAttributes;
  var init_gather_block_quantized = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs13 = (inputs, attributes) => {
        if (inputs.length < 3 || inputs.length > 4) {
          throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");
        }
        const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputs[0].dims.length);
        const blockSize = attributes.blockSize;
        const data = inputs[0];
        const scales = inputs[2];
        const zeroPoint = inputs.length === 4 ? inputs[3] : void 0;
        if (scales.dims.length !== data.dims.length || !data.dims.map((d, i) => i === quantizeAxis ? Math.ceil(d / blockSize) === scales.dims[i] : d === scales.dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error(
            "Scales must have the same rank as the input tensor and the dims should match except on gatherAxis."
          );
        }
        if (zeroPoint) {
          if (zeroPoint.dataType !== data.dataType) {
            throw new Error("Zero point must have the same data type as the input tensor.");
          }
          if (zeroPoint.dims.length !== scales.dims.length || !zeroPoint.dims.map((d, i) => d === scales.dims[i]).reduce((a, b) => a && b, true)) {
            throw new Error(
              "Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis."
            );
          }
        }
      };
      createGatherBlockQuantizedProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const indicesShape = inputs[1].dims;
        const inputRank = inputShape.length;
        const gatherAxis = ShapeUtil.normalizeAxis(attributes.gatherAxis, inputRank);
        const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputRank);
        const outputShape = inputShape.slice(0);
        outputShape.splice(gatherAxis, 1, ...indicesShape);
        const outputSize = ShapeUtil.size(outputShape);
        const outputType = inputs[2].dataType;
        const inputType = inputs[0].dataType;
        const isSigned = inputType === 22 /* int4 */;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: quantizeAxis },
          { type: 12 /* uint32 */, data: gatherAxis },
          { type: 12 /* uint32 */, data: attributes.blockSize },
          ...createTensorShapeVariables(...inputs.map((input, _) => input.dims), outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
          const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
          const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
          const zeroPoint = inputs.length > 3 ? inputVariable("zeroPoint", inputs[3].dataType, inputs[3].dims.length) : void 0;
          const output = outputVariable("output", outputType, outputShape.length);
          const inputVariables = [data, indices, scales];
          if (zeroPoint) {
            inputVariables.push(zeroPoint);
          }
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "quantize_axis", type: "u32" },
            { name: "gather_axis", type: "u32" },
            { name: "block_size", type: "u32" }
          ];
          return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart()}
        let output_indices = ${output.offsetToIndices("global_idx")};
        var indices_indices = ${indices.type.indices}(0);
        ${(() => {
            if (indicesShape.length > 1) {
              return `
          for (var i: u32 = 0; i < ${indicesShape.length}; i++) {
            let index = ${output.indicesGet("output_indices", "uniforms.gather_axis + i")};
            ${indices.indicesSet("indices_indices", "i", "index")};
          }`;
            } else {
              return `indices_indices = ${output.indicesGet("output_indices", "uniforms.gather_axis")};`;
            }
          })()};
        var data_indices = ${data.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${output.indicesGet("output_indices", "i")};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        var index_from_indices = ${indices.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${inputShape[gatherAxis]};
        }
        ${data.indicesSet("data_indices", "uniforms.gather_axis", "u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${outputShape.length}; i++) {
          let index = ${output.indicesGet("output_indices", `i + ${indicesShape.length} - 1`)};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        let data_offset = ${data.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${data.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${scales.indicesGet("data_indices", "uniforms.quantize_axis")} / uniforms.block_size;
        ${scales.indicesSet("scale_indices", "uniforms.quantize_axis", "quantize_axis_index")};
        var scale = ${scales.getByIndices("scale_indices")};
        ${(() => {
            if (!zeroPoint) {
              return "var zero_point = 0";
            } else {
              return `
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${zeroPoint.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${zeroPoint.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`;
            }
          })()};
        let dequantized_data = ${tensorTypeToWsglValueType(outputType)}(quantized_data - zero_point) * scale;
        ${output.setByOffset("global_idx", "dequantized_data")};
    }`;
        };
        return {
          name: "GatherBlockQuantized",
          shaderCache: {
            hint: `${attributes.cacheKey};${inputs.filter((_, i) => i !== 1).map((input) => input.dims.join("_")).join(";")}`,
            inputDependencies: Array.from({ length: inputs.length }, (_v, _i) => "rank")
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      gatherBlockQuantized = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs13(inputs, attributes);
        context.compute(createGatherBlockQuantizedProgramInfo(context.inputs, attributes));
      };
      parseGatherBlockQuantizedAttributes = (attributes) => createAttributeWithCacheKey({
        blockSize: attributes.blockSize,
        gatherAxis: attributes.gatherAxis,
        quantizeAxis: attributes.quantizeAxis
      });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather-elements.ts
  var validateInputs14, createGatherElementsProgramInfo, parseGatherElementsAttributes, gatherElements;
  var init_gather_elements = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs14 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("GatherElements requires 2 inputs.");
        }
        if (inputs[0].dims.length < 1) {
          throw new Error("GatherElements requires that the data input be rank >= 1.");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
        }
      };
      createGatherElementsProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputOutputDataType = inputs[0].dataType;
        const inputRank = inputShape.length;
        const indicesShape = inputs[1].dims;
        const indicesDataType = inputs[1].dataType;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const axisDimLimit = inputShape[axis];
        const outputShape = indicesShape.slice(0);
        const outputSize = ShapeUtil.size(outputShape);
        const input = inputVariable("input", inputOutputDataType, inputRank);
        const indices = inputVariable("indicesInput", indicesDataType, indicesShape.length);
        const output = outputVariable("output", inputOutputDataType, outputShape.length);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: axisDimLimit },
          { type: 12 /* uint32 */, data: axis }
        ];
        programUniforms.push(...createTensorShapeVariables(inputShape, indicesShape, outputShape));
        const inputDependencies = ["rank", "rank"];
        const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(input, indices, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${output.offsetToIndices("global_idx")};

      var idx = ${indices.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${input.type.indices}(outputIndices);
      ${input.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${input.getByIndices("inputIndices")};

      ${output.setByOffset("global_idx", "value")};
  }`;
        return {
          name: "GatherElements",
          shaderCache: { inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGatherElementsAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
      gatherElements = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs14(inputs);
        context.compute(createGatherElementsProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gemm.ts
  var validateInputs15, createGemmProgramInfo, parseGemmAttributes, gemm;
  var init_gemm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gemm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs15 = (inputs) => {
        if (!inputs) {
          throw new Error("Input is missing");
        }
        if (inputs.length < 2 || inputs.length > 3) {
          throw new Error("Invaid input number.");
        }
        if (inputs.length === 3 && inputs[2].dims.length > 2) {
          throw new Error("Invalid input shape of C");
        }
        if (inputs[0].dataType !== inputs[1].dataType || inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("Input types are mismatched");
        }
      };
      createGemmProgramInfo = (inputs, attributes) => {
        const aShape = inputs[0].dims.slice();
        const bShape = inputs[1].dims.slice();
        const [M, N, K] = GemmUtil.getShapeOfGemmResult(
          aShape,
          attributes.transA,
          bShape,
          attributes.transB,
          inputs.length === 3 ? inputs[2].dims : void 0
        );
        const outputShape = [M, N];
        if (!outputShape) {
          throw new Error("Can't use gemm on the given tensors");
        }
        const tileSize = 16;
        const numTileN = Math.ceil(N / tileSize);
        const numTileM = Math.ceil(M / tileSize);
        const useShared = true;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: useShared ? numTileN : outputSize },
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: K },
          { type: 1 /* float */, data: attributes.alpha },
          { type: 1 /* float */, data: attributes.beta }
        ];
        const inputDependencies = ["type", "type"];
        if (inputs.length === 3) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          let line = "";
          if (attributes.transA && attributes.transB) {
            line = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];";
          } else if (attributes.transA && !attributes.transB) {
            line = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];";
          } else if (!attributes.transA && attributes.transB) {
            line = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];";
          } else if (!attributes.transA && !attributes.transB) {
            line = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];";
          }
          const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
          const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
          const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
          const dataType = a.type.value;
          let c = null;
          const variables = [a, b];
          if (inputs.length === 3) {
            c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
            variables.push(c);
          }
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          variables.push(output);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "beta", type: "f32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${dataType}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${line}
    }

    ${calculateAlpha}
    ${(() => {
            if (c != null) {
              return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${dataType}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
            }
            return "";
          })()}
    output[global_idx] = value;
  }`;
        };
        const getShaderSourceShared = (shaderHelper) => {
          const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
          const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
          let c = null;
          const variables = [a, b];
          if (inputs.length === 3) {
            c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
            variables.push(c);
          }
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          variables.push(output);
          const uniforms = [
            { name: "num_tile_n", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "beta", type: "f32" }
          ];
          let calcResult = "";
          let fillWorkgroupMemory = "";
          if (attributes.transA && attributes.transB) {
            fillWorkgroupMemory = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
            calcResult = `value += tile_a[k][local_id.y] * tile_b[local_id.x][k];`;
          } else if (attributes.transA && !attributes.transB) {
            fillWorkgroupMemory = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
            calcResult = `value += tile_a[k][local_id.y] * tile_b[k][local_id.x];`;
          } else if (!attributes.transA && attributes.transB) {
            fillWorkgroupMemory = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
            calcResult = `value += tile_a[local_id.y][k] * tile_b[local_id.x][k];`;
          } else if (!attributes.transA && !attributes.transB) {
            fillWorkgroupMemory = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
            calcResult = `value += tile_a[local_id.y][k] * tile_b[k][local_id.x];`;
          }
          const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  var<workgroup> tile_a: array<array<${a.type.storage}, ${tileSize}>, ${tileSize}>;
  var<workgroup> tile_b: array<array<${b.type.storage}, ${tileSize}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${tileSize};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${tileSize};
    let num_tiles = (uniforms.K - 1) / ${tileSize} + 1;
    var k_start = 0u;
    var value = ${output.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${fillWorkgroupMemory}
      k_start = k_start + ${tileSize};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${tileSize}; k++) {
        ${calcResult}
      }
      workgroupBarrier();
    }

    ${calculateAlpha}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${(() => {
            if (c != null) {
              return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${output.type.value}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
            }
            return "";
          })()}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`;
        };
        if (useShared) {
          return {
            name: "GemmShared",
            shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: numTileN * numTileM },
              programUniforms
            }),
            getShaderSource: getShaderSourceShared
          };
        }
        return {
          name: "Gemm",
          shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGemmAttributes = (attributes) => {
        const transA = attributes.transA;
        const transB = attributes.transB;
        const alpha = attributes.alpha;
        const beta = attributes.beta;
        return {
          transA,
          transB,
          alpha,
          beta,
          cacheKey: `${attributes.transA};${attributes.transB};${attributes.alpha === 1}`
        };
      };
      gemm = (context, attributes) => {
        validateInputs15(context.inputs);
        context.compute(createGemmProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/grid-sample.ts
  var idxN, idxC, idxH, idxW, validateInputs16, gsGetCubicCoeffs, gsBicubicInterpolate, gsDenormalize, gsReflect, pixelAtGrid, computePixel, createGridSampleProgramInfo, gridSample, parseGridSampleAttributes;
  var init_grid_sample = __esm({
    "web/lib/wasm/jsep/webgpu/ops/grid-sample.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      [idxN, idxC, idxH, idxW] = [0, 1, 2, 3];
      validateInputs16 = (inputs) => {
        if (inputs[0].dims.length !== 4) {
          throw new Error("only 4-D tensor is supported.");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("input dimensions must be equal to grid dimensions");
        }
        if (inputs[0].dims.length - 2 !== inputs[1].dims[inputs[1].dims.length - 1]) {
          throw new Error(`last dimension of grid must be equal to ${inputs[0].dims.length - 2}`);
        }
        if (inputs[0].dims[0] !== inputs[1].dims[0]) {
          throw new Error("grid batch size must match input batch size");
        }
      };
      gsGetCubicCoeffs = `
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`;
      gsBicubicInterpolate = (dataType) => `
  fn gs_bicubic_interpolate(p: mat4x4<${dataType}>, x: f32, y: f32) -> ${dataType} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${dataType}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`;
      gsDenormalize = (attributes) => `
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${attributes.alignCorners === 0 ? `
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    ` : `
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`;
      gsReflect = (attributes) => `
  ${attributes.paddingMode === "reflection" ? `
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }` : ""}
`;
      pixelAtGrid = (input, dataType, attributes) => `
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${dataType} {
     var pixel = ${dataType}(0);
     var indices = vec4<u32>(0);
     indices[${idxN}] = batch;
     indices[${idxC}] = channel;` + (() => {
        switch (attributes.paddingMode) {
          case "zeros":
            return `
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${idxH}] = u32(r);
            indices[${idxW}] = u32(c);
          } else {
            return ${dataType}(0);
          }
        `;
          case "border":
            return `
          indices[${idxH}] = u32(clamp(r, 0, H - 1));
          indices[${idxW}] = u32(clamp(c, 0, W - 1));
        `;
          case "reflection":
            return `
          indices[${idxH}] = gs_reflect(r, border[1], border[3]);
          indices[${idxW}] = gs_reflect(c, border[0], border[2]);
        `;
          default:
            throw new Error(`padding mode ${attributes.paddingMode} is not supported`);
        }
      })() + `
    return ${input.getByIndices("indices")};
  }
`;
      computePixel = (output, dataType, attributes) => (() => {
        switch (attributes.mode) {
          case "nearest":
            return `
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${idxN}], indices[${idxC}], border);
        `;
          case "bilinear":
            return `
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${idxN}], indices[${idxC}], border);

          let dx2 = ${dataType}(f32(x2) - x);
          let dx1 = ${dataType}(x - f32(x1));
          let dy2 = ${dataType}(f32(y2) - y);
          let dy1 = ${dataType}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;
          case "bicubic":
            return `
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${dataType}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;
          default:
            throw new Error(`mode ${attributes.mode} is not supported`);
        }
      })() + `${output.setByOffset("global_idx", "result")}`;
      createGridSampleProgramInfo = (inputs, attributes) => {
        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length);
        const gridShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2]];
        const grid = inputVariable("grid", inputs[1].dataType, gridShape.length, 2);
        let outputShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[1].dims[1], inputs[1].dims[2]];
        if (attributes.format === "NHWC") {
          outputShape = [inputs[0].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[0].dims[3]];
          [idxN, idxC, idxH, idxW] = [0, 3, 1, 2];
        }
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const dataType = x.type.value;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          ...createTensorShapeVariables(inputs[0].dims, gridShape, outputShape)
        ];
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(x, grid, output)}
  ${gsGetCubicCoeffs}
  ${gsBicubicInterpolate(dataType)}
  ${gsDenormalize(attributes)}
  ${gsReflect(attributes)}
  ${pixelAtGrid(x, dataType, attributes)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${idxH}]);
      let W_in = i32(uniforms.x_shape[${idxW}]);

      ${attributes.alignCorners === 0 ? `
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      ` : `
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${output.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${idxN}], indices[${idxH}], indices[${idxW}]);
      let nxy = ${grid.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${computePixel(output, dataType, attributes)}
  }`;
        return {
          name: "GridSample",
          shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies: ["type", "type"] },
          getRunData: (inputs2) => {
            const outputSize2 = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputs2[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize2 / 64
                /* workgroup size */
              ) },
              programUniforms
            };
          },
          getShaderSource
        };
      };
      gridSample = (context, attributes) => {
        validateInputs16(context.inputs);
        context.compute(createGridSampleProgramInfo(context.inputs, attributes));
      };
      parseGridSampleAttributes = (attributes) => createAttributeWithCacheKey({
        alignCorners: attributes.align_corners,
        mode: attributes.mode,
        paddingMode: attributes.padding_mode,
        format: attributes.format
      });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts
  var getInput, validateInputs17, parseMultiHeadAttentionAttributes, weightTransposeAttribute2, addBiasTranspose, maybeTransposeToBNSHAndAddBias, multiHeadAttention;
  var init_multihead_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_types();
      init_attention();
      init_common();
      init_transpose();
      getInput = (inputs, i) => inputs.length > i && inputs[i].dims.length > 0 ? inputs[i] : void 0;
      validateInputs17 = (inputs, attributes) => {
        const query = inputs[0];
        const key = getInput(inputs, 1);
        const value = getInput(inputs, 2);
        const bias = getInput(inputs, 3);
        const keyPaddingMask = getInput(inputs, 4);
        const attentionBias = getInput(inputs, 5);
        const pastKey = getInput(inputs, 6);
        const pastValue = getInput(inputs, 7);
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error("Input query is expected to have 3 or 5 dimensions");
        }
        const batchSize = query.dims[0];
        const sequenceLength = query.dims[1];
        const hiddenSize = query.dims.length === 3 ? query.dims[2] : attributes.numHeads * query.dims[4];
        let kvSequenceLength = sequenceLength;
        let pastSequenceLength = 0;
        let maxSequenceLength = 0;
        const headSize = Math.floor(hiddenSize / attributes.numHeads);
        if (pastKey && pastValue && ShapeUtil.size(pastKey.dims) && ShapeUtil.size(pastValue.dims)) {
          if (pastKey.dims.length !== 4) {
            throw new Error('Input "past_key" is expected to have 4 dimensions');
          }
          if (pastKey.dims[0] !== batchSize || pastKey.dims[1] !== attributes.numHeads || pastKey.dims[3] !== headSize) {
            throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
          }
          if (pastValue.dims[0] !== batchSize || pastValue.dims[1] !== attributes.numHeads || pastValue.dims[3] !== headSize) {
            throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
          }
          if (pastKey.dims[2] !== pastValue.dims[2]) {
            throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
          }
          if (pastValue.dims.length !== 4) {
            throw new Error('Input "past_value" is expected to have 4 dimensions');
          }
          pastSequenceLength = pastKey.dims[2];
          maxSequenceLength = pastKey.dims[2];
        } else if (pastKey && ShapeUtil.size(pastKey.dims) || pastValue && ShapeUtil.size(pastValue.dims)) {
          throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
        }
        let qkvFormat;
        if (key && ShapeUtil.size(key.dims) > 0) {
          if (query.dims.length !== 3) {
            throw new Error('Input "query" is expected to have 3 dimensions when key is given');
          }
          if (key.dims.length < 3 || key.dims.length > 5) {
            throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
          }
          if (query.dims[0] !== key.dims[0]) {
            throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
          }
          if (key.dims.length === 3) {
            if (key.dims[2] !== query.dims[2]) {
              throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
            }
            qkvFormat = 2 /* qkvBSNH */;
            kvSequenceLength = key.dims[1];
          } else if (key.dims.length === 5) {
            if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
            }
            if (value) {
              throw new Error('Expect "value" be none when "key" has packed kv format.');
            }
            qkvFormat = 5 /* qKvBSNHxBSN2H */;
            kvSequenceLength = key.dims[1];
          } else {
            if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
            }
            qkvFormat = 0 /* unknown */;
            kvSequenceLength = key.dims[2];
          }
        } else {
          if (query.dims.length !== 5) {
            throw new Error('Input "query" is expected to have 5 dimensions when key is empty');
          }
          if (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3) {
            throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
          }
          qkvFormat = 3 /* qkvBSN3H */;
        }
        if (bias && ShapeUtil.size(bias.dims) > 0) {
          if (bias.dims.length !== 1) {
            throw new Error('Input "bias" is expected to have 1 dimension');
          }
          if (key) {
            if (key.dims.length === 5 && key.dims[3] === 2) {
              throw new Error("bias is not allowed for packed kv.");
            }
          }
        }
        const totalSequenceLength = pastSequenceLength + kvSequenceLength;
        let maskType = 0 /* none */;
        if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
          maskType = 8 /* maskUnknown */;
          const maskDims = keyPaddingMask.dims;
          if (maskDims.length === 1) {
            if (maskDims[0] === batchSize) {
              maskType = 1 /* mask1dKeySeqLen */;
            } else if (maskDims[0] === 3 * batchSize + 2) {
              maskType = 3 /* mask1DKeySeqLenStart */;
            }
          } else if (maskDims.length === 2 && maskDims[0] === batchSize && maskDims[1] === totalSequenceLength) {
            maskType = 5 /* mask2dKeyPadding */;
          }
          if (maskType === 8 /* maskUnknown */) {
            throw new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)');
          }
          throw new Error("Mask not supported");
        }
        let passPastInKv = false;
        let vHiddenSize = hiddenSize;
        if (value && ShapeUtil.size(value.dims) > 0) {
          if (value.dims.length !== 3 && value.dims.length !== 4) {
            throw new Error('Input "value" is expected to have 3 or 4 dimensions');
          }
          if (query.dims[0] !== value.dims[0]) {
            throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
          }
          if (value.dims.length === 3) {
            if (kvSequenceLength !== value.dims[1]) {
              throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[2];
          } else {
            if (kvSequenceLength !== value.dims[2]) {
              throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[1] * value.dims[3];
            passPastInKv = true;
          }
        }
        const broadcastResPosBias = false;
        if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
          throw new Error("Key padding mask is not supported");
        }
        if (attentionBias && ShapeUtil.size(attentionBias.dims) > 0) {
          if (attentionBias.dims.length !== 4) {
            throw new Error('Input "attention_bias" is expected to have 4 dimensions');
          }
          if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
            throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
          }
        }
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize: 0,
          hiddenSize,
          vHiddenSize,
          headSize,
          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
          numHeads: attributes.numHeads,
          isUnidirectional: false,
          pastPresentShareBuffer: false,
          maskFilterValue: attributes.maskFilterValue,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias,
          passPastInKv,
          qkvFormat
        };
      };
      parseMultiHeadAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
      weightTransposeAttribute2 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
      addBiasTranspose = (context, qkv, bias, batchSize, sequenceLength, hiddenSize, biasOffset) => {
        const outputShape = [batchSize, sequenceLength, hiddenSize];
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: biasOffset },
          { type: 12 /* uint32 */, data: hiddenSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("qkv_with_bias", qkv.dataType, outputShape);
          const qkvInput = inputVariable("qkv", qkv.dataType, outputShape);
          const biasInput = inputVariable("bias", bias.dataType, outputShape);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "bias_offset", type: "u32" },
            { name: "hidden_size", type: "u32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(qkvInput, biasInput, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
        };
        return context.compute(
          {
            name: "MultiHeadAttentionAddBias",
            shaderCache: { inputDependencies: ["type", "type"] },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: qkv.dataType, gpuDataType: 0 /* default */ }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [qkv, bias], outputs: [-1] }
        )[0];
      };
      maybeTransposeToBNSHAndAddBias = (context, batchSize, numHeads, sequenceLength, headSize, input, bias, biasOffset) => {
        let reshapedInput = input;
        if (!(bias && ShapeUtil.size(bias.dims) > 0)) {
          if (input.dims.length === 3) {
            reshapedInput = input.reshape([batchSize, sequenceLength, numHeads, headSize]);
          }
          if (numHeads === 1 || sequenceLength === 1) {
            return reshapedInput;
          }
          return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
            inputs: [reshapedInput],
            outputs: [-1]
          })[0];
        } else {
          if (sequenceLength === 1) {
            throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
          } else {
            reshapedInput = addBiasTranspose(
              context,
              input,
              bias,
              batchSize,
              sequenceLength,
              numHeads * headSize,
              biasOffset
            );
            reshapedInput = reshapedInput.reshape([batchSize, sequenceLength, numHeads, headSize]);
            if (numHeads === 1 || sequenceLength === 1) {
              return reshapedInput;
            }
            return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
              inputs: [reshapedInput],
              outputs: [-1]
            })[0];
          }
        }
      };
      multiHeadAttention = (context, attributes) => {
        const params = validateInputs17(context.inputs, attributes);
        const query = context.inputs[0];
        const key = getInput(context.inputs, 1);
        const value = getInput(context.inputs, 2);
        const bias = getInput(context.inputs, 3);
        const keyPaddingMask = getInput(context.inputs, 4);
        const attentionBias = getInput(context.inputs, 5);
        const pastKey = getInput(context.inputs, 6);
        const pastValue = getInput(context.inputs, 7);
        if (query.dims.length === 5) {
          throw new Error("Packed QKV is not implemented");
        }
        if (key?.dims.length === 5) {
          throw new Error("Packed KV is not implemented");
        }
        const kvBNSH = key && value && key.dims.length === 4 && value.dims.length === 4;
        const Q = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.sequenceLength,
          params.headSize,
          query,
          bias,
          0
        );
        if (kvBNSH) {
          return applyAttention(context, Q, key, value, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
        }
        if (!key || !value) {
          throw new Error("key and value must be provided");
        }
        const K = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.kvSequenceLength,
          params.headSize,
          key,
          bias,
          params.hiddenSize
        );
        const V = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.kvSequenceLength,
          params.vHeadSize,
          value,
          bias,
          2 * params.hiddenSize
        );
        applyAttention(context, Q, K, V, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/split.ts
  var validateInputs18, createSplitAttributesFromInputs, calculateOutputIndexImpl, writeBufferDataImpl, createSplitProgramInfo, split, parseSplitAttributes;
  var init_split = __esm({
    "web/lib/wasm/jsep/webgpu/ops/split.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs18 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
      };
      createSplitAttributesFromInputs = (inputs, attributes) => {
        const splitSizes = [];
        let numOutputs = attributes.numOutputs;
        if (inputs[1].dims[0] > 0) {
          inputs[1].getBigInt64Array().forEach((v) => splitSizes.push(Number(v)));
          numOutputs = splitSizes.length;
        }
        return createAttributeWithCacheKey({ numOutputs, axis: attributes.axis, splitSizes });
      };
      calculateOutputIndexImpl = (numberOfTensors) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${numberOfTensors}u; i += 1u ) {
    if (index < ${getElementAt("uniforms.size_in_split_axis", "i", numberOfTensors)}) {
        return i;
    }
    }
    return ${numberOfTensors}u;
}`;
      writeBufferDataImpl = (outputs) => {
        const numberOfTensors = outputs.length;
        const codeLines = [];
        for (let i = 0; i < numberOfTensors; ++i) {
          const returnSnippet = outputs[i].setByIndices("indices", "input[global_idx]");
          if (numberOfTensors === 1) {
            codeLines.push(returnSnippet);
          } else if (i === 0) {
            codeLines.push(`if (output_number == ${i}u) { ${returnSnippet} }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`else { ${returnSnippet} }`);
          } else {
            codeLines.push(`else if (output_number == ${i}) { ${returnSnippet} }`);
          }
        }
        return `
      fn writeBufferData(output_number: u32, indices: ${outputs[0].type.indices}, global_idx: u32) {
        ${codeLines.join("\n")}
      }`;
      };
      createSplitProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const dataType = inputs[0].dataType;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        const outputs = new Array(attributes.numOutputs);
        const input = inputVariable("input", dataType, inputShape.length);
        const sizeInSplitAxis = new Array(attributes.numOutputs);
        const outputsTensorInfo = [];
        const outputShapes = [];
        let previousSum = 0;
        const programUniforms = [{ type: 12 /* uint32 */, data: inputSize }];
        for (let i = 0; i < attributes.numOutputs; i++) {
          previousSum += attributes.splitSizes[i];
          sizeInSplitAxis[i] = previousSum;
          const outputShape = inputShape.slice();
          outputShape[axis] = attributes.splitSizes[i];
          outputShapes.push(outputShape);
          outputs[i] = outputVariable(`output${i}`, dataType, outputShape.length);
          outputsTensorInfo.push({ dims: outputShapes[i], dataType: inputs[0].dataType });
        }
        programUniforms.push(
          { type: 12 /* uint32 */, data: sizeInSplitAxis },
          ...createTensorShapeVariables(inputShape, ...outputShapes)
        );
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", sizeInSplitAxis.length).declareVariables(input, ...outputs)}
  ${calculateOutputIndexImpl(sizeInSplitAxis.length)}
  ${writeBufferDataImpl(outputs)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${input.offsetToIndices("global_idx")};
    var index = ${input.indicesGet("indices", axis)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${getElementAt("uniforms.size_in_split_axis", "output_number - 1u", sizeInSplitAxis.length)};
      ${input.indicesSet("indices", axis, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
        return {
          name: "Split",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: outputsTensorInfo,
            dispatchGroup: { x: Math.ceil(
              inputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      split = (context, attributes) => {
        validateInputs18(context.inputs);
        const updatedAttributes = context.inputs.length === 1 ? attributes : createSplitAttributesFromInputs(context.inputs, attributes);
        context.compute(createSplitProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
      parseSplitAttributes = (attributes) => {
        const axis = attributes.axis;
        const splitSizes = attributes.splitSizes;
        const numOutputs = attributes.numOutputs < 0 ? splitSizes.length : attributes.numOutputs;
        if (numOutputs !== splitSizes.length) {
          throw new Error("numOutputs and splitSizes length must be equal");
        }
        return createAttributeWithCacheKey({ axis, numOutputs, splitSizes });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts
  var validateInputs19, createRotaryEmbeddingProgramInfo, rotaryEmbedding;
  var init_rotary_embedding = __esm({
    "web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs19 = (inputs, attributes) => {
        const [input, positionIds, cosCache, sinCache] = inputs;
        const { numHeads, rotaryEmbeddingDim } = attributes;
        if (input.dims.length !== 3 && input.dims.length !== 4) {
          throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${input.dims.length}`);
        }
        if (!ShapeUtil.areEqual(positionIds.dims, []) && !ShapeUtil.areEqual(positionIds.dims, [1]) && positionIds.dims.length !== 2) {
          throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${positionIds.dims.length}`);
        }
        if (cosCache.dims.length !== 2) {
          throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${cosCache.dims.length}`);
        }
        if (sinCache.dims.length !== 2) {
          throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${sinCache.dims.length}`);
        }
        if (!ShapeUtil.areEqual(cosCache.dims, sinCache.dims)) {
          throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
        }
        if (rotaryEmbeddingDim > 0 && numHeads === 0) {
          throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
        }
        const batchSize = input.dims[0];
        const sequenceLength = input.dims[input.dims.length - 2];
        const maxSequenceLength = cosCache.dims[0];
        const hiddenSize = ShapeUtil.sizeFromDimension(input.dims, 1) / sequenceLength;
        const headSize = rotaryEmbeddingDim === 0 ? cosCache.dims[1] * 2 : hiddenSize / numHeads;
        if (rotaryEmbeddingDim > headSize) {
          throw new Error("rotary_embedding_dim must be less than or equal to head_size");
        }
        if (positionIds.dims.length === 2) {
          if (batchSize !== positionIds.dims[0]) {
            throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${positionIds.dims[0]}`);
          }
          if (sequenceLength !== positionIds.dims[1]) {
            throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${positionIds.dims[1]}`);
          }
        }
        if (headSize / 2 !== cosCache.dims[1] && rotaryEmbeddingDim / 2 !== cosCache.dims[1]) {
          throw new Error(
            `Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${cosCache.dims[1]}`
          );
        }
        if (sequenceLength > maxSequenceLength) {
          throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
        }
      };
      createRotaryEmbeddingProgramInfo = (inputs, attributes) => {
        const { interleaved, numHeads, rotaryEmbeddingDim, scale } = attributes;
        const batchSize = inputs[0].dims[0];
        const batchStride = ShapeUtil.sizeFromDimension(inputs[0].dims, 1);
        const sequenceLength = inputs[0].dims[inputs[0].dims.length - 2];
        const hiddenSize = batchStride / sequenceLength;
        const halfRotaryEmbeddingDim = inputs[2].dims[1];
        const headSize = rotaryEmbeddingDim === 0 ? halfRotaryEmbeddingDim * 2 : hiddenSize / numHeads;
        const globalShape = new Array(
          batchSize,
          sequenceLength,
          hiddenSize / headSize,
          headSize - halfRotaryEmbeddingDim
        );
        const globalStrides = ShapeUtil.computeStrides(globalShape);
        const programUniforms = [
          { type: 1 /* float */, data: scale },
          { type: 12 /* uint32 */, data: globalShape },
          { type: 12 /* uint32 */, data: globalStrides },
          // strides for addressing the input/output tensor, in permutated order to align with the unfolded global index,
          // i.e. BSNH
          ...inputs[0].dims.length === 3 ? new Array({ type: 12 /* uint32 */, data: [batchStride, hiddenSize, headSize, 1] }) : [],
          ...inputs[0].dims.length === 4 ? new Array({
            type: 12 /* uint32 */,
            data: [batchStride, headSize, sequenceLength * headSize, 1]
          }) : [],
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, inputs[2].dims, inputs[3].dims, inputs[0].dims)
        ];
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
          const positionIds = inputVariable("position_ids", inputs[1].dataType, inputs[1].dims.length);
          const cosCache = inputVariable("cos_cache", inputs[2].dataType, inputs[2].dims.length);
          const sinCache = inputVariable("sin_cache", inputs[3].dataType, inputs[3].dims.length);
          const output = outputVariable("output", inputs[0].dataType, inputs[0].dims.length);
          shaderHelper.registerUniforms([
            { name: "scale", type: "f32" },
            { name: "global_shape", type: "u32", length: globalShape.length },
            { name: "global_strides", type: "u32", length: globalStrides.length },
            { name: "input_output_strides", type: "u32", length: globalStrides.length }
          ]);
          return `
        ${shaderHelper.declareVariables(input, positionIds, cosCache, sinCache, output)}

        ${shaderHelper.mainStart(WORKGROUP_SIZE)}
          let half_rotary_emb_dim = uniforms.${cosCache.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${positionIds.broadcastedIndicesToOffset("bsnh.xy", outputVariable("", positionIds.type.tensor, 2))};
            let position_id =
                u32(${positionIds.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${interleaved});
            let j = i + select(half_rotary_emb_dim, 1, ${interleaved});
            let re = ${input.getByOffset("i")} * ${cosCache.get("position_id", "bsnh[3]")} -
                ${input.getByOffset("j")} * ${sinCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("i", "re")}
            let im = ${input.getByOffset("i")} * ${sinCache.get("position_id", "bsnh[3]")} +
                ${input.getByOffset("j")} * ${cosCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${output.setByOffset("k", input.getByOffset("k"))}
          }
        }`;
        };
        return {
          name: "RotaryEmbedding",
          shaderCache: {
            hint: createAttributeWithCacheKey({
              interleaved
            }).cacheKey,
            inputDependencies: ["rank", "rank", "rank", "rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(ShapeUtil.size(globalShape) / WORKGROUP_SIZE) },
            programUniforms
          })
        };
      };
      rotaryEmbedding = (context, attributes) => {
        validateInputs19(context.inputs, attributes);
        context.compute(createRotaryEmbeddingProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts
  var validateInputs20, weightTransposeAttribute3, maybeTransposeToBNSH, generatePositionIdsProgramInfo, groupQueryAttention;
  var init_group_query_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts"() {
      "use strict";
      init_attribute_with_cache_key();
      init_wasm_common();
      init_attention();
      init_multihead_attention();
      init_split();
      init_transpose();
      init_rotary_embedding();
      init_common();
      validateInputs20 = (inputs, attributes) => {
        if (attributes.doRotary && inputs.length <= 7) {
          throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");
        }
        const query = inputs[0];
        const key = inputs[1];
        const value = inputs[2];
        const pastKey = inputs[3];
        const pastValue = inputs[4];
        if (attributes.doRotary !== 0 && inputs.length <= 7) {
          throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");
        }
        if (attributes.localWindowSize !== -1) {
          throw new Error("Local attention is not supported");
        }
        if (attributes.softcap !== 0) {
          throw new Error("Softcap is not supported");
        }
        if (attributes.rotaryInterleaved !== 0) {
          throw new Error("Rotary interleaved is not supported");
        }
        if (attributes.smoothSoftmax) {
          throw new Error("Smooth softmax is not supported");
        }
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error("Input query is expected to have 3 or 5 dimensions");
        }
        const dmmhaPacking = false;
        const batchSize = query.dims[0];
        const sequenceLength = query.dims[1];
        let hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
        let kvSequenceLength = sequenceLength;
        let pastSequenceLength = 0;
        const packedQKV = !key || key.dims.length === 0;
        const headSize = !packedQKV ? Math.floor(hiddenSize / attributes.numHeads) : Math.floor(hiddenSize / (attributes.numHeads + 2 * attributes.kvNumHeads));
        if (packedQKV) {
          hiddenSize = headSize * attributes.numHeads;
        }
        const hasPastKey = pastKey && pastKey.dims.length !== 0;
        const hasPastValue = pastValue && pastValue.dims.length !== 0;
        const isPastkvBSNH = hasPastKey && pastKey.dims.length === 4 && pastKey.dims[0] === batchSize && pastKey.dims[1] !== attributes.kvNumHeads && pastKey.dims[2] === attributes.kvNumHeads && pastKey.dims[3] === headSize;
        if (isPastkvBSNH) {
          throw new Error("BSNH pastKey/pastValue is not supported");
        }
        if (hasPastKey && hasPastValue) {
          if (pastKey.dims.length !== 4) {
            throw new Error('Input "past_key" is expected to have 4 dimensions');
          }
          if (pastValue.dims.length !== 4) {
            throw new Error('Input "past_value" is expected to have 4 dimensions');
          }
          pastSequenceLength = pastKey.dims[2];
        } else if (hasPastKey || hasPastValue) {
          throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
        }
        let qkvFormat = 1 /* qkvBNSH */;
        if (key && key.dims.length > 0) {
          if (query.dims.length !== 3) {
            throw new Error('Input "query" is expected to have 3 dimensions when key is given');
          }
          if (key.dims.length < 3 || key.dims.length > 5) {
            throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
          }
          if (query.dims[0] !== key.dims[0]) {
            throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
          }
          if (key.dims.length === 3) {
            if (query.dims[2] % key.dims[2] !== 0) {
              throw new Error('Dimension 2 of "query" should be a multiple of "key"');
            }
            kvSequenceLength = key.dims[1];
          } else if (key.dims.length === 5) {
            if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
            }
            if (value) {
              throw new Error('Expect "value" be none when "key" has packed kv format.');
            }
            kvSequenceLength = key.dims[1];
          } else {
            if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
            }
            kvSequenceLength = key.dims[2];
          }
        } else {
          if (query.dims.length !== 3 && query.dims.length !== 5) {
            throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
          }
          if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
            throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
          }
          qkvFormat = 3 /* qkvBSN3H */;
        }
        const maskType = 0 /* none */;
        let passPastInKv = false;
        let vHiddenSize = attributes.kvNumHeads ? headSize * attributes.kvNumHeads : hiddenSize;
        if (value && value.dims.length > 0) {
          if (value.dims.length !== 3 && value.dims.length !== 4) {
            throw new Error('Input "value" is expected to have 3 or 4 dimensions');
          }
          if (query.dims[0] !== value.dims[0]) {
            throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
          }
          if (value.dims.length === 3) {
            if (kvSequenceLength !== value.dims[1]) {
              throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[2];
          } else {
            if (kvSequenceLength !== value.dims[2]) {
              throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[1] * value.dims[3];
            passPastInKv = true;
          }
        }
        const seqlLens = inputs.length > 4 ? inputs[5] : void 0;
        if (seqlLens && seqlLens.dims.length !== 1 && seqlLens.dims[0] !== batchSize) {
          throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');
        }
        const totalSequenceLength = -1;
        const maxSequenceLength = -1;
        const broadcastResPosBias = false;
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize: 0,
          hiddenSize,
          vHiddenSize,
          headSize,
          vHeadSize: Math.floor(vHiddenSize / attributes.kvNumHeads),
          numHeads: attributes.numHeads,
          kvNumHeads: attributes.kvNumHeads,
          nReps: attributes.numHeads / attributes.kvNumHeads,
          pastPresentShareBuffer: false,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias,
          passPastInKv,
          qkvFormat
        };
      };
      weightTransposeAttribute3 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
      maybeTransposeToBNSH = (context, input, params) => {
        let reshapedInput = input;
        const numHeads = params.kvNumHeads;
        if (input.dims.length === 3 && params.kvSequenceLength !== 0) {
          reshapedInput = input.reshape([params.batchSize, params.kvSequenceLength, numHeads, params.headSize]);
          reshapedInput = context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute3.perm), {
            inputs: [reshapedInput],
            outputs: [-1]
          })[0];
        }
        return reshapedInput;
      };
      generatePositionIdsProgramInfo = (batchSize, sequenceLength, seqLens, totalSeqLen) => {
        const outputDataType = 7 /* int64 */;
        const inputDependencies = ["type", "type"];
        const outputShape = [batchSize * sequenceLength];
        const outputSize = batchSize * sequenceLength;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: sequenceLength },
          { type: 12 /* uint32 */, data: batchSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const seqLensInputHelper = inputVariable("seq_lens", seqLens.dataType, seqLens.dims);
          const totalSeqLenInputHelper = inputVariable("total_seq_lens", totalSeqLen.dataType, totalSeqLen.dims);
          const positionIdsHelper = outputVariable("pos_ids", outputDataType, outputShape);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "sequence_length", type: "u32" },
            { name: "batch_size", type: "u32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(seqLensInputHelper, totalSeqLenInputHelper, positionIdsHelper)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${totalSeqLenInputHelper.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${seqLensInputHelper.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${positionIdsHelper.setByOffset("global_idx", "pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${positionIdsHelper.setByOffset("global_idx", "pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${positionIdsHelper.setByOffset("global_idx", "seqlen")}
    };
  }
  `;
        };
        return {
          name: "GeneratePositionIds",
          shaderCache: { hint: `${batchSize};${sequenceLength}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      groupQueryAttention = (context, attributes) => {
        const params = validateInputs20(context.inputs, attributes);
        if (context.inputs[0].dims.length === 5) {
          throw new Error("Packed QKV is not implemented");
        }
        if (context.inputs[1]?.dims.length === 5) {
          throw new Error("Packed KV is not implemented");
        }
        const q = context.inputs[0];
        const k = context.inputs[1] && context.inputs[1].dims.length > 0 ? context.inputs[1] : void 0;
        const v = context.inputs[2] && context.inputs[2].dims.length > 0 ? context.inputs[2] : void 0;
        const pastKey = context.inputs[3] && context.inputs[3].dims.length !== 0 ? context.inputs[3] : void 0;
        const pastValue = context.inputs[4] && context.inputs[4].dims.length !== 0 ? context.inputs[4] : void 0;
        const seqLens = context.inputs.length > 4 ? context.inputs[5] : void 0;
        const totalSequenceLengthInput = context.inputs.length > 5 ? context.inputs[6] : void 0;
        const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
        const splitAttributes = createAttributeWithCacheKey({
          axis: 2,
          numOutputs: 3,
          splitSizes: [params.numHeads * params.headSize, kvNumHeads * params.headSize, kvNumHeads * params.headSize]
        });
        const [query, key, value] = !k && !v ? context.compute(createSplitProgramInfo([q], splitAttributes), { inputs: [q], outputs: [-1, -1, -1] }) : [q, k, v];
        let qRotary;
        let kRotary;
        if (attributes.doRotary) {
          const posIds = context.compute(
            generatePositionIdsProgramInfo(params.batchSize, params.sequenceLength, seqLens, totalSequenceLengthInput),
            { inputs: [seqLens, totalSequenceLengthInput], outputs: [-1] }
          )[0];
          const cosCache = context.inputs[7];
          const sinCache = context.inputs[8];
          const qRotaryEmbeddingAttributes = createAttributeWithCacheKey({
            interleaved: attributes.rotaryInterleaved !== 0,
            numHeads: params.numHeads,
            rotaryEmbeddingDim: 0,
            scale: attributes.scale
          });
          const inputs = [query, posIds, cosCache, sinCache];
          const outputs = [-1];
          qRotary = context.compute(createRotaryEmbeddingProgramInfo(inputs, qRotaryEmbeddingAttributes), {
            inputs,
            outputs
          })[0];
          inputs.splice(0, 1, key);
          const kRotaryEmbeddingAttributes = createAttributeWithCacheKey({
            interleaved: attributes.rotaryInterleaved !== 0,
            numHeads: params.kvNumHeads,
            rotaryEmbeddingDim: 0,
            scale: attributes.scale
          });
          kRotary = context.compute(createRotaryEmbeddingProgramInfo(inputs, kRotaryEmbeddingAttributes), {
            inputs,
            outputs
          })[0];
        }
        const Q = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.sequenceLength,
          params.headSize,
          attributes.doRotary ? qRotary : query,
          void 0,
          0
        );
        const K = maybeTransposeToBNSH(context, attributes.doRotary ? kRotary : key, params);
        const V = maybeTransposeToBNSH(context, value, params);
        applyAttention(
          context,
          Q,
          K,
          V,
          void 0,
          void 0,
          pastKey,
          pastValue,
          void 0,
          params,
          seqLens,
          totalSequenceLengthInput
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/instance-norm.ts
  var computeChannelScaleShift, createInstanceNormProgramInfo, createInstanceNormNHWCProgramInfo, instanceNorm;
  var init_instance_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_transpose();
      init_common();
      computeChannelScaleShift = (context, input, scale, bias, n, h, c, epsilon) => {
        const components = getMaxComponents(h);
        const f32Type = components === 1 ? "f32" : `vec${components}f`;
        const wgType = components === 1 ? "vec2f" : `mat2x${components}f`;
        const unitsOfWork = n * c;
        let workgroupSize = 64;
        if (unitsOfWork === 1) {
          workgroupSize = 256;
        }
        const inputShape = [n, c, h / components];
        const outputShape = [n, c, 2];
        const inputDependencies = ["rank", "type", "type"];
        const programUniforms = [];
        programUniforms.push(...createTensorShapeVariables(inputShape, outputShape));
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", input.dataType, 3, components);
          const s = inputVariable("scale", scale.dataType, scale.dims);
          const b = inputVariable("bias", bias.dataType, bias.dims);
          const output = outputVariable("output", 1 /* float */, 3, 2);
          const variables = [x, s, b, output];
          return `
  var<workgroup> workgroup_shared : array<${wgType}, ${workgroupSize}>;
  const workgroup_size = ${workgroupSize}u;
  ${shaderHelper.declareVariables(...variables)}
  ${shaderHelper.mainStart(workgroupSize)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${f32Type}(0);
    var squared_sum = ${f32Type}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${f32Type}(${x.get("batch", "channel", "h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${wgType}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${sumVector("workgroup_shared[0][0]", components)} / f32(hight * ${components});
      let squared_sum_final = ${sumVector("workgroup_shared[0][1]", components)} / f32(hight * ${components});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${epsilon}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`;
        };
        return context.compute(
          {
            name: "InstanceNormComputeChannelScaleShift",
            // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
            shaderCache: { hint: `${components};${epsilon};${workgroupSize}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: 1 /* float */ }],
              dispatchGroup: { x: unitsOfWork },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [input, scale, bias], outputs: [-1] }
        )[0];
      };
      createInstanceNormProgramInfo = (context, inputs, attributes) => {
        const xShape = inputs[0].dims;
        const outputShape = xShape;
        const axis = 2;
        const N = xShape[0];
        const C = xShape[1];
        const H = ShapeUtil.sizeFromDimension(xShape, axis);
        const components = getMaxComponents(H);
        const outputSize = ShapeUtil.size(outputShape) / components;
        const channelScaleShift = computeChannelScaleShift(
          context,
          inputs[0],
          inputs[1],
          inputs[2],
          N,
          H,
          C,
          attributes.epsilon
        );
        const inputShape = [N, C, H / components];
        const scaleShape = [N, C];
        const inputDependencies = ["type", "none"];
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", inputs[0].dataType, inputShape.length, components);
          const scale = inputVariable("scale_shift", 1 /* float */, scaleShape.length, 2);
          const output = outputVariable("output", inputs[0].dataType, inputShape.length, components);
          const variables = [x, scale, output];
          return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(...variables)}
  ${shaderHelper.mainStart()}
  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${output.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${scale.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${x.getByOffset("global_idx")} * ${output.type.value}(scale_shift.x) + ${output.type.value}(scale_shift.y);
      ${output.setByOffset("global_idx", "value")};
  }`;
        };
        context.compute(
          {
            name: "InstanceNormalization",
            shaderCache: { hint: `${components}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(inputShape, scaleShape, inputShape)
              ]
            }),
            getShaderSource
          },
          { inputs: [inputs[0], channelScaleShift] }
        );
      };
      createInstanceNormNHWCProgramInfo = (context, inputs, attributes) => {
        const xShape = inputs[0].dims;
        const outputShape = xShape;
        const N = xShape[0];
        const C = xShape[xShape.length - 1];
        const H = ShapeUtil.sizeFromDimension(xShape, 1) / C;
        const components = getMaxComponents(C);
        const outputSize = ShapeUtil.size(outputShape) / components;
        const programUniforms = [
          { type: 12 /* uint32 */, data: H },
          { type: 12 /* uint32 */, data: Math.floor(C / components) }
        ];
        const inputDependencies = ["type", "type"];
        let needTranspose = false;
        const transposedXPerm = [0, xShape.length - 1];
        for (let i = 0; i < xShape.length - 2; i++) {
          needTranspose = needTranspose || xShape[i + 1] !== 1;
          transposedXPerm.push(i + 1);
        }
        needTranspose = needTranspose && xShape[xShape.length - 1] !== 1;
        const transposedX = needTranspose ? context.compute(createTransposeProgramInfo(context.inputs[0], transposedXPerm), {
          inputs: [context.inputs[0]],
          outputs: [-1]
        })[0] : context.inputs[0].reshape(Array.from({ length: xShape.length }, (_, i) => xShape[transposedXPerm[i]]));
        const channelScaleShift = computeChannelScaleShift(
          context,
          transposedX,
          inputs[1],
          inputs[2],
          N,
          H,
          C,
          attributes.epsilon
        );
        const getShaderSource = (shaderHelper) => {
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const scaleType = components === 1 ? "vec2f" : `mat${components}x2f`;
          const scaleData = (num) => {
            const index = num === 0 ? "x" : "y";
            const f32Type = components === 1 ? "f32" : `vec${components}f`;
            switch (components) {
              case 1:
                return `${dataType}(${f32Type}(scale.${index}))`;
              case 2:
                return `vec2<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}))`;
              case 4:
                return `vec4<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}, scale[2].${index}, scale[3].${index}))`;
              default:
                throw new Error(`Not supported compoents ${components}`);
            }
          };
          const inputHelper = inputVariable("input", inputs[0].dataType, inputs[0].dims, components);
          const outputHelper = outputVariable("output", inputs[0].dataType, outputShape, components);
          return `
  @group(0) @binding(0) var<storage, read> input : array<${inputHelper.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${scaleType}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${outputHelper.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${scaleData(0)}, ${scaleData(1)});
  }`;
        };
        context.compute(
          {
            name: "InstanceNormalizationNHWC",
            shaderCache: { hint: `${components}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [inputs[0], channelScaleShift] }
        );
      };
      instanceNorm = (context, attributes) => {
        if (attributes.format === "NHWC") {
          createInstanceNormNHWCProgramInfo(context, context.inputs, attributes);
        } else {
          createInstanceNormProgramInfo(context, context.inputs, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/layer-norm.ts
  var validateInputs21, createLayerNormProgramInfo, layerNorm;
  var init_layer_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs21 = (inputs) => {
        if (!inputs || inputs.length < 2) {
          throw new Error("layerNorm requires at least 2 inputs.");
        }
      };
      createLayerNormProgramInfo = (inputs, attributes, outputCount) => {
        const simplified = attributes.simplified;
        const xShape = inputs[0].dims;
        const scale = inputs[1];
        const bias = !simplified && inputs[2];
        const outputShape = xShape;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, xShape.length);
        const normCount = ShapeUtil.sizeToDimension(xShape, axis);
        const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
        const scaleSize = ShapeUtil.size(scale.dims);
        const biasSize = bias ? ShapeUtil.size(bias.dims) : 0;
        if (scaleSize !== normSize || bias && biasSize !== normSize) {
          throw new Error(`Size of X.shape()[axis:] == ${normSize}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${scaleSize} and bias size of ${biasSize}`);
        }
        const meanInvStdDevDim = [];
        for (let i = 0; i < xShape.length; ++i) {
          if (i < axis) {
            meanInvStdDevDim.push(xShape[i]);
          } else {
            meanInvStdDevDim.push(1);
          }
        }
        const components = getMaxComponents(normSize);
        const inputDependencies = ["type", "type"];
        const programUniforms = [
          { type: 12 /* uint32 */, data: normCount },
          { type: 1 /* float */, data: normSize },
          { type: 12 /* uint32 */, data: Math.floor(normSize / components) },
          { type: 1 /* float */, data: attributes.epsilon }
        ];
        if (bias) {
          inputDependencies.push("type");
        }
        const hasMeanDataOutput = outputCount > 1;
        const hasInvStdOutput = outputCount > 2;
        const getShaderSource = (shaderHelper) => {
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const variables = [
            inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
            inputVariable("scale", scale.dataType, scale.dims, components)
          ];
          if (bias) {
            variables.push(inputVariable("bias", bias.dataType, bias.dims, components));
          }
          variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
          if (hasMeanDataOutput) {
            variables.push(outputVariable("mean_data_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInvStdOutput) {
            variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
          }
          const uniforms = [
            { name: "norm_count", type: "u32" },
            { name: "norm_size", type: "f32" },
            { name: "norm_size_vectorized", type: "u32" },
            { name: "epsilon", type: "f32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${fillVector("f32", components)};
    var mean_square_vector = ${fillVector("f32", components)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${castToF32(dataType, components, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${sumVector("mean_vector", components)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${sumVector("mean_square_vector", components)} / uniforms.norm_size ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${castToF32(dataType, components, "x[j + offset]")};
      let f32scale = ${castToF32(dataType, components, "scale[j]")};
      output[j + offset] = ${variables[0].type.value}((f32input ${simplified ? "" : "- mean"}) * inv_std_dev * f32scale
        ${bias ? `+ ${castToF32(dataType, components, "bias[j]")}` : ""}
      );
    }

    ${hasMeanDataOutput ? "mean_data_output[global_idx] = mean" : ""};
    ${hasInvStdOutput ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
        };
        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
        if (hasMeanDataOutput) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (hasInvStdOutput) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        return {
          name: "LayerNormalization",
          shaderCache: { hint: `${components};${outputCount};${simplified}`, inputDependencies },
          getRunData: () => ({
            outputs,
            dispatchGroup: { x: Math.ceil(
              normCount / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      layerNorm = (context, attributes) => {
        validateInputs21(context.inputs);
        context.compute(createLayerNormProgramInfo(context.inputs, attributes, context.outputCount));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmul.ts
  var validateInputs22, matMul;
  var init_matmul = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmul.ts"() {
      "use strict";
      init_util();
      init_matmul_shaders();
      init_matmul_packed_webgpu();
      validateInputs22 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("MatMul requires 2 inputs.");
        }
        if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
          throw new Error("shared dimension does not match.");
        }
      };
      matMul = (context) => {
        validateInputs22(context.inputs);
        const outputShape = BroadcastUtil.calcShape(context.inputs[0].dims, context.inputs[1].dims, true);
        if (!outputShape) {
          throw new Error("Can't use matmul on the given tensors");
        }
        const N = outputShape[outputShape.length - 1];
        const K = context.inputs[0].dims[context.inputs[0].dims.length - 1];
        if (N < 8 && K < 8) {
          context.compute(createNaiveMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
        } else {
          const M = outputShape[outputShape.length - 2];
          const batchA = ShapeUtil.size(context.inputs[0].dims.slice(0, -2));
          const batchB = ShapeUtil.size(context.inputs[1].dims.slice(0, -2));
          if (batchA !== 1 && M === 1 && batchB === 1) {
            const reshapedA = context.inputs[0].reshape([1, batchA, K]);
            const reshapedB = context.inputs[1].reshape([1, K, N]);
            const matmulOutputShape = [1, batchA, N];
            const matmulInputs = [reshapedA, reshapedB];
            context.compute(createMatmulProgramInfo(matmulInputs, { activation: "" }, outputShape, matmulOutputShape), {
              inputs: matmulInputs
            });
          } else {
            context.compute(createMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
          }
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts
  var validateInputs23, createMatMulNBitsProgramInfo, createMatMulNBitsBlockSize32ProgramInfo, matMulNBits, parseMatMulNBitsAttributes;
  var init_matmulnbits = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs23 = (inputs, attributes) => {
        if (inputs.length < 3 || inputs.length > 4) {
          throw new Error("MatMulNBits requires 3 or 4 inputs");
        }
        const a = inputs[0];
        const aRank = a.dims.length;
        if (a.dims[aRank - 1] !== attributes.k) {
          throw new Error("The last dim of input shape does not match the k value");
        }
        const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
        const blobSize = attributes.blockSize / 8 * attributes.bits;
        const b = inputs[1];
        if (!ShapeUtil.areEqual(b.dims, [attributes.n, nBlocksPerCol, blobSize])) {
          throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
        }
        const scales = inputs[2];
        const scalesShape = scales.dims;
        if (ShapeUtil.size(scalesShape) !== attributes.n * nBlocksPerCol) {
          throw new Error("scales input size error.");
        }
        if (inputs.length === 4) {
          const zeroPoints = inputs[3];
          const zeroPointsShape = zeroPoints.dims;
          const expectedZeroPointsSize = attributes.n * (attributes.bits === 8 ? nBlocksPerCol : Math.floor((nBlocksPerCol * attributes.bits + 7) / 8));
          if (ShapeUtil.size(zeroPointsShape) !== expectedZeroPointsSize) {
            throw new Error("zeroPoints input size error.");
          }
        }
      };
      createMatMulNBitsProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const aRank = inputShape.length;
        const dimAOuter = inputShape[aRank - 2];
        const dimInner = attributes.k;
        const dimBOuter = attributes.n;
        const batchDims = inputShape.slice(0, aRank - 2);
        const batchSize = ShapeUtil.size(batchDims);
        const blobSize = inputs[1].dims[2];
        const blobSizeInWords = blobSize / 4;
        const dataType = inputs[0].dataType;
        const aComponents = getMaxComponents(attributes.k);
        const bComponents = getMaxComponents(blobSizeInWords);
        const components = getMaxComponents(dimBOuter);
        const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
        const outputNumber = dimAOuter > 1 && dimBOuter / components % 2 === 0 ? 2 : 1;
        const dispatchSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const workgroupSize = 64;
        const programUniforms = [];
        const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
        const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
        bShape.splice(-1, 1, blobSizeInWords / bComponents);
        programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
        programUniforms.push(...createTensorShapeVariables(bShape));
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        if (inputs.length === 4) {
          programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
        }
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const inputRank = inputShapeTemp.length;
          const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
          const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
          const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
          const inputVariables = [a, b, scales];
          const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
          if (zeroPoints) {
            inputVariables.push(zeroPoints);
          }
          const outputRank = outputShapeTemp.length;
          const output = outputVariable("output", inputs[0].dataType, outputRank, components);
          const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
          const qDqDataType = (() => {
            switch (aComponents) {
              case 1:
                return `array<${dataType2}, 8>`;
              case 2:
                return `mat4x2<${dataType2}>`;
              case 4:
                return `mat2x4<${dataType2}>`;
              default:
                throw new Error(`${aComponents}-component is not supported.`);
            }
          })();
          const processOneWord = () => {
            let calcStr = `
          // reuse a data
            var input_offset = ${a.indicesToOffset(`${a.type.indices}(batch, row, word_offset)`)};
            var a_data: ${qDqDataType};
            for (var j: u32 = 0; j < ${8 / aComponents}; j++) {
              a_data[j] = ${a.getByOffset("input_offset")};
              input_offset++;
            }
          `;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            b_value = ${bComponents === 1 ? `b${c}_data` : `b${c}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${qDqDataType}(${Array.from(
                { length: 4 },
                (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
              ).join(", ")});
            b_dequantized_values = ${(() => {
                if (aComponents === 1) {
                  return `${qDqDataType}(${Array.from(
                    { length: 8 },
                    (_, i) => `(b_quantized_values[${i}] - ${zeroPoints ? `zero_point${c}` : "zero_point"}) * scale${c}`
                  ).join(", ")});`;
                } else {
                  return `(b_quantized_values - ${qDqDataType}(${Array(8).fill(`${zeroPoints ? `zero_point${c}` : "zero_point"}`).join(",")})) * scale${c};`;
                }
              })()};
            workgroup_shared[local_id.x * ${outputNumber} + ${Math.floor(c / components)}]${components > 1 ? `[${c % components}]` : ""} += ${Array.from(
                { length: 8 / aComponents },
                (_, i) => `${aComponents === 1 ? `a_data[${i}] * b_dequantized_values[${i}]` : `dot(a_data[${i}], b_dequantized_values[${i}])`}`
              ).join(" + ")};
          `;
            }
            return calcStr;
          };
          const prepareScaleAndZeroPoint = () => {
            let calcStr = `
            var col_index = col * ${components};
            ${zeroPoints ? `
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${8});`}
            `;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            let scale${c} = ${scales.getByOffset(`col_index * nBlocksPerCol + block`)};
            ${zeroPoints ? `
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${c} = ${dataType2}((zero_point_word) & 0xFu);` : ""}
            col_index += 1;`;
            }
            return calcStr;
          };
          const prepareBData = () => {
            let calcStr = `col_index = col * ${components};`;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            let b${c}_data = ${b.getByIndices(`${b.type.indices}(col_index, block, word)`)};
            col_index += 1;`;
            }
            calcStr += `
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${qDqDataType};
            var b_dequantized_values: ${qDqDataType};`;
            return calcStr;
          };
          return `
        var<workgroup> workgroup_shared: array<${output.type.value}, ${outputNumber * workgroupSize}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupSize, 1, 1])}
          let output_indices = ${output.offsetToIndices(`(global_idx / ${workgroupSize}) * ${outputNumber}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${workgroupSize}) {
            //process one block
            var word_offset: u32 = block * ${attributes.blockSize / aComponents};
            ${prepareScaleAndZeroPoint()}
            for (var word: u32 = 0; word < ${blobSizeInWords}; word += ${bComponents}) {
              ${prepareBData()}
              for (var i: u32 = 0; i < ${bComponents}; i++) {
                ${processOneWord()}
                word_offset += ${8 / aComponents};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${outputNumber}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${workgroupSize}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${outputNumber};
            }
            ${output.setByIndices(`${output.type.indices}(batch, row, col + local_id.x)`, "output_value")};
          }
        }`;
        };
        return {
          name: "MatMulNBits",
          shaderCache: {
            hint: `${attributes.blockSize};${attributes.bits};${aComponents};${bComponents};${components};${outputNumber};${workgroupSize}`,
            inputDependencies: Array(inputs.length).fill("rank")
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: dispatchSize },
            programUniforms
          }),
          getShaderSource
        };
      };
      createMatMulNBitsBlockSize32ProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const aRank = inputShape.length;
        const dimAOuter = inputShape[aRank - 2];
        const dimInner = attributes.k;
        const dimBOuter = attributes.n;
        const batchDims = inputShape.slice(0, aRank - 2);
        const batchSize = ShapeUtil.size(batchDims);
        const blobSize = inputs[1].dims[2];
        const blobSizeInWords = blobSize / 4;
        const dataType = inputs[0].dataType;
        const aComponents = getMaxComponents(attributes.k);
        const bComponents = getMaxComponents(blobSizeInWords);
        const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
        const workgroupSize = 128;
        const workgroupY = dimBOuter % 8 === 0 ? 8 : dimBOuter % 4 === 0 ? 4 : 1;
        const workgroupX = workgroupSize / workgroupY;
        const tileSize = workgroupX * bComponents * 8;
        const aLengthPerTile = tileSize / aComponents;
        const blocksPerTile = tileSize / attributes.blockSize;
        const dispatchSize = ShapeUtil.size(outputShape) / workgroupY;
        const programUniforms = [];
        const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
        const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
        bShape.splice(-1, 1, blobSizeInWords / bComponents);
        programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
        programUniforms.push(...createTensorShapeVariables(bShape));
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        if (inputs.length === 4) {
          programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
        }
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter];
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const inputRank = inputShapeTemp.length;
          const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
          const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
          const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
          const inputVariables = [a, b, scales];
          const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
          if (zeroPoints) {
            inputVariables.push(zeroPoints);
          }
          const outputRank = outputShapeTemp.length;
          const output = outputVariable("output", inputs[0].dataType, outputRank);
          const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
          const readA = () => {
            switch (aComponents) {
              case 1:
                return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;
              case 2:
                return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;
              case 4:
                return `
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;
              default:
                throw new Error(`${aComponents}-component is not supported.`);
            }
          };
          return `
        var<workgroup> sub_a: array<${a.type.value}, ${aLengthPerTile}>;
        var<workgroup> inter_results: array<array<${output.type.value}, ${workgroupX}>, ${workgroupY}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupX, workgroupY, 1])}
          let output_indices = ${output.offsetToIndices(`workgroup_index * ${workgroupY}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${blocksPerTile} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${aLengthPerTile};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${aLengthPerTile}; a_offset += ${workgroupSize})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${a.getByIndices(`${a.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${a.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${blocksPerTile} + local_id.x;
            ${zeroPoints ? `
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${dataType2}((zero_point_word) & 0xFu);` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${8});`}
            let scale = ${scales.getByOffset(`b_row * n_blocks_per_col + block`)};
            let b_data = ${b.getByIndices(`${b.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${attributes.blockSize / aComponents};
            for (var i: u32 = 0; i < ${bComponents}; i++) {
              ${readA()}
              let b_value = ${bComponents === 1 ? `b_data` : `b_data[i]`};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${dataType2}>(${Array.from(
            { length: 4 },
            (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
          ).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${dataType2}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from(
            { length: 2 },
            (_, i) => `${`dot(a_data${i}, b_dequantized_values[${i}])`}`
          ).join(" + ")};
              word_offset += ${8 / aComponents};
            }
            workgroupBarrier();
          }

          if (local_idx < ${workgroupY}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            for (var b = 0u; b < ${workgroupX}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${output.setByIndices(`${output.type.indices}(batch, row, col + local_idx)`, "output_value")}
            }
          }
        }`;
        };
        return {
          name: "BlockwiseMatMulNBits32",
          shaderCache: {
            hint: `${attributes.blockSize};${aComponents};${bComponents};${workgroupX};${workgroupY}`,
            inputDependencies: Array(inputs.length).fill("rank")
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: dispatchSize },
            programUniforms
          }),
          getShaderSource
        };
      };
      matMulNBits = (context, attributes) => {
        validateInputs23(context.inputs, attributes);
        if (attributes.blockSize === 32 && context.adapterInfo.isVendor("intel") && context.adapterInfo.isArchitecture("gen-12lp")) {
          context.compute(createMatMulNBitsBlockSize32ProgramInfo(context.inputs, attributes));
        } else {
          context.compute(createMatMulNBitsProgramInfo(context.inputs, attributes));
        }
      };
      parseMatMulNBitsAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/pad.ts
  var validateInputs24, getPadConstant, getPadReflect, getPadEdge, getPadWrap, getPadSnippet, createPadProgramInfo, createPadAttributesFromInputs, pad;
  var init_pad = __esm({
    "web/lib/wasm/jsep/webgpu/ops/pad.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs24 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("Too few inputs");
        }
        if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */) {
          throw new Error("Input type must be float or float16.");
        }
        if (inputs.length >= 2) {
          let validPads = inputs[0].dims.length * 2 === inputs[1].dims[0];
          if (inputs.length === 4) {
            validPads = inputs[3].dims[0] * 2 === inputs[1].dims[0];
          }
          if (!validPads) {
            throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
          }
        }
      };
      getPadConstant = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
            k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
              break;
            }
            offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
        `;
        }
        return `
          value = ${output.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${block}
            value = x[offset];
          }
      `;
      };
      getPadReflect = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadEdge = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k = i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1;
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadWrap = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0)  {
                  k += i32(${getElementAt("uniforms.x_shape", i, inputRank)}]);
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k -= i32(${getElementAt("uniforms.x_shape", i, inputRank)});
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadSnippet = (output, inputRank, attributes) => {
        switch (attributes.mode) {
          case 0:
            return getPadConstant(output, inputRank, attributes.pads.length);
          case 1:
            return getPadReflect(output, inputRank, attributes.pads.length);
          case 2:
            return getPadEdge(output, inputRank, attributes.pads.length);
          case 3:
            return getPadWrap(output, inputRank, attributes.pads.length);
          default:
            throw new Error("Invalid mode");
        }
      };
      createPadProgramInfo = (inputs, attributes) => {
        const outputShape = ShapeUtil.padShape(inputs[0].dims.slice(), attributes.pads);
        const inputDims = inputs[0].dims;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: attributes.pads }
        ];
        const isValueFromInput = inputs.length >= 3 && inputs[2].data;
        if (attributes.mode === 0) {
          programUniforms.push({ type: isValueFromInput ? inputs[2].dataType : 1 /* float */, data: attributes.value });
        }
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, outputShape));
        const inputDependencies = ["rank"];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          const input = inputVariable("x", inputs[0].dataType, inputDims.length);
          const dataType = input.type.value;
          const padSnippet = getPadSnippet(output, inputDims.length, attributes);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "pads", type: "i32", length: attributes.pads.length }
          ];
          if (attributes.mode === 0) {
            uniforms.push({ name: "constant_value", type: isValueFromInput ? dataType : "f32" });
          }
          return `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${output.offsetToIndices("global_idx")};

            var value = ${dataType}(0);
            ${padSnippet}
            output[global_idx] = value;
        }`;
        };
        return {
          name: "Pad",
          shaderCache: { hint: `${attributes.mode}${isValueFromInput}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      createPadAttributesFromInputs = (inputs, attributes) => {
        if (inputs.length > 1) {
          const bigInt64Pads = inputs[1].getBigInt64Array();
          const value = inputs.length >= 3 && inputs[2].data ? inputs[2].dataType === 10 /* float16 */ ? inputs[2].getUint16Array()[0] : inputs[2].getFloat32Array()[0] : 0;
          const inputRank = inputs[0].dims.length;
          const updatePads = new Int32Array(2 * inputRank).fill(0);
          if (inputs.length >= 4) {
            const axes = inputs[3].getBigInt64Array();
            for (let i = 0; i < axes.length; i++) {
              updatePads[Number(axes[i])] = Number(bigInt64Pads[i]);
              updatePads[Number(axes[i]) + inputRank] = Number(bigInt64Pads[i + axes.length]);
            }
          } else {
            bigInt64Pads.forEach((v, i) => updatePads[Number(i)] = Number(v));
          }
          const pads = [];
          updatePads.forEach((v) => pads.push(v));
          return { mode: attributes.mode, value, pads };
        } else {
          return attributes;
        }
      };
      pad = (context, attributes) => {
        validateInputs24(context.inputs);
        const updatedAttributes = createPadAttributesFromInputs(context.inputs, attributes);
        context.compute(createPadProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/pool.ts
  var validateInputs25, getAdjustedPoolAttributesAndOutputShape, getUniformAndPadInfo, generatePoolingCode, createShaderKeyFromAttributes, createAveragePoolShaderKeyFromAttributes, createMaxPoolShaderKeyFromAttributes, parsePoolCommonAttributes, createAveragePoolProgramInfo, parseAveragePoolAttributes, averagePool, globalPoolAttributes, parseGlobalAveragePoolAttributes, globalAveragePool, createMaxPoolProgramInfo, maxPool, parseMaxPoolAttributes, parseGlobalMaxPoolAttributes, globalMaxPool;
  var init_pool = __esm({
    "web/lib/wasm/jsep/webgpu/ops/pool.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_util();
      init_common();
      validateInputs25 = (inputs) => {
        if (env2.webgpu.validateInputContent && (!inputs || inputs.length !== 1)) {
          throw new Error("Pool ops requires 1 input.");
        }
      };
      getAdjustedPoolAttributesAndOutputShape = (input, attributes, isGlobalOperator) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inputShapeAsChannelFirst = input.dims.slice();
        if (isChannelsLast) {
          inputShapeAsChannelFirst.splice(1, 0, inputShapeAsChannelFirst.pop());
        }
        const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
        const kernelShape = attributes.kernelShape.slice();
        const strides = attributes.strides.slice();
        const dilations = hasDilations ? attributes.dilations.slice() : [];
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShapeAsChannelFirst, kernelShape, strides, dilations, pads);
        const outputShapeAsChannelFirst = PoolConvUtil.computePoolOutputShape(
          isGlobalOperator,
          inputShapeAsChannelFirst,
          strides,
          dilations,
          kernelShape,
          pads,
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        if (hasDilations) {
          Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
        } else {
          Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
        }
        const outputShapeAsChannelLast = outputShapeAsChannelFirst.slice();
        outputShapeAsChannelLast.push(outputShapeAsChannelLast.splice(1, 1)[0]);
        return [newAttributes, isChannelsLast ? outputShapeAsChannelLast : outputShapeAsChannelFirst];
      };
      getUniformAndPadInfo = (outputShape, attributes) => {
        const isChannelsLast = attributes.format === "NHWC";
        const outputSize = ShapeUtil.size(outputShape);
        const kernelSize = ShapeUtil.size(attributes.kernelShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: kernelSize }
        ];
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "kernelSize", type: "u32" }
        ];
        if (attributes.kernelShape.length <= 2) {
          const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
          const sw = attributes.strides[attributes.strides.length - 1];
          const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
          const pwEnd = attributes.pads[attributes.pads.length - 1];
          const pwStartEndNotZero = !!(pwStart + pwEnd);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kw },
            { type: 12 /* uint32 */, data: sw },
            { type: 12 /* uint32 */, data: pwStart },
            { type: 12 /* uint32 */, data: pwEnd }
          );
          uniforms.push(
            { name: "kw", type: "u32" },
            { name: "sw", type: "u32" },
            { name: "pwStart", type: "u32" },
            { name: "pwEnd", type: "u32" }
          );
          let phStartEndNotZero = false;
          if (attributes.kernelShape.length === 2) {
            const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
            const sh = attributes.strides[attributes.strides.length - 2];
            const phStart = attributes.pads[attributes.pads.length / 2 - 2];
            const phEnd = attributes.pads[attributes.pads.length - 2];
            phStartEndNotZero = !!(phStart + phEnd);
            programUniforms.push(
              { type: 12 /* uint32 */, data: kh },
              { type: 12 /* uint32 */, data: sh },
              { type: 12 /* uint32 */, data: phStart },
              { type: 12 /* uint32 */, data: phEnd }
            );
            uniforms.push(
              { name: "kh", type: "u32" },
              { name: "sh", type: "u32" },
              { name: "phStart", type: "u32" },
              { name: "phEnd", type: "u32" }
            );
          }
          return [programUniforms, uniforms, true, pwStartEndNotZero, phStartEndNotZero];
        } else {
          if (isChannelsLast) {
            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
          }
          const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kernelStrides },
            { type: 12 /* uint32 */, data: attributes.pads },
            { type: 12 /* uint32 */, data: attributes.strides }
          );
          uniforms.push(
            { name: "kernelStrides", type: "u32", length: kernelStrides.length },
            { name: "pads", type: "u32", length: attributes.pads.length },
            { name: "strides", type: "u32", length: attributes.strides.length }
          );
          const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);
          return [programUniforms, uniforms, !!hasPads, false, false];
        }
      };
      generatePoolingCode = (shaderHelper, x, rank, outputShapeRank, attributes, op1, op2, start, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero) => {
        const isChannelsLast = attributes.format === "NHWC";
        const dataType = x.type.value;
        const output = outputVariable("output", x.type.tensor, outputShapeRank);
        if (attributes.kernelShape.length <= 2) {
          let codeW = "";
          let codeH = "";
          let codeHEnd = "";
          const dimIdxW = rank - (isChannelsLast ? 2 : 1);
          if (pwStartEndNotZero) {
            codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${dimIdxW}] < 0 || xIndices[${dimIdxW}]
                      >= uniforms.x_shape[${dimIdxW}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
          } else {
            codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
          }
          if (attributes.kernelShape.length === 2) {
            const dimIdxH = rank - (isChannelsLast ? 3 : 2);
            if (phStartEndNotZero) {
              codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${dimIdxH}] < 0 || xIndices[${dimIdxH}] >= uniforms.x_shape[${dimIdxH}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `;
            } else {
              codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                `;
            }
            codeHEnd = `
              }
            `;
          }
          const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var value = ${dataType}(${start});
              var pad = 0;
              ${codeH}
              ${codeW}
              ${codeHEnd}
              ${op2}

              output[global_idx] = value;
            }`;
          return poolingCode;
        } else {
          if (isChannelsLast) {
            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
          }
          const stridesRank = attributes.kernelShape.length;
          const padsRank = attributes.pads.length;
          let padCode = "";
          if (hasPads) {
            padCode = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${x.indicesToOffset("xIndices")}];
                ${op1}
              }`;
          } else {
            padCode = `
              }
              let x_val = x[${x.indicesToOffset("xIndices")}];
              ${op1}
            `;
          }
          const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var offsets: array<u32, ${stridesRank}>;

              var value = ${dataType}(${start});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${stridesRank - 1}u; j++) {
                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                }
                offsets[${stridesRank - 1}] = offset;

                isPad = false;
                for (var j = ${rank - stridesRank}u; j < ${rank}u; j++) {
                  xIndices[j] = indices[j] * ${getElementAt(
            "uniforms.strides",
            `j - ${rank - stridesRank}u`,
            stridesRank
          )}
                    + offsets[j - ${rank - stridesRank}u] - ${getElementAt("uniforms.pads", "j - 2u", padsRank)};
                  ${padCode}
              }
              ${op2}

              output[global_idx] = value;
            }`;
          return poolingCode;
        }
      };
      createShaderKeyFromAttributes = (attributes) => `${attributes.format};${attributes.ceilMode};${attributes.autoPad};${attributes.kernelShape.length}`;
      createAveragePoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.countIncludePad}`;
      createMaxPoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.storageOrder};${attributes.dilations}`;
      parsePoolCommonAttributes = (attributes) => ({
        format: attributes.format,
        autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad],
        ceilMode: attributes.ceil_mode,
        kernelShape: attributes.kernel_shape,
        strides: attributes.strides,
        pads: attributes.pads
      });
      createAveragePoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          input,
          attributes,
          isGlobalOperator
        );
        const x = inputVariable("x", input.dataType, input.dims.length);
        const dataType = x.type.value;
        const op1 = "value += x_val;";
        let op2 = "";
        if (adjustedAttributes.countIncludePad) {
          op2 += `value /= ${dataType}(uniforms.kernelSize);`;
        } else {
          op2 += `value /= ${dataType}(i32(uniforms.kernelSize) - pad);`;
        }
        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
          outputShape,
          adjustedAttributes
        );
        programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
        const inputDependencies = ["rank"];
        return {
          name,
          shaderCache: {
            hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: input.dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource: (shaderHelper) => generatePoolingCode(
            shaderHelper,
            x,
            input.dims.length,
            outputShape.length,
            adjustedAttributes,
            op1,
            op2,
            0,
            uniforms,
            hasPads,
            pwStartEndNotZero,
            phStartEndNotZero
          )
        };
      };
      parseAveragePoolAttributes = (attributes) => {
        const countIncludePad = attributes.count_include_pad === 0 ? false : true;
        const attr = parsePoolCommonAttributes(attributes);
        if (attr.ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
        }
        const averagePoolAttributes = { countIncludePad, ...attr, cacheKey: "" };
        return { ...averagePoolAttributes, cacheKey: createAveragePoolShaderKeyFromAttributes(averagePoolAttributes) };
      };
      averagePool = (context, attributes) => {
        validateInputs25(context.inputs);
        context.compute(createAveragePoolProgramInfo("AveragePool", context.inputs[0], false, attributes));
      };
      globalPoolAttributes = {
        autoPad: "",
        ceilMode: 0,
        countIncludePad: false,
        kernelShape: [],
        strides: [],
        pads: [],
        storageOrder: 0,
        dilations: []
      };
      parseGlobalAveragePoolAttributes = (attributes) => {
        const format = attributes.format;
        return { format, ...globalPoolAttributes, cacheKey: format };
      };
      globalAveragePool = (context, attributes) => {
        validateInputs25(context.inputs);
        context.compute(createAveragePoolProgramInfo("GlobalAveragePool", context.inputs[0], true, attributes));
      };
      createMaxPoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          input,
          attributes,
          isGlobalOperator
        );
        const op1 = `
      value = max(x_val, value);
    `;
        const op2 = "";
        const x = inputVariable("x", input.dataType, input.dims.length);
        const inputDependencies = ["rank"];
        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
          outputShape,
          adjustedAttributes
        );
        programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
        return {
          name,
          shaderCache: {
            hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: input.dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource: (shaderHelper) => generatePoolingCode(
            shaderHelper,
            x,
            input.dims.length,
            outputShape.length,
            adjustedAttributes,
            op1,
            op2,
            input.dataType === 10 /* float16 */ ? -65504 : -1e5,
            uniforms,
            hasPads,
            pwStartEndNotZero,
            phStartEndNotZero
          )
        };
      };
      maxPool = (context, attributes) => {
        validateInputs25(context.inputs);
        context.compute(createMaxPoolProgramInfo("MaxPool", context.inputs[0], false, attributes));
      };
      parseMaxPoolAttributes = (attributes) => {
        const storageOrder = attributes.storage_order;
        const dilations = attributes.dilations;
        const attr = parsePoolCommonAttributes(attributes);
        if (storageOrder !== 0) {
          throw new Error("column major storage order is not yet supported for MaxPool");
        }
        if (attr.ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
        }
        const maxPoolAttributes = { storageOrder, dilations, ...attr, cacheKey: "" };
        return { ...maxPoolAttributes, cacheKey: createMaxPoolShaderKeyFromAttributes(maxPoolAttributes) };
      };
      parseGlobalMaxPoolAttributes = (attributes) => {
        const format = attributes.format;
        return { format, ...globalPoolAttributes, cacheKey: format };
      };
      globalMaxPool = (context, attributes) => {
        validateInputs25(context.inputs);
        context.compute(createMaxPoolProgramInfo("GlobalMaxPool", context.inputs[0], true, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts
  var validateInputs26, createDequantizeLinearProgramInfo, dequantizeLinear, parseDequantizeLinearAttributes;
  var init_quantize_linear = __esm({
    "web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs26 = (inputs, attributes) => {
        if (inputs.length < 2 || inputs.length > 3) {
          throw new Error("DequantizeLinear requires 2 or 3 inputs.");
        }
        if (inputs.length === 3 && inputs[1].dims === inputs[2].dims) {
          throw new Error("x-scale and x-zero-point must have the same shape.");
        }
        if (inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("x and x-zero-point must have the same data type.");
        }
        if (inputs[0].dataType === 6 /* int32 */ && inputs.length > 2) {
          throw new Error("In the case of dequantizing int32 there is no zero point.");
        }
        if (inputs[1].dims.length !== 0 && inputs[1].dims.length !== 1 && inputs[1].dims.length !== inputs[0].dims.length) {
          throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");
        }
        if (inputs.length > 2) {
          if (inputs[0].dataType !== inputs[2].dataType) {
            throw new Error("x and x-zero-point must have the same data type.");
          }
          if (inputs[1].dims.length !== inputs[2].dims.length) {
            throw new Error("scale and zero-point inputs must have the same rank.");
          }
          if (!inputs[1].dims.map((d, i) => d === inputs[2].dims[i]).reduce((a, b) => a && b, true)) {
            throw new Error("scale and zero-point inputs must have the same shape.");
          }
        }
        if (attributes.blockSize > 0) {
          if (inputs[1].dims.length === 0 || inputs[1].dims.length === 1 && inputs[1].dims[0] === 1) {
            throw new Error("blockSize must be set only for block quantization.");
          }
          if (!inputs[1].dims.map((d, i) => i === attributes.axis || d === inputs[0].dims[i]).reduce((a, b) => a && b, true)) {
            throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");
          }
          if (inputs[1].dims.length !== inputs[0].dims.length) {
            throw new Error("For block qunatization the scale input rank must be the same as the x rank.");
          }
          const dI = inputs[0].dims[attributes.axis];
          const si = inputs[1].dims[attributes.axis];
          if (attributes.blockSize < Math.ceil(dI / si) || attributes.blockSize > Math.ceil(dI / (si - 1) - 1)) {
            throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].");
          }
        }
      };
      createDequantizeLinearProgramInfo = (inputs, attributes) => {
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
        const inputType = inputs[0].dataType;
        const isSigned = inputType === 3 /* int8 */;
        const outputShape = inputs[0].dims;
        const dataType = inputs[1].dataType;
        const outputSize = ShapeUtil.size(outputShape);
        const isPacked = inputType === 3 /* int8 */ || inputType === 2 /* uint8 */;
        const inputShape = isPacked ? [Math.ceil(ShapeUtil.size(inputs[0].dims) / 4)] : inputs[0].dims;
        const scaleShape = inputs[1].dims;
        const zeroPointInput = inputs.length > 2 ? inputs[2] : void 0;
        const zeroPointShape = zeroPointInput ? isPacked ? [Math.ceil(ShapeUtil.size(zeroPointInput.dims) / 4)] : zeroPointInput.dims : void 0;
        const perLayerQuantization = scaleShape.length === 0 || scaleShape.length === 1 && scaleShape[0] === 1;
        const perAxisQuantization = perLayerQuantization === false && scaleShape.length === 1;
        const maxComponents = getMaxComponents(outputSize);
        const useComponents = perLayerQuantization && (!isPacked || maxComponents === 4);
        const components = useComponents ? maxComponents : 1;
        const inputComponent = useComponents && !isPacked ? maxComponents : 1;
        const input = inputVariable("input", isPacked ? 12 /* uint32 */ : inputType, inputShape.length, inputComponent);
        const scale = inputVariable("scale", dataType, scaleShape.length);
        const zeroPoint = zeroPointInput ? inputVariable("zero_point", isPacked ? 12 /* uint32 */ : inputType, zeroPointShape.length) : void 0;
        const output = outputVariable("output", dataType, outputShape.length, components);
        const inputVariables = [input, scale];
        if (zeroPoint) {
          inputVariables.push(zeroPoint);
        }
        const inputShapes = [inputShape, scaleShape];
        if (zeroPointInput) {
          inputShapes.push(zeroPointShape);
        }
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize / components },
          { type: 12 /* uint32 */, data: axis },
          { type: 12 /* uint32 */, data: attributes.blockSize },
          ...createTensorShapeVariables(...inputShapes, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "axis", type: "u32" },
            { name: "block_size", type: "u32" }
          ];
          return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${output.offsetToIndices("global_idx")};

          // Set input x
          ${(() => {
            if (isPacked) {
              return `
            let input = ${input.getByOffset("global_idx / 4")};
            let x_vec = ${isSigned ? "unpack4xI8(input)" : "unpack4xU8(input)"};
            let x_value = ${components === 1 ? "x_vec[global_idx % 4]" : "x_vec"};`;
            } else {
              return `let x_value = ${input.getByOffset("global_idx")};`;
            }
          })()};

          // Set scale input
          ${(() => {
            if (perLayerQuantization) {
              return `let scale_value= ${scale.getByOffset("0")}`;
            } else if (perAxisQuantization) {
              return `
            let scale_index = ${output.indicesGet("output_indices", "uniforms.axis")};
            let scale_value= ${scale.getByOffset("scale_index")};`;
            } else {
              return `
            var scale_indices: ${scale.type.indices} = output_indices;
            let index = ${scale.indicesGet("scale_indices", "uniforms.axis")} / uniforms.block_size;
            ${scale.indicesSet("scale_indices", "uniforms.axis", "index")};
            let scale_value= ${scale.getByIndices("scale_indices")};`;
            }
          })()};

          // Set zero-point input
          ${(() => {
            if (zeroPoint) {
              if (perLayerQuantization) {
                if (isPacked) {
                  return `
                let zero_point_input = ${zeroPoint.getByOffset("0")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`;
                } else {
                  return `let zero_point_value = ${zeroPoint.getByOffset("0")}`;
                }
              } else if (perAxisQuantization) {
                if (isPacked) {
                  return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`;
                } else {
                  return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_value = ${zeroPoint.getByOffset("zero_point_index")};`;
                }
              } else {
                if (isPacked) {
                  return `
                let zero_point_offset = ${scale.indicesToOffset("scale_indices")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`;
                } else {
                  return `let zero_point_value = ${zeroPoint.getByIndices("scale_indices")};`;
                }
              }
            } else {
              return `let zero_point_value = ${isPacked ? isSigned ? "i32" : "u32" : input.type.value}(0);`;
            }
          })()};
      // Compute and write output
      ${output.setByOffset("global_idx", `${output.type.value}(x_value - zero_point_value) * scale_value`)};
      }`;
        };
        return {
          name: "DequantizeLinear",
          shaderCache: {
            hint: attributes.cacheKey,
            inputDependencies: zeroPoint ? ["rank", "rank", "rank"] : ["rank", "rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(outputSize / components / 64), y: 1, z: 1 },
            programUniforms
          })
        };
      };
      dequantizeLinear = (context, attributes) => {
        validateInputs26(context.inputs, attributes);
        context.compute(createDequantizeLinearProgramInfo(context.inputs, attributes));
      };
      parseDequantizeLinearAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis, blockSize: attributes.blockSize });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/range.ts
  var validateInputsContent, createRangeProgramInfo, range;
  var init_range = __esm({
    "web/lib/wasm/jsep/webgpu/ops/range.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_common();
      validateInputsContent = (start, limit, delta) => {
        const sameStartLimit = start === limit;
        const increasingRangeNegativeStep = start < limit && delta < 0;
        const decreasingRangePositiveStep = start > limit && delta > 0;
        if (sameStartLimit || increasingRangeNegativeStep || decreasingRangePositiveStep) {
          throw new Error("Range these inputs' contents are invalid.");
        }
      };
      createRangeProgramInfo = (start, limit, delta, dataType) => {
        const numElements = Math.abs(Math.ceil((limit - start) / delta));
        const outputShape = [numElements];
        const outputSize = numElements;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: dataType, data: start },
          { type: dataType, data: delta },
          ...createTensorShapeVariables(outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", dataType, outputShape.length);
          const wgslType = output.type.value;
          const uniforms = [
            { name: "outputSize", type: "u32" },
            { name: "start", type: wgslType },
            { name: "delta", type: wgslType }
          ];
          return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${wgslType}(global_idx) * uniforms.delta;
      }`;
        };
        return {
          name: "Range",
          shaderCache: { hint: `${dataType}` },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      range = (context) => {
        let start = 0;
        let limit = 0;
        let delta = 0;
        if (context.inputs[0].dataType === 6 /* int32 */) {
          start = context.inputs[0].getInt32Array()[0];
          limit = context.inputs[1].getInt32Array()[0];
          delta = context.inputs[2].getInt32Array()[0];
        } else if (context.inputs[0].dataType === 1 /* float */) {
          start = context.inputs[0].getFloat32Array()[0];
          limit = context.inputs[1].getFloat32Array()[0];
          delta = context.inputs[2].getFloat32Array()[0];
        }
        if (env2.webgpu.validateInputContent) {
          validateInputsContent(start, limit, delta);
        }
        context.compute(createRangeProgramInfo(start, limit, delta, context.inputs[0].dataType), { inputs: [] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/scatter-nd.ts
  var atomicReductionSnippet, createScatterNDProgramInfo, parseScatterNDAttributes, scatterND;
  var init_scatter_nd = __esm({
    "web/lib/wasm/jsep/webgpu/ops/scatter-nd.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      atomicReductionSnippet = (reduction, ptr, v, type) => {
        if (reduction !== "none" && type !== "i32" && type !== "u32" && type !== "f32") {
          throw new Error(`Input ${type} is not supported with reduction ${reduction}.`);
        }
        const floatStart = `{
                var oldValue = 0;
                loop {
                  let newValueF32 =`;
        const floatEnd = `;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${ptr}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;
        switch (reduction) {
          case "none":
            return `${ptr}=${v};`;
          case "add":
            if (type === "i32" || type === "u32") {
              return `atomicAdd(&${ptr}, bitcast<${type}>(${v}));`;
            } else {
              return `
              ${floatStart}bitcast<${type}>(oldValue) + (${v})${floatEnd}`;
            }
          case "max":
            if (type === "i32" || type === "u32") {
              return `atomicMax(&${ptr}, bitcast<${type}>(${v}));`;
            } else {
              return `
                ${floatStart}max(bitcast<f32>(oldValue), (${v}))${floatEnd}`;
            }
          case "min":
            if (type === "i32" || type === "u32") {
              return `atomicMin(&${ptr}, bitcast<${type}>(${v}));`;
            } else {
              return `${floatStart}min(bitcast<${type}>(oldValue), (${v}))${floatEnd}`;
            }
          case "mul":
            return `${floatStart}(bitcast<${type}>(oldValue) * (${v}))${floatEnd}`;
          default:
            throw new Error(`Reduction ${reduction} is not supported.`);
        }
      };
      createScatterNDProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const indicesShape = inputs[1].dims;
        const outputShape = inputShape;
        const components = 1;
        const outputSize = Math.ceil(ShapeUtil.sizeToDimension(indicesShape, indicesShape.length - 1) / components);
        const lastIndexDimension = indicesShape[indicesShape.length - 1];
        const numUpdatesElements = ShapeUtil.sizeFromDimension(inputShape, lastIndexDimension);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: lastIndexDimension },
          { type: 12 /* uint32 */, data: numUpdatesElements },
          ...createTensorShapeVariables(inputs[1].dims, inputs[2].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const indices = inputVariable("indices", inputs[1].dataType, inputs[1].dims.length);
          const updates = inputVariable("updates", inputs[2].dataType, inputs[2].dims.length, components);
          const output = attributes.reduction !== "none" && attributes.reduction !== "" ? atomicOutputVariable("output", inputs[0].dataType, outputShape.length) : outputVariable("output", inputs[0].dataType, outputShape.length, components);
          return `
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("last_index_dimension", "u32").registerUniform("num_updates_elements", "u32").declareVariables(indices, updates, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var data_offset = 0u;
  let indices_start = uniforms.last_index_dimension * global_idx;
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${inputs[0].dims.length === 1 ? `
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;` : `
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${atomicReductionSnippet(
            attributes.reduction,
            "output[data_offset + i]",
            "value",
            output.type.value
          )}
  }

      }`;
        };
        return {
          name: "ScatterND",
          shaderCache: {
            hint: `${attributes.cacheKey}_${attributes.reduction}`,
            inputDependencies: ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseScatterNDAttributes = (attributes) => createAttributeWithCacheKey({ reduction: attributes.reduction });
      scatterND = (context, attributes) => {
        context.compute(createScatterNDProgramInfo(context.inputs, attributes), {
          inputs: [context.inputs[1], context.inputs[2]],
          outputs: []
        });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/resize.ts
  var validateScales, updateScales, validateInputs27, getSafeIntegerDivision, getOriginalCoordinateFromResizedCoordinate, getNearestPixelFromOriginal, updateRoI, initOutputShape, adjustOutputShape, calculateOriginalIndicesFromOutputIndices, calculateInputIndicesFromOutputIndices, checkInputIndices, setChannelAndBatchIndices, bilinearInterpolation, bicubicInterpolation, trilinearInterpolation, createResizeProgramInfo, getOpsetVersionFromCustomDataBuffer, resize, parseResizeAttributes;
  var init_resize = __esm({
    "web/lib/wasm/jsep/webgpu/ops/resize.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateScales = (scales, attributes) => {
        scales.every(
          (value) => value > 0 || (() => {
            throw new Error("Resize requires scales input values to be positive");
          })
        );
        if (scales.length > 0) {
          if (attributes.mode === "linear") {
            if (!(scales.length === 2 || scales.length === 3 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1 || scales.length === 5 && scales[0] === 1 && scales[1] === 1)) {
              throw new Error(
                `For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`
              );
            }
          } else if (attributes.mode === "cubic") {
            if (!(scales.length === 2 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1)) {
              throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
            }
          }
        }
      };
      updateScales = (scales, axes, rank) => {
        axes.every(
          (value) => value >= 0 && value < rank || (() => {
            throw new Error("Resize requires axes input values to be positive and less than rank");
          })
        );
        const newScales = new Array(rank).fill(1);
        axes.forEach((value, index) => newScales[value] = scales[index]);
        return newScales;
      };
      validateInputs27 = (inputs, attributes, opsetVersion, scales, sizes, roi) => {
        const [roiInputIndex, scalesInputIndex, sizesInputIndex] = opsetVersion > 10 ? [1, 2, 3] : [-1, inputs.length > 1 ? 1 : -1, -1];
        const rank = inputs[0].dims.length;
        if (roiInputIndex > 0 && inputs.length > roiInputIndex && inputs[roiInputIndex].dims.length > 0) {
          inputs[roiInputIndex].getFloat32Array().forEach((value) => roi.push(value));
        } else if (attributes.coordinateTransformMode === "tf_crop_and_resize") {
          throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
        }
        if (scalesInputIndex > 0 && inputs.length > scalesInputIndex && inputs[scalesInputIndex].dims.length === 1 && inputs[scalesInputIndex].dims[0] > 0) {
          inputs[scalesInputIndex].getFloat32Array().forEach((value) => scales.push(value));
          if (scales.length !== 0 && scales.length !== rank && opsetVersion >= 18 && scales.length !== attributes.axes.length) {
            throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");
          }
          validateScales(scales, attributes);
          if (attributes.axes.length > 0) {
            updateScales(scales, attributes.axes, rank).forEach((value, index) => scales[index] = value);
          }
        }
        if (sizesInputIndex > 0 && inputs.length > sizesInputIndex && inputs[sizesInputIndex].dims.length === 1 && inputs[sizesInputIndex].dims[0] > 0) {
          inputs[sizesInputIndex].getBigInt64Array().forEach((value) => sizes.push(Number(value)));
          if (sizes.length !== 0 && sizes.length !== rank && opsetVersion >= 18 && sizes.length !== attributes.axes.length) {
            throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
          }
        }
        if (attributes.axes.length > 0) {
          if (scales.length !== 0 && scales.length !== attributes.axes.length) {
            throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
          }
          if (sizes.length !== 0 && sizes.length !== attributes.axes.length) {
            throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified');
          }
        }
        if (typeof scales !== "undefined" && typeof sizes !== "undefined" && scales.length > 0 && sizes.length > rank) {
          throw new Error("Resize requires only of scales or sizes to be specified");
        }
      };
      getSafeIntegerDivision = (a, b, c, dType) => `
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${a}) * (${b});
  let whole = ${dType}(big / (${c}));
  let fract = ${dType}(big % (${c})) / ${dType}(${c});
  return whole + fract;
`;
      getOriginalCoordinateFromResizedCoordinate = (coordinateTransferMode, dType) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${dType} { ` + (() => {
        switch (coordinateTransferMode) {
          case "asymmetric":
            return `
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${dType}(xResized) / ${dType}(xScale);
          } else {
            ${getSafeIntegerDivision("xResized", "lengthOriginal", "lengthResized", dType)}
          }
        `;
          case "pytorch_half_pixel":
            return `if (lengthResized > 1) {
                    return (${dType}(xResized) + 0.5) / ${dType}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
          case "tf_half_pixel_for_nn":
            return `return (${dType}(xResized) + 0.5) / ${dType}(xScale);`;
          case "align_corners":
            return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${getSafeIntegerDivision("xResized", "lengthOriginal - 1", "lengthResized - 1", dType)}
                  }`;
          case "tf_crop_and_resize":
            return `if (lengthResized > 1) {
                    return ${dType}(roiStart) * ${dType}(lengthOriginal - 1) +
                        (${dType}(xResized) * ${dType}(roiEnd - roiStart) * ${dType}(lengthOriginal - 1)) /
                        ${dType}(lengthResized - 1);
                  } else {
                    return 0.5 * ${dType}(roiStart + roiEnd) * ${dType}(lengthOriginal - 1);
                  }`;
          case "half_pixel_symmetric":
            return `const outputWidth = ${dType}xScale * ${dType}(lengthResized);
                  const adjustment = ${dType}(lengthResized) / outputWidth;
                  const center = ${dType}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
          case "half_pixel":
            return `return ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
          default:
            throw new Error(`Coordinate transform mode ${coordinateTransferMode} is not supported`);
        }
      })() + "}";
      getNearestPixelFromOriginal = (nearestMode, opsetVersion, dType) => `fn getNearestPixelFromOriginal(xOriginal: ${dType}, isDownSample: bool) -> ${dType} {` + (() => {
        switch (nearestMode) {
          case "round_prefer_ceil":
            return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
          case "floor":
            return "return floor(xOriginal);";
          case "ceil":
            return "return ceil(xOriginal);";
          case "round_prefer_floor":
            return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
          case "simple":
          default:
            if (opsetVersion < 11) {
              return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
            }
            throw new Error(`Nearest mode ${nearestMode} is not supported`);
        }
      })() + "}";
      updateRoI = (roi, axes, rank) => {
        const roiTmp = new Array(rank).fill(0).concat(new Array(rank).fill(1));
        const roiLocal = roi.length === 0 ? roiTmp : roi.slice();
        if (axes.length > 0) {
          axes.forEach((v, i) => {
            roiTmp[v] = roiLocal[i];
            roiTmp[i + rank] = roiLocal[axes.length + i];
          });
          return roiTmp;
        }
        return roiLocal;
      };
      initOutputShape = (inputShape, scales, sizes, axes) => {
        let outputShape = [];
        if (sizes.length > 0) {
          if (axes.length > 0) {
            inputShape.forEach((v) => outputShape.push(v));
            if (Math.max(...axes) > inputShape.length) {
              throw new Error("axes is out of bound");
            }
            axes.forEach((v, i) => outputShape[v] = sizes[i]);
          } else {
            sizes.forEach((v) => outputShape.push(v));
          }
        } else {
          if (scales.length === 0) {
            throw new Error("Resize requires either scales or sizes.");
          } else {
            outputShape = inputShape.map((value, index) => Math.round(value * scales[index]));
          }
        }
        return outputShape;
      };
      adjustOutputShape = (inputShape, scales, attributes) => {
        const scaleInPolicy = (() => {
          switch (attributes.keepAspectRatioPolicy) {
            case "not_larger":
              return attributes.axes.length > 0 ? Math.min(...attributes.axes.map((i) => scales[i]), Number.MAX_VALUE) : Math.min(...scales, Number.MAX_VALUE);
            case "not_smaller":
              return attributes.axes.length > 0 ? Math.max(...attributes.axes.map((i) => scales[i]), Number.MIN_VALUE) : Math.max(...scales, Number.MIN_VALUE);
            default:
              throw new Error(`Keep aspect ratio policy ${attributes.keepAspectRatioPolicy} is not supported`);
          }
        })();
        scales.fill(1, 0, scales.length);
        const adjustedOutputShape = inputShape.slice();
        if (attributes.axes.length > 0) {
          attributes.axes.forEach((v) => scales[v] = scaleInPolicy);
          attributes.axes.forEach((v) => adjustedOutputShape[v] = Math.round(inputShape[v] * scales[v]));
        } else {
          scales.fill(scaleInPolicy, 0, scales.length);
          adjustedOutputShape.forEach((v, i) => adjustedOutputShape[i] = Math.round(v * scales[i]));
        }
        return adjustedOutputShape;
      };
      calculateOriginalIndicesFromOutputIndices = (output, inputShape, outputShape, scalesLength, roiLength) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> array<${output.type.value}, ${outputShape.length}> {
      var original_indices: array<${output.type.value}, ${outputShape.length}>;
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
        var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
        if (scale == 1.0) {
          original_indices[i] = ${output.type.value}(output_index);
        } else {
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`;
      calculateInputIndicesFromOutputIndices = (input, output, inputShape, outputShape, scalesLength, roiLength, useExtrapolation) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
      var input_indices: ${input.type.indices};
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
          var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${useExtrapolation} || (original_idx >= 0 && original_idx < ${output.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${output.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${input.indicesSet("input_indices", "i", "input_index")}
      }
      return input_indices;
    }`;
      checkInputIndices = (input, inputShape) => `
    fn checkInputIndices(input_indices: ${input.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${inputShape.length}; i++) {
        var input_index = ${input.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape", "i", inputShape.length)}) {
          return false;
        }
      }
      return true;
    }`;
      setChannelAndBatchIndices = (input, channelIdx, batchIdx, spacialDims) => input.rank > spacialDims ? `
    ${input.indicesSet("input_indices", channelIdx, "channel")};
    ${input.indicesSet("input_indices", batchIdx, "batch")};
` : "";
      bilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
        const isNchw = true;
        const [batchIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 2 ? [-1, 0, 1, -1] : isNchw ? [0, 2, 3, 1] : [0, 1, 2, 3];
        const dType = input.type.value;
        return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(row, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(col, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 2)}
      return ${input.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${dType} = originalIndices[${heightIdx}];
      var col:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (row < 0 || row > (${inputShape[heightIdx]} - 1) || col < 0 || col > (${inputShape[widthIdx]} - 1)) {
        return ${extrapolationValue};
      }` : ""};
      row = max(0, min(row, ${inputShape[heightIdx]} - 1));
      col = max(0, min(col, ${inputShape[widthIdx]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${inputShape.length > 2 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 2 ? `u32(originalIndices[${batchIdx}])` : "0"};
      var x11: ${dType} = getInputValue(batch, channel, row1, col1);
      var x12: ${dType} = getInputValue(batch, channel, row1, col2);
      var x21: ${dType} = getInputValue(batch, channel, row2, col1);
      var x22: ${dType} = getInputValue(batch, channel, row2, col2);
      var dx1: ${dType} = abs(row - ${dType}(row1));
      var dx2: ${dType} = abs(${dType}(row2) - row);
      var dy1: ${dType} = abs(col - ${dType}(col1));
      var dy2: ${dType} = abs(${dType}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
      };
      bicubicInterpolation = (input, output, inputShape, outputShape, scales, roi, cubicCoeffA, useExtrapolation, extrapolationValue, excludeOutside) => {
        const is2D = inputShape.length === 2;
        const isNchw = true;
        const [heightIdx, widthIdx] = is2D ? [0, 1] : isNchw ? [2, 3] : [1, 2];
        const dType = input.type.value;
        const createCubicInterpolationFunction = (idx) => {
          const direction = idx === heightIdx ? "row" : "col";
          return `
      fn ${direction}CubicInterpolation(input_indices: ${input.type.indices}, output_indices: ${output.type.indices}) -> ${dType} {
        var output_index = ${output.indicesGet("output_indices", idx)};
        var originalIdx: ${dType} = getOriginalCoordinateFromResizedCoordinate(output_index, ${scales[idx]},
        ${outputShape[idx]}, ${inputShape[idx]}, ${roi[idx]}, ${roi[idx]} + ${inputShape.length});
        var fractOriginalIdx: ${dType} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${useExtrapolation} && (originalIdx < 0 || originalIdx > (${inputShape[idx]} - 1))) {
          return ${extrapolationValue};
        }
        var data: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${direction}: ${dType} = originalIdx + ${dType}(i);
          if (${direction} < 0 || ${direction} >= ${inputShape[idx]}) {
            ${(() => {
            if (excludeOutside) {
              return `coefs[i + 1] = 0.0;
                        continue;`;
            } else if (useExtrapolation) {
              return `return ${extrapolationValue};`;
            } else {
              return `${direction} = max(0, min(${direction}, ${inputShape[idx]} - 1));`;
            }
          })()};
          }
        var input_indices_copy: ${input.type.indices} = input_indices;
          ${input.indicesSet("input_indices_copy", idx, `u32(${direction})`)};
          data[i + 1] = ${idx === heightIdx ? input.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
        };
        return `
    ${createCubicInterpolationFunction(heightIdx)};
    ${createCubicInterpolationFunction(widthIdx)};
  fn getCubicInterpolationCoefs(s: ${dType}) -> array<${dType}, 4> {
    var absS = abs(s);
    var coeffs: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${dType} = 1.0 - absS;
    var twoMinusAbsS: ${dType} = 2.0 - absS;
    var onePlusAbsS: ${dType} = 1.0 + absS;
    coeffs[0] = ((${cubicCoeffA} * onePlusAbsS - 5 * ${cubicCoeffA}) * onePlusAbsS + 8 * ${cubicCoeffA}) * onePlusAbsS - 4 * ${cubicCoeffA};
    coeffs[1] = ((${cubicCoeffA} + 2) * absS - (${cubicCoeffA} + 3)) * absS * absS + 1;
    coeffs[2] = ((${cubicCoeffA} + 2) * oneMinusAbsS - (${cubicCoeffA} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${cubicCoeffA} * twoMinusAbsS - 5 * ${cubicCoeffA}) * twoMinusAbsS + 8 * ${cubicCoeffA}) * twoMinusAbsS - 4 * ${cubicCoeffA};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${dType}, 4>, coefs: array<${dType}, 4>) -> ${dType} {
    var coefsSum: ${dType} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
    var input_indices: ${input.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
      };
      trilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
        const isNchw = true;
        const [batchIdx, depthIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 3 ? [-1, 0, 1, 2, -1] : isNchw ? [0, 2, 3, 4, 1] : [0, 1, 2, 3, 4];
        const dType = input.type.value;
        return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", depthIdx, `max(0, min(depth, ${inputShape[depthIdx]} - 1))`)};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(height, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(width, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 3)}
      return ${input.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${dType} = originalIndices[${depthIdx}];
      var height:${dType} = originalIndices[${heightIdx}];
      var width:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (depth < 0 || depth > (${inputShape[depthIdx]} - 1) || height < 0 || height > (${inputShape[heightIdx]} - 1) || width < 0 || (width > ${inputShape[widthIdx]} - 1)) {
      return ${extrapolationValue};
        }` : ""};

    depth = max(0, min(depth, ${inputShape[depthIdx]} - 1));
      height = max(0, min(height, ${inputShape[heightIdx]} - 1));
      width = max(0, min(width, ${inputShape[widthIdx]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${inputShape.length > 3 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 3 ? `u32(originalIndices[${batchIdx}])` : "0"};

      var x111: ${dType} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${dType} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${dType} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${dType} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${dType} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${dType} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${dType} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${dType} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${dType} = abs(depth - ${dType}(depth1));
      var dx2: ${dType} = abs(${dType}(depth2) - depth);
      var dy1: ${dType} = abs(height - ${dType}(height1));
      var dy2: ${dType} = abs(${dType}(height2) - height);
      var dz1: ${dType} = abs(width - ${dType}(width1));
      var dz2: ${dType} = abs(${dType}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
      };
      createResizeProgramInfo = (inputTensor, attributes, opsetVersion, scalesInput, sizes, roiInput) => {
        const inputShape = inputTensor.dims;
        const roi = updateRoI(roiInput, attributes.axes, inputShape.length);
        let outputShape = initOutputShape(inputShape, scalesInput, sizes, attributes.axes);
        let scales = scalesInput.slice();
        if (scalesInput.length === 0) {
          scales = inputShape.map((value, index) => value === 0 ? 1 : outputShape[index] / value);
          if (attributes.keepAspectRatioPolicy !== "stretch") {
            outputShape = adjustOutputShape(inputShape, scales, attributes);
          }
        }
        const output = outputVariable("output", inputTensor.dataType, outputShape.length);
        const input = inputVariable("input", inputTensor.dataType, inputShape.length);
        const outputSize = ShapeUtil.size(outputShape);
        const noScale = inputShape.length === outputShape.length && inputShape.every((d, i) => d === outputShape[i]);
        const useExtrapolation = attributes.coordinateTransformMode === "tf_crop_and_resize";
        const extrapolationValue = attributes.extrapolationValue;
        const dataType = input.type.value;
        const getShaderSource = (shaderHelper) => `
      ${noScale ? "" : `
      ${getOriginalCoordinateFromResizedCoordinate(attributes.coordinateTransformMode, dataType)};
      ${(() => {
          switch (attributes.mode) {
            case "nearest":
              return `
              ${checkInputIndices(input, inputShape)};
              ${getNearestPixelFromOriginal(attributes.nearestMode, opsetVersion, dataType)};
              ${calculateInputIndicesFromOutputIndices(
                input,
                output,
                inputShape,
                outputShape,
                scales.length,
                roi.length,
                useExtrapolation
              )};
              `;
            case "linear":
              return `
              ${calculateOriginalIndicesFromOutputIndices(output, inputShape, outputShape, scales.length, roi.length)};
              ${(() => {
                if (inputShape.length === 2 || inputShape.length === 4) {
                  return `${bilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
                } else if (inputShape.length === 3 || inputShape.length === 5) {
                  return `${trilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
                } else {
                  throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
                }
              })()};
            `;
            case "cubic":
              return `
            ${(() => {
                if (inputShape.length === 2 || inputShape.length === 4) {
                  return `${bicubicInterpolation(
                    input,
                    output,
                    inputShape,
                    outputShape,
                    scales,
                    roi,
                    attributes.cubicCoeffA,
                    useExtrapolation,
                    attributes.extrapolationValue,
                    attributes.excludeOutside
                  )}`;
                } else {
                  throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
                }
              })()};
            `;
            default:
              throw Error("Invalid resize mode");
          }
        })()};
      `}
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("scales", "f32", scales.length).registerUniform("roi", "f32", roi.length).declareVariables(input, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${noScale ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${output.offsetToIndices("global_idx")};
        var input_indices: ${input.type.indices};
        ${(() => {
          switch (attributes.mode) {
            case "nearest":
              return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${input.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${attributes.extrapolationValue};
                }`;
            case "linear":
              return `output[global_idx] = ${inputShape.length === 2 || inputShape.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
            case "cubic":
              return "output[global_idx] = bicubicInterpolation(output_indices);";
            default:
              throw Error(`Unsupported resize mode: ${attributes.mode}`);
          }
        })()};
`}
      }`;
        return {
          name: "Resize",
          shaderCache: {
            hint: `${attributes.cacheKey}|${opsetVersion}|${scales.length > 0 ? attributes.mode === "cubic" ? scales : scales.length : ""}|${sizes.length > 0 ? sizes : ""}|${roi.length > 0 ? roi : ""}|${noScale}|${attributes.mode === "nearest" ? inputShape.length : inputShape}`,
            inputDependencies: ["rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              { type: 1 /* float */, data: scales },
              { type: 1 /* float */, data: roi },
              ...createTensorShapeVariables(inputShape, outputShape)
            ]
          })
        };
      };
      getOpsetVersionFromCustomDataBuffer = (context) => {
        const customDataBuffer = context.customDataBuffer;
        const customDataBuffer32 = new Uint32Array(customDataBuffer, customDataBuffer.byteOffset, 1);
        const opsetVersion = customDataBuffer32[0];
        return opsetVersion;
      };
      resize = (context, attributes) => {
        const scales = [];
        const sizes = [];
        const roi = [];
        const opsetVersion = getOpsetVersionFromCustomDataBuffer(context);
        if (attributes.antialias !== 0) {
          throw Error("Only default value (0) for Antialias attribute is supported");
        }
        validateInputs27(context.inputs, attributes, opsetVersion, scales, sizes, roi);
        context.compute(createResizeProgramInfo(context.inputs[0], attributes, opsetVersion, scales, sizes, roi), {
          inputs: [0]
        });
      };
      parseResizeAttributes = (attributes) => {
        const antialias = attributes.antialias;
        const axes = attributes.axes;
        const coordinateTransformMode = attributes.coordinateTransformMode;
        const cubicCoeffA = attributes.cubicCoeffA;
        const excludeOutside = attributes.excludeOutside !== 0;
        const extrapolationValue = attributes.extrapolationValue;
        const keepAspectRatioPolicy = attributes.keepAspectRatioPolicy;
        const mode = attributes.mode;
        const nearestMode = attributes.nearestMode === "" ? "simple" : attributes.nearestMode;
        return createAttributeWithCacheKey({
          antialias,
          axes,
          coordinateTransformMode,
          cubicCoeffA,
          excludeOutside,
          extrapolationValue,
          keepAspectRatioPolicy,
          mode,
          nearestMode
        });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts
  var validateInputs28, createSkipLayerNormProgramInfo, skipLayerNorm;
  var init_skip_layer_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs28 = (inputs) => {
        if (!inputs || inputs.length < 3) {
          throw new Error("layerNorm requires at least 3 inputs.");
        }
        const input = inputs[0];
        const skip = inputs[1];
        const gamma = inputs[2];
        if (input.dataType !== skip.dataType || input.dataType !== gamma.dataType) {
          throw new Error("All inputs must have the same data type");
        }
        if (input.dims.length !== 3 && input.dims.length !== 2) {
          throw new Error("Input must be 2D or 3D");
        }
        if (skip.dims.length !== 3 && skip.dims.length !== 2) {
          throw new Error("Skip must be 2D or 3D");
        }
        const hiddenSize = input.dims[input.dims.length - 1];
        const sequenceLength = input.dims[input.dims.length - 2];
        if (skip.dims[skip.dims.length - 1] !== hiddenSize) {
          throw new Error("Skip must have the same hidden size as input");
        }
        if (skip.dims[skip.dims.length - 2] !== sequenceLength) {
          throw new Error("Skip must have the same sequence length as input");
        }
        if (gamma.dims.length !== 1) {
          throw new Error("Gamma must be 1D");
        }
        if (gamma.dims[gamma.dims.length - 1] !== hiddenSize) {
          throw new Error("Gamma must have the same hidden size as input");
        }
        if (inputs.length > 3) {
          const beta = inputs[3];
          if (beta.dims.length !== 1) {
            throw new Error("Beta must be 1D");
          }
          if (beta.dims[beta.dims.length - 1] !== hiddenSize) {
            throw new Error("Beta must have the same hidden size as input");
          }
        }
        if (inputs.length > 4) {
          const bias = inputs[4];
          if (bias.dims.length !== 1) {
            throw new Error("Bias must be 1D");
          }
          if (bias.dims[bias.dims.length - 1] !== hiddenSize) {
            throw new Error("Bias must have the same hidden size as input");
          }
        }
      };
      createSkipLayerNormProgramInfo = (inputs, attributes, outputCount, isTraining) => {
        const simplified = attributes.simplified;
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const outputShape = inputShape;
        const outputSize = inputSize;
        const hiddenSize = inputShape.slice(-1)[0];
        const meanInvStdDevDim = isTraining ? inputShape.slice(0, -1).concat(1) : [];
        const hasBetaInput = !simplified && inputs.length > 3;
        const hasBiasInput = inputs.length > 4;
        const hasMeanOutput = isTraining && outputCount > 1;
        const hasInvStdDevOutput = isTraining && outputCount > 2;
        const hasInputSkipBiasSumOutput = outputCount > 3;
        const workgroupSize = 64;
        const components = getMaxComponents(hiddenSize);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: components },
          { type: 12 /* uint32 */, data: hiddenSize },
          { type: 1 /* float */, data: attributes.epsilon }
        ];
        const getShaderSource = (shaderHelper) => {
          const uniformsArray = [
            { name: "output_size", type: "u32" },
            { name: "components", type: "u32" },
            { name: "hidden_size", type: "u32" },
            { name: "epsilon", type: "f32" }
          ];
          const variables = [
            inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
            inputVariable("skip", inputs[1].dataType, inputs[1].dims, components),
            inputVariable("gamma", inputs[2].dataType, inputs[2].dims, components)
          ];
          if (hasBetaInput) {
            variables.push(inputVariable("beta", inputs[3].dataType, inputs[3].dims, components));
          }
          if (hasBiasInput) {
            variables.push(inputVariable("bias", inputs[4].dataType, inputs[4].dims, components));
          }
          variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
          if (hasMeanOutput) {
            variables.push(outputVariable("mean_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInvStdDevOutput) {
            variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInputSkipBiasSumOutput) {
            variables.push(outputVariable("input_skip_bias_sum", inputs[0].dataType, outputShape, components));
          }
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const vecDataType = tensorTypeToWsglStorageType(1 /* float */, components);
          return `

      ${shaderHelper.registerUniforms(uniformsArray).declareVariables(...variables)}
      var<workgroup> sum_shared : array<${vecDataType}, ${workgroupSize}>;
      var<workgroup> sum_squared_shared : array<${vecDataType}, ${workgroupSize}>;

      ${shaderHelper.mainStart([workgroupSize, 1, 1])}
        let ix = local_id.x;
        let iy = global_id.x / ${workgroupSize};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${workgroupSize};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${workgroupSize - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${hasBiasInput ? "bias[offset1d + i]" : dataType + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${hasInputSkipBiasSumOutput ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${castToF32(dataType, components, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${workgroupSize};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${sumVector("sum", components)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${sumVector("square_sum", components)} / f32(uniforms.hidden_size) ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);
        ${hasMeanOutput ? "mean_output[global_idx] = mean;" : ""}
        ${hasInvStdDevOutput ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${simplified ? "" : `- ${dataType}(mean)`}) *
            ${dataType}(inv_std_dev) * gamma[offset1d + i]
            ${hasBetaInput ? "+ beta[offset1d + i]" : ""};
        }
      }`;
        };
        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
        if (outputCount > 1) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (outputCount > 2) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (outputCount > 3) {
          outputs.push({ dims: inputShape, dataType: inputs[0].dataType });
        }
        return {
          name: "SkipLayerNormalization",
          shaderCache: {
            hint: `${components};${hasMeanOutput};${hasInvStdDevOutput};${hasInputSkipBiasSumOutput}`,
            inputDependencies: inputs.map((_input, _index) => "type")
          },
          getShaderSource,
          getRunData: () => ({
            outputs,
            dispatchGroup: {
              x: Math.ceil(outputSize / hiddenSize)
            },
            programUniforms
          })
        };
      };
      skipLayerNorm = (context, attributes) => {
        const isTraining = false;
        validateInputs28(context.inputs);
        const outputs = [0];
        if (context.outputCount > 1) {
          outputs.push(isTraining ? 1 : -3);
        }
        if (context.outputCount > 2) {
          outputs.push(isTraining ? 2 : -3);
        }
        if (context.outputCount > 3) {
          outputs.push(3);
        }
        context.compute(createSkipLayerNormProgramInfo(context.inputs, attributes, context.outputCount, isTraining), {
          outputs
        });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/slice.ts
  var validateInputs29, readInput, createSliceAttributesFromInputs, fixStartEndValues, calculateInputIndicesImpl, createSliceProgramInfo, slice, parseSliceAttributes;
  var init_slice = __esm({
    "web/lib/wasm/jsep/webgpu/ops/slice.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs29 = (inputs, attributes) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        if (attributes.axes.length !== 0) {
          if (attributes.axes.length !== attributes.starts.length || attributes.axes.length !== attributes.ends.length) {
            throw new Error("axes, starts and ends must have the same length");
          }
        } else if (attributes.starts.length !== attributes.ends.length) {
          throw new Error("starts and ends must have the same length");
        }
        inputs.slice(1).forEach((_, idx) => {
          if (inputs[idx + 1].dataType !== 6 /* int32 */ && inputs[idx + 1].dataType !== 7 /* int64 */) {
            throw new Error(`Input ${idx} must be an array of int32 or int64`);
          }
        });
      };
      readInput = (inputs, idx) => {
        const input = [];
        if (inputs.length > idx) {
          if (inputs[idx].dataType === 7 /* int64 */) {
            inputs[idx].getBigInt64Array().forEach((v) => input.push(Number(v)));
          } else if (inputs[idx].dataType === 6 /* int32 */) {
            inputs[idx].getInt32Array().forEach((v) => input.push(Number(v)));
          } else {
            throw new Error(`Input ${idx} must be an array of int32 or int64`);
          }
        }
        return input;
      };
      createSliceAttributesFromInputs = (inputs, attributes) => {
        if (inputs.length > 1) {
          const starts = readInput(inputs, 1);
          const ends = readInput(inputs, 2);
          let axes = readInput(inputs, 3);
          if (axes.length === 0) {
            axes = [...Array(inputs[0].dims.length).keys()];
          }
          return createAttributeWithCacheKey({ starts, ends, axes });
        } else {
          return attributes;
        }
      };
      fixStartEndValues = (value, index, inputShape, axes, steps) => {
        let newValue = value;
        if (value < 0) {
          newValue += inputShape[axes[index]];
        }
        if (steps[index] < 0) {
          return Math.max(0, Math.min(newValue, inputShape[axes[index]] - 1));
        } else {
          return Math.max(0, Math.min(newValue, inputShape[axes[index]]));
        }
      };
      calculateInputIndicesImpl = (input, output, inputShape) => `fn calculateInputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
          var input_indices: ${input.type.indices};
          var carry = 0u;
          for (var i = ${inputShape.length - 1}; i >= 0; i--) {
            let input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
            let steps_i = ${getElementAt("uniforms.steps", "i", inputShape.length)};
            let signs_i = ${getElementAt("uniforms.signs", "i", inputShape.length)};
            let starts_i = ${getElementAt("uniforms.starts", "i", inputShape.length)};
            var output_index = ${output.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${input.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`;
      createSliceProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const axes = attributes.axes.length > 0 ? ShapeUtil.normalizeAxes(attributes.axes, inputShape.length) : [...Array(inputShape.length).keys()];
        let steps = readInput(inputs, 4);
        steps.forEach(
          (step) => step !== 0 || (() => {
            throw new Error("step cannot be 0");
          })
        );
        if (steps.length === 0) {
          steps = Array(axes.length).fill(1);
        }
        const starts = attributes.starts.map((start, i) => fixStartEndValues(start, i, inputShape, axes, steps));
        const ends = attributes.ends.map((end, i) => fixStartEndValues(end, i, inputShape, axes, steps));
        if (axes.length !== starts.length || axes.length !== ends.length) {
          throw new Error("start, ends and axes should have the same number of elements");
        }
        if (axes.length !== inputShape.length) {
          for (let i = 0; i < inputShape.length; ++i) {
            if (!axes.includes(i)) {
              starts.splice(i, 0, 0);
              ends.splice(i, 0, inputShape[i]);
              steps.splice(i, 0, 1);
            }
          }
        }
        const signs = steps.map((step) => Math.sign(step));
        steps.forEach((step, i, array) => {
          if (step < 0) {
            const numSteps = (ends[i] - starts[i]) / step;
            const newEnd = starts[i];
            const newStart = newEnd + numSteps * steps[i];
            starts[i] = newStart;
            ends[i] = newEnd;
            array[i] = -step;
          }
        });
        const outputShape = inputShape.slice(0);
        axes.forEach((axis, _) => {
          outputShape[axis] = Math.ceil((ends[axis] - starts[axis]) / steps[axis]);
        });
        const outputTensorInfo = { dims: outputShape, dataType: inputs[0].dataType };
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
        const outputSize = ShapeUtil.size(outputShape);
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "starts", type: "u32", length: starts.length },
          { name: "signs", type: "i32", length: signs.length },
          { name: "steps", type: "u32", length: steps.length }
        ];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: starts },
          { type: 6 /* int32 */, data: signs },
          { type: 12 /* uint32 */, data: steps },
          ...createTensorShapeVariables(inputs[0].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
        ${calculateInputIndicesImpl(input, output, inputShape)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${output.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
      }`;
        return {
          name: "Slice",
          shaderCache: { hint: `${signs.length}_${starts.length}_${steps.length}`, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [outputTensorInfo],
            dispatchGroup: { x: Math.ceil(
              inputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      slice = (context, attributes) => {
        validateInputs29(context.inputs, attributes);
        const updatedAttributes = createSliceAttributesFromInputs(context.inputs, attributes);
        context.compute(createSliceProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
      parseSliceAttributes = (attributes) => {
        const starts = attributes.starts;
        const ends = attributes.ends;
        const axes = attributes.axes;
        return createAttributeWithCacheKey({ starts, ends, axes });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/softmax.ts
  var validateInputs30, createSoftmaxProgramInfo, softmax, parseSoftmaxAttributes;
  var init_softmax = __esm({
    "web/lib/wasm/jsep/webgpu/ops/softmax.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_transpose();
      init_common();
      validateInputs30 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Softmax op requires 1 input.");
        }
      };
      createSoftmaxProgramInfo = (context, attributes) => {
        const input = context.inputs[0];
        const inputShape = input.dims;
        const outputSize = ShapeUtil.size(inputShape);
        const inputRank = inputShape.length;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const isTransposeRequired = axis < inputShape.length - 1;
        let transposedInput;
        let perm = [];
        if (isTransposeRequired) {
          perm = Array.from({ length: inputRank }, (_, i) => i);
          perm[axis] = inputRank - 1;
          perm[inputRank - 1] = axis;
          transposedInput = context.compute(createTransposeProgramInfo(input, perm), {
            inputs: [input],
            outputs: [-1]
          })[0];
        } else {
          transposedInput = input;
        }
        const transposedInputShape = transposedInput.dims;
        const cols = transposedInputShape[inputRank - 1];
        const rows = outputSize / cols;
        const components = getMaxComponents(cols);
        const packedCols = cols / components;
        let WG = 64;
        if (rows === 1) {
          WG = 256;
        }
        const maxVector = (name, components2) => {
          if (components2 === 4) {
            return `max(max(${name}.x, ${name}.y), max(${name}.z, ${name}.w))`;
          } else if (components2 === 2) {
            return `max(${name}.x, ${name}.y)`;
          } else if (components2 === 3) {
            return `max(max(${name}.x, ${name}.y), ${name}.z)`;
          }
          return name;
        };
        const x = inputVariable("x", transposedInput.dataType, transposedInput.dims, components);
        const output = outputVariable("result", transposedInput.dataType, transposedInput.dims, components);
        const valueType = x.type.value;
        const threadMaxDecl = tensorTypeToWsglStorageType(transposedInput.dataType) === "f32" ? `var threadMax = ${valueType}(-3.402823e+38f);` : `var threadMax = ${valueType}(-65504.0h);`;
        const getShaderSource = (shaderHelper) => `
      var<workgroup> rowMaxShared : ${valueType};
      var<workgroup> rowSumShared : ${valueType};
      var<workgroup> threadShared : array<${valueType}, ${WG}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${valueType} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${valueType}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${shaderHelper.registerUniform("packedCols", "i32").declareVariables(x, output)}
      ${shaderHelper.mainStart(WG)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${WG};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${threadMaxDecl}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${valueType}(${maxVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${valueType}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${valueType}(${sumVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          // max operation protects against NaN since all values should be >=0
          value = max(value, ${valueType}(0.0));
          setValue(row, col, row_stride, value);
        }
      }`;
        const result = context.compute(
          {
            name: "Softmax",
            // Note that in JSEP, WG size is not included in cache by default, but WebGPU EP it is.
            shaderCache: { hint: `${components};${WG}`, inputDependencies: ["type"] },
            getRunData: () => ({
              outputs: [{ dims: transposedInputShape, dataType: transposedInput.dataType }],
              dispatchGroup: { x: rows },
              programUniforms: [{ type: 6 /* int32 */, data: packedCols }]
            }),
            getShaderSource
          },
          {
            inputs: [transposedInput],
            outputs: [isTransposeRequired ? -1 : 0]
          }
        )[0];
        if (isTransposeRequired) {
          context.compute(createTransposeProgramInfo(result, perm), {
            inputs: [result]
          });
        }
      };
      softmax = (context, attributes) => {
        validateInputs30(context.inputs);
        createSoftmaxProgramInfo(context, attributes);
      };
      parseSoftmaxAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/tile.ts
  var getRepeats, validateInputs31, getOutputShape2, createTileProgramInfo, tile;
  var init_tile = __esm({
    "web/lib/wasm/jsep/webgpu/ops/tile.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      getRepeats = (repeatsTensorView) => Array.from(repeatsTensorView.getBigInt64Array(), Number);
      validateInputs31 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Tile requires 2 inputs.");
        }
        if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */ && inputs[0].dataType !== 6 /* int32 */ && inputs[0].dataType !== 12 /* uint32 */) {
          throw new Error("Tile only support float, float16, int32, and uint32 data types");
        }
        if (inputs[1].dataType !== 7 /* int64 */) {
          throw new Error("Tile `repeats` input should be of int64 data type");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("Tile `repeats` input should be 1-D");
        }
        const repeats = getRepeats(inputs[1]);
        if (repeats.length !== inputs[0].dims.length) {
          throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
        }
      };
      getOutputShape2 = (inputShape, repeats) => {
        const outputShape = [];
        for (let i = 0; i < inputShape.length; ++i) {
          outputShape.push(inputShape[i] * repeats[i]);
        }
        return outputShape;
      };
      createTileProgramInfo = (inputs, shape) => {
        const inputShape = inputs[0].dims;
        const repeats = shape == null ? getRepeats(inputs[1]) : shape;
        const outputShape = getOutputShape2(inputShape, repeats);
        const outputSize = ShapeUtil.size(outputShape);
        const dataType = inputs[0].dataType;
        const input = inputVariable("input", dataType, inputShape.length);
        const output = outputVariable("output", dataType, outputShape.length);
        const getShaderSource = (shaderHelper) => `
      const inputShape = ${input.indices(...inputShape)};
      ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${output.offsetToIndices("global_idx")};
      var input_indices: ${input.type.indices};
      for (var i = 0; i < ${inputShape.length}; i++) {
        let input_dim_i = ${input.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${output.indicesGet("output_indices", "i")}  % input_dim_i;

        ${input.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
    }`;
        return {
          name: "Tile",
          shaderCache: { hint: `${repeats}`, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(inputs[0].dims, outputShape)
            ]
          }),
          getShaderSource
        };
      };
      tile = (context) => {
        validateInputs31(context.inputs);
        context.compute(createTileProgramInfo(context.inputs), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/where.ts
  var createWhereOpProgramShader, createWhereOpProgramInfo, where;
  var init_where = __esm({
    "web/lib/wasm/jsep/webgpu/ops/where.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      createWhereOpProgramShader = (shaderHelper, inputs, dimsOutput, isBroadcast, typeOutput) => {
        const output = outputVariable("output_data", typeOutput, dimsOutput.length, 4);
        const a = inputVariable("a_data", inputs[1].dataType, inputs[1].dims.length, 4);
        const b = inputVariable("b_data", inputs[2].dataType, inputs[2].dims.length, 4);
        const c = inputVariable("c_data", inputs[0].dataType, inputs[0].dims.length, 4);
        let assignment;
        const expression = (a2, b2, c2) => `select(${b2}, ${a2}, ${c2})`;
        if (!isBroadcast) {
          assignment = output.setByOffset(
            "global_idx",
            expression(a.getByOffset("global_idx"), b.getByOffset("global_idx"), c.getByOffset("global_idx"))
          );
        } else {
          const singleAssignment = (resStr, x, typeCast = "") => {
            const expressionA = `a_data[index_a${x}][component_a${x}]`;
            const expressionB = `b_data[index_b${x}][component_b${x}]`;
            const expressionC = `bool(c_data[index_c${x}] & (0xffu << (component_c${x} * 8)))`;
            return `
            let output_indices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offset_a${x} = ${a.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_b${x} = ${b.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_c${x} = ${c.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let index_a${x} = offset_a${x} / 4u;
            let index_b${x} = offset_b${x} / 4u;
            let index_c${x} = offset_c${x} / 4u;
            let component_a${x} = offset_a${x} % 4u;
            let component_b${x} = offset_b${x} % 4u;
            let component_c${x} = offset_c${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expression(expressionA, expressionB, expressionC)});
          `;
          };
          if (typeOutput === 9 /* bool */) {
            assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
          } else {
            assignment = `
            ${singleAssignment("output_data[global_idx]", 0)}
            ${singleAssignment("output_data[global_idx]", 1)}
            ${singleAssignment("output_data[global_idx]", 2)}
            ${singleAssignment("output_data[global_idx]", 3)}
          `;
          }
        }
        return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(c, a, b, output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
      };
      createWhereOpProgramInfo = (inputs) => {
        const dimsA = inputs[1].dims;
        const dimsB = inputs[2].dims;
        const dimsC = inputs[0].dims;
        const outputDataType = inputs[1].dataType;
        const isBroadcast = !(ShapeUtil.areEqual(dimsA, dimsB) && ShapeUtil.areEqual(dimsB, dimsC));
        let outputShape = dimsA;
        let outputSize = ShapeUtil.size(dimsA);
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(BroadcastUtil.calcShape(dimsA, dimsB, false), dimsC, false);
          if (!calculatedShape) {
            throw new Error("Can't perform where op on the given tensors");
          }
          outputShape = calculatedShape;
          outputSize = ShapeUtil.size(outputShape);
        }
        const vecSize = Math.ceil(outputSize / 4);
        return {
          name: "Where",
          shaderCache: { inputDependencies: ["rank", "rank", "rank"] },
          getShaderSource: (shaderHelper) => createWhereOpProgramShader(shaderHelper, inputs, outputShape, isBroadcast, outputDataType),
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64 / 4
              /* vec size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: vecSize },
              ...createTensorShapeVariables(dimsC, dimsA, dimsB, outputShape)
            ]
          })
        };
      };
      where = (context) => {
        context.compute(createWhereOpProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/op-resolve-rules.ts
  var WEBGPU_OP_RESOLVE_RULES;
  var init_op_resolve_rules = __esm({
    "web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"() {
      "use strict";
      init_argminmax();
      init_attention();
      init_batch_norm();
      init_bias_add();
      init_bias_split_gelu();
      init_binary_op();
      init_concat();
      init_conv();
      init_conv_transpose();
      init_cumsum();
      init_depth_to_space();
      init_einsum();
      init_expand();
      init_fast_gelu();
      init_gather();
      init_gather_nd();
      init_gather_block_quantized();
      init_gather_elements();
      init_gemm();
      init_grid_sample();
      init_group_query_attention();
      init_instance_norm();
      init_layer_norm();
      init_matmul();
      init_matmulnbits();
      init_multihead_attention();
      init_pad();
      init_pool();
      init_quantize_linear();
      init_range();
      init_scatter_nd();
      init_reduce();
      init_resize();
      init_rotary_embedding();
      init_skip_layer_norm();
      init_slice();
      init_softmax();
      init_split();
      init_tile();
      init_transpose();
      init_unary_op();
      init_where();
      WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([
        ["Abs", [abs]],
        ["Acos", [acos]],
        ["Acosh", [acosh]],
        ["Add", [add]],
        ["ArgMax", [argMax, parseArgMinMaxAttributes]],
        ["ArgMin", [argMin, parseArgMinMaxAttributes]],
        ["Asin", [asin]],
        ["Asinh", [asinh]],
        ["Atan", [atan]],
        ["Atanh", [atanh]],
        ["Attention", [attention]],
        // TODO: support new attributes for AveragePool-10
        ["AveragePool", [averagePool, parseAveragePoolAttributes]],
        ["BatchNormalization", [batchNorm]],
        ["BiasAdd", [biasAdd]],
        ["BiasSplitGelu", [biasSplitGelu]],
        ["Cast", [cast, parseCastAttributes]],
        ["Ceil", [ceil]],
        ["Clip", [clip]],
        ["Concat", [concat, parseConcatAttributes]],
        ["Conv", [conv, parseConvAttributes]],
        ["ConvTranspose", [convTranspose, parseConvTransposeAttributes]],
        ["Cos", [cos]],
        ["Cosh", [cosh]],
        ["CumSum", [cumsum, parseCumSumAttributes]],
        ["DepthToSpace", [depthToSpace, parseDepthToSpaceAttributes]],
        ["DequantizeLinear", [dequantizeLinear, parseDequantizeLinearAttributes]],
        ["Div", [div]],
        ["Einsum", [einsum, parseEinsumAttributes]],
        ["Elu", [elu, parseAlphaAttributes]],
        ["Equal", [equal]],
        ["Erf", [erf]],
        ["Exp", [exp]],
        ["Expand", [expand]],
        ["FastGelu", [fastGelu2]],
        ["Floor", [floor]],
        ["FusedConv", [conv, parseConvAttributes]],
        ["Gather", [gather, parseGatherAttributes]],
        ["GatherElements", [gatherElements, parseGatherElementsAttributes]],
        ["GatherBlockQuantized", [gatherBlockQuantized, parseGatherBlockQuantizedAttributes]],
        ["GatherND", [gatherND, parseGatherNDAttributes]],
        ["Gelu", [gelu]],
        ["Gemm", [gemm, parseGemmAttributes]],
        ["GlobalAveragePool", [globalAveragePool, parseGlobalAveragePoolAttributes]],
        ["GlobalMaxPool", [globalMaxPool, parseGlobalMaxPoolAttributes]],
        ["Greater", [greater]],
        ["GreaterOrEqual", [greaterOrEqual]],
        ["GridSample", [gridSample, parseGridSampleAttributes]],
        ["GroupQueryAttention", [groupQueryAttention]],
        ["HardSigmoid", [hardSigmoid, parseHardSigmoidAttributes]],
        ["InstanceNormalization", [instanceNorm]],
        ["LayerNormalization", [layerNorm]],
        ["LeakyRelu", [leakyRelu, parseAlphaAttributes]],
        ["Less", [less]],
        ["LessOrEqual", [lessOrEqual]],
        ["Log", [log]],
        ["MatMul", [matMul]],
        ["MatMulNBits", [matMulNBits, parseMatMulNBitsAttributes]],
        // TODO: support new attributes for MaxPool-8 and MaxPool-10
        ["MaxPool", [maxPool, parseMaxPoolAttributes]],
        ["Mul", [mul]],
        ["MultiHeadAttention", [multiHeadAttention, parseMultiHeadAttentionAttributes]],
        ["Neg", [neg]],
        ["Not", [not]],
        ["Pad", [pad]],
        ["Pow", [pow]],
        ["QuickGelu", [quickgelu, parseAlphaAttributes]],
        ["Range", [range]],
        ["Reciprocal", [reciprocal]],
        ["ReduceMin", [reduceMin]],
        ["ReduceMean", [reduceMean]],
        ["ReduceMax", [reduceMax]],
        ["ReduceSum", [reduceSum]],
        ["ReduceProd", [reduceProd]],
        ["ReduceL1", [reduceL1]],
        ["ReduceL2", [reduceL2]],
        ["ReduceLogSum", [reduceLogSum]],
        ["ReduceLogSumExp", [reduceLogSumExp]],
        ["ReduceSumSquare", [reduceSumSquare]],
        ["Relu", [relu]],
        ["Resize", [resize, parseResizeAttributes]],
        ["RotaryEmbedding", [rotaryEmbedding]],
        ["ScatterND", [scatterND, parseScatterNDAttributes]],
        ["Sigmoid", [sigmoid]],
        ["Sin", [sin]],
        ["Sinh", [sinh]],
        ["Slice", [slice, parseSliceAttributes]],
        ["SkipLayerNormalization", [skipLayerNorm]],
        ["Split", [split, parseSplitAttributes]],
        ["Sqrt", [sqrt]],
        ["Softmax", [softmax, parseSoftmaxAttributes]],
        ["Sub", [sub]],
        ["Tan", [tan]],
        ["Tanh", [tanh]],
        ["ThresholdedRelu", [thresholdedRelu, parseAlphaAttributes]],
        ["Tile", [tile]],
        ["Transpose", [transpose, parseTransposeAttributes]],
        ["Where", [where]]
      ]);
    }
  });

  // web/lib/wasm/jsep/webgpu/program-manager.ts
  var ProgramManager;
  var init_program_manager = __esm({
    "web/lib/wasm/jsep/webgpu/program-manager.ts"() {
      "use strict";
      init_esm();
      init_log();
      init_common();
      ProgramManager = class {
        constructor(backend) {
          this.backend = backend;
          this.repo = /* @__PURE__ */ new Map();
          this.attributesBound = false;
        }
        getArtifact(key) {
          return this.repo.get(key);
        }
        setArtifact(key, artifact) {
          this.repo.set(key, artifact);
        }
        run(buildArtifact, inputs, outputs, dispatchGroup, uniformBufferBinding) {
          TRACE_FUNC_BEGIN(buildArtifact.programInfo.name);
          const device = this.backend.device;
          const computePassEncoder = this.backend.getComputePassEncoder();
          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
          const entries = [];
          for (const input of inputs) {
            entries.push({ binding: entries.length, resource: { buffer: input.buffer } });
          }
          for (const output of outputs) {
            entries.push({ binding: entries.length, resource: { buffer: output.buffer } });
          }
          if (uniformBufferBinding) {
            entries.push({ binding: entries.length, resource: uniformBufferBinding });
          }
          const bindGroup = device.createBindGroup({
            layout: buildArtifact.computePipeline.getBindGroupLayout(0),
            entries,
            label: buildArtifact.programInfo.name
          });
          if (this.backend.sessionStatus === "capturing") {
            const commandInfo = {
              kernelId: this.backend.currentKernelId,
              computePipeline: buildArtifact.computePipeline,
              bindGroup,
              dispatchGroup
            };
            const sessionCommandList = this.backend.capturedCommandList.get(this.backend.currentSessionId);
            sessionCommandList.push(commandInfo);
          }
          computePassEncoder.setPipeline(buildArtifact.computePipeline);
          computePassEncoder.setBindGroup(0, bindGroup);
          computePassEncoder.dispatchWorkgroups(...dispatchGroup);
          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1);
          this.backend.pendingDispatchNumber++;
          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") {
            this.backend.endComputePass();
          }
          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber) {
            this.backend.flush();
          }
          TRACE_FUNC_END(buildArtifact.programInfo.name);
        }
        dispose() {
        }
        build(programInfo, normalizedDispatchGroupSize) {
          TRACE_FUNC_BEGIN(programInfo.name);
          const device = this.backend.device;
          const enableDirectives = [];
          const extensionsInfo = [
            { feature: "shader-f16", extension: "f16" },
            { feature: "subgroups", extension: "subgroups" }
          ];
          extensionsInfo.forEach((info) => {
            if (device.features.has(info.feature)) {
              enableDirectives.push(`enable ${info.extension};`);
            }
          });
          const shaderHelper = createShaderHelper(normalizedDispatchGroupSize, this.backend.device.limits);
          const userCode = programInfo.getShaderSource(shaderHelper);
          const code = `${enableDirectives.join("\n")}
${shaderHelper.additionalImplementations}
${userCode}`;
          const shaderModule = device.createShaderModule({ code, label: programInfo.name });
          LOG_DEBUG("verbose", () => `[WebGPU] ${programInfo.name} shader code: ${code}`);
          const computePipeline = device.createComputePipeline({
            compute: { module: shaderModule, entryPoint: "main" },
            layout: "auto",
            label: programInfo.name
          });
          TRACE_FUNC_END(programInfo.name);
          return { programInfo, computePipeline, uniformVariablesInfo: shaderHelper.variablesInfo };
        }
        normalizeDispatchGroupSize(dispatchGroup) {
          const x = typeof dispatchGroup === "number" ? dispatchGroup : dispatchGroup.x;
          const y = typeof dispatchGroup === "number" ? 1 : dispatchGroup.y || 1;
          const z = typeof dispatchGroup === "number" ? 1 : dispatchGroup.z || 1;
          const limitPerDimension = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
          if (x <= limitPerDimension && y <= limitPerDimension && z <= limitPerDimension) {
            return [x, y, z];
          }
          const size = x * y * z;
          let dispatchAverage = Math.ceil(Math.sqrt(size));
          if (dispatchAverage > limitPerDimension) {
            dispatchAverage = Math.ceil(Math.cbrt(size));
            if (dispatchAverage > limitPerDimension) {
              throw new Error("Total dispatch size exceeds WebGPU maximum.");
            }
            return [dispatchAverage, dispatchAverage, dispatchAverage];
          } else {
            return [dispatchAverage, dispatchAverage, 1];
          }
        }
      };
    }
  });

  // web/lib/wasm/jsep/backend-webgpu.ts
  var backend_webgpu_exports = {};
  __export(backend_webgpu_exports, {
    WebGpuBackend: () => WebGpuBackend
  });
  var getProgramInputTensorInfoDependencyKey, getProgramInfoUniqueKey, AdapterInfoImpl, WebGpuBackend;
  var init_backend_webgpu = __esm({
    "web/lib/wasm/jsep/backend-webgpu.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_log();
      init_tensor_view();
      init_gpu_data_manager();
      init_op_resolve_rules();
      init_program_manager();
      getProgramInputTensorInfoDependencyKey = (inputTensors, inputDependencies) => {
        if (inputDependencies.length !== inputTensors.length) {
          throw new Error(
            `inputDependencies length ${inputDependencies.length} is not equal to inputTensors length ${inputTensors.length}.`
          );
        }
        const inputInfos = [];
        for (let i = 0; i < inputTensors.length; ++i) {
          const type = inputTensors[i].dataType;
          switch (inputDependencies[i]) {
            case "none": {
              inputInfos.push("");
              break;
            }
            case "type": {
              inputInfos.push(`${type}`);
              break;
            }
            case "rank": {
              const rank = inputTensors[i].dims.length;
              inputInfos.push(`${type};${rank}`);
              break;
            }
            case "dims": {
              const dims = inputTensors[i].dims.join(",");
              inputInfos.push(`${type};${dims}`);
              break;
            }
            default:
              throw new Error(`unsupported input dependency: ${inputDependencies[i]}`);
          }
        }
        return inputInfos.join("|");
      };
      getProgramInfoUniqueKey = (programInfo, inputTensors, is1DimensionDispatch) => {
        let key = programInfo.name;
        if (programInfo.shaderCache?.hint) {
          key += "[" + programInfo.shaderCache.hint + "]";
        }
        key += ":" + is1DimensionDispatch + `:${getProgramInputTensorInfoDependencyKey(
          inputTensors,
          programInfo.shaderCache?.inputDependencies ?? new Array(inputTensors.length).fill("dims")
        )}`;
        return key;
      };
      AdapterInfoImpl = class {
        constructor(adapterInfo) {
          if (adapterInfo) {
            this.architecture = adapterInfo.architecture;
            this.vendor = adapterInfo.vendor;
          }
        }
        isArchitecture(architecture) {
          return this.architecture === architecture;
        }
        isVendor(vendor) {
          return this.vendor === vendor;
        }
      };
      WebGpuBackend = class {
        constructor() {
          /**
           * representing the session ID of which is currently being run.
           * `null` means no session is being run.
           * only valid when session.run is executed.
           */
          this.currentSessionId = null;
          /**
           * representing the kernel ID of which is currently being computed (CPU code perspective).
           * `null` means no kernel is being computed.
           * only one kernel can be computed at a moment.
           */
          this.currentKernelId = null;
          this.commandEncoder = null;
          this.computePassEncoder = null;
          this.maxDispatchNumber = 16;
          this.pendingDispatchNumber = 0;
          // info of kernels pending submission for a single batch
          this.pendingKernels = [];
          // queryReadBuffer -> pendingKernels mapping for all the batches
          this.pendingQueries = /* @__PURE__ */ new Map();
          this.sessionStatus = "default";
          /**
           * a SessionID -> CommandInfo[] mapping. It's used to record all GPU commands for corresponding session.
           */
          this.capturedCommandList = /* @__PURE__ */ new Map();
          /**
           * a SessionID -> PendingKernelInfo[] mapping for profiling.
           */
          this.capturedPendingKernels = /* @__PURE__ */ new Map();
          /**
           * a SessionID -> a Map of (InputOutputIndex -> [ID, GPUBuffer]) mapping.
           */
          this.sessionExternalDataMapping = /* @__PURE__ */ new Map();
        }
        /**
         * get the custom data of the current kernel
         */
        get currentKernelCustomData() {
          if (this.currentKernelId === null) {
            throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
          }
          let data = this.kernelCustomData.get(this.currentKernelId);
          if (!data) {
            data = {};
            this.kernelCustomData.set(this.currentKernelId, data);
          }
          return data;
        }
        async initialize(env3, adapter) {
          this.env = env3;
          const requiredFeatures = [];
          const deviceDescriptor = {
            requiredLimits: {
              maxComputeWorkgroupStorageSize: adapter.limits.maxComputeWorkgroupStorageSize,
              maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,
              maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
              maxBufferSize: adapter.limits.maxBufferSize,
              maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,
              maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,
              maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,
              maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ
            },
            requiredFeatures
          };
          const requireFeatureIfAvailable = (feature) => adapter.features.has(feature) && requiredFeatures.push(feature) && true;
          if (!requireFeatureIfAvailable("chromium-experimental-timestamp-query-inside-passes")) {
            requireFeatureIfAvailable("timestamp-query");
          }
          requireFeatureIfAvailable("shader-f16");
          requireFeatureIfAvailable("subgroups");
          this.device = await adapter.requestDevice(deviceDescriptor);
          this.adapterInfo = new AdapterInfoImpl(adapter.info || await adapter.requestAdapterInfo());
          this.gpuDataManager = createGpuDataManager(this);
          this.programManager = new ProgramManager(this);
          this.kernels = /* @__PURE__ */ new Map();
          this.kernelPersistentData = /* @__PURE__ */ new Map();
          this.kernelCustomData = /* @__PURE__ */ new Map();
          configureLogger(env3.logLevel, !!env3.debug);
          this.device.onuncapturederror = (ev) => {
            if (ev.error instanceof GPUValidationError) {
              console.error(`An uncaught WebGPU validation error was raised: ${ev.error.message}`);
            }
          };
          Object.defineProperty(this.env.webgpu, "device", {
            value: this.device,
            writable: false,
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(this.env.webgpu, "adapter", {
            value: adapter,
            writable: false,
            enumerable: true,
            configurable: false
          });
          this.setQueryType();
        }
        dispose() {
          if (typeof this.querySet !== "undefined") {
            this.querySet.destroy();
          }
          this.gpuDataManager.dispose();
        }
        getCommandEncoder() {
          if (!this.commandEncoder) {
            this.commandEncoder = this.device.createCommandEncoder();
          }
          return this.commandEncoder;
        }
        getComputePassEncoder() {
          if (!this.computePassEncoder) {
            const commandEncoder = this.getCommandEncoder();
            const computePassDescriptor = {};
            if (this.queryType === "at-passes") {
              computePassDescriptor.timestampWrites = {
                querySet: this.querySet,
                beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
                endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
              };
            }
            this.computePassEncoder = commandEncoder.beginComputePass(computePassDescriptor);
          }
          return this.computePassEncoder;
        }
        endComputePass() {
          if (this.computePassEncoder) {
            this.computePassEncoder.end();
            this.computePassEncoder = null;
          }
        }
        flush() {
          if (!this.commandEncoder) {
            return;
          }
          TRACE_FUNC_BEGIN();
          this.endComputePass();
          let queryReadBuffer;
          if (this.queryType !== "none") {
            this.commandEncoder.resolveQuerySet(
              this.querySet,
              0,
              this.pendingDispatchNumber * 2,
              this.queryResolveBuffer,
              0
            );
            queryReadBuffer = this.device.createBuffer(
              // eslint-disable-next-line no-bitwise
              { size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }
            );
            this.pendingQueries.set(queryReadBuffer, this.pendingKernels);
            this.pendingKernels = [];
            this.commandEncoder.copyBufferToBuffer(
              this.queryResolveBuffer,
              0,
              queryReadBuffer,
              0,
              this.pendingDispatchNumber * 2 * 8
            );
          }
          this.device.queue.submit([this.commandEncoder.finish()]);
          this.gpuDataManager.refreshPendingBuffers();
          this.commandEncoder = null;
          this.pendingDispatchNumber = 0;
          if (this.queryType !== "none") {
            void queryReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
              const mappedData = new BigUint64Array(queryReadBuffer.getMappedRange());
              const pendingKernels = this.pendingQueries.get(queryReadBuffer);
              for (let i = 0; i < mappedData.length / 2; i++) {
                const pendingKernelInfo = pendingKernels[i];
                const kernelId = pendingKernelInfo.kernelId;
                const kernelInfo = this.kernels.get(kernelId);
                const kernelType = kernelInfo.kernelType;
                const kernelName = kernelInfo.kernelName;
                const programName = pendingKernelInfo.programName;
                const inputTensorViews = pendingKernelInfo.inputTensorViews;
                const outputTensorViews = pendingKernelInfo.outputTensorViews;
                const startTimeU64 = mappedData[i * 2];
                const endTimeU64 = mappedData[i * 2 + 1];
                if (typeof this.queryTimeBase === "undefined") {
                  this.queryTimeBase = startTimeU64;
                }
                const startTime = Number(startTimeU64 - this.queryTimeBase);
                const endTime = Number(endTimeU64 - this.queryTimeBase);
                if (!Number.isSafeInteger(startTime) || !Number.isSafeInteger(endTime)) {
                  throw new RangeError("incorrect timestamp range");
                }
                if (this.env.webgpu.profiling?.ondata) {
                  this.env.webgpu.profiling.ondata({
                    version: 1,
                    inputsMetadata: inputTensorViews.map((value) => ({
                      dims: value.dims,
                      dataType: tensorDataTypeEnumToString(value.dataType)
                    })),
                    outputsMetadata: outputTensorViews.map((value) => ({
                      dims: value.dims,
                      dataType: tensorDataTypeEnumToString(value.dataType)
                    })),
                    kernelId,
                    kernelType,
                    kernelName,
                    programName,
                    startTime,
                    endTime
                  });
                } else {
                  let inputShapes = "";
                  inputTensorViews.forEach((value, i2) => {
                    inputShapes += `input[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                  });
                  let outputShapes = "";
                  outputTensorViews.forEach((value, i2) => {
                    outputShapes += `output[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                  });
                  console.log(
                    `[profiling] kernel "${kernelId}|${kernelType}|${kernelName}|${programName}" ${inputShapes}${outputShapes}start time: ${startTime} ns, execution time: ${endTime - startTime} ns`
                  );
                }
                TRACE("GPU", `${programName}::${startTimeU64}::${endTimeU64}`);
              }
              queryReadBuffer.unmap();
              this.pendingQueries.delete(queryReadBuffer);
            });
          }
          TRACE_FUNC_END();
        }
        /**
         * run a WebGPU program.
         * @param program a ProgramInfo instance
         * @param inputTensorViews a TensorView array. each element represents a value already exists in GPU.
         * @param outputIndices an indices array. each element can be either -1 (temporary data), -2 (persistent data) or an
         * index to the kernel's output.
         * @param createKernelOutput a callback function that create a value to kernel's output with the given index
         * @param createIntermediateOutput a callback function that create a value as a intermediate value, either temporary
         * or persistent (owned by the current kernel)
         * @returns a TensorView array representing the result.
         */
        run(program, inputTensorViews, outputIndices, createKernelOutput, createIntermediateOutput, outputCount) {
          TRACE_FUNC_BEGIN(program.name);
          const inputDatas = [];
          for (let i = 0; i < inputTensorViews.length; ++i) {
            const data = inputTensorViews[i].data;
            if (data === 0) {
              continue;
            }
            const gpuData = this.gpuDataManager.get(data);
            if (!gpuData) {
              throw new Error(`no GPU data for input: ${data}`);
            }
            inputDatas.push(gpuData);
          }
          const { outputs, dispatchGroup, programUniforms } = program.getRunData(inputTensorViews);
          const validatedOutputIndices = outputIndices.length === 0 ? outputs.map((_, i) => i) : outputIndices;
          if (validatedOutputIndices.length !== outputs.length) {
            throw new Error(`Output size ${validatedOutputIndices.length} must be equal to ${outputs.length}.`);
          }
          const outputTensorViews = [];
          const outputDatas = [];
          for (let i = 0; i < outputs.length; ++i) {
            if (!Number.isInteger(validatedOutputIndices[i]) || validatedOutputIndices[i] < -3 || validatedOutputIndices[i] >= outputCount) {
              throw new Error(`Invalid output index: ${validatedOutputIndices[i]}`);
            }
            if (validatedOutputIndices[i] === -3) {
              continue;
            }
            const isTemporary = validatedOutputIndices[i] === -1;
            const isPersistent = validatedOutputIndices[i] === -2;
            const tensorView = isTemporary || isPersistent ? createIntermediateOutput(outputs[i].dataType, outputs[i].dims) : createKernelOutput(validatedOutputIndices[i], outputs[i].dataType, outputs[i].dims);
            outputTensorViews.push(tensorView);
            if (tensorView.data === 0) {
              continue;
            }
            const gpuData = this.gpuDataManager.get(tensorView.data);
            if (!gpuData) {
              throw new Error(`no GPU data for output: ${tensorView.data}`);
            }
            if (isTemporary) {
              this.temporaryData.push(gpuData);
            }
            if (isPersistent) {
              let persistentData = this.kernelPersistentData.get(this.currentKernelId);
              if (!persistentData) {
                persistentData = [];
                this.kernelPersistentData.set(this.currentKernelId, persistentData);
              }
              persistentData.push(gpuData);
            }
            outputDatas.push(gpuData);
          }
          if (inputDatas.length !== inputTensorViews.length || outputDatas.length !== outputTensorViews.length) {
            if (outputDatas.length === 0) {
              TRACE_FUNC_END(program.name);
              return outputTensorViews;
            }
            throw new Error(
              `Program ${program.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`
            );
          }
          let uniformBufferBinding;
          if (programUniforms) {
            let currentOffset = 0;
            const offsets = [];
            programUniforms.forEach((v) => {
              const data = typeof v.data === "number" ? [v.data] : v.data;
              if (data.length === 0) {
                return;
              }
              const sizeOfElement = v.type === 10 /* float16 */ ? 2 : 4;
              let sizeOfVecOrMat;
              let baseAlignment;
              if (v.type === 10 /* float16 */) {
                baseAlignment = data.length > 4 ? 16 : data.length > 2 ? 8 : data.length * sizeOfElement;
                sizeOfVecOrMat = data.length > 4 ? 16 : sizeOfElement * data.length;
              } else {
                baseAlignment = data.length <= 2 ? data.length * sizeOfElement : 16;
                sizeOfVecOrMat = 16;
              }
              currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;
              offsets.push(currentOffset);
              const elementPerVecOrMat = v.type === 10 /* float16 */ ? 8 : 4;
              currentOffset += data.length > 4 ? Math.ceil(data.length / elementPerVecOrMat) * sizeOfVecOrMat : data.length * sizeOfElement;
            });
            const maxAlignmentOfField = 16;
            currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;
            const arrayBuffer = new ArrayBuffer(currentOffset);
            programUniforms.forEach((v, i) => {
              const offset = offsets[i];
              const data = typeof v.data === "number" ? [v.data] : v.data;
              if (v.type === 6 /* int32 */) {
                new Int32Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 12 /* uint32 */) {
                new Uint32Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 10 /* float16 */) {
                new Uint16Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 1 /* float */) {
                new Float32Array(arrayBuffer, offset, data.length).set(data);
              } else {
                throw new Error(`Unsupported uniform type: ${tensorDataTypeEnumToString(v.type)}`);
              }
            });
            const uniformBufferData = (
              // eslint-disable-next-line no-bitwise
              this.gpuDataManager.create(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM)
            );
            this.device.queue.writeBuffer(uniformBufferData.buffer, 0, arrayBuffer, 0, currentOffset);
            this.gpuDataManager.release(uniformBufferData.id);
            uniformBufferBinding = { offset: 0, size: currentOffset, buffer: uniformBufferData.buffer };
          }
          const normalizedDispatchGroup = this.programManager.normalizeDispatchGroupSize(dispatchGroup);
          const is1DimensionDispatch = normalizedDispatchGroup[1] === 1 && normalizedDispatchGroup[2] === 1;
          const key = getProgramInfoUniqueKey(program, inputTensorViews, is1DimensionDispatch);
          let artifact = this.programManager.getArtifact(key);
          if (!artifact) {
            artifact = this.programManager.build(program, normalizedDispatchGroup);
            this.programManager.setArtifact(key, artifact);
            LOG_DEBUG("info", () => `[artifact] key: ${key}, programName: ${program.name}`);
          }
          if (programUniforms && artifact.uniformVariablesInfo) {
            if (programUniforms.length !== artifact.uniformVariablesInfo.length) {
              throw new Error(
                `Uniform variables count mismatch: expect ${artifact.uniformVariablesInfo.length}, got ${programUniforms.length} in program "${artifact.programInfo.name}".`
              );
            }
            for (let i = 0; i < programUniforms.length; i++) {
              const uniform = programUniforms[i];
              const actualType = uniform.type;
              const actualLength = typeof uniform.data === "number" ? 1 : uniform.data.length;
              const [type, length] = artifact.uniformVariablesInfo[i];
              if (actualType !== type || actualLength !== length) {
                throw new Error(
                  `Uniform variable ${i} mismatch: expect type ${type} with size ${length}, got type ${actualType} with size ${actualLength} in program "${artifact.programInfo.name}".`
                );
              }
            }
          }
          LOG_DEBUG(
            "info",
            () => `[ProgramManager] run "${program.name}" (key=${key}) with ${normalizedDispatchGroup[0]}x${normalizedDispatchGroup[1]}x${normalizedDispatchGroup[2]}`
          );
          if (this.queryType !== "none" || this.sessionStatus === "capturing") {
            const pendingKernelInfo = {
              kernelId: this.currentKernelId,
              programName: artifact.programInfo.name,
              inputTensorViews,
              outputTensorViews
            };
            this.pendingKernels.push(pendingKernelInfo);
            if (this.sessionStatus === "capturing") {
              const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
              sessionPendingKernels.push(pendingKernelInfo);
            }
          }
          this.programManager.run(artifact, inputDatas, outputDatas, normalizedDispatchGroup, uniformBufferBinding);
          TRACE_FUNC_END(program.name);
          return outputTensorViews;
        }
        upload(gpuDataId, data) {
          this.gpuDataManager.upload(gpuDataId, data);
        }
        memcpy(src, dst) {
          this.gpuDataManager.memcpy(src, dst);
        }
        async download(gpuDataId, getTargetBuffer) {
          await this.gpuDataManager.download(gpuDataId, getTargetBuffer);
        }
        alloc(size) {
          return this.gpuDataManager.create(size).id;
        }
        free(ptr) {
          return this.gpuDataManager.release(ptr);
        }
        createKernel(kernelType, kernelId, attribute, kernelName) {
          const op = WEBGPU_OP_RESOLVE_RULES.get(kernelType);
          if (!op) {
            throw new Error(`kernel not implemented: ${kernelType}`);
          }
          const kernelInfo = {
            kernelType,
            kernelName,
            kernelEntry: op[0],
            attributes: [op[1], attribute]
          };
          this.kernels.set(kernelId, kernelInfo);
        }
        releaseKernel(kernelId) {
          const persistentData = this.kernelPersistentData.get(kernelId);
          if (persistentData) {
            for (const data of persistentData) {
              this.gpuDataManager.release(data.id);
            }
            this.kernelPersistentData.delete(kernelId);
          }
          this.kernelCustomData.delete(kernelId);
          this.kernels.delete(kernelId);
        }
        computeKernel(kernelId, context, errors) {
          const kernel = this.kernels.get(kernelId);
          if (!kernel) {
            throw new Error(`kernel not created: ${kernelId}`);
          }
          const kernelType = kernel.kernelType;
          const kernelName = kernel.kernelName;
          const kernelEntry = kernel.kernelEntry;
          const attributes = kernel.attributes;
          if (this.currentKernelId !== null) {
            throw new Error(`kernel "[${kernelType}] ${kernelName}" is not allowed to be called recursively`);
          }
          this.currentKernelId = kernelId;
          if (attributes[0]) {
            attributes[1] = attributes[0](attributes[1]);
            attributes[0] = void 0;
          }
          LOG_DEBUG("info", () => `[WebGPU] Start to run kernel "[${kernelType}] ${kernelName}"...`);
          const useErrorScope = this.env.debug;
          this.temporaryData = [];
          try {
            if (useErrorScope) {
              this.device.pushErrorScope("validation");
            }
            kernelEntry(context, attributes[1]);
            return 0;
          } catch (e) {
            errors.push(Promise.resolve(`[WebGPU] Kernel "[${kernelType}] ${kernelName}" failed. ${e}`));
            return 1;
          } finally {
            if (useErrorScope) {
              errors.push(
                this.device.popErrorScope().then(
                  (err) => err ? `GPU validation error for kernel "[${kernelType}] ${kernelName}": ${err.message}` : null
                )
              );
            }
            for (const data of this.temporaryData) {
              this.gpuDataManager.release(data.id);
            }
            this.temporaryData = [];
            this.currentKernelId = null;
          }
        }
        // #region external buffer
        registerBuffer(sessionId, index, buffer, size) {
          let sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
          if (!sessionInputOutputMapping) {
            sessionInputOutputMapping = /* @__PURE__ */ new Map();
            this.sessionExternalDataMapping.set(sessionId, sessionInputOutputMapping);
          }
          const previousBuffer = sessionInputOutputMapping.get(index);
          const id = this.gpuDataManager.registerExternalBuffer(buffer, size, previousBuffer);
          sessionInputOutputMapping.set(index, [id, buffer]);
          return id;
        }
        unregisterBuffers(sessionId) {
          const sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
          if (sessionInputOutputMapping) {
            sessionInputOutputMapping.forEach((bufferInfo) => this.gpuDataManager.unregisterExternalBuffer(bufferInfo[0]));
            this.sessionExternalDataMapping.delete(sessionId);
          }
        }
        getBuffer(gpuDataId) {
          const gpuData = this.gpuDataManager.get(gpuDataId);
          if (!gpuData) {
            throw new Error(`no GPU data for buffer: ${gpuDataId}`);
          }
          return gpuData.buffer;
        }
        createDownloader(gpuBuffer, size, type) {
          return async () => {
            const data = await downloadGpuData(this, gpuBuffer, size);
            return createView(data.buffer, type);
          };
        }
        // #endregion
        writeTimestamp(index) {
          if (this.queryType !== "inside-passes") {
            return;
          }
          this.computePassEncoder.writeTimestamp(this.querySet, index);
        }
        setQueryType() {
          this.queryType = "none";
          if (this.env.webgpu.profiling?.mode === "default" || (typeof this.env.trace === "undefined" ? this.env.wasm.trace : this.env.trace)) {
            if (this.device.features.has("chromium-experimental-timestamp-query-inside-passes")) {
              this.queryType = "inside-passes";
            } else if (this.device.features.has("timestamp-query")) {
              this.queryType = "at-passes";
            }
            if (this.queryType !== "none" && typeof this.querySet === "undefined") {
              this.querySet = this.device.createQuerySet({
                type: "timestamp",
                count: this.maxDispatchNumber * 2
              });
              this.queryResolveBuffer = this.device.createBuffer(
                // eslint-disable-next-line no-bitwise
                { size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE }
              );
            }
          }
        }
        captureBegin() {
          LOG_DEBUG("info", "captureBegin");
          if (!this.capturedCommandList.get(this.currentSessionId)) {
            this.capturedCommandList.set(this.currentSessionId, []);
          }
          if (!this.capturedPendingKernels.get(this.currentSessionId)) {
            this.capturedPendingKernels.set(this.currentSessionId, []);
          }
          this.flush();
          this.sessionStatus = "capturing";
        }
        captureEnd() {
          LOG_DEBUG("info", "captureEnd");
          this.flush();
          this.sessionStatus = "default";
        }
        replay() {
          LOG_DEBUG("info", "replay");
          this.sessionStatus = "replaying";
          const sessionCommandList = this.capturedCommandList.get(this.currentSessionId);
          const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
          const length = sessionCommandList.length;
          this.pendingKernels = [];
          for (let i = 0; i < length; i++) {
            const computePassEncoder = this.getComputePassEncoder();
            const command = sessionCommandList[i];
            this.writeTimestamp(this.pendingDispatchNumber * 2);
            computePassEncoder.setPipeline(command.computePipeline);
            computePassEncoder.setBindGroup(0, command.bindGroup);
            computePassEncoder.dispatchWorkgroups(...command.dispatchGroup);
            this.writeTimestamp(this.pendingDispatchNumber * 2 + 1);
            this.pendingDispatchNumber++;
            if (this.queryType !== "none") {
              this.pendingKernels.push(sessionPendingKernels[i]);
            }
            if (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") {
              this.endComputePass();
            }
            if (this.pendingDispatchNumber >= this.maxDispatchNumber) {
              this.flush();
            }
          }
          this.flush();
          this.sessionStatus = "default";
        }
        onCreateSession() {
          this.gpuDataManager.onCreateSession();
        }
        onReleaseSession(sessionId) {
          this.unregisterBuffers(sessionId);
          if (this.capturedCommandList.has(sessionId)) {
            this.capturedCommandList.delete(sessionId);
          }
          if (this.capturedPendingKernels.has(sessionId)) {
            this.capturedPendingKernels.delete(sessionId);
          }
          this.gpuDataManager.onReleaseSession(sessionId);
        }
        onRunStart(sessionId) {
          this.currentSessionId = sessionId;
          this.setQueryType();
        }
      };
    }
  });

  // web/lib/wasm/jsep/init.ts
  var init_exports = {};
  __export(init_exports, {
    init: () => init
  });
  var TensorViewImpl, ComputeContextImpl, init;
  var init_init = __esm({
    "web/lib/wasm/jsep/init.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_backend_webnn();
      TensorViewImpl = class _TensorViewImpl {
        constructor(module, dataType, data, dims) {
          this.module = module;
          this.dataType = dataType;
          this.data = data;
          this.dims = dims;
        }
        getFloat32Array() {
          if (this.dataType !== 1 /* float */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getBigInt64Array() {
          if (this.dataType !== 7 /* int64 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getInt32Array() {
          if (this.dataType !== 6 /* int32 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getUint16Array() {
          if (this.dataType !== 10 /* float16 */ && this.dataType !== 4 /* uint16 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Uint16Array() : new Uint16Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        reshape(newDims) {
          if (ShapeUtil.size(newDims) !== ShapeUtil.size(this.dims)) {
            throw new Error("Invalid new shape");
          }
          return new _TensorViewImpl(this.module, this.dataType, this.data, newDims);
        }
      };
      ComputeContextImpl = class {
        constructor(module, backend, contextDataOffset) {
          this.module = module;
          this.backend = backend;
          this.customDataOffset = 0;
          this.customDataSize = 0;
          this.adapterInfo = backend.adapterInfo;
          const ptrSize = module.PTR_SIZE;
          let dataIndex = contextDataOffset / module.PTR_SIZE;
          const type = ptrSize === 4 ? "i32" : "i64";
          this.opKernelContext = Number(module.getValue(ptrSize * dataIndex++, type));
          const inputCount = Number(module.getValue(ptrSize * dataIndex++, type));
          this.outputCount = Number(module.getValue(ptrSize * dataIndex++, type));
          this.customDataOffset = Number(module.getValue(ptrSize * dataIndex++, "*"));
          this.customDataSize = Number(module.getValue(ptrSize * dataIndex++, type));
          const inputs = [];
          for (let i = 0; i < inputCount; i++) {
            const dataType = Number(module.getValue(ptrSize * dataIndex++, type));
            const data = Number(module.getValue(ptrSize * dataIndex++, "*"));
            const dim = Number(module.getValue(ptrSize * dataIndex++, type));
            const dims = [];
            for (let d = 0; d < dim; d++) {
              dims.push(Number(module.getValue(ptrSize * dataIndex++, type)));
            }
            inputs.push(new TensorViewImpl(module, dataType, data, dims));
          }
          this.inputs = inputs;
        }
        get kernelCustomData() {
          return this.backend.currentKernelCustomData;
        }
        get customDataBuffer() {
          return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
        }
        compute(program, inputsOutputsMapping) {
          const mappedInputs = inputsOutputsMapping?.inputs?.map((i) => typeof i === "number" ? this.inputs[i] : i) ?? this.inputs;
          const outputIndices = inputsOutputsMapping?.outputs ?? [];
          const createKernelOutput = (index, dataType, dims) => new TensorViewImpl(this.module, dataType, this.output(index, dims), dims);
          const createTemporaryOutput = (dataType, dims) => {
            const bufferSize = calculateTensorSizeInBytes(dataType, dims);
            if (!bufferSize) {
              throw new Error(`Unsupported data type: ${dataType}`);
            }
            const gpuDataId = bufferSize > 0 ? this.backend.gpuDataManager.create(bufferSize).id : 0;
            return new TensorViewImpl(this.module, dataType, gpuDataId, dims);
          };
          return this.backend.run(
            program,
            mappedInputs,
            outputIndices,
            createKernelOutput,
            createTemporaryOutput,
            this.outputCount
          );
        }
        output(index, dims) {
          const stack = this.module.stackSave();
          try {
            const ptrSize = this.module.PTR_SIZE;
            const type = ptrSize === 4 ? "i32" : "i64";
            const data = this.module.stackAlloc(
              (1 + dims.length) * ptrSize
              /* sizeof(size_t) */
            );
            this.module.setValue(data, dims.length, type);
            for (let i = 0; i < dims.length; i++) {
              this.module.setValue(data + ptrSize * (i + 1), dims[i], type);
            }
            return this.module._JsepOutput(this.opKernelContext, index, data);
          } catch (e) {
            throw new Error(
              `Failed to generate kernel's output[${index}] with dims [${dims}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${e}`
            );
          } finally {
            this.module.stackRestore(stack);
          }
        }
      };
      init = async (name, module, env3, gpuAdapter) => {
        const jsepInit = module.jsepInit;
        if (!jsepInit) {
          throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
        }
        if (name === "webgpu") {
          const webGpuBackendImpl = (init_backend_webgpu(), __toCommonJS(backend_webgpu_exports)).WebGpuBackend;
          const backend = new webGpuBackendImpl();
          await backend.initialize(env3, gpuAdapter);
          jsepInit("webgpu", [
            // backend
            backend,
            // jsepAlloc()
            (size) => backend.alloc(Number(size)),
            // jsepFree()
            (ptr) => backend.free(ptr),
            // jsepCopy(src, dst, size, isSourceGpu)
            (src, dst, size, isSourceGpu = false) => {
              if (isSourceGpu) {
                LOG_DEBUG(
                  "verbose",
                  () => `[WebGPU] jsepCopyGpuToGpu: src=${Number(src)}, dst=${Number(dst)}, size=${Number(size)}`
                );
                backend.memcpy(Number(src), Number(dst));
              } else {
                LOG_DEBUG(
                  "verbose",
                  () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(src)}, gpuDataId=${Number(dst)}, size=${Number(size)}`
                );
                const data = module.HEAPU8.subarray(Number(src >>> 0), Number(src >>> 0) + Number(size));
                backend.upload(Number(dst), data);
              }
            },
            // jsepCopyAsync(src, dst, size)
            async (gpuDataId, dataOffset, size) => {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${gpuDataId}, dataOffset=${dataOffset}, size=${size}`
              );
              await backend.download(
                Number(gpuDataId),
                () => module.HEAPU8.subarray(Number(dataOffset) >>> 0, Number(dataOffset + size) >>> 0)
              );
            },
            // jsepCreateKernel
            (kernelType, kernelId, attribute) => backend.createKernel(
              kernelType,
              Number(kernelId),
              attribute,
              module.UTF8ToString(module._JsepGetNodeName(Number(kernelId)))
            ),
            // jsepReleaseKernel
            (kernel) => backend.releaseKernel(kernel),
            // jsepRun
            (kernel, contextDataOffset, sessionHandle, errors) => {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepRun: sessionHandle=${sessionHandle}, kernel=${kernel}, contextDataOffset=${contextDataOffset}`
              );
              const context = new ComputeContextImpl(module, backend, Number(contextDataOffset));
              return backend.computeKernel(Number(kernel), context, errors);
            },
            // jsepCaptureBegin
            () => backend.captureBegin(),
            // jsepCaptureEnd
            () => backend.captureEnd(),
            // jsepReplay
            () => backend.replay()
          ]);
        } else {
          const backend = new WebNNBackend(env3);
          jsepInit("webnn", [
            backend,
            // webnnReserveTensorId
            () => backend.reserveTensorId(),
            // webnnReleaseTensorId
            (tensorId) => backend.releaseTensorId(tensorId),
            // webnnEnsureTensor
            async (sessionId, tensorId, onnxDataType, shape, copyOld) => backend.ensureTensor(sessionId, tensorId, onnxDataType, shape, copyOld),
            // webnnUploadTensor
            (tensorId, data) => {
              backend.uploadTensor(tensorId, data);
            },
            // webnnDownloadTensor
            async (tensorId, dstBuffer) => backend.downloadTensor(tensorId, dstBuffer),
            // webnnRegisterMLContext
            (sessionId, mlContext) => backend.registerMLContext(sessionId, mlContext),
            // webnnEnableTraceEvent
            !!env3.trace
          ]);
        }
      };
    }
  });

  // web/lib/wasm/wasm-core-impl.ts
  var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, getSessionInputOutputMetadata, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
  var init_wasm_core_impl = __esm({
    "web/lib/wasm/wasm-core-impl.ts"() {
      "use strict";
      init_esm();
      init_run_options();
      init_session_options();
      init_wasm_common();
      init_wasm_factory();
      init_wasm_utils();
      init_wasm_utils_load_file();
      initOrt = (numThreads, loggingLevel) => {
        const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
        if (errorCode !== 0) {
          checkLastError("Can't initialize onnxruntime.");
        }
      };
      initRuntime = async (env3) => {
        initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
      };
      initEp = async (env3, epName) => {
        getInstance().asyncInit?.();
        let webgpuAdapter = env3.webgpu.adapter;
        if (epName === "webgpu") {
          if (typeof navigator === "undefined" || !navigator.gpu) {
            throw new Error("WebGPU is not supported in current environment");
          }
          if (!webgpuAdapter) {
            const powerPreference = env3.webgpu.powerPreference;
            if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
              throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
            }
            const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
            if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
              throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
            }
            webgpuAdapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
            if (!webgpuAdapter) {
              throw new Error(
                'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
              );
            }
          } else {
            if (typeof webgpuAdapter.limits !== "object" || typeof webgpuAdapter.features !== "object" || typeof webgpuAdapter.requestDevice !== "function") {
              throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
            }
          }
        }
        if (epName === "webnn") {
          if (typeof navigator === "undefined" || !navigator.ml) {
            throw new Error("WebNN is not supported in current environment");
          }
        }
        if (true) {
          const initJsep = (init_init(), __toCommonJS(init_exports)).init;
          if (epName === "webgpu") {
            await initJsep("webgpu", getInstance(), env3, webgpuAdapter);
          }
          if (epName === "webnn") {
            await initJsep("webnn", getInstance(), env3);
          }
        } else {
          if (false) {
            getInstance().webgpuInit((device) => {
              env3.webgpu.device = device;
            });
          }
          if (epName === "webnn") {
            const backend = new null.WebNNBackend(env3);
            getInstance().webnnInit([
              backend,
              // webnnReserveTensorId
              () => backend.reserveTensorId(),
              // webnnReleaseTensorId,
              (tensorId) => backend.releaseTensorId(tensorId),
              // webnnEnsureTensor
              async (sessionId, tensorId, onnxDataType, shape, copyOld) => backend.ensureTensor(sessionId, tensorId, onnxDataType, shape, copyOld),
              // webnnUploadTensor
              (tensorId, data) => {
                backend.uploadTensor(tensorId, data);
              },
              // webnnDownloadTensor
              async (tensorId, dstBuffer) => backend.downloadTensor(tensorId, dstBuffer),
              // webnnRegisterMLContext
              (sessionId, mlContext) => backend.registerMLContext(sessionId, mlContext),
              // webnnEnableTraceEvent
              !!env3.trace
            ]);
          }
        }
      };
      activeSessions = /* @__PURE__ */ new Map();
      getSessionInputOutputCount = (sessionHandle) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        try {
          const ptrSize = wasm2.PTR_SIZE;
          const dataOffset = wasm2.stackAlloc(2 * ptrSize);
          const errorCode = wasm2._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + ptrSize);
          if (errorCode !== 0) {
            checkLastError("Can't get session input/output count.");
          }
          const type = ptrSize === 4 ? "i32" : "i64";
          return [Number(wasm2.getValue(dataOffset, type)), Number(wasm2.getValue(dataOffset + ptrSize, type))];
        } finally {
          wasm2.stackRestore(stack);
        }
      };
      getSessionInputOutputMetadata = (sessionHandle, index) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        let metadataOffset = 0;
        try {
          const ptrSize = wasm2.PTR_SIZE;
          const dataOffset = wasm2.stackAlloc(2 * ptrSize);
          const errorCode = wasm2._OrtGetInputOutputMetadata(sessionHandle, index, dataOffset, dataOffset + ptrSize);
          if (errorCode !== 0) {
            checkLastError("Can't get session input/output metadata.");
          }
          const nameOffset = Number(wasm2.getValue(dataOffset, "*"));
          metadataOffset = Number(wasm2.getValue(dataOffset + ptrSize, "*"));
          const elementType = wasm2.HEAP32[metadataOffset / 4];
          if (elementType === 0) {
            return [nameOffset, 0];
          }
          const dimsCount = wasm2.HEAPU32[metadataOffset / 4 + 1];
          const dims = [];
          for (let i = 0; i < dimsCount; i++) {
            const symbolicDimNameOffset = Number(wasm2.getValue(metadataOffset + 8 + i * ptrSize, "*"));
            dims.push(
              symbolicDimNameOffset !== 0 ? wasm2.UTF8ToString(symbolicDimNameOffset) : Number(wasm2.getValue(metadataOffset + 8 + (i + dimsCount) * ptrSize, "*"))
            );
          }
          return [nameOffset, elementType, dims];
        } finally {
          wasm2.stackRestore(stack);
          if (metadataOffset !== 0) {
            wasm2._OrtFree(metadataOffset);
          }
        }
      };
      copyFromExternalBuffer = (model) => {
        const wasm2 = getInstance();
        const modelDataOffset = wasm2._malloc(model.byteLength);
        if (modelDataOffset === 0) {
          throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
        }
        wasm2.HEAPU8.set(model, modelDataOffset);
        return [modelDataOffset, model.byteLength];
      };
      createSession = async (modelData, options) => {
        let modelDataOffset, modelDataLength;
        const wasm2 = getInstance();
        if (Array.isArray(modelData)) {
          [modelDataOffset, modelDataLength] = modelData;
        } else if (modelData.buffer === wasm2.HEAPU8.buffer) {
          [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
        } else {
          [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
        }
        let sessionHandle = 0;
        let sessionOptionsHandle = 0;
        let ioBindingHandle = 0;
        let allocs = [];
        const inputNamesUTF8Encoded = [];
        const outputNamesUTF8Encoded = [];
        try {
          [sessionOptionsHandle, allocs] = await setSessionOptions(options);
          if (options?.externalData && wasm2.mountExternalData) {
            const loadingPromises = [];
            for (const file of options.externalData) {
              const path = typeof file === "string" ? file : file.path;
              loadingPromises.push(
                loadFile(typeof file === "string" ? file : file.data).then((data) => {
                  wasm2.mountExternalData(path, data);
                })
              );
            }
            await Promise.all(loadingPromises);
          }
          for (const provider of options?.executionProviders ?? []) {
            const providerName = typeof provider === "string" ? provider : provider.name;
            if (providerName === "webnn") {
              wasm2.shouldTransferToMLTensor = false;
              if (typeof provider !== "string") {
                const webnnOptions = provider;
                const context = webnnOptions?.context;
                const gpuDevice = webnnOptions?.gpuDevice;
                const deviceType = webnnOptions?.deviceType;
                const powerPreference = webnnOptions?.powerPreference;
                if (context) {
                  wasm2.currentContext = context;
                } else if (gpuDevice) {
                  wasm2.currentContext = await wasm2.webnnCreateMLContext(gpuDevice);
                } else {
                  wasm2.currentContext = await wasm2.webnnCreateMLContext({ deviceType, powerPreference });
                }
              } else {
                wasm2.currentContext = await wasm2.webnnCreateMLContext();
              }
              break;
            }
          }
          sessionHandle = await wasm2._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
          wasm2.webgpuOnCreateSession?.(sessionHandle);
          if (sessionHandle === 0) {
            checkLastError("Can't create a session.");
          }
          wasm2.jsepOnCreateSession?.();
          if (wasm2.currentContext) {
            wasm2.webnnRegisterMLContext(sessionHandle, wasm2.currentContext);
            wasm2.currentContext = void 0;
            wasm2.shouldTransferToMLTensor = true;
          }
          const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
          const enableGraphCapture = !!options?.enableGraphCapture;
          const inputNames = [];
          const outputNames = [];
          const inputMetadata = [];
          const outputMetadata = [];
          const outputPreferredLocations = [];
          for (let i = 0; i < inputCount; i++) {
            const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i);
            if (nameOffset === 0) {
              checkLastError("Can't get an input name.");
            }
            inputNamesUTF8Encoded.push(nameOffset);
            const name = wasm2.UTF8ToString(nameOffset);
            inputNames.push(name);
            inputMetadata.push(
              elementType === 0 ? { name, isTensor: false } : { name, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape }
            );
          }
          for (let i = 0; i < outputCount; i++) {
            const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i + inputCount);
            if (nameOffset === 0) {
              checkLastError("Can't get an output name.");
            }
            outputNamesUTF8Encoded.push(nameOffset);
            const nameString = wasm2.UTF8ToString(nameOffset);
            outputNames.push(nameString);
            outputMetadata.push(
              elementType === 0 ? { name: nameString, isTensor: false } : { name: nameString, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape }
            );
            if (true) {
              if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
                outputPreferredLocations.push("gpu-buffer");
                continue;
              }
              const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
              const isGraphOutput = wasm2.webnnIsGraphOutput;
              if (location2 === "cpu" && isGraphOutput && isGraphOutput(sessionHandle, nameString)) {
                outputPreferredLocations.push("ml-tensor-cpu-output");
                continue;
              }
              if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer" && location2 !== "ml-tensor") {
                throw new Error(`Not supported preferred output location: ${location2}.`);
              }
              if (enableGraphCapture && location2 !== "gpu-buffer") {
                throw new Error(
                  `Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`
                );
              }
              outputPreferredLocations.push(location2);
            }
          }
          let bindingState = null;
          if (outputPreferredLocations.some((l) => l === "gpu-buffer" || l === "ml-tensor" || l === "ml-tensor-cpu-output")) {
            ioBindingHandle = wasm2._OrtCreateBinding(sessionHandle);
            if (ioBindingHandle === 0) {
              checkLastError("Can't create IO binding.");
            }
            bindingState = {
              handle: ioBindingHandle,
              outputPreferredLocations,
              outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => l === "ml-tensor-cpu-output" ? "ml-tensor" : l).map((l) => dataLocationStringToEnum(l))
            };
          }
          activeSessions.set(sessionHandle, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            bindingState,
            enableGraphCapture,
            false
          ]);
          return [sessionHandle, inputNames, outputNames, inputMetadata, outputMetadata];
        } catch (e) {
          inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
          outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
          if (ioBindingHandle !== 0) {
            if (wasm2._OrtReleaseBinding(ioBindingHandle) !== 0) {
              checkLastError("Can't release IO binding.");
            }
          }
          if (sessionHandle !== 0) {
            if (wasm2._OrtReleaseSession(sessionHandle) !== 0) {
              checkLastError("Can't release session.");
            }
          }
          throw e;
        } finally {
          wasm2._free(modelDataOffset);
          if (sessionOptionsHandle !== 0) {
            if (wasm2._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {
              checkLastError("Can't release session options.");
            }
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          wasm2.unmountExternalData?.();
        }
      };
      releaseSession = (sessionId) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot release session. invalid session id: ${sessionId}`);
        }
        const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
        if (ioBindingState) {
          if (enableGraphCapture) {
            if (wasm2._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {
              checkLastError("Can't clear bound outputs.");
            }
          }
          if (wasm2._OrtReleaseBinding(ioBindingState.handle) !== 0) {
            checkLastError("Can't release IO binding.");
          }
        }
        wasm2.jsepOnReleaseSession?.(sessionId);
        wasm2.webnnOnReleaseSession?.(sessionId);
        wasm2.webgpuOnReleaseSession?.(sessionId);
        inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        if (wasm2._OrtReleaseSession(sessionHandle) !== 0) {
          checkLastError("Can't release session.");
        }
        activeSessions.delete(sessionId);
      };
      prepareInputOutputTensor = async (tensor, tensorHandles, allocs, sessionId, tensorNameUTF8Encoded, index, enableGraphCapture = false) => {
        if (!tensor) {
          tensorHandles.push(0);
          return;
        }
        const wasm2 = getInstance();
        const ptrSize = wasm2.PTR_SIZE;
        const dataType = tensor[0];
        const dims = tensor[1];
        const location2 = tensor[3];
        let actualLocation = location2;
        let rawData;
        let dataByteLength;
        if (dataType === "string" && (location2 === "gpu-buffer" || location2 === "ml-tensor")) {
          throw new Error("String tensor is not supported on GPU.");
        }
        if (enableGraphCapture && location2 !== "gpu-buffer") {
          throw new Error(
            `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
          );
        }
        if (location2 === "gpu-buffer") {
          const gpuBuffer = tensor[2].gpuBuffer;
          dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
          if (false) {
            const registerBuffer = wasm2.webgpuRegisterBuffer;
            if (!registerBuffer) {
              throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
            }
            rawData = registerBuffer(gpuBuffer, sessionId);
          } else {
            const registerBuffer = wasm2.jsepRegisterBuffer;
            if (!registerBuffer) {
              throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
            }
            rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
          }
        } else if (location2 === "ml-tensor") {
          const mlTensor = tensor[2].mlTensor;
          dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
          const registerMLTensor = wasm2.webnnRegisterMLTensor;
          if (!registerMLTensor) {
            throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
          }
          rawData = registerMLTensor(sessionId, mlTensor, tensorDataTypeStringToEnum(dataType), dims);
        } else {
          const data = tensor[2];
          if (Array.isArray(data)) {
            dataByteLength = ptrSize * data.length;
            rawData = wasm2._malloc(dataByteLength);
            allocs.push(rawData);
            for (let i = 0; i < data.length; i++) {
              if (typeof data[i] !== "string") {
                throw new TypeError(`tensor data at index ${i} is not a string`);
              }
              wasm2.setValue(rawData + i * ptrSize, allocWasmString(data[i], allocs), "*");
            }
          } else {
            const isGraphInput = wasm2.webnnIsGraphInput;
            const isGraphOutput = wasm2.webnnIsGraphOutput;
            if (dataType !== "string" && isGraphInput && isGraphOutput) {
              const tensorName = wasm2.UTF8ToString(tensorNameUTF8Encoded);
              if (isGraphInput(sessionId, tensorName) || isGraphOutput(sessionId, tensorName)) {
                const dataTypeEnum = tensorDataTypeStringToEnum(dataType);
                dataByteLength = calculateTensorSizeInBytes(dataTypeEnum, dims);
                actualLocation = "ml-tensor";
                const createTemporaryTensor = wasm2.webnnCreateTemporaryTensor;
                const uploadTensor = wasm2.webnnUploadTensor;
                if (!createTemporaryTensor || !uploadTensor) {
                  throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
                }
                const tensorId = await createTemporaryTensor(sessionId, dataTypeEnum, dims);
                uploadTensor(tensorId, new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
                rawData = tensorId;
              } else {
                dataByteLength = data.byteLength;
                rawData = wasm2._malloc(dataByteLength);
                allocs.push(rawData);
                wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
              }
            } else {
              dataByteLength = data.byteLength;
              rawData = wasm2._malloc(dataByteLength);
              allocs.push(rawData);
              wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
            }
          }
        }
        const stack = wasm2.stackSave();
        const dimsOffset = wasm2.stackAlloc(4 * dims.length);
        try {
          dims.forEach((d, index2) => wasm2.setValue(dimsOffset + index2 * ptrSize, d, ptrSize === 4 ? "i32" : "i64"));
          const tensor2 = wasm2._OrtCreateTensor(
            tensorDataTypeStringToEnum(dataType),
            rawData,
            dataByteLength,
            dimsOffset,
            dims.length,
            dataLocationStringToEnum(actualLocation)
          );
          if (tensor2 === 0) {
            checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
          }
          tensorHandles.push(tensor2);
        } finally {
          wasm2.stackRestore(stack);
        }
      };
      run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
        const wasm2 = getInstance();
        const ptrSize = wasm2.PTR_SIZE;
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
        }
        const sessionHandle = session[0];
        const inputNamesUTF8Encoded = session[1];
        const outputNamesUTF8Encoded = session[2];
        const ioBindingState = session[3];
        const enableGraphCapture = session[4];
        const inputOutputBound = session[5];
        const inputCount = inputIndices.length;
        const outputCount = outputIndices.length;
        let runOptionsHandle = 0;
        let runOptionsAllocs = [];
        const inputTensorHandles = [];
        const outputTensorHandles = [];
        const inputOutputAllocs = [];
        const preAllocatedOutputs = [];
        const beforeRunStack = wasm2.stackSave();
        const inputValuesOffset = wasm2.stackAlloc(inputCount * ptrSize);
        const inputNamesOffset = wasm2.stackAlloc(inputCount * ptrSize);
        const outputValuesOffset = wasm2.stackAlloc(outputCount * ptrSize);
        const outputNamesOffset = wasm2.stackAlloc(outputCount * ptrSize);
        try {
          [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
          TRACE_EVENT_BEGIN("wasm prepareInputOutputTensor");
          for (let i = 0; i < inputCount; i++) {
            await prepareInputOutputTensor(
              inputTensors[i],
              inputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputNamesUTF8Encoded[inputIndices[i]],
              inputIndices[i],
              enableGraphCapture
            );
          }
          for (let i = 0; i < outputCount; i++) {
            await prepareInputOutputTensor(
              outputTensors[i],
              outputTensorHandles,
              inputOutputAllocs,
              sessionId,
              outputNamesUTF8Encoded[outputIndices[i]],
              inputCount + outputIndices[i],
              enableGraphCapture
            );
          }
          TRACE_EVENT_END("wasm prepareInputOutputTensor");
          for (let i = 0; i < inputCount; i++) {
            wasm2.setValue(inputValuesOffset + i * ptrSize, inputTensorHandles[i], "*");
            wasm2.setValue(inputNamesOffset + i * ptrSize, inputNamesUTF8Encoded[inputIndices[i]], "*");
          }
          for (let i = 0; i < outputCount; i++) {
            wasm2.setValue(outputValuesOffset + i * ptrSize, outputTensorHandles[i], "*");
            wasm2.setValue(outputNamesOffset + i * ptrSize, outputNamesUTF8Encoded[outputIndices[i]], "*");
          }
          if (ioBindingState && !inputOutputBound) {
            const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
            if (inputNamesUTF8Encoded.length !== inputCount) {
              throw new Error(
                `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`
              );
            }
            TRACE_EVENT_BEGIN("wasm bindInputsOutputs");
            for (let i = 0; i < inputCount; i++) {
              const index = inputIndices[i];
              const errorCode2 = await wasm2._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
              }
            }
            for (let i = 0; i < outputCount; i++) {
              const index = outputIndices[i];
              const location2 = outputTensors[i]?.[3];
              if (location2) {
                preAllocatedOutputs.push(outputTensorHandles[i]);
                const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
                }
              } else {
                const errorCode2 = wasm2._OrtBindOutput(
                  handle,
                  outputNamesUTF8Encoded[index],
                  0,
                  outputPreferredLocationsEncoded[index]
                );
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
                }
              }
            }
            TRACE_EVENT_END("wasm bindInputsOutputs");
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              true
            ]);
          }
          wasm2.jsepOnRunStart?.(sessionHandle);
          wasm2.webnnOnRunStart?.(sessionHandle);
          let errorCode;
          if (ioBindingState) {
            errorCode = await wasm2._OrtRunWithBinding(
              sessionHandle,
              ioBindingState.handle,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          } else {
            errorCode = await wasm2._OrtRun(
              sessionHandle,
              inputNamesOffset,
              inputValuesOffset,
              inputCount,
              outputNamesOffset,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          }
          if (errorCode !== 0) {
            checkLastError("failed to call OrtRun().");
          }
          const output = [];
          const outputPromises = [];
          TRACE_EVENT_BEGIN("wasm ProcessOutputTensor");
          for (let i = 0; i < outputCount; i++) {
            const tensor = Number(wasm2.getValue(outputValuesOffset + i * ptrSize, "*"));
            if (tensor === outputTensorHandles[i] || preAllocatedOutputs.includes(outputTensorHandles[i])) {
              output.push(outputTensors[i]);
              if (tensor !== outputTensorHandles[i]) {
                if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                  checkLastError("Can't release tensor.");
                }
              }
              continue;
            }
            const beforeGetTensorDataStack = wasm2.stackSave();
            const tensorDataOffset = wasm2.stackAlloc(4 * ptrSize);
            let keepOutputTensor = false;
            let type, dataOffset = 0;
            try {
              const errorCode2 = wasm2._OrtGetTensorData(
                tensor,
                tensorDataOffset,
                tensorDataOffset + ptrSize,
                tensorDataOffset + 2 * ptrSize,
                tensorDataOffset + 3 * ptrSize
              );
              if (errorCode2 !== 0) {
                checkLastError(`Can't access output tensor data on index ${i}.`);
              }
              const valueType = ptrSize === 4 ? "i32" : "i64";
              const dataType = Number(wasm2.getValue(tensorDataOffset, valueType));
              dataOffset = wasm2.getValue(tensorDataOffset + ptrSize, "*");
              const dimsOffset = wasm2.getValue(tensorDataOffset + ptrSize * 2, "*");
              const dimsLength = Number(wasm2.getValue(tensorDataOffset + ptrSize * 3, valueType));
              const dims = [];
              for (let i2 = 0; i2 < dimsLength; i2++) {
                dims.push(Number(wasm2.getValue(dimsOffset + i2 * ptrSize, valueType)));
              }
              if (wasm2._OrtFree(dimsOffset) !== 0) {
                checkLastError("Can't free memory for tensor dims.");
              }
              const size = dims.reduce((a, b) => a * b, 1);
              type = tensorDataTypeEnumToString(dataType);
              const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
              if (type === "string") {
                if (preferredLocation === "gpu-buffer" || preferredLocation === "ml-tensor") {
                  throw new Error("String tensor is not supported on GPU.");
                }
                const stringData = [];
                for (let i2 = 0; i2 < size; i2++) {
                  const offset = wasm2.getValue(dataOffset + i2 * ptrSize, "*");
                  const nextOffset = wasm2.getValue(dataOffset + (i2 + 1) * ptrSize, "*");
                  const maxBytesToRead = i2 === size - 1 ? void 0 : nextOffset - offset;
                  stringData.push(wasm2.UTF8ToString(offset, maxBytesToRead));
                }
                output.push([type, dims, stringData, "cpu"]);
              } else {
                if (preferredLocation === "gpu-buffer" && size > 0) {
                  const getBuffer = false ? wasm2.webgpuGetBuffer : wasm2.jsepGetBuffer;
                  if (!getBuffer) {
                    throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                  }
                  const gpuBuffer = getBuffer(dataOffset);
                  const bufferSize = calculateTensorSizeInBytes(dataType, size);
                  if (bufferSize === void 0 || !isGpuBufferSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  keepOutputTensor = true;
                  if (false) {
                    wasm2.webgpuRegisterBuffer(gpuBuffer, sessionId, dataOffset);
                    const downloadDataFunction = wasm2.webgpuCreateDownloader(gpuBuffer, bufferSize, sessionId);
                    output.push([
                      type,
                      dims,
                      {
                        gpuBuffer,
                        download: async () => {
                          const arrayBuffer = await downloadDataFunction();
                          const data = new (tensorTypeToTypedArrayConstructor(type))(arrayBuffer);
                          return data;
                        },
                        dispose: () => {
                          if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                            checkLastError("Can't release tensor.");
                          }
                        }
                      },
                      "gpu-buffer"
                    ]);
                  } else {
                    output.push([
                      type,
                      dims,
                      {
                        gpuBuffer,
                        download: wasm2.jsepCreateDownloader(gpuBuffer, bufferSize, type),
                        dispose: () => {
                          if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                            checkLastError("Can't release tensor.");
                          }
                        }
                      },
                      "gpu-buffer"
                    ]);
                  }
                } else if (preferredLocation === "ml-tensor" && size > 0) {
                  const ensureTensor = wasm2.webnnEnsureTensor;
                  const isGraphInputOutputTypeSupported = wasm2.webnnIsGraphInputOutputTypeSupported;
                  if (!ensureTensor || !isGraphInputOutputTypeSupported) {
                    throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
                  }
                  const tensorSize = calculateTensorSizeInBytes(dataType, size);
                  if (tensorSize === void 0 || !isMLTensorSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  if (!isGraphInputOutputTypeSupported(sessionId, type, false)) {
                    throw new Error(
                      `preferredLocation "ml-tensor" for ${type} output is not supported by current WebNN Context.`
                    );
                  }
                  const mlTensor = await ensureTensor(sessionId, dataOffset, dataType, dims, false);
                  keepOutputTensor = true;
                  output.push([
                    type,
                    dims,
                    {
                      mlTensor,
                      download: wasm2.webnnCreateMLTensorDownloader(dataOffset, type),
                      dispose: () => {
                        wasm2.webnnReleaseTensorId(dataOffset);
                        wasm2._OrtReleaseTensor(tensor);
                      }
                    },
                    "ml-tensor"
                  ]);
                } else if (preferredLocation === "ml-tensor-cpu-output" && size > 0) {
                  const data = wasm2.webnnCreateMLTensorDownloader(dataOffset, type)();
                  const index = output.length;
                  keepOutputTensor = true;
                  outputPromises.push(
                    (async () => {
                      const result = [index, await data];
                      wasm2.webnnReleaseTensorId(dataOffset);
                      wasm2._OrtReleaseTensor(tensor);
                      return result;
                    })()
                  );
                  output.push([type, dims, [], "cpu"]);
                } else {
                  const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                  const data = new typedArrayConstructor(size);
                  new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(
                    wasm2.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength)
                  );
                  output.push([type, dims, data, "cpu"]);
                }
              }
            } finally {
              wasm2.stackRestore(beforeGetTensorDataStack);
              if (type === "string" && dataOffset) {
                wasm2._free(dataOffset);
              }
              if (!keepOutputTensor) {
                wasm2._OrtReleaseTensor(tensor);
              }
            }
          }
          if (ioBindingState && !enableGraphCapture) {
            if (wasm2._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {
              checkLastError("Can't clear bound outputs.");
            }
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              false
            ]);
          }
          for (const [index, data] of await Promise.all(outputPromises)) {
            output[index][2] = data;
          }
          TRACE_EVENT_END("wasm ProcessOutputTensor");
          return output;
        } finally {
          wasm2.webnnOnRunEnd?.(sessionHandle);
          wasm2.stackRestore(beforeRunStack);
          if (false) {
            inputTensors.forEach((t) => {
              if (t && t[3] === "gpu-buffer") {
                wasm2.webgpuUnregisterBuffer(t[2].gpuBuffer);
              }
            });
            outputTensors.forEach((t) => {
              if (t && t[3] === "gpu-buffer") {
                wasm2.webgpuUnregisterBuffer(t[2].gpuBuffer);
              }
            });
          }
          inputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
          outputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
          inputOutputAllocs.forEach((p) => wasm2._free(p));
          if (runOptionsHandle !== 0) {
            wasm2._OrtReleaseRunOptions(runOptionsHandle);
          }
          runOptionsAllocs.forEach((p) => wasm2._free(p));
        }
      };
      endProfiling = (sessionId) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error("invalid session id");
        }
        const sessionHandle = session[0];
        const profileFileName = wasm2._OrtEndProfiling(sessionHandle);
        if (profileFileName === 0) {
          checkLastError("Can't get an profile file name.");
        }
        wasm2._OrtFree(profileFileName);
      };
      extractTransferableBuffers = (tensors) => {
        const buffers = [];
        for (const tensor of tensors) {
          const data = tensor[2];
          if (!Array.isArray(data) && "buffer" in data) {
            buffers.push(data.buffer);
          }
        }
        return buffers;
      };
    }
  });

  // web/lib/wasm/proxy-wrapper.ts
  var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
  var init_proxy_wrapper = __esm({
    "web/lib/wasm/proxy-wrapper.ts"() {
      "use strict";
      init_esm();
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
      initializing2 = false;
      initialized2 = false;
      aborted2 = false;
      queuedCallbacks = /* @__PURE__ */ new Map();
      enqueueCallbacks = (type, callbacks) => {
        const queue = queuedCallbacks.get(type);
        if (queue) {
          queue.push(callbacks);
        } else {
          queuedCallbacks.set(type, [callbacks]);
        }
      };
      ensureWorker = () => {
        if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
          throw new Error("worker not ready");
        }
      };
      onProxyWorkerMessage = (ev) => {
        switch (ev.data.type) {
          case "init-wasm":
            initializing2 = false;
            if (ev.data.err) {
              aborted2 = true;
              initWasmCallbacks[1](ev.data.err);
            } else {
              initialized2 = true;
              initWasmCallbacks[0]();
            }
            if (temporaryObjectUrl) {
              URL.revokeObjectURL(temporaryObjectUrl);
              temporaryObjectUrl = void 0;
            }
            break;
          case "init-ep":
          case "copy-from":
          case "create":
          case "release":
          case "run":
          case "end-profiling": {
            const callbacks = queuedCallbacks.get(ev.data.type);
            if (ev.data.err) {
              callbacks.shift()[1](ev.data.err);
            } else {
              callbacks.shift()[0](ev.data.out);
            }
            break;
          }
          default:
        }
      };
      initializeWebAssemblyAndOrtRuntime = async () => {
        if (initialized2) {
          return;
        }
        if (initializing2) {
          throw new Error("multiple calls to 'initWasm()' detected.");
        }
        if (aborted2) {
          throw new Error("previous call to 'initWasm()' failed.");
        }
        initializing2 = true;
        if (isProxy()) {
          return new Promise((resolve, reject) => {
            proxyWorker?.terminate();
            void importProxyWorker().then(([objectUrl, worker]) => {
              try {
                proxyWorker = worker;
                proxyWorker.onerror = (ev) => reject(ev);
                proxyWorker.onmessage = onProxyWorkerMessage;
                initWasmCallbacks = [resolve, reject];
                const message = { type: "init-wasm", in: env2 };
                if (!message.in.wasm.wasmPaths && objectUrl) {
                  const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();
                  if (inferredWasmPathPrefix) {
                    message.in.wasm.wasmPaths = inferredWasmPathPrefix;
                  }
                }
                if (false) {
                  message.in.wasm.wasmPaths = {
                    wasm: true ? new URL("ort-wasm-simd-threaded.jsep.wasm", void 0).href : false ? new URL("ort-wasm-simd-threaded.asyncify.wasm", void 0).href : new URL("ort-wasm-simd-threaded.wasm", void 0).href
                  };
                }
                proxyWorker.postMessage(message);
                temporaryObjectUrl = objectUrl;
              } catch (e) {
                reject(e);
              }
            }, reject);
          });
        } else {
          try {
            await initializeWebAssembly(env2.wasm);
            await initRuntime(env2);
            initialized2 = true;
          } catch (e) {
            aborted2 = true;
            throw e;
          } finally {
            initializing2 = false;
          }
        }
      };
      initializeOrtEp = async (epName) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("init-ep", [resolve, reject]);
            const message = { type: "init-ep", in: { epName, env: env2 } };
            proxyWorker.postMessage(message);
          });
        } else {
          await initEp(env2, epName);
        }
      };
      copyFromExternalBuffer2 = async (buffer) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("copy-from", [resolve, reject]);
            const message = { type: "copy-from", in: { buffer } };
            proxyWorker.postMessage(message, [buffer.buffer]);
          });
        } else {
          return copyFromExternalBuffer(buffer);
        }
      };
      createSession2 = async (model, options) => {
        if (isProxy()) {
          if (options?.preferredOutputLocation) {
            throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("create", [resolve, reject]);
            const message = { type: "create", in: { model, options: { ...options } } };
            const transferable = [];
            if (model instanceof Uint8Array) {
              transferable.push(model.buffer);
            }
            proxyWorker.postMessage(message, transferable);
          });
        } else {
          return createSession(model, options);
        }
      };
      releaseSession2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("release", [resolve, reject]);
            const message = { type: "release", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          releaseSession(sessionId);
        }
      };
      run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
        if (isProxy()) {
          if (inputs.some((t) => t[3] !== "cpu")) {
            throw new Error("input tensor on GPU is not supported for proxy.");
          }
          if (outputs.some((t) => t)) {
            throw new Error("pre-allocated output tensor is not supported for proxy.");
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("run", [resolve, reject]);
            const serializableInputs = inputs;
            const message = {
              type: "run",
              in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options }
            };
            proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
          });
        } else {
          return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
        }
      };
      endProfiling2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("end-profiling", [resolve, reject]);
            const message = { type: "end-profiling", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          endProfiling(sessionId);
        }
      };
    }
  });

  // web/lib/wasm/session-handler-inference.ts
  var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
  var init_session_handler_inference = __esm({
    "web/lib/wasm/session-handler-inference.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_wasm_common();
      init_wasm_utils_env();
      init_wasm_utils_load_file();
      encodeTensorMetadata = (tensor, getName) => {
        switch (tensor.location) {
          case "cpu":
            return [tensor.type, tensor.dims, tensor.data, "cpu"];
          case "gpu-buffer":
            return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
          case "ml-tensor":
            return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, "ml-tensor"];
          default:
            throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
        }
      };
      decodeTensorMetadata = (tensor) => {
        switch (tensor[3]) {
          case "cpu":
            return new Tensor2(tensor[0], tensor[2], tensor[1]);
          case "gpu-buffer": {
            const dataType = tensor[0];
            if (!isGpuBufferSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
            }
            const { gpuBuffer, download, dispose } = tensor[2];
            return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
          }
          case "ml-tensor": {
            const dataType = tensor[0];
            if (!isMLTensorSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);
            }
            const { mlTensor, download, dispose } = tensor[2];
            return Tensor2.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });
          }
          default:
            throw new Error(`invalid data location: ${tensor[3]}`);
        }
      };
      OnnxruntimeWebAssemblySessionHandler = class {
        async fetchModelAndCopyToWasmMemory(path) {
          return copyFromExternalBuffer2(await loadFile(path));
        }
        async loadModel(pathOrBuffer, options) {
          TRACE_FUNC_BEGIN();
          let model;
          if (typeof pathOrBuffer === "string") {
            if (isNode) {
              model = await loadFile(pathOrBuffer);
            } else {
              model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
            }
          } else {
            model = pathOrBuffer;
          }
          [this.sessionId, this.inputNames, this.outputNames, this.inputMetadata, this.outputMetadata] = await createSession2(
            model,
            options
          );
          TRACE_FUNC_END();
        }
        async dispose() {
          return releaseSession2(this.sessionId);
        }
        async run(feeds, fetches, options) {
          TRACE_FUNC_BEGIN();
          const inputArray = [];
          const inputIndices = [];
          Object.entries(feeds).forEach((kvp) => {
            const name = kvp[0];
            const tensor = kvp[1];
            const index = this.inputNames.indexOf(name);
            if (index === -1) {
              throw new Error(`invalid input '${name}'`);
            }
            inputArray.push(tensor);
            inputIndices.push(index);
          });
          const outputArray = [];
          const outputIndices = [];
          Object.entries(fetches).forEach((kvp) => {
            const name = kvp[0];
            const tensor = kvp[1];
            const index = this.outputNames.indexOf(name);
            if (index === -1) {
              throw new Error(`invalid output '${name}'`);
            }
            outputArray.push(tensor);
            outputIndices.push(index);
          });
          const inputs = inputArray.map(
            (t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`)
          );
          const outputs = outputArray.map(
            (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
          );
          const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
          const resultMap = {};
          for (let i = 0; i < results.length; i++) {
            resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
          }
          TRACE_FUNC_END();
          return resultMap;
        }
        startProfiling() {
        }
        endProfiling() {
          void endProfiling2(this.sessionId);
        }
      };
    }
  });

  // web/lib/backend-wasm.ts
  var backend_wasm_exports = {};
  __export(backend_wasm_exports, {
    OnnxruntimeWebAssemblyBackend: () => OnnxruntimeWebAssemblyBackend,
    initializeFlags: () => initializeFlags,
    wasmBackend: () => wasmBackend
  });
  var initializeFlags, OnnxruntimeWebAssemblyBackend, wasmBackend;
  var init_backend_wasm = __esm({
    "web/lib/backend-wasm.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_session_handler_inference();
      initializeFlags = () => {
        if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
          env2.wasm.initTimeout = 0;
        }
        const simd = env2.wasm.simd;
        if (typeof simd !== "boolean" && simd !== void 0 && simd !== "fixed" && simd !== "relaxed") {
          console.warn(
            `Property "env.wasm.simd" is set to unknown value "${simd}". Reset it to \`false\` and ignore SIMD feature checking.`
          );
          env2.wasm.simd = false;
        }
        if (typeof env2.wasm.proxy !== "boolean") {
          env2.wasm.proxy = false;
        }
        if (typeof env2.wasm.trace !== "boolean") {
          env2.wasm.trace = false;
        }
        if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            env2.wasm.numThreads = 1;
          } else {
            const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
            env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
          }
        }
      };
      OnnxruntimeWebAssemblyBackend = class {
        /**
         * This function initializes the WebAssembly backend.
         *
         * This function will be called only once for each backend name. It will be called the first time when
         * `ort.InferenceSession.create()` is called with a registered backend name.
         *
         * @param backendName - the registered backend name.
         */
        async init(backendName) {
          initializeFlags();
          await initializeWebAssemblyAndOrtRuntime();
          await initializeOrtEp(backendName);
        }
        async createInferenceSessionHandler(pathOrBuffer, options) {
          const handler = new OnnxruntimeWebAssemblySessionHandler();
          await handler.loadModel(pathOrBuffer, options);
          return handler;
        }
      };
      wasmBackend = new OnnxruntimeWebAssemblyBackend();
    }
  });

  // web/lib/index.ts
  var index_exports = {};
  __export(index_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_EVENT_BEGIN: () => TRACE_EVENT_BEGIN,
    TRACE_EVENT_END: () => TRACE_EVENT_END,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    default: () => index_default,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  init_esm();
  init_esm();
  init_esm();

  // web/lib/version.ts
  var version2 = "1.23.0";

  // web/lib/index.ts
  var index_default = esm_exports;
  if (false) {
    const onnxjsBackend = null.onnxjsBackend;
    registerBackend("webgl", onnxjsBackend, -10);
  }
  if (false) {
    throw new Error(
      "The current build is specified to enable both JSEP and WebGPU EP. This is not a valid configuration. JSEP and WebGPU EPs cannot be enabled at the same time."
    );
  }
  if (false) {
    throw new Error(
      "The current build is specified to enable WebNN EP without JSEP or WebGPU EP. This is not a valid configuration. WebNN EP requires either JSEP or WebGPU EP to be enabled."
    );
  }
  if (true) {
    const wasmBackend2 = (init_backend_wasm(), __toCommonJS(backend_wasm_exports)).wasmBackend;
    if (true) {
      registerBackend("webgpu", wasmBackend2, 5);
    }
    if (true) {
      registerBackend("webnn", wasmBackend2, 5);
    }
    registerBackend("cpu", wasmBackend2, 10);
    registerBackend("wasm", wasmBackend2, 10);
  }
  Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
  return __toCommonJS(index_exports);
})();
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
typeof exports=="object"&&typeof module=="object"&&(module.exports=ort);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmRleC50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWVudi50cyIsICIuLi9saWIvd2FzbS9wcm94eS13b3JrZXIvbWFpbi50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50cyIsICIuLi9saWIvd2FzbS93YXNtLWZhY3RvcnkudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy50cyIsICIuLi9saWIvd2FzbS9ydW4tb3B0aW9ucy50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb21tb24udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1sb2FkLWZpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC9sb2cudHMiLCAiLi4vbGliL3dhc20vanNlcC91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvdGVuc29yLXZpZXcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJubi90ZW5zb3ItbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL2JhY2tlbmQtd2Vibm4udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvdHlwZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvZ3B1LWRhdGEtbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXkudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbW1vbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2Utc2hhcmVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2FyZ21pbm1heC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYXR0ZW50aW9uLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iYXRjaC1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iaWFzLWFkZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdW5hcnktb3AudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2JpYXMtc3BsaXQtZ2VsdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmluYXJ5LW9wLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb25jYXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2Z1c2UtdXRpbHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9hY3RpdmF0aW9uX3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252X3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL21hdG11bC1zaGFkZXJzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252MmRfbW1fd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udjNkX25haXZlX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb252LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl9iYWNrcHJvcF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbnYtdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jdW1zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2RlcHRoLXRvLXNwYWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9laW5zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2V4cGFuZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZmFzdC1nZWx1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXIudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dhdGhlci1uZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLWJsb2NrLXF1YW50aXplZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLWVsZW1lbnRzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nZW1tLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9ncmlkLXNhbXBsZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbXVsdGloZWFkLWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc3BsaXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3JvdGFyeS1lbWJlZGRpbmcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvaW5zdGFuY2Utbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbWF0bXVsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9tYXRtdWxuYml0cy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcGFkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9wb29sLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9xdWFudGl6ZS1saW5lYXIudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3JhbmdlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zY2F0dGVyLW5kLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZXNpemUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NraXAtbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc2xpY2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NvZnRtYXgudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3doZXJlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wLXJlc29sdmUtcnVsZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvcHJvZ3JhbS1tYW5hZ2VyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvYmFja2VuZC13ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC9pbml0LnRzIiwgIi4uL2xpYi93YXNtL3dhc20tY29yZS1pbXBsLnRzIiwgIi4uL2xpYi93YXNtL3Byb3h5LXdyYXBwZXIudHMiLCAiLi4vbGliL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZS50cyIsICIuLi9saWIvYmFja2VuZC13YXNtLnRzIiwgIi4uL2xpYi9pbmRleC50cyIsICIuLi9saWIvdmVyc2lvbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IEJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQuanMnO1xyXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XHJcblxyXG5pbnRlcmZhY2UgQmFja2VuZEluZm8ge1xyXG4gIGJhY2tlbmQ6IEJhY2tlbmQ7XHJcbiAgcHJpb3JpdHk6IG51bWJlcjtcclxuXHJcbiAgaW5pdFByb21pc2U/OiBQcm9taXNlPHZvaWQ+O1xyXG4gIGluaXRpYWxpemVkPzogYm9vbGVhbjtcclxuICBhYm9ydGVkPzogYm9vbGVhbjtcclxuICBlcnJvcj86IHN0cmluZztcclxufVxyXG5cclxuY29uc3QgYmFja2VuZHM6IE1hcDxzdHJpbmcsIEJhY2tlbmRJbmZvPiA9IG5ldyBNYXAoKTtcclxuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5OiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cclxuICpcclxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBhcyBhIGtleSB0byBsb29rdXAgYXMgYW4gZXhlY3V0aW9uIHByb3ZpZGVyLlxyXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cclxuICogQHBhcmFtIHByaW9yaXR5IC0gYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBwcmlvcml0eSBvZiB0aGUgYmFja2VuZC4gSGlnaGVyIG51bWJlciBtZWFucyBoaWdoZXIgcHJpb3JpdHkuIGlmIHByaW9yaXR5XHJcbiAqIDwgMCwgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgJ2JldGEnIHZlcnNpb24gYW5kIHdpbGwgbm90IGJlIHVzZWQgYXMgYSBmYWxsYmFjayBiYWNrZW5kIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBjb25zdCByZWdpc3RlckJhY2tlbmQgPSAobmFtZTogc3RyaW5nLCBiYWNrZW5kOiBCYWNrZW5kLCBwcmlvcml0eTogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgaWYgKGJhY2tlbmQgJiYgdHlwZW9mIGJhY2tlbmQuaW5pdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYmFja2VuZC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoY3VycmVudEJhY2tlbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBiYWNrZW5kcy5zZXQobmFtZSwgeyBiYWNrZW5kLCBwcmlvcml0eSB9KTtcclxuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xyXG4gICAgICAvLyBzYW1lIG5hbWUgaXMgYWxyZWFkeSByZWdpc3RlcmVkIHdpdGggYSBoaWdoZXIgcHJpb3JpdHkuIHNraXAgcmVnaXN0ZXJhdGlvbi5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcclxuICAgICAgaWYgKGN1cnJlbnRCYWNrZW5kLmJhY2tlbmQgIT09IGJhY2tlbmQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtuYW1lfVwiIHVzaW5nIHByaW9yaXR5ICR7cHJpb3JpdHl9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xyXG4gICAgICBjb25zdCBpID0gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LmluZGV4T2YobmFtZSk7XHJcbiAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGJhY2tlbmRzLmdldChiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHlbaV0pIS5wcmlvcml0eSA8PSBwcmlvcml0eSkge1xyXG4gICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAwLCBuYW1lKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSB2YWxpZCBiYWNrZW5kJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYSBiYWNrZW5kLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmFja2VuZE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYmFja2VuZC5cclxuICogQHJldHVybnMgdGhlIGJhY2tlbmQgaW5zdGFuY2UgaWYgcmVzb2x2ZWQgYW5kIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBmYWlsZWQuXHJcbiAqL1xyXG5jb25zdCB0cnlSZXNvbHZlQW5kSW5pdGlhbGl6ZUJhY2tlbmQgPSBhc3luYyAoYmFja2VuZE5hbWU6IHN0cmluZyk6IFByb21pc2U8QmFja2VuZCB8IHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHMuZ2V0KGJhY2tlbmROYW1lKTtcclxuICBpZiAoIWJhY2tlbmRJbmZvKSB7XHJcbiAgICByZXR1cm4gJ2JhY2tlbmQgbm90IGZvdW5kLic7XHJcbiAgfVxyXG5cclxuICBpZiAoYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQpIHtcclxuICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xyXG4gIH0gZWxzZSBpZiAoYmFja2VuZEluZm8uYWJvcnRlZCkge1xyXG4gICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgaXNJbml0aWFsaXppbmcgPSAhIWJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xyXG4gICAgICAgIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlID0gYmFja2VuZEluZm8uYmFja2VuZC5pbml0KGJhY2tlbmROYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcclxuICAgICAgYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xyXG4gICAgICAgIGJhY2tlbmRJbmZvLmVycm9yID0gYCR7ZX1gO1xyXG4gICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5lcnJvciE7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBkZWxldGUgYmFja2VuZEluZm8uaW5pdFByb21pc2U7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc29sdmUgZXhlY3V0aW9uIHByb3ZpZGVycyBmcm9tIHRoZSBzcGVjaWZpYyBzZXNzaW9uIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXHJcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgYW4gaW5pdGlhbGl6ZWQgYmFja2VuZCBpbnN0YW5jZSBhbmQgYSBzZXNzaW9uIG9wdGlvbnMgb2JqZWN0IHdpdGhcclxuICogZmlsdGVyZWQgRVAgbGlzdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMgKFxyXG4gIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXHJcbik6IFByb21pc2U8W2JhY2tlbmQ6IEJhY2tlbmQsIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnNdPiA9PiB7XHJcbiAgLy8gZXh0cmFjdCBiYWNrZW5kIGhpbnRzIGZyb20gc2Vzc2lvbiBvcHRpb25zXHJcbiAgY29uc3QgZXBzID0gb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgfHwgW107XHJcbiAgY29uc3QgYmFja2VuZEhpbnRzID0gZXBzLm1hcCgoaSkgPT4gKHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpKTtcclxuICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xyXG5cclxuICAvLyB0cnkgdG8gcmVzb2x2ZSBhbmQgaW5pdGlhbGl6ZSBhbGwgcmVxdWVzdGVkIGJhY2tlbmRzXHJcbiAgbGV0IGJhY2tlbmQ6IEJhY2tlbmQgfCB1bmRlZmluZWQ7XHJcbiAgY29uc3QgZXJyb3JzID0gW107XHJcbiAgY29uc3QgYXZhaWxhYmxlQmFja2VuZE5hbWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcclxuICAgIGNvbnN0IHJlc29sdmVSZXN1bHQgPSBhd2FpdCB0cnlSZXNvbHZlQW5kSW5pdGlhbGl6ZUJhY2tlbmQoYmFja2VuZE5hbWUpO1xyXG4gICAgaWYgKHR5cGVvZiByZXNvbHZlUmVzdWx0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICBlcnJvcnMucHVzaCh7IG5hbWU6IGJhY2tlbmROYW1lLCBlcnI6IHJlc29sdmVSZXN1bHQgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoIWJhY2tlbmQpIHtcclxuICAgICAgICBiYWNrZW5kID0gcmVzb2x2ZVJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYmFja2VuZCA9PT0gcmVzb2x2ZVJlc3VsdCkge1xyXG4gICAgICAgIGF2YWlsYWJsZUJhY2tlbmROYW1lcy5hZGQoYmFja2VuZE5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBpZiBubyBiYWNrZW5kIGlzIGF2YWlsYWJsZSwgdGhyb3cgZXJyb3IuXHJcbiAgaWYgKCFiYWNrZW5kKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ZXJyb3JzLm1hcCgoZSkgPT4gYFske2UubmFtZX1dICR7ZS5lcnJ9YCkuam9pbignLCAnKX1gKTtcclxuICB9XHJcblxyXG4gIC8vIGZvciBlYWNoIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJhY2tlbmQsIGlmIGl0J3Mgbm90IGF2YWlsYWJsZSwgb3V0cHV0IHdhcm5pbmcgbWVzc2FnZS5cclxuICBmb3IgKGNvbnN0IHsgbmFtZSwgZXJyIH0gb2YgZXJyb3JzKSB7XHJcbiAgICBpZiAoYmFja2VuZEhpbnRzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bmFtZX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZXJyfWAsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBmaWx0ZXJlZEVwcyA9IGVwcy5maWx0ZXIoKGkpID0+IGF2YWlsYWJsZUJhY2tlbmROYW1lcy5oYXModHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xyXG5cclxuICByZXR1cm4gW1xyXG4gICAgYmFja2VuZCxcclxuICAgIG5ldyBQcm94eShvcHRpb25zLCB7XHJcbiAgICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xyXG4gICAgICAgIGlmIChwcm9wID09PSAnZXhlY3V0aW9uUHJvdmlkZXJzJykge1xyXG4gICAgICAgICAgcmV0dXJuIGZpbHRlcmVkRXBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKTtcclxuICAgICAgfSxcclxuICAgIH0pLFxyXG4gIF07XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xyXG5pbXBvcnQgeyBPbm54VmFsdWUgfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBTZXNzaW9uSGFuZGxlciB7XHJcbiAgdHlwZSBGZWVkc1R5cGUgPSB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfTtcclxuICB0eXBlIEZldGNoZXNUeXBlID0geyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbCB9O1xyXG4gIHR5cGUgUmV0dXJuVHlwZSA9IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBzaGFyZWQgU2Vzc2lvbkhhbmRsZXIgZnVuY3Rpb25hbGl0eVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbnRlcmZhY2UgU2Vzc2lvbkhhbmRsZXIge1xyXG4gIGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgcmVhZG9ubHkgaW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XHJcbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xyXG5cclxuICByZWFkb25seSBpbnB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcclxuICByZWFkb25seSBvdXRwdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGFuIGluZmVyZW5jZSBzZXNzaW9uLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIGV4dGVuZHMgU2Vzc2lvbkhhbmRsZXIge1xyXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XHJcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XHJcblxyXG4gIHJ1bihcclxuICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsXHJcbiAgICBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcclxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcclxuICApOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+O1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50IGEgYmFja2VuZCB0aGF0IHByb3ZpZGVzIGltcGxlbWVudGF0aW9uIG9mIG1vZGVsIGluZmVyZW5jaW5nLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tlbmQge1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIGJhY2tlbmQgYXN5bmNocm9ub3VzbHkuIFNob3VsZCB0aHJvdyB3aGVuIGZhaWxlZC5cclxuICAgKi9cclxuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihcclxuICAgIHVyaU9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxyXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XHJcbn1cclxuXHJcbmV4cG9ydCB7IHJlZ2lzdGVyQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IC9qcy9zY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLnRzXHJcbi8vIERvIG5vdCBtb2RpZnkgZmlsZSBjb250ZW50IG1hbnVhbGx5LlxyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4yMy4wJztcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBFbnYgfSBmcm9tICcuL2Vudi5qcyc7XHJcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xyXG5cclxudHlwZSBMb2dMZXZlbFR5cGUgPSBFbnZbJ2xvZ0xldmVsJ107XHJcblxyXG5sZXQgbG9nTGV2ZWxWYWx1ZTogUmVxdWlyZWQ8TG9nTGV2ZWxUeXBlPiA9ICd3YXJuaW5nJztcclxuXHJcbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IHtcclxuICB3YXNtOiB7fSBhcyBFbnYuV2ViQXNzZW1ibHlGbGFncyxcclxuICB3ZWJnbDoge30gYXMgRW52LldlYkdMRmxhZ3MsXHJcbiAgd2ViZ3B1OiB7fSBhcyBFbnYuV2ViR3B1RmxhZ3MsXHJcbiAgdmVyc2lvbnM6IHsgY29tbW9uOiB2ZXJzaW9uIH0sXHJcblxyXG4gIHNldCBsb2dMZXZlbCh2YWx1ZTogTG9nTGV2ZWxUeXBlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBbJ3ZlcmJvc2UnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJywgJ2ZhdGFsJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHt2YWx1ZX1gKTtcclxuICAgIH1cclxuICAgIGxvZ0xldmVsVmFsdWUgPSB2YWx1ZTtcclxuICB9LFxyXG4gIGdldCBsb2dMZXZlbCgpOiBSZXF1aXJlZDxMb2dMZXZlbFR5cGU+IHtcclxuICAgIHJldHVybiBsb2dMZXZlbFZhbHVlO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vLyBzZXQgcHJvcGVydHkgJ2xvZ0xldmVsJyBzbyB0aGF0IHRoZXkgY2FuIGJlIGNvcnJlY3RseSB0cmFuc2ZlcnJlZCB0byB3b3JrZXIgYnkgYHBvc3RNZXNzYWdlKClgLlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LCAnbG9nTGV2ZWwnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgZW52IGFzIGVudkltcGwgfSBmcm9tICcuL2Vudi1pbXBsLmpzJztcclxuaW1wb3J0IHsgVHJ5R2V0R2xvYmFsVHlwZSB9IGZyb20gJy4vdHlwZS1oZWxwZXIuanMnO1xyXG5cclxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEVudiB7XHJcbiAgZXhwb3J0IHR5cGUgV2FzbVBhdGhQcmVmaXggPSBzdHJpbmc7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBXYXNtRmlsZVBhdGhzIHtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSB0aGUgb3ZlcnJpZGUgcGF0aCBmb3IgdGhlIG1haW4gLndhc20gZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC53YXNtIGZpbGUgaXM6XHJcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21gIGZvciBkZWZhdWx0IGJ1aWxkXHJcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbWAgZm9yIEpTRVAgYnVpbGQgKHdpdGggV2ViR1BVIGFuZCBXZWJOTilcclxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuYXN5bmNpZnkud2FzbWAgZm9yIFdlYkdQVSBidWlsZCB3aXRoIEFzeW5jaWZ5ICh3aXRoIFdlYk5OKVxyXG4gICAgICovXHJcbiAgICB3YXNtPzogVVJMIHwgc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAubWpzIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIElmIG5vdCBtb2RpZmllZCwgdGhlIGZpbGVuYW1lIG9mIHRoZSAubWpzIGZpbGUgaXM6XHJcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLm1qc2AgZm9yIGRlZmF1bHQgYnVpbGRcclxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNgIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXHJcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmFzeW5jaWZ5Lm1qc2AgZm9yIFdlYkdQVSBidWlsZCB3aXRoIEFzeW5jaWZ5ICh3aXRoIFdlYk5OKVxyXG4gICAgICovXHJcbiAgICBtanM/OiBVUkwgfCBzdHJpbmc7XHJcbiAgfVxyXG4gIGV4cG9ydCB0eXBlIFdhc21QcmVmaXhPckZpbGVQYXRocyA9IFdhc21QYXRoUHJlZml4IHwgV2FzbUZpbGVQYXRocztcclxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkFzc2VtYmx5RmxhZ3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgb3IgZ2V0IG51bWJlciBvZiB0aHJlYWQocykuIElmIG9taXR0ZWQgb3Igc2V0IHRvIDAsIG51bWJlciBvZiB0aHJlYWQocykgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHN5c3RlbS4gSWYgc2V0XHJcbiAgICAgKiB0byAxLCBubyB3b3JrZXIgdGhyZWFkIHdpbGwgYmUgc3Bhd25lZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgd2hlbiBXZWJBc3NlbWJseSBtdWx0aXRocmVhZCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcclxuICAgICAqL1xyXG4gICAgbnVtVGhyZWFkcz86IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldCBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBlbmFibGUgU0lNRC5cclxuICAgICAqXHJcbiAgICAgKiBPTk5YIFJ1bnRpbWUgd2lsbCBwZXJmb3JtIGZlYXR1cmUgZGV0ZWN0aW9uIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5LiBTcGVjaWZpY2FsbHksIHdoZW4gdGhlIHZhbHVlIGlzXHJcbiAgICAgKiBzZXQgdG86XHJcbiAgICAgKiAtIGB1bmRlZmluZWRgLCBgdHJ1ZWAgb3IgYFwiZml4ZWRcImA6IHdpbGwgY2hlY2sgYXZhaWxhYmlsaXR5IG9mIEZpeGVkLXdpZHRoIFNJTUQuXHJcbiAgICAgKiAtIGBcInJlbGF4ZWRcImA6IHdpbGwgY2hlY2sgYXZhaWxhYmlsaXR5IG9mIFJlbGF4ZWQgU0lNRC5cclxuICAgICAqIC0gYGZhbHNlYDogd2lsbCBub3QgcGVyZm9ybSBTSU1EIGZlYXR1cmUgY2hlY2tpbmcuXHJcbiAgICAgKlxyXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IGRvZXMgbm90IG1ha2UgT05OWCBSdW50aW1lIHRvIHN3aXRjaCB0byB0aGUgY29ycmVzcG9uZGluZyBydW50aW1lIGF1dG9tYXRpY2FsbHkuIFVzZXIgbmVlZFxyXG4gICAgICogdG8gc2V0IGB3YXNtUGF0aHNgIG9yIGB3YXNtQmluYXJ5YCBwcm9wZXJ0eSB0byBsb2FkIHRoZSBjb3JyZXNwb25kaW5nIHJ1bnRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgU0lNRCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgdHJ1ZWBcclxuICAgICAqL1xyXG4gICAgc2ltZD86IGJvb2xlYW4gfCAnZml4ZWQnIHwgJ3JlbGF4ZWQnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGVudi50cmFjZWAgaW5zdGVhZC4gSWYgYGVudi50cmFjZWAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgdHJhY2U/OiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCBhIG51bWJlciBzcGVjaWZ5aW5nIHRoZSB0aW1lb3V0IGZvciBpbml0aWFsaXphdGlvbiBvZiBXZWJBc3NlbWJseSBiYWNrZW5kLCBpbiBtaWxsaXNlY29uZHMuIEEgemVyb1xyXG4gICAgICogdmFsdWUgaW5kaWNhdGVzIG5vIHRpbWVvdXQgaXMgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBkZWZhdWx0VmFsdWUgYDBgXHJcbiAgICAgKi9cclxuICAgIGluaXRUaW1lb3V0PzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY3VzdG9tIFVSTCBwcmVmaXggdG8gdGhlIC53YXNtLy5tanMgZmlsZXMsIG9yIGFuIG9iamVjdCBvZiBvdmVycmlkZXMgZm9yIGJvdGggLndhc20vLm1qcyBmaWxlLiBUaGUgb3ZlcnJpZGVcclxuICAgICAqIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHdhc21QYXRocz86IFdhc21QcmVmaXhPckZpbGVQYXRocztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGN1c3RvbSBidWZmZXIgd2hpY2ggY29udGFpbnMgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeS4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBgd2FzbVBhdGhzYCBwcm9wZXJ0eSB3aWxsXHJcbiAgICAgKiBiZSBpZ25vcmVkLlxyXG4gICAgICovXHJcbiAgICB3YXNtQmluYXJ5PzogQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBwcm94eSB0aGUgZXhlY3V0aW9uIG9mIG1haW4gdGhyZWFkIHRvIGEgd29ya2VyIHRocmVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcclxuICAgICAqL1xyXG4gICAgcHJveHk/OiBib29sZWFuO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEZsYWdzIHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgV2ViR0wgQ29udGV4dCBJRCAod2ViZ2wgb3Igd2ViZ2wyKS5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAnd2ViZ2wyJ2BcclxuICAgICAqL1xyXG4gICAgY29udGV4dElkPzogJ3dlYmdsJyB8ICd3ZWJnbDInO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBjb250ZXh0OiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIG1heGltdW0gYmF0Y2ggc2l6ZSBmb3IgbWF0bXVsLiAwIG1lYW5zIHRvIGRpc2FibGUgYmF0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgbWF0bXVsTWF4QmF0Y2hTaXplPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSB0ZXh0dXJlIGNhY2hlIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgJ2Z1bGwnYFxyXG4gICAgICovXHJcbiAgICB0ZXh0dXJlQ2FjaGVNb2RlPzogJ2luaXRpYWxpemVyT25seScgfCAnZnVsbCc7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHBhY2tlZCB0ZXh0dXJlIG1vZGVcclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcclxuICAgICAqL1xyXG4gICAgcGFjaz86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciBlbmFibGUgYXN5bmMgZG93bmxvYWQuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXHJcbiAgICAgKi9cclxuICAgIGFzeW5jPzogYm9vbGVhbjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGEge1xyXG4gICAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XHJcbiAgICBkYXRhVHlwZTogc3RyaW5nO1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMSB7XHJcbiAgICB2ZXJzaW9uOiAxO1xyXG4gICAgaW5wdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XHJcbiAgICBvdXRwdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XHJcbiAgICBrZXJuZWxJZDogbnVtYmVyO1xyXG4gICAga2VybmVsVHlwZTogc3RyaW5nO1xyXG4gICAga2VybmVsTmFtZTogc3RyaW5nO1xyXG4gICAgcHJvZ3JhbU5hbWU6IHN0cmluZztcclxuICAgIHN0YXJ0VGltZTogbnVtYmVyO1xyXG4gICAgZW5kVGltZTogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IHR5cGUgV2ViR3B1UHJvZmlsaW5nRGF0YSA9IFdlYkdwdVByb2ZpbGluZ0RhdGFWMTtcclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVGbGFncyB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBtb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaW5zdGVhZC4gSWYgYGVudi53ZWJncHUucHJvZmlsaW5nLm1vZGVgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlXHJcbiAgICAgKiBpZ25vcmVkLlxyXG4gICAgICovXHJcbiAgICBwcm9maWxpbmdNb2RlPzogJ29mZicgfCAnZGVmYXVsdCc7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBjb25maWd1cmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcm9maWxpbmc6IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBtb2RlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcclxuICAgICAgICovXHJcbiAgICAgIG1vZGU/OiAnb2ZmJyB8ICdkZWZhdWx0JztcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZXQgb3IgZ2V0IGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIHByb2ZpbGluZyBkYXRhIGlzIHJlY2VpdmVkLiBJZiBub3Qgc2V0LCB0aGUgcHJvZmlsaW5nIGRhdGEgd2lsbCBiZVxyXG4gICAgICAgKiBwcmludGVkIHRvIGNvbnNvbGUuXHJcbiAgICAgICAqL1xyXG4gICAgICBvbmRhdGE/OiAoZGF0YTogV2ViR3B1UHJvZmlsaW5nRGF0YSkgPT4gdm9pZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHBvd2VyIHByZWZlcmVuY2UuXHJcbiAgICAgKlxyXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IG9ubHkgaGFzIGVmZmVjdCBiZWZvcmUgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZVxyXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cclxuICAgICAqXHJcbiAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vZ3B1d2ViLmdpdGh1Yi5pby9ncHV3ZWIvI2RpY3RkZWYtZ3B1cmVxdWVzdGFkYXB0ZXJvcHRpb25zfSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICpcclxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBDcmVhdGUgeW91ciBvd24gR1BVQWRhcHRlciwgdXNlIGl0IHRvIGNyZWF0ZSBhIEdQVURldmljZSBpbnN0YW5jZSBhbmQgc2V0IHtAbGluayBkZXZpY2V9IHByb3BlcnR5IGlmXHJcbiAgICAgKiB5b3Ugd2FudCB0byB1c2UgYSBzcGVjaWZpYyBwb3dlciBwcmVmZXJlbmNlLlxyXG4gICAgICovXHJcbiAgICBwb3dlclByZWZlcmVuY2U/OiAnbG93LXBvd2VyJyB8ICdoaWdoLXBlcmZvcm1hbmNlJztcclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgZm9yY2UgZmFsbGJhY2sgYWRhcHRlciBmbGFnLlxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcclxuICAgICAqIHVzZWQgYXMgb3B0aW9ucyBmb3IgYG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKWAuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgQ3JlYXRlIHlvdXIgb3duIEdQVUFkYXB0ZXIsIHVzZSBpdCB0byBjcmVhdGUgYSBHUFVEZXZpY2UgaW5zdGFuY2UgYW5kIHNldCB7QGxpbmsgZGV2aWNlfSBwcm9wZXJ0eSBpZlxyXG4gICAgICogeW91IHdhbnQgdG8gdXNlIGEgc3BlY2lmaWMgZmFsbGJhY2sgb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBmb3JjZUZhbGxiYWNrQWRhcHRlcj86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIGFkYXB0ZXIgZm9yIFdlYkdQVS5cclxuICAgICAqXHJcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXHJcbiAgICAgKiB1c2VkIGFzIHRoZSBHUFUgYWRhcHRlciBmb3IgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQgdG8gY3JlYXRlIEdQVSBkZXZpY2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhpcyBwcm9wZXJ0eSBpcyBub3Qgc2V0LCBpdCB3aWxsIGJlIGF2YWlsYWJsZSB0byBnZXQgYWZ0ZXIgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGVcclxuICAgICAqIHZhbHVlIHdpbGwgYmUgdGhlIEdQVSBhZGFwdGVyIHRoYXQgY3JlYXRlZCBieSB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZC5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHVzZSB3aXRoIFR5cGVTY3JpcHQsIHRoZSB0eXBlIG9mIHRoaXMgcHJvcGVydHkgaXMgYEdQVUFkYXB0ZXJgIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgSXQgaXMgbm8gbG9uZ2VyIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIHByb3BlcnR5LiBUaGUgbGF0ZXN0IFdlYkdQVSBzcGVjIGFkZHMgYEdQVURldmljZS5hZGFwdGVySW5mb2BcclxuICAgICAqIChodHRwczovL3d3dy53My5vcmcvVFIvd2ViZ3B1LyNkb20tZ3B1ZGV2aWNlLWFkYXB0ZXJpbmZvKSwgd2hpY2ggYWxsb3dzIHRvIGdldCB0aGUgYWRhcHRlciBpbmZvcm1hdGlvbiBmcm9tIHRoZVxyXG4gICAgICogZGV2aWNlLiBXaGVuIGl0J3MgYXZhaWxhYmxlLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNldC9nZXQgdGhlIHtAbGluayBhZGFwdGVyfSBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgYWRhcHRlcjogVHJ5R2V0R2xvYmFsVHlwZTwnR1BVQWRhcHRlcic+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBHUFUgZGV2aWNlIGZvciBXZWJHUFUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlcmUgYXJlIDMgdmFsaWQgc2NlbmFyaW9zIG9mIGFjY2Vzc2luZyB0aGlzIHByb3BlcnR5OlxyXG4gICAgICogLSBTZXQgYSB2YWx1ZSBiZWZvcmUgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZSB1c2VkIGJ5IHRoZSBXZWJHUFUgYmFja2VuZFxyXG4gICAgICogdG8gcGVyZm9ybSBjYWxjdWxhdGlvbnMuIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBgR1BVRGV2aWNlYCBvYmplY3QsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG4gICAgICogLSBHZXQgdGhlIHZhbHVlIGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoaXMgd2lsbCB0cnkgdG8gY3JlYXRlIGEgbmV3IEdQVURldmljZVxyXG4gICAgICogaW5zdGFuY2UuIFJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byBhIGBHUFVEZXZpY2VgIG9iamVjdC5cclxuICAgICAqIC0gR2V0IHRoZSB2YWx1ZSBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFJldHVybnMgYSByZXNvbHZlZCBgUHJvbWlzZWAgdG8gdGhlXHJcbiAgICAgKiBgR1BVRGV2aWNlYCBvYmplY3QgdXNlZCBieSB0aGUgV2ViR1BVIGJhY2tlbmQuXHJcbiAgICAgKi9cclxuICAgIGdldCBkZXZpY2UoKTogUHJvbWlzZTxUcnlHZXRHbG9iYWxUeXBlPCdHUFVEZXZpY2UnPj47XHJcbiAgICBzZXQgZGV2aWNlKHZhbHVlOiBUcnlHZXRHbG9iYWxUeXBlPCdHUFVEZXZpY2UnPik7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciB2YWxpZGF0ZSBpbnB1dCBjb250ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZUlucHV0Q29udGVudD86IGJvb2xlYW47XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVudiB7XHJcbiAgLyoqXHJcbiAgICogc2V0IHRoZSBzZXZlcml0eSBsZXZlbCBmb3IgbG9nZ2luZy5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0VmFsdWUgYCd3YXJuaW5nJ2BcclxuICAgKi9cclxuICBsb2dMZXZlbD86ICd2ZXJib3NlJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnZmF0YWwnO1xyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHJ1biBpbiBkZWJ1ZyBtb2RlLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXHJcbiAgICovXHJcbiAgZGVidWc/OiBib29sZWFuO1xyXG5cclxuICAvKipcclxuICAgKiBzZXQgb3IgZ2V0IGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gZW5hYmxlIHRyYWNlLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXHJcbiAgICovXHJcbiAgdHJhY2U/OiBib29sZWFuO1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgdmVyc2lvbiBvZiB0aGUgY3VycmVudCBwYWNrYWdlLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IHZlcnNpb25zOiB7XHJcbiAgICByZWFkb25seSBjb21tb246IHN0cmluZztcclxuICAgIHJlYWRvbmx5IHdlYj86IHN0cmluZztcclxuICAgIHJlYWRvbmx5IG5vZGU/OiBzdHJpbmc7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICByZWFkb25seSAncmVhY3QtbmF0aXZlJz86IHN0cmluZztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkFzc2VtYmx5XHJcbiAgICovXHJcbiAgcmVhZG9ubHkgd2FzbTogRW52LldlYkFzc2VtYmx5RmxhZ3M7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR0xcclxuICAgKi9cclxuICByZWFkb25seSB3ZWJnbDogRW52LldlYkdMRmxhZ3M7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR1BVXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgd2ViZ3B1OiBFbnYuV2ViR3B1RmxhZ3M7XHJcblxyXG4gIFtuYW1lOiBzdHJpbmddOiB1bmtub3duO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGFzIGEgZ2xvYmFsIHNpbmdsZXRvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IGVudkltcGw7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yVG9EYXRhVXJsT3B0aW9ucywgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zIH0gZnJvbSAnLi90ZW5zb3ItY29udmVyc2lvbi5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcclxuXHJcbi8qKlxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9EYXRhVVJMKClcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0RhdGFVUkwgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBjYW52YXMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykgOiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xyXG4gIGNhbnZhcy53aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xyXG4gIGNhbnZhcy5oZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcclxuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhc1xyXG4gICAgfCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcbiAgICB8IG51bGw7XHJcblxyXG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xyXG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcclxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xyXG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xyXG4gICAgaWYgKG9wdGlvbnM/LnRlbnNvckxheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcclxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcclxuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbM107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXHJcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbM107XHJcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InO1xyXG5cclxuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xyXG4gICAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG5vcm1NZWFuID0gWzI1NSwgMjU1LCAyNTUsIDI1NV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhblswXSwgbm9ybS5tZWFuWzFdLCBub3JtLm1lYW5bMl0sIDBdO1xyXG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcclxuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xyXG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXHJcbiAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLFxyXG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSxcclxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxyXG4gICAgICBhVGVuc29yUG9pbnRlciA9IC0xO1xyXG5cclxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcclxuICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XHJcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcclxuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XHJcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcclxuICAgICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xyXG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcclxuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xyXG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcclxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xyXG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcclxuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xyXG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcclxuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XHJcbiAgICAgICAgY29uc3QgUiA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXHJcbiAgICAgICAgY29uc3QgRyA9ICgodGVuc29yLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXHJcbiAgICAgICAgY29uc3QgQiA9ICgodGVuc29yLmRhdGFbYlRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAvLyBCIHZhbHVlXHJcbiAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXHJcbiAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBSICsgJywnICsgRyArICcsJyArIEIgKyAnLCcgKyBBICsgJyknO1xyXG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCd0b0RhdGFVUkwnIGluIGNhbnZhcykge1xyXG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLnRvSW1hZ2VEYXRhKClcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0ltYWdlRGF0YSA9ICh0ZW5zb3I6IFRlbnNvciwgb3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSA9PiB7XHJcbiAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID1cclxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpXHJcbiAgICAgIDogKG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSkuZ2V0Q29udGV4dCgnMmQnKSBhcyBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpO1xyXG4gIGxldCBpbWFnZTogSW1hZ2VEYXRhO1xyXG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xyXG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcclxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xyXG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xyXG4gICAgbGV0IGNoYW5uZWxzOiBudW1iZXI7XHJcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xyXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xyXG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1sxXTtcclxuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1szXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIERlZmF1bHQgbGF5b3V0IGlzIE5DV0hcclxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcclxuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XHJcbiAgICAgIGNoYW5uZWxzID0gdGVuc29yLmRpbXNbMV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcclxuXHJcbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcclxuICAgIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xyXG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAyNTVdO1xyXG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcclxuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xyXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgY2hhbm5lbHMgPT09IDQgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0JBJykgfHxcclxuICAgICAgICAoY2hhbm5lbHMgPT09IDMgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0InICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnQkdSJylcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGZvcm1hdCBkb2Vzbid0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXHJcbiAgICBjb25zdCBzdGVwID0gNDtcclxuICAgIGxldCBySW1hZ2VQb2ludGVyID0gMCxcclxuICAgICAgZ0ltYWdlUG9pbnRlciA9IDEsXHJcbiAgICAgIGJJbWFnZVBvaW50ZXIgPSAyLFxyXG4gICAgICBhSW1hZ2VQb2ludGVyID0gMztcclxuICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsXHJcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxyXG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXHJcbiAgICAgIGFUZW5zb3JQb2ludGVyID0gLTE7XHJcblxyXG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxyXG4gICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcclxuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xyXG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcclxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xyXG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XHJcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xyXG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XHJcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xyXG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XHJcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkJHJykge1xyXG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XHJcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xyXG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XHJcbiAgICB9XHJcblxyXG4gICAgaW1hZ2UgPSBwaXhlbHMyRENvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIGZvciAoXHJcbiAgICAgIGxldCBpID0gMDtcclxuICAgICAgaSA8IGhlaWdodCAqIHdpZHRoO1xyXG4gICAgICBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGkrK1xyXG4gICAgKSB7XHJcbiAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgLy8gUiB2YWx1ZVxyXG4gICAgICBpbWFnZS5kYXRhW2dJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMV0pICogbm9ybU1lYW5bMV07IC8vIEcgdmFsdWVcclxuICAgICAgaW1hZ2UuZGF0YVtiSW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbYlRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAvLyBCIHZhbHVlXHJcbiAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPVxyXG4gICAgICAgIGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xyXG4gIH1cclxuICByZXR1cm4gaW1hZ2U7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHtcclxuICBPcHRpb25zRGltZW5zaW9ucyxcclxuICBPcHRpb25zRm9ybWF0LFxyXG4gIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyxcclxuICBPcHRpb25zVGVuc29yRm9ybWF0LFxyXG4gIE9wdGlvbnNUZW5zb3JMYXlvdXQsXHJcbiAgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsXHJcbiAgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcclxuICBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucyxcclxuICBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcclxuICBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zLFxyXG4gIFRlbnNvckZyb21UZXh0dXJlT3B0aW9ucyxcclxuICBUZW5zb3JGcm9tVXJsT3B0aW9ucyxcclxufSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcclxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL3RlbnNvci5qcyc7XHJcblxyXG5pbnRlcmZhY2UgQnVmZmVyVG9UZW5zb3JPcHRpb25zXHJcbiAgZXh0ZW5kcyBPcHRpb25zRGltZW5zaW9ucyxcclxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXHJcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsXHJcbiAgICBPcHRpb25zRm9ybWF0LFxyXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCB7fVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gaW1hZ2Ugb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBidWZmZXIgLSBFeHRyYWN0ZWQgaW1hZ2UgYnVmZmVyIGRhdGEgLSBhc3N1bWluZyBSR0JBIGZvcm1hdFxyXG4gKiBAcGFyYW0gaW1hZ2VGb3JtYXQgLSBpbnB1dCBpbWFnZSBjb25maWd1cmF0aW9uIC0gcmVxdWlyZWQgY29uZmlndXJhdGlvbnMgaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XHJcbiAqIEBwYXJhbSB0ZW5zb3JGb3JtYXQgLSBvdXRwdXQgdGVuc29yIGNvbmZpZ3VyYXRpb24gLSBEZWZhdWx0IGlzIFJHQiBmb3JtYXRcclxuICovXHJcbmV4cG9ydCBjb25zdCBidWZmZXJUb1RlbnNvciA9IChidWZmZXI6IFVpbnQ4Q2xhbXBlZEFycmF5IHwgdW5kZWZpbmVkLCBvcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMpOiBUZW5zb3IgPT4ge1xyXG4gIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkJyk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMud2lkdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZCcpO1xyXG4gIH1cclxuICBpZiAob3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gb3B0aW9ucztcclxuXHJcbiAgY29uc3Qgbm9ybSA9IG9wdGlvbnMubm9ybSA/PyB7IG1lYW46IDI1NSwgYmlhczogMCB9O1xyXG4gIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XHJcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4hWzBdLCBub3JtLm1lYW4hWzFdLCBub3JtLm1lYW4hWzJdLCBub3JtLm1lYW4hWzNdID8/IDI1NV07XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIG5vcm0uYmlhcyA9PT0gJ251bWJlcicpIHtcclxuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XHJcbiAgfSBlbHNlIHtcclxuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcyFbMF0sIG5vcm0uYmlhcyFbMV0sIG5vcm0uYmlhcyFbMl0sIG5vcm0uYmlhcyFbM10gPz8gMF07XHJcbiAgfVxyXG5cclxuICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0JBJztcclxuICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcclxuXHJcbiAgY29uc3Qgb3V0cHV0Zm9ybWF0ID1cclxuICAgIG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XHJcbiAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XHJcbiAgY29uc3QgZmxvYXQzMkRhdGEgPSBvdXRwdXRmb3JtYXQgPT09ICdSR0JBJyA/IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogNCkgOiBuZXcgRmxvYXQzMkFycmF5KHN0cmlkZSAqIDMpO1xyXG5cclxuICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcclxuICBsZXQgc3RlcCA9IDQsXHJcbiAgICBySW1hZ2VQb2ludGVyID0gMCxcclxuICAgIGdJbWFnZVBvaW50ZXIgPSAxLFxyXG4gICAgYkltYWdlUG9pbnRlciA9IDIsXHJcbiAgICBhSW1hZ2VQb2ludGVyID0gMztcclxuICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLFxyXG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsXHJcbiAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXHJcbiAgICBhVGVuc29yUG9pbnRlciA9IC0xO1xyXG5cclxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XHJcbiAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xyXG4gICAgc3RlcCA9IDM7XHJcbiAgICBySW1hZ2VQb2ludGVyID0gMDtcclxuICAgIGdJbWFnZVBvaW50ZXIgPSAxO1xyXG4gICAgYkltYWdlUG9pbnRlciA9IDI7XHJcbiAgICBhSW1hZ2VQb2ludGVyID0gLTE7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcclxuICBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcclxuICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcclxuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcclxuICAgIHJUZW5zb3JQb2ludGVyID0gMDtcclxuICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xyXG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xyXG4gIH0gZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnQkdSJykge1xyXG4gICAgYlRlbnNvclBvaW50ZXIgPSAwO1xyXG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XHJcbiAgICByVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XHJcbiAgfVxyXG5cclxuICBmb3IgKFxyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgaSA8IHN0cmlkZTtcclxuICAgIGkrKywgckltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwXHJcbiAgKSB7XHJcbiAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1swXSkgLyBub3JtTWVhblswXTtcclxuICAgIGZsb2F0MzJEYXRhW2dUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltnSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzFdKSAvIG5vcm1NZWFuWzFdO1xyXG4gICAgZmxvYXQzMkRhdGFbYlRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMl0pIC8gbm9ybU1lYW5bMl07XHJcbiAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XHJcbiAgICAgIGZsb2F0MzJEYXRhW2FUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlclthSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzNdKSAvIG5vcm1NZWFuWzNdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmxvYXQzMkFycmF5IC0+IG9ydC5UZW5zb3JcclxuICBjb25zdCBvdXRwdXRUZW5zb3IgPVxyXG4gICAgb3V0cHV0Zm9ybWF0ID09PSAnUkdCQSdcclxuICAgICAgPyBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCA0LCBoZWlnaHQsIHdpZHRoXSlcclxuICAgICAgOiBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCAzLCBoZWlnaHQsIHdpZHRoXSk7XHJcbiAgcmV0dXJuIG91dHB1dFRlbnNvcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUltYWdlKCkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUltYWdlID0gYXN5bmMgKFxyXG4gIGltYWdlOiBJbWFnZURhdGEgfCBIVE1MSW1hZ2VFbGVtZW50IHwgSW1hZ2VCaXRtYXAgfCBzdHJpbmcsXHJcbiAgb3B0aW9ucz86XHJcbiAgICB8IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zXHJcbiAgICB8IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zXHJcbiAgICB8IFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcclxuICAgIHwgVGVuc29yRnJvbVVybE9wdGlvbnMsXHJcbik6IFByb21pc2U8VGVuc29yPiA9PiB7XHJcbiAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XHJcbiAgY29uc3QgaXNIVE1MSW1hZ2VFbGUgPSB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGNvbnN0IGlzSW1hZ2VEYXRhRWxlID0gdHlwZW9mIEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGE7XHJcbiAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcclxuICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZyc7XHJcblxyXG4gIGxldCBkYXRhOiBVaW50OENsYW1wZWRBcnJheSB8IHVuZGVmaW5lZDtcclxuICBsZXQgYnVmZmVyVG9UZW5zb3JPcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xyXG5cclxuICBjb25zdCBjcmVhdGVDYW52YXMgPSAoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgY3JlYXRlQ2FudmFzQ29udGV4dCA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICB9IGVsc2UgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xyXG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICBpZiAoaXNIVE1MSW1hZ2VFbGUpIHtcclxuICAgIC8vIEhUTUxJbWFnZUVsZW1lbnQgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgaXMgUkdCQSBieSBkZWZhdWx0XHJcbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcclxuXHJcbiAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcclxuICAgICAgbGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuICAgICAgbGV0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkV2lkdGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcclxuICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XHJcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcbiAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XHJcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XHJcbiAgICBsZXQgd2lkdGg6IG51bWJlcjtcclxuXHJcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xyXG4gICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5mb3JtYXQgPSAnUkdCQSc7XHJcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCB0ZW1wQ2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XHJcblxyXG4gICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dCh0ZW1wQ2FudmFzKTtcclxuXHJcbiAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xyXG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xyXG4gICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRhdGEgPSBpbWFnZS5kYXRhO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNJbWFnZUJpdG1hcCkge1xyXG4gICAgLy8gSW1hZ2VCaXRtYXAgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgbXVzdCBiZSBwcm92aWRlZCBieSB1c2VyXHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xyXG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xyXG5cclxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcbiAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xyXG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcclxuICAgICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcclxuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcclxuICAgICAgaWYgKCFpbWFnZSB8fCAhY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiByZWplY3QoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBuZXdJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICBuZXdJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xyXG4gICAgICBuZXdJbWFnZS5zcmMgPSBpbWFnZTtcclxuICAgICAgbmV3SW1hZ2Uub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdJbWFnZS5oZWlnaHQ7XHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UobmV3SW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gY2FudmFzLndpZHRoO1xyXG4gICAgICAgIHJlc29sdmUoYnVmZmVyVG9UZW5zb3IoaW1nLmRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucykpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcclxuICB9XHJcblxyXG4gIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tVGV4dHVyZSgpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21UZXh0dXJlID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXHJcbiAgdGV4dHVyZTogVGVuc29ySW50ZXJmYWNlLlRleHR1cmVUeXBlLFxyXG4gIG9wdGlvbnM6IFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUPixcclxuKTogVGVuc29yID0+IHtcclxuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xyXG4gIC8vIEFsd2F5cyBhc3N1bWUgUkdCQUYzMi4gVE9ETzogc3VwcG9ydCBkaWZmZXJlbnQgdGV4dHVyZSBmb3JtYXRcclxuICBjb25zdCBkaW1zID0gWzEsIGhlaWdodCwgd2lkdGgsIDRdO1xyXG4gIHJldHVybiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICd0ZXh0dXJlJywgdHlwZTogJ2Zsb2F0MzInLCB0ZXh0dXJlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcigpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21HcHVCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJEYXRhVHlwZXM+KFxyXG4gIGdwdUJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlclR5cGUsXHJcbiAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXHJcbik6IFRlbnNvciA9PiB7XHJcbiAgY29uc3QgeyBkYXRhVHlwZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IG9wdGlvbnM7XHJcbiAgcmV0dXJuIG5ldyBUZW5zb3IoeyBsb2NhdGlvbjogJ2dwdS1idWZmZXInLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIGdwdUJ1ZmZlciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21NTFRlbnNvcigpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21NTFRlbnNvciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yRGF0YVR5cGVzPihcclxuICBtbFRlbnNvcjogVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZSxcclxuICBvcHRpb25zOiBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQ+LFxyXG4pOiBUZW5zb3IgPT4ge1xyXG4gIGNvbnN0IHsgZGF0YVR5cGUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xyXG4gIHJldHVybiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICdtbC10ZW5zb3InLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIG1sVGVuc29yLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVBpbm5lZEJ1ZmZlcigpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21QaW5uZWRCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5DcHVQaW5uZWREYXRhVHlwZXM+KFxyXG4gIHR5cGU6IFQsXHJcbiAgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sXHJcbiAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4pOiBUZW5zb3IgPT4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsIHR5cGUsIGRhdGE6IGJ1ZmZlciwgZGltczogZGltcyA/PyBbYnVmZmVyLmxlbmd0aF0gfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xyXG5cclxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9XHJcbiAgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcclxuICB8IEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgQmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvcjtcclxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheSA9IEluc3RhbmNlVHlwZTxTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzPjtcclxuXHJcbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXHJcbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQID0gbmV3IE1hcDxzdHJpbmcsIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+KFtcclxuICBbJ2Zsb2F0MzInLCBGbG9hdDMyQXJyYXldLFxyXG4gIFsndWludDgnLCBVaW50OEFycmF5XSxcclxuICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxyXG4gIFsndWludDE2JywgVWludDE2QXJyYXldLFxyXG4gIFsnaW50MTYnLCBJbnQxNkFycmF5XSxcclxuICBbJ2ludDMyJywgSW50MzJBcnJheV0sXHJcbiAgWydib29sJywgVWludDhBcnJheV0sXHJcbiAgWydmbG9hdDY0JywgRmxvYXQ2NEFycmF5XSxcclxuICBbJ3VpbnQzMicsIFVpbnQzMkFycmF5XSxcclxuICBbJ2ludDQnLCBVaW50OEFycmF5XSxcclxuICBbJ3VpbnQ0JywgVWludDhBcnJheV0sXHJcbl0pO1xyXG5cclxuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cclxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAgPSBuZXcgTWFwPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsIFRlbnNvci5UeXBlPihbXHJcbiAgW0Zsb2F0MzJBcnJheSwgJ2Zsb2F0MzInXSxcclxuICBbVWludDhBcnJheSwgJ3VpbnQ4J10sXHJcbiAgW0ludDhBcnJheSwgJ2ludDgnXSxcclxuICBbVWludDE2QXJyYXksICd1aW50MTYnXSxcclxuICBbSW50MTZBcnJheSwgJ2ludDE2J10sXHJcbiAgW0ludDMyQXJyYXksICdpbnQzMiddLFxyXG4gIFtGbG9hdDY0QXJyYXksICdmbG9hdDY0J10sXHJcbiAgW1VpbnQzMkFycmF5LCAndWludDMyJ10sXHJcbl0pO1xyXG5cclxuLy8gdGhlIGZvbGxvd2luZyBjb2RlIGFsbG93cyBkZWxheWluZyBleGVjdXRpb24gb2YgQmlnSW50L0Zsb2F0MTZBcnJheSBjaGVja2luZy4gVGhpcyBhbGxvd3MgbGF6eSBpbml0aWFsaXphdGlvbiBmb3JcclxuLy8gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCBhbmQgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCwgd2hpY2ggYWxsb3dzIEJpZ0ludC9GbG9hdDE2QXJyYXlcclxuLy8gcG9seWZpbGwgaWYgYXZhaWxhYmxlLlxyXG5sZXQgaXNUeXBlZEFycmF5Q2hlY2tlZCA9IGZhbHNlO1xyXG5leHBvcnQgY29uc3QgY2hlY2tUeXBlZEFycmF5ID0gKCkgPT4ge1xyXG4gIGlmICghaXNUeXBlZEFycmF5Q2hlY2tlZCkge1xyXG4gICAgaXNUeXBlZEFycmF5Q2hlY2tlZCA9IHRydWU7XHJcbiAgICBjb25zdCBpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnSW50NjRBcnJheS5mcm9tO1xyXG4gICAgY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnVWludDY0QXJyYXkuZnJvbTtcclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBjb25zdCBGbG9hdDE2QXJyYXkgPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLkZsb2F0MTZBcnJheTtcclxuICAgIGNvbnN0IGlzRmxvYXQxNkFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb207XHJcblxyXG4gICAgaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xyXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnaW50NjQnLCBCaWdJbnQ2NEFycmF5KTtcclxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnSW50NjRBcnJheSwgJ2ludDY0Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSkge1xyXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgndWludDY0JywgQmlnVWludDY0QXJyYXkpO1xyXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRmxvYXQxNkFycmF5QXZhaWxhYmxlKSB7XHJcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgRmxvYXQxNkFycmF5KTtcclxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoRmxvYXQxNkFycmF5LCAnZmxvYXQxNicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaWYgRmxvYXQxNkFycmF5IGlzIG5vdCBhdmFpbGFibGUsIHVzZSAnVWludDE2QXJyYXknIHRvIHN0b3JlIHRoZSBkYXRhLlxyXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnZmxvYXQxNicsIFVpbnQxNkFycmF5KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHtcclxuICBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXHJcbiAgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxyXG4gIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxyXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXHJcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSBzaXplIGZyb20gZGltcy5cclxuICpcclxuICogQHBhcmFtIGRpbXMgdGhlIGRpbXMgYXJyYXkuIE1heSBiZSBhbiBpbGxlZ2FsIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcclxuICBsZXQgc2l6ZSA9IDE7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xyXG4gICAgaWYgKHR5cGVvZiBkaW0gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaW0pKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpbSA8IDApIHtcclxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xyXG4gICAgfVxyXG4gICAgc2l6ZSAqPSBkaW07XHJcbiAgfVxyXG4gIHJldHVybiBzaXplO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5yZXNoYXBlKClcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XHJcbiAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcclxuICAgIGNhc2UgJ2NwdSc6XHJcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XHJcbiAgICBjYXNlICdjcHUtcGlubmVkJzpcclxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xyXG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXHJcbiAgICAgICAgZGF0YTogdGVuc29yLmRhdGEgYXMgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzWydkYXRhJ10sXHJcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXHJcbiAgICAgICAgZGltcyxcclxuICAgICAgfSk7XHJcbiAgICBjYXNlICd0ZXh0dXJlJzpcclxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xyXG4gICAgICAgIGxvY2F0aW9uOiAndGV4dHVyZScsXHJcbiAgICAgICAgdGV4dHVyZTogdGVuc29yLnRleHR1cmUsXHJcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxyXG4gICAgICAgIGRpbXMsXHJcbiAgICAgIH0pO1xyXG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XHJcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHtcclxuICAgICAgICBsb2NhdGlvbjogJ2dwdS1idWZmZXInLFxyXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcclxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcclxuICAgICAgICBkaW1zLFxyXG4gICAgICB9KTtcclxuICAgIGNhc2UgJ21sLXRlbnNvcic6XHJcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHtcclxuICAgICAgICBsb2NhdGlvbjogJ21sLXRlbnNvcicsXHJcbiAgICAgICAgbWxUZW5zb3I6IHRlbnNvci5tbFRlbnNvcixcclxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxyXG4gICAgICAgIGRpbXMsXHJcbiAgICAgIH0pO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgdGVuc29yVG9EYXRhVVJMLCB0ZW5zb3JUb0ltYWdlRGF0YSB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcyc7XHJcbmltcG9ydCB7IFRlbnNvclRvRGF0YVVybE9wdGlvbnMsIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xyXG5pbXBvcnQge1xyXG4gIHRlbnNvckZyb21HcHVCdWZmZXIsXHJcbiAgdGVuc29yRnJvbUltYWdlLFxyXG4gIHRlbnNvckZyb21NTFRlbnNvcixcclxuICB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyLFxyXG4gIHRlbnNvckZyb21UZXh0dXJlLFxyXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnktaW1wbC5qcyc7XHJcbmltcG9ydCB7XHJcbiAgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxyXG4gIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcclxuICBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcclxuICBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9ucyxcclxuICBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zLFxyXG4gIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxyXG4gIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLFxyXG4gIFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnMsXHJcbiAgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLFxyXG4gIFRlbnNvckZyb21VcmxPcHRpb25zLFxyXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXHJcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XHJcbmltcG9ydCB7XHJcbiAgY2hlY2tUeXBlZEFycmF5LFxyXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAsXHJcbiAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCxcclxuICBTdXBwb3J0ZWRUeXBlZEFycmF5LFxyXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsXHJcbn0gZnJvbSAnLi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcuanMnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVTaXplLCB0ZW5zb3JSZXNoYXBlIH0gZnJvbSAnLi90ZW5zb3ItdXRpbHMtaW1wbC5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL3RlbnNvci5qcyc7XHJcblxyXG4vLyB0eXBlIGFsaWFzZXMgZm9yIHRob3NlIGV4cG9ydGVkIGZyb20gVGVuc29yIGludGVyZmFjZVxyXG5cclxudHlwZSBUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLlR5cGU7XHJcbnR5cGUgVGVuc29yRGF0YVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGU7XHJcbnR5cGUgVGVuc29yRGF0YUxvY2F0aW9uID0gVGVuc29ySW50ZXJmYWNlLkRhdGFMb2NhdGlvbjtcclxudHlwZSBUZW5zb3JUZXh0dXJlVHlwZSA9IFRlbnNvckludGVyZmFjZS5UZXh0dXJlVHlwZTtcclxudHlwZSBUZW5zb3JHcHVCdWZmZXJUeXBlID0gVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlclR5cGU7XHJcbnR5cGUgVGVuc29yTUxUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZTtcclxuXHJcbi8qKlxyXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVGVuc29yIGludGVyZmFjZS5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRlbnNvciBpbXBsZW1lbnRzIFRlbnNvckludGVyZmFjZSB7XHJcbiAgLy8gI3JlZ2lvbiBjb25zdHJ1Y3RvcnNcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICB0eXBlOiBUZW5zb3JUeXBlLFxyXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBib29sZWFuW10sXHJcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKTtcclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy4gVHlwZSBpcyBpbmZlcnJlZCBmcm9tIGRhdGEuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBkYXRhOiBUZW5zb3JEYXRhVHlwZSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgcmVhZG9ubHkgc3RyaW5nW10gfCByZWFkb25seSBib29sZWFuW10sXHJcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKTtcclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBwaW5uZWQgQ1BVIGRhdGEgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdjcHUtcGlubmVkJy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBXZWJHTCB0ZXh0dXJlIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAndGV4dHVyZScuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihwYXJhbXM6IFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdQVSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdncHUtYnVmZmVyJy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViTk4gTUxUZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdtbC10ZW5zb3InLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHBhcmFtcyAtIFNwZWNpZnkgdGhlIHBhcmFtZXRlcnMgdG8gY29uc3RydWN0IHRoZSB0ZW5zb3IuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocGFyYW1zOiBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGltcGxlbWVudGF0aW9uLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgYXJnMDpcclxuICAgICAgfCBUZW5zb3JUeXBlXHJcbiAgICAgIHwgVGVuc29yRGF0YVR5cGVcclxuICAgICAgfCBVaW50OENsYW1wZWRBcnJheVxyXG4gICAgICB8IHJlYWRvbmx5IHN0cmluZ1tdXHJcbiAgICAgIHwgcmVhZG9ubHkgYm9vbGVhbltdXHJcbiAgICAgIHwgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzXHJcbiAgICAgIHwgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1xyXG4gICAgICB8IEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVyc1xyXG4gICAgICB8IE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxyXG4gICAgYXJnMT86IFRlbnNvckRhdGFUeXBlIHwgVWludDhDbGFtcGVkQXJyYXkgfCByZWFkb25seSBudW1iZXJbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxyXG4gICAgYXJnMj86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICkge1xyXG4gICAgLy8gcGVyZm9ybSBvbmUtdGltZSBjaGVjayBmb3IgQmlnSW50L0Zsb2F0MTZBcnJheSBzdXBwb3J0XHJcbiAgICBjaGVja1R5cGVkQXJyYXkoKTtcclxuXHJcbiAgICBsZXQgdHlwZTogVGVuc29yVHlwZTtcclxuICAgIGxldCBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdvYmplY3QnICYmICdsb2NhdGlvbicgaW4gYXJnMCkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cclxuICAgICAgLy9cclxuICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSBhcmcwLmxvY2F0aW9uO1xyXG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xyXG4gICAgICBkaW1zID0gYXJnMC5kaW1zO1xyXG4gICAgICBzd2l0Y2ggKGFyZzAubG9jYXRpb24pIHtcclxuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xyXG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldCh0eXBlKTtcclxuICAgICAgICAgIGlmICghZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCEoYXJnMC5kYXRhIGluc3RhbmNlb2YgZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmNwdURhdGEgPSBhcmcwLmRhdGE7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAndGV4dHVyZSc6IHtcclxuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcclxuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XHJcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gYXJnMC5kaXNwb3NlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDMyJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQxNicgJiZcclxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAnaW50NjQnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50MzInICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcclxuICAgICAgICAgICAgdHlwZSAhPT0gJ2Jvb2wnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50NCcgJiZcclxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gZ3B1IGJ1ZmZlcmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5ncHVCdWZmZXJEYXRhID0gYXJnMC5ncHVCdWZmZXI7XHJcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xyXG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdtbC10ZW5zb3InOiB7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDMyJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQxNicgJiZcclxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAnaW50NjQnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50MzInICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50NjQnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ4JyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDgnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDQnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ0J1xyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLm1sVGVuc29yRGF0YSA9IGFyZzAubWxUZW5zb3I7XHJcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xyXG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgY29uc3RydWN0b3I6IHVuc3VwcG9ydGVkIGxvY2F0aW9uICcke3RoaXMuZGF0YUxvY2F0aW9ufSdgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gY29uc3RydWN0aW5nIHRlbnNvciBvZiBsb2NhdGlvbiAnY3B1J1xyXG4gICAgICAvL1xyXG4gICAgICBsZXQgZGF0YTogVGVuc29yRGF0YVR5cGU7XHJcbiAgICAgIGxldCBtYXliZURpbXM6IHR5cGVvZiBhcmcxIHwgdHlwZW9mIGFyZzI7XHJcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcclxuICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIC4uLilcclxuICAgICAgICAvL1xyXG4gICAgICAgIHR5cGUgPSBhcmcwO1xyXG4gICAgICAgIG1heWJlRGltcyA9IGFyZzI7XHJcbiAgICAgICAgaWYgKGFyZzAgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXHJcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgc3RyaW5nIHRlbnNvcidzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS5cIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcclxuICAgICAgICAgIC8vIGVycm9yIHdpbGwgYmUgcG9wdWxhdGVkIGF0IGluZmVyZW5jZVxyXG4gICAgICAgICAgZGF0YSA9IGFyZzE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG51bWVyaWMgdGVuc29yXHJcbiAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldChhcmcwKTtcclxuICAgICAgICAgIGlmICh0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHthcmcwfS5gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XHJcbiAgICAgICAgICAgIGlmICgoYXJnMCA9PT0gJ2Zsb2F0MTYnICYmIHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9PT0gVWludDE2QXJyYXkpIHx8IGFyZzAgPT09ICd1aW50NCcgfHwgYXJnMCA9PT0gJ2ludDQnKSB7XHJcbiAgICAgICAgICAgICAgLy8gLSAnZmxvYXQxNic6XHJcbiAgICAgICAgICAgICAgLy8gICBXaGVuIG5vIEZsb2F0MTZBcnJheSBwb2x5ZmlsbCBpcyB1c2VkLCB3ZSBjYW5ub3QgY3JlYXRlICdmbG9hdDE2JyB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAvLyAgIFRocm93IGVycm9yIGhlcmUgYmVjYXVzZSB3aGVuIHVzZXIgdHJ5IHRvIHVzZSBudW1iZXIgYXJyYXkgYXMgZGF0YSxcclxuICAgICAgICAgICAgICAvLyAgIGUuZy4gbmV3IFRlbnNvcignZmxvYXQxNicsIFsxLCAyLCAzLCA0XSwgZGltcykpLCBpdCB3aWxsIGFjdHVhbGx5IGNhbGxcclxuICAgICAgICAgICAgICAvLyAgIFVpbnQxNkFycmF5LmZyb20oYXJnMSkgd2hpY2ggZ2VuZXJhdGVzIHdyb25nIGRhdGEuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAvLyAtICd1aW50NCcgYW5kICdpbnQ0JzpcclxuICAgICAgICAgICAgICAvLyAgIFVpbnQ4QXJyYXkuZnJvbShhcmcxKSB3aWxsIGdlbmVyYXRlIHdyb25nIGRhdGEgZm9yICd1aW50NCcgYW5kICdpbnQ0JyB0ZW5zb3IuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgYENyZWF0aW5nIGEgJHthcmcwfSB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSAke3R5cGVkQXJyYXlDb25zdHJ1Y3Rvci5uYW1lfSBhcyBkYXRhLmAsXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwID09PSAndWludDY0JyB8fCBhcmcwID09PSAnaW50NjQnKSB7XHJcbiAgICAgICAgICAgICAgLy8gdXNlICdhcyBhbnknIGhlcmUgYmVjYXVzZTpcclxuICAgICAgICAgICAgICAvLyAxLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdHlwZSBvZiAnQXJyYXkuaXNBcnJheSgpJyBkb2VzIG5vdCB3b3JrIHdpdGggcmVhZG9ubHkgYXJyYXlzLlxyXG4gICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MDAyXHJcbiAgICAgICAgICAgICAgLy8gMi4gVHlwZVNjcmlwdCdzIGNoZWNrIG9uIHVuaW9uIHR5cGUgb2YgJyhCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvcikuZnJvbSgpJ1xyXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXIgbWFwRm4uXHJcbiAgICAgICAgICAgICAgLy8gMy4gcGFyYW1ldGVycyBvZiAnU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycy5mcm9tKCknIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlbWVudCBvZiB0aGUgdW5pb25cclxuICAgICAgICAgICAgICAvLyB0eXBlLlxyXG5cclxuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBiaWdpbnRbXVwiIGhlcmUuXHJcblxyXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEsIEJpZ0ludCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW11cIiBoZXJlLlxyXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgZGF0YSA9IGFyZzE7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ3VpbnQ4Jykge1xyXG4gICAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBVaW50OENsYW1wZWRBcnJheSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiB1aW50OGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzAgPT09ICdmbG9hdDE2JyAmJiBhcmcxIGluc3RhbmNlb2YgVWludDE2QXJyYXkgJiYgdHlwZWRBcnJheUNvbnN0cnVjdG9yICE9PSBVaW50MTZBcnJheSkge1xyXG4gICAgICAgICAgICAvLyB3aGVuIEZsb2F0MTZBcnJheSBpcyBhdmFpbGFibGUgYW5kIGRhdGEgaXMgb2YgdHlwZSBVaW50MTZBcnJheS5cclxuICAgICAgICAgICAgLy8gV2UgYWxsb3cgVWludDE2QXJyYXkgdG8gYmUgcGFzc2VkIGluIGFzIGRhdGEgZm9yICdmbG9hdDE2JyB0ZW5zb3IgdW50aWwgRmxvYXQxNkFycmF5IGlzIGdlbmVyYWxseVxyXG4gICAgICAgICAgICAvLyBzdXBwb3J0ZWQgaW4gSmF2YVNjcmlwdCBlbnZpcm9ubWVudC5cclxuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgKGdsb2JhbFRoaXMgYXMgYW55KS5GbG9hdDE2QXJyYXkoYXJnMS5idWZmZXIsIGFyZzEuYnl0ZU9mZnNldCwgYXJnMS5sZW5ndGgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke3R5cGV9IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yfWApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3RvcihkYXRhLCAuLi4pXHJcbiAgICAgICAgLy9cclxuICAgICAgICBtYXliZURpbXMgPSBhcmcxO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XHJcbiAgICAgICAgICAvLyBvbmx5IGJvb2xlYW5bXSBhbmQgc3RyaW5nW10gaXMgc3VwcG9ydGVkXHJcbiAgICAgICAgICBpZiAoYXJnMC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnRUeXBlID0gdHlwZW9mIGFyZzBbMF07XHJcbiAgICAgICAgICBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdHlwZSA9ICdzdHJpbmcnO1xyXG4gICAgICAgICAgICBkYXRhID0gYXJnMDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAnYm9vbCc7XHJcbiAgICAgICAgICAgIC8vICdhcmcwJyBpcyBvZiB0eXBlICdib29sZWFuW10nLiBVaW50OEFycmF5LmZyb20oYm9vbGVhbltdKSBhY3R1YWxseSB3b3JrcywgYnV0IHR5cGVzY3JpcHQgdGhpbmtzIHRoaXMgaXNcclxuICAgICAgICAgICAgLy8gd3JvbmcgdHlwZS4gV2UgdXNlICdhcyBhbnknIHRvIG1ha2UgaXQgaGFwcHkuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCBhcyBhbnlbXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke2ZpcnN0RWxlbWVudFR5cGV9LmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XHJcbiAgICAgICAgICB0eXBlID0gJ3VpbnQ4JztcclxuICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGdldCB0ZW5zb3IgdHlwZSBmcm9tIFR5cGVkQXJyYXlcclxuICAgICAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPSBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLmdldChcclxuICAgICAgICAgICAgYXJnMC5jb25zdHJ1Y3RvciBhcyBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGlmIChtYXBwZWRUeXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0eXBlID0gbWFwcGVkVHlwZTtcclxuICAgICAgICAgIGRhdGEgPSBhcmcwIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0eXBlIGFuZCBkYXRhIGlzIHByb2Nlc3NlZCwgbm93IHByb2Nlc3NpbmcgZGltc1xyXG4gICAgICBpZiAobWF5YmVEaW1zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcclxuICAgICAgICBtYXliZURpbXMgPSBbZGF0YS5sZW5ndGhdO1xyXG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1heWJlRGltcykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSB0ZW5zb3IncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXlcIik7XHJcbiAgICAgIH1cclxuICAgICAgZGltcyA9IG1heWJlRGltcyBhcyByZWFkb25seSBudW1iZXJbXTtcclxuXHJcbiAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XHJcbiAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ2NwdSc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcGVyZm9ybSBjaGVjayBvbiBkaW1zXHJcbiAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcclxuICAgIC8vIGlmIGRhdGEgaXMgb24gQ1BVLCBjaGVjayB3aGV0aGVyIGRhdGEgbGVuZ3RoIG1hdGNoZXMgdGVuc29yIHNpemVcclxuICAgIGlmICh0aGlzLmNwdURhdGEgJiYgc2l6ZSAhPT0gdGhpcy5jcHVEYXRhLmxlbmd0aCkge1xyXG4gICAgICBpZiAoKHR5cGUgPT09ICd1aW50NCcgfHwgdHlwZSA9PT0gJ2ludDQnKSAmJiBNYXRoLmNlaWwoc2l6ZSAvIDIpID09PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gZm9yICh1KWludDQsIHRoZSBkYXRhIGxlbmd0aCBpcyBoYWxmIG9mIHRoZSB0ZW5zb3Igc2l6ZS4gU28gd2UgY2hlY2sgdGhpcyBzcGVjaWFsIGNhc2Ugd2hlbiBzaXplIGlzIG9kZC5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHt0aGlzLmNwdURhdGEubGVuZ3RofSkuYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgdGhpcy5kaW1zID0gZGltcztcclxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgfVxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBmYWN0b3J5XHJcbiAgc3RhdGljIGFzeW5jIGZyb21JbWFnZShcclxuICAgIGltYWdlOiBJbWFnZURhdGEgfCBIVE1MSW1hZ2VFbGVtZW50IHwgSW1hZ2VCaXRtYXAgfCBzdHJpbmcsXHJcbiAgICBvcHRpb25zPzpcclxuICAgICAgfCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xyXG4gICAgICB8IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zXHJcbiAgICAgIHwgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc1xyXG4gICAgICB8IFRlbnNvckZyb21VcmxPcHRpb25zLFxyXG4gICk6IFByb21pc2U8VGVuc29ySW50ZXJmYWNlPiB7XHJcbiAgICByZXR1cm4gdGVuc29yRnJvbUltYWdlKGltYWdlLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tVGV4dHVyZTxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLlRleHR1cmVEYXRhVHlwZXM+KFxyXG4gICAgdGV4dHVyZTogVGVuc29yVGV4dHVyZVR5cGUsXHJcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4sXHJcbiAgKTogVGVuc29ySW50ZXJmYWNlIHtcclxuICAgIHJldHVybiB0ZW5zb3JGcm9tVGV4dHVyZSh0ZXh0dXJlLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tR3B1QnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcclxuICAgIGdwdUJ1ZmZlcjogVGVuc29yR3B1QnVmZmVyVHlwZSxcclxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+LFxyXG4gICk6IFRlbnNvckludGVyZmFjZSB7XHJcbiAgICByZXR1cm4gdGVuc29yRnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGZyb21NTFRlbnNvcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yRGF0YVR5cGVzPihcclxuICAgIG1sVGVuc29yOiBUZW5zb3JNTFRlbnNvclR5cGUsXHJcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQ+LFxyXG4gICk6IFRlbnNvckludGVyZmFjZSB7XHJcbiAgICByZXR1cm4gdGVuc29yRnJvbU1MVGVuc29yKG1sVGVuc29yLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcclxuICAgIHR5cGU6IFQsXHJcbiAgICBidWZmZXI6IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZU1hcFtUXSxcclxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcclxuICApOiBUZW5zb3Ige1xyXG4gICAgcmV0dXJuIHRlbnNvckZyb21QaW5uZWRCdWZmZXIodHlwZSwgYnVmZmVyLCBkaW1zKTtcclxuICB9XHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBjb252ZXJzaW9uc1xyXG4gIHRvRGF0YVVSTChvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGVuc29yVG9EYXRhVVJMKHRoaXMsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSB7XHJcbiAgICByZXR1cm4gdGVuc29yVG9JbWFnZURhdGEodGhpcywgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBwdWJsaWMgZmllbGRzXHJcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XHJcbiAgcmVhZG9ubHkgdHlwZTogVGVuc29yVHlwZTtcclxuICByZWFkb25seSBzaXplOiBudW1iZXI7XHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAvLyAjcmVnaW9uIHByaXZhdGUgZmllbGRzXHJcblxyXG4gIC8qKlxyXG4gICAqIHN0b3JlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBkYXRhTG9jYXRpb246IFRlbnNvckRhdGFMb2NhdGlvbjtcclxuXHJcbiAgLyoqXHJcbiAgICogc3RvcmVzIHRoZSBkYXRhIG9uIENQVSwgaWYgbG9jYXRpb24gaXMgJ2NwdScgb3IgJ2NwdS1waW5uZWQnLiBvdGhlcndpc2UgZW1wdHkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcHVEYXRhPzogVGVuc29yRGF0YVR5cGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyB0ZXh0dXJlIHdoZW4gbG9jYXRpb24gaXMgJ3RleHR1cmUnLiBvdGhlcndpc2UgZW1wdHkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBncHVUZXh0dXJlRGF0YT86IFRlbnNvclRleHR1cmVUeXBlO1xyXG5cclxuICAvKipcclxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgR1BVIGJ1ZmZlciB3aGVuIGxvY2F0aW9uIGlzICdncHUtYnVmZmVyJy4gb3RoZXJ3aXNlIGVtcHR5LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ3B1QnVmZmVyRGF0YT86IFRlbnNvckdwdUJ1ZmZlclR5cGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyBXZWJOTiBNTFRlbnNvciB3aGVuIGxvY2F0aW9uIGlzICdtbC10ZW5zb3InLiBvdGhlcndpc2UgZW1wdHkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBtbFRlbnNvckRhdGE/OiBUZW5zb3JNTFRlbnNvclR5cGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIHN0b3JlcyBhbiBvcHRpb25hbCBkb3dubG9hZGVyIGZ1bmN0aW9uIHRvIGRvd25sb2FkIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZG93bmxvYWRlcj8oKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT47XHJcblxyXG4gIC8qKlxyXG4gICAqIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgaXMgYmVpbmcgZG93bmxvYWRlZCBmcm9tIEdQVSB0byBDUFUuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc0Rvd25sb2FkaW5nPzogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRpc3Bvc2VyIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHVuZGVybHlpbmcgZGF0YS5cclxuICAgKi9cclxuICBwcml2YXRlIGRpc3Bvc2VyPygpOiB2b2lkO1xyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBwcm9wZXJ0aWVzXHJcbiAgZ2V0IGRhdGEoKTogVGVuc29yRGF0YVR5cGUge1xyXG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xyXG4gICAgaWYgKCF0aGlzLmNwdURhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICdUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCAnICtcclxuICAgICAgICAgICdvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuJyxcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmNwdURhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgbG9jYXRpb24oKTogVGVuc29yRGF0YUxvY2F0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGFMb2NhdGlvbjtcclxuICB9XHJcblxyXG4gIGdldCB0ZXh0dXJlKCk6IFRlbnNvclRleHR1cmVUeXBlIHtcclxuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcclxuICAgIGlmICghdGhpcy5ncHVUZXh0dXJlRGF0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgZ3B1QnVmZmVyKCk6IFRlbnNvckdwdUJ1ZmZlclR5cGUge1xyXG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xyXG4gICAgaWYgKCF0aGlzLmdwdUJ1ZmZlckRhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR1BVIGJ1ZmZlci4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgbWxUZW5zb3IoKTogVGVuc29yTUxUZW5zb3JUeXBlIHtcclxuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcclxuICAgIGlmICghdGhpcy5tbFRlbnNvckRhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5tbFRlbnNvckRhdGE7XHJcbiAgfVxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBtZXRob2RzXHJcblxyXG4gIGFzeW5jIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT4ge1xyXG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xyXG4gICAgc3dpdGNoICh0aGlzLmRhdGFMb2NhdGlvbikge1xyXG4gICAgICBjYXNlICdjcHUnOlxyXG4gICAgICBjYXNlICdjcHUtcGlubmVkJzpcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgICBjYXNlICd0ZXh0dXJlJzpcclxuICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XHJcbiAgICAgIGNhc2UgJ21sLXRlbnNvcic6IHtcclxuICAgICAgICBpZiAoIXRoaXMuZG93bmxvYWRlcikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZG93bmxvYWRlcigpO1xyXG4gICAgICAgICAgdGhpcy5kb3dubG9hZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcclxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgICAgaWYgKHJlbGVhc2VEYXRhICYmIHRoaXMuZGlzcG9zZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwb3NlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kaXNwb3Nlcikge1xyXG4gICAgICB0aGlzLmRpc3Bvc2VyKCk7XHJcbiAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNwdURhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmdwdVRleHR1cmVEYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5ncHVCdWZmZXJEYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5tbFRlbnNvckRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnbm9uZSc7XHJcbiAgfVxyXG5cclxuICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gIC8vICNyZWdpb24gdGVuc29yIHV0aWxpdGllc1xyXG4gIHByaXZhdGUgZW5zdXJlVmFsaWQoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5kYXRhTG9jYXRpb24gPT09ICdub25lJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29ySW50ZXJmYWNlIHtcclxuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcclxuICAgIGlmICh0aGlzLmRvd25sb2FkZXIgfHwgdGhpcy5kaXNwb3Nlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVuc29yUmVzaGFwZSh0aGlzLCBkaW1zKTtcclxuICB9XHJcbiAgLy8gI2VuZHJlZ2lvblxyXG59XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yRmFjdG9yeSB9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xyXG5pbXBvcnQgeyBUZW5zb3IgYXMgVGVuc29ySW1wbCB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xyXG5pbXBvcnQgeyBUeXBlZFRlbnNvclV0aWxzIH0gZnJvbSAnLi90ZW5zb3ItdXRpbHMuanMnO1xyXG5pbXBvcnQgeyBUcnlHZXRHbG9iYWxUeXBlIH0gZnJvbSAnLi90eXBlLWhlbHBlci5qcyc7XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXHJcblxyXG4vKipcclxuICogcmVwcmVzZW50IGEgYmFzaWMgdGVuc29yIHdpdGggc3BlY2lmaWVkIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZS5cclxuICovXHJcbmludGVyZmFjZSBUeXBlZFRlbnNvckJhc2U8VCBleHRlbmRzIFRlbnNvci5UeXBlPiB7XHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cclxuICAgKi9cclxuICByZWFkb25seSB0eXBlOiBUO1xyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cclxuICAgKlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBDUFUgKGVnLiBpdCdzIGluIHRoZSBmb3JtIG9mIFdlYkdMIHRleHR1cmUgb3IgV2ViR1BVIGJ1ZmZlciksIHRocm93IGVycm9yLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcclxuICAvKipcclxuICAgKiBHZXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiBUZW5zb3IuRGF0YUxvY2F0aW9uO1xyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR0wgdGV4dHVyZSwgdGhyb3cgZXJyb3IuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgdGV4dHVyZTogVGVuc29yLlRleHR1cmVUeXBlO1xyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR1BVIGJ1ZmZlciwgdGhyb3cgZXJyb3IuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgZ3B1QnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBXZWJOTiBNTFRlbnNvciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBpbiBhIFdlYk5OIE1MVGVuc29yLCB0aHJvdyBlcnJvci5cclxuICAgKi9cclxuICByZWFkb25seSBtbFRlbnNvcjogVGVuc29yLk1MVGVuc29yVHlwZTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZXR1cm5zIHRoZSBkYXRhIGltbWVkaWF0ZWx5LlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgZG93bmxvYWRzIHRoZSBkYXRhIGFuZCByZXR1cm5zIHRoZSBwcm9taXNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlbGVhc2VEYXRhIC0gd2hldGhlciByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS4gSWdub3JlIGlmIGRhdGEgaXMgYWxyZWFkeSBvbiBDUFUuXHJcbiAgICovXHJcbiAgZ2V0RGF0YShyZWxlYXNlRGF0YT86IGJvb2xlYW4pOiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZU1hcFtUXT47XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3Bvc2UgdGhlIHRlbnNvciBkYXRhLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZW1vdmUgaXRzIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBkYXRhLlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuXHJcbiAgICpcclxuICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIHRoZSB0ZW5zb3IgaXMgY29uc2lkZXJlZCBubyBsb25nZXIgdmFsaWQuIEl0cyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnbm9uZScuXHJcbiAgICovXHJcbiAgZGlzcG9zZSgpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVGVuc29yIHtcclxuICBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xyXG4gICAgZmxvYXQzMjogRmxvYXQzMkFycmF5O1xyXG4gICAgdWludDg6IFVpbnQ4QXJyYXk7XHJcbiAgICBpbnQ4OiBJbnQ4QXJyYXk7XHJcbiAgICB1aW50MTY6IFVpbnQxNkFycmF5O1xyXG4gICAgaW50MTY6IEludDE2QXJyYXk7XHJcbiAgICBpbnQzMjogSW50MzJBcnJheTtcclxuICAgIGludDY0OiBCaWdJbnQ2NEFycmF5O1xyXG4gICAgc3RyaW5nOiBzdHJpbmdbXTtcclxuICAgIGJvb2w6IFVpbnQ4QXJyYXk7XHJcbiAgICBmbG9hdDE2OiBVaW50MTZBcnJheTsgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxyXG4gICAgZmxvYXQ2NDogRmxvYXQ2NEFycmF5O1xyXG4gICAgdWludDMyOiBVaW50MzJBcnJheTtcclxuICAgIHVpbnQ2NDogQmlnVWludDY0QXJyYXk7XHJcbiAgICAvLyBjb21wbGV4NjQ6IG5ldmVyO1xyXG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XHJcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XHJcbiAgICB1aW50NDogVWludDhBcnJheTtcclxuICAgIGludDQ6IEludDhBcnJheTtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBFbGVtZW50VHlwZU1hcCB7XHJcbiAgICBmbG9hdDMyOiBudW1iZXI7XHJcbiAgICB1aW50ODogbnVtYmVyO1xyXG4gICAgaW50ODogbnVtYmVyO1xyXG4gICAgdWludDE2OiBudW1iZXI7XHJcbiAgICBpbnQxNjogbnVtYmVyO1xyXG4gICAgaW50MzI6IG51bWJlcjtcclxuICAgIGludDY0OiBiaWdpbnQ7XHJcbiAgICBzdHJpbmc6IHN0cmluZztcclxuICAgIGJvb2w6IGJvb2xlYW47XHJcbiAgICBmbG9hdDE2OiBudW1iZXI7IC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cclxuICAgIGZsb2F0NjQ6IG51bWJlcjtcclxuICAgIHVpbnQzMjogbnVtYmVyO1xyXG4gICAgdWludDY0OiBiaWdpbnQ7XHJcbiAgICAvLyBjb21wbGV4NjQ6IG5ldmVyO1xyXG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XHJcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XHJcbiAgICB1aW50NDogbnVtYmVyO1xyXG4gICAgaW50NDogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgdHlwZSBEYXRhVHlwZSA9IERhdGFUeXBlTWFwW1R5cGVdO1xyXG4gIHR5cGUgRWxlbWVudFR5cGUgPSBFbGVtZW50VHlwZU1hcFtUeXBlXTtcclxuXHJcbiAgLyoqXHJcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBDcHVQaW5uZWREYXRhVHlwZXMgPSBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJz47XHJcblxyXG4gIC8qKlxyXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdMIHRleHR1cmVcclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBUZXh0dXJlVHlwZSA9IFdlYkdMVGV4dHVyZTtcclxuXHJcbiAgLyoqXHJcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic7XHJcblxyXG4gIHR5cGUgR3B1QnVmZmVyVHlwZUZhbGxiYWNrID0geyBzaXplOiBudW1iZXI7IG1hcFN0YXRlOiAndW5tYXBwZWQnIHwgJ3BlbmRpbmcnIHwgJ21hcHBlZCcgfTtcclxuICAvKipcclxuICAgKiB0eXBlIGFsaWFzIGZvciBXZWJHUFUgYnVmZmVyXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyVHlwZSA9IFRyeUdldEdsb2JhbFR5cGU8J0dQVUJ1ZmZlcicsIEdwdUJ1ZmZlclR5cGVGYWxsYmFjaz47XHJcblxyXG4gIHR5cGUgTUxUZW5zb3JUeXBlRmFsbGJhY2sgPSB7IGRlc3Ryb3koKTogdm9pZCB9O1xyXG4gIC8qKlxyXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYk5OIE1MVGVuc29yXHJcbiAgICpcclxuICAgKiBUaGUgc3BlY2lmaWNhdGlvbiBmb3IgV2ViTk4ncyBNTFRlbnNvciBpcyBjdXJyZW50bHkgaW4gZmx1eC5cclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBNTFRlbnNvclR5cGUgPSBUcnlHZXRHbG9iYWxUeXBlPCdNTFRlbnNvcicsIE1MVGVuc29yVHlwZUZhbGxiYWNrPjtcclxuXHJcbiAgLyoqXHJcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIEdwdUJ1ZmZlckRhdGFUeXBlcyA9ICdmbG9hdDMyJyB8ICdmbG9hdDE2JyB8ICdpbnQzMicgfCAnaW50NjQnIHwgJ3VpbnQzMicgfCAndWludDgnIHwgJ2Jvb2wnO1xyXG5cclxuICAvKipcclxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJOTiBNTFRlbnNvclxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIE1MVGVuc29yRGF0YVR5cGVzID1cclxuICAgIHwgJ2Zsb2F0MzInXHJcbiAgICB8ICdmbG9hdDE2J1xyXG4gICAgfCAnaW50OCdcclxuICAgIHwgJ3VpbnQ4J1xyXG4gICAgfCAnaW50MzInXHJcbiAgICB8ICd1aW50MzInXHJcbiAgICB8ICdpbnQ2NCdcclxuICAgIHwgJ3VpbnQ2NCdcclxuICAgIHwgJ2Jvb2wnXHJcbiAgICB8ICd1aW50NCdcclxuICAgIHwgJ2ludDQnO1xyXG5cclxuICAvKipcclxuICAgKiByZXByZXNlbnQgd2hlcmUgdGhlIHRlbnNvciBkYXRhIGlzIHN0b3JlZFxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIERhdGFMb2NhdGlvbiA9ICdub25lJyB8ICdjcHUnIHwgJ2NwdS1waW5uZWQnIHwgJ3RleHR1cmUnIHwgJ2dwdS1idWZmZXInIHwgJ21sLXRlbnNvcic7XHJcblxyXG4gIC8qKlxyXG4gICAqIHJlcHJlc2VudCB0aGUgZGF0YSB0eXBlIG9mIGEgdGVuc29yXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgVHlwZSA9IGtleW9mIERhdGFUeXBlTWFwO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50IG11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyB0byBmZWVkIHRvIG9yIGZldGNoIGZyb20gbW9kZWwgaW5mZXJlbmNpbmcuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVkVGVuc29yPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4gZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VD4sIFR5cGVkVGVuc29yVXRpbHM8VD4ge31cclxuLyoqXHJcbiAqIFJlcHJlc2VudCBtdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgdG8gZmVlZCB0byBvciBmZXRjaCBmcm9tIG1vZGVsIGluZmVyZW5jaW5nLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3IgZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VGVuc29yLlR5cGU+LCBUeXBlZFRlbnNvclV0aWxzPFRlbnNvci5UeXBlPiB7fVxyXG5cclxuLyoqXHJcbiAqIHR5cGUgVGVuc29yQ29uc3RydWN0b3IgZGVmaW5lcyB0aGUgY29uc3RydWN0b3JzIG9mICdUZW5zb3InIHRvIGNyZWF0ZSBDUFUgdGVuc29yIGluc3RhbmNlcy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yQ29uc3RydWN0b3IgZXh0ZW5kcyBUZW5zb3JGYWN0b3J5IHtcclxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBzcGVjaWZ5IGVsZW1lbnQgdHlwZVxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyBzdHJpbmcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChcclxuICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXSB8IHJlYWRvbmx5IHN0cmluZ1tdLFxyXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChcclxuICAgIHR5cGU6ICdib29sJyxcclxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFsnYm9vbCddIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxyXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IFR5cGVkVGVuc29yPCdib29sJz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gYSBVaW50OENsYW1wZWRBcnJheSwgZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAodHlwZTogJ3VpbnQ4JywgZGF0YTogVWludDhDbGFtcGVkQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgNjQtYml0IGludGVnZXIgdHlwZWQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IDxUIGV4dGVuZHMgJ3VpbnQ2NCcgfCAnaW50NjQnPihcclxuICAgIHR5cGU6IFQsXHJcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0gfCByZWFkb25seSBiaWdpbnRbXSB8IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgbnVtZXJpYyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgPFQgZXh0ZW5kcyBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJyB8ICdib29sJyB8ICd1aW50NjQnIHwgJ2ludDY0Jz4+KFxyXG4gICAgdHlwZTogVCxcclxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXSB8IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gaW5mZXIgZWxlbWVudCB0eXBlc1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKGRhdGE6IEZsb2F0MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Zsb2F0MzInPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBJbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ4Jz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKGRhdGE6IFVpbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBVaW50OENsYW1wZWRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ4Jz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50MTYgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBVaW50MTZBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQxNic+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50MTYgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBJbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MTYnPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAoZGF0YTogSW50MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDMyJz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKGRhdGE6IEJpZ0ludDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ2NCc+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAoZGF0YTogcmVhZG9ubHkgc3RyaW5nW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiByZWFkb25seSBib29sZWFuW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdib29sJz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyBmbG9hdDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAoZGF0YTogRmxvYXQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnZmxvYXQ2NCc+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAoZGF0YTogVWludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MzInPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKGRhdGE6IEJpZ1VpbnQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDY0Jz47XHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gZmFsbCBiYWNrIHRvIG5vbi1nZW5lcmljIHRlbnNvciB0eXBlIGRlY2xhcmF0aW9uXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKFxyXG4gICAgdHlwZTogVGVuc29yLlR5cGUsXHJcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGUgfCByZWFkb25seSBudW1iZXJbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYmlnaW50W10gfCByZWFkb25seSBib29sZWFuW10sXHJcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKTogVGVuc29yO1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBUZW5zb3IuRGF0YVR5cGUsIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvcjtcclxuICAvLyAjZW5kcmVnaW9uXHJcbn1cclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNvbnN0IFRlbnNvciA9IFRlbnNvckltcGwgYXMgVGVuc29yQ29uc3RydWN0b3I7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XHJcblxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRSQUNFID0gKGRldmljZVR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZykgPT4ge1xyXG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICBjb25zb2xlLnRpbWVTdGFtcChgJHtkZXZpY2VUeXBlfTo6T1JUOjoke2xhYmVsfWApO1xyXG59O1xyXG5cclxuY29uc3QgVFJBQ0VfRlVOQyA9IChtc2c6IHN0cmluZywgZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcclxuICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZykgfHwgW107XHJcbiAgbGV0IGhhc1RyYWNlRnVuYyA9IGZhbHNlO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChoYXNUcmFjZUZ1bmMgJiYgIXN0YWNrW2ldLmluY2x1ZGVzKCdUUkFDRV9GVU5DJykpIHtcclxuICAgICAgbGV0IGxhYmVsID0gYEZVTkNfJHttc2d9Ojoke3N0YWNrW2ldLnRyaW0oKS5zcGxpdCgnICcpWzFdfWA7XHJcbiAgICAgIGlmIChleHRyYU1zZykge1xyXG4gICAgICAgIGxhYmVsICs9IGA6OiR7ZXh0cmFNc2d9YDtcclxuICAgICAgfVxyXG4gICAgICBUUkFDRSgnQ1BVJywgbGFiZWwpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xyXG4gICAgICBoYXNUcmFjZUZ1bmMgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19CRUdJTiA9IChleHRyYU1zZz86IHN0cmluZykgPT4ge1xyXG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgVFJBQ0VfRlVOQygnQkVHSU4nLCBleHRyYU1zZyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfRU5EID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBUUkFDRV9GVU5DKCdFTkQnLCBleHRyYU1zZyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRSQUNFX0VWRU5UX0JFR0lOID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gIGNvbnNvbGUudGltZShgT1JUOjoke2V4dHJhTXNnfWApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBjb25zdCBUUkFDRV9FVkVOVF9FTkQgPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcclxuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgY29uc29sZS50aW1lRW5kKGBPUlQ6OiR7ZXh0cmFNc2d9YCk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMgfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XHJcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcclxuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XHJcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcclxuaW1wb3J0IHsgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkQsIFRSQUNFX0VWRU5UX0JFR0lOLCBUUkFDRV9FVkVOVF9FTkQgfSBmcm9tICcuL3RyYWNlLmpzJztcclxuXHJcbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xyXG50eXBlIFJ1bk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlJ1bk9wdGlvbnM7XHJcbnR5cGUgRmVlZHNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5GZWVkc1R5cGU7XHJcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xyXG50eXBlIFJldHVyblR5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlJldHVyblR5cGU7XHJcblxyXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xyXG4gIHByaXZhdGUgY29uc3RydWN0b3IoaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIpIHtcclxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgfVxyXG4gIHJ1bihmZWVkczogRmVlZHNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XHJcbiAgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGZldGNoZXM6IEZldGNoZXNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XHJcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XHJcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XHJcbiAgICBUUkFDRV9FVkVOVF9CRUdJTignSW5mZXJlbmNlU2Vzc2lvbi5ydW4nKTtcclxuICAgIGNvbnN0IGZldGNoZXM6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfSA9IHt9O1xyXG4gICAgbGV0IG9wdGlvbnM6IFJ1bk9wdGlvbnMgPSB7fTtcclxuICAgIC8vIGNoZWNrIGlucHV0c1xyXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICBcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XHJcbiAgICAvLyBkZXRlcm1pbmUgd2hpY2ggb3ZlcnJpZGUgaXMgYmVpbmcgdXNlZFxyXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYSBUZW5zb3JcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XHJcbiAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xyXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXHJcbiAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcclxuICAgICAgICAgIGlmIChhcmcxS2V5cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCB2ID0gKGFyZzEgYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5OdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGUpW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XHJcbiAgICAgICAgICAgICAgaXNGZXRjaGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNGZXRjaGVzKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNoZWNrIGlmIGFsbCBpbnB1dHMgYXJlIGluIGZlZWRcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmlucHV0TmFtZXMpIHtcclxuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke25hbWV9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XHJcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcclxuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcclxuICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcclxuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfSA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xyXG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywga2V5KSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcclxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVGVuc29yKSB7XHJcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gcmVzdWx0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gbmV3IFRlbnNvcihyZXN1bHQudHlwZSwgcmVzdWx0LmRhdGEsIHJlc3VsdC5kaW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFRSQUNFX0VWRU5UX0VORCgnSW5mZXJlbmNlU2Vzc2lvbi5ydW4nKTtcclxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XHJcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY3JlYXRlKHBhdGg6IHN0cmluZywgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcclxuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xyXG4gIHN0YXRpYyBjcmVhdGUoXHJcbiAgICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZSxcclxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcclxuICAgIGJ5dGVMZW5ndGg/OiBudW1iZXIsXHJcbiAgICBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcclxuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcclxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKFxyXG4gICAgYXJnMDogc3RyaW5nIHwgQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheSxcclxuICAgIGFyZzE/OiBTZXNzaW9uT3B0aW9ucyB8IG51bWJlcixcclxuICAgIGFyZzI/OiBudW1iZXIsXHJcbiAgICBhcmczPzogU2Vzc2lvbk9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPiB7XHJcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XHJcbiAgICBUUkFDRV9FVkVOVF9CRUdJTignSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUnKTtcclxuICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxyXG4gICAgbGV0IGZpbGVQYXRoT3JVaW50OEFycmF5OiBzdHJpbmcgfCBVaW50OEFycmF5O1xyXG4gICAgbGV0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0ge307XHJcblxyXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xyXG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XHJcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSBhcmcxO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcclxuICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGFyZzAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxyXG4gICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpXHJcbiAgICApIHtcclxuICAgICAgY29uc3QgYnVmZmVyID0gYXJnMDtcclxuICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xyXG4gICAgICBsZXQgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aDtcclxuICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYnl0ZU9mZnNldCA9IGFyZzE7XHJcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlT2Zmc2V0KSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke2J1ZmZlci5ieXRlTGVuZ3RofSkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBhcmcyO1xyXG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlTGVuZ3RoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke2J1ZmZlci5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldH1dLmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcclxuICAgIGNvbnN0IFtiYWNrZW5kLCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQc10gPSBhd2FpdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyhvcHRpb25zKTtcclxuICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGZpbGVQYXRoT3JVaW50OEFycmF5LCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQcyk7XHJcbiAgICBUUkFDRV9FVkVOVF9FTkQoJ0luZmVyZW5jZVNlc3Npb24uY3JlYXRlJyk7XHJcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xyXG4gICAgcmV0dXJuIG5ldyBJbmZlcmVuY2VTZXNzaW9uKGhhbmRsZXIpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XHJcbiAgICB0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKTtcclxuICB9XHJcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xyXG4gICAgdGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGlucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzO1xyXG4gIH1cclxuICBnZXQgb3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcclxuICB9XHJcblxyXG4gIGdldCBpbnB1dE1ldGFkYXRhKCk6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuVmFsdWVNZXRhZGF0YVtdIHtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXRNZXRhZGF0YTtcclxuICB9XHJcblxyXG4gIGdldCBvdXRwdXRNZXRhZGF0YSgpOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlZhbHVlTWV0YWRhdGFbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE1ldGFkYXRhO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVyOiBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcjtcclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGwgfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMnO1xyXG5pbXBvcnQgeyBPbm54TW9kZWxPcHRpb25zIH0gZnJvbSAnLi9vbm54LW1vZGVsLmpzJztcclxuaW1wb3J0IHsgT25ueFZhbHVlLCBPbm54VmFsdWVEYXRhTG9jYXRpb24gfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xyXG5pbXBvcnQgdHlwZSB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcclxuaW1wb3J0IHsgVHJ5R2V0R2xvYmFsVHlwZSB9IGZyb20gJy4vdHlwZS1oZWxwZXIuanMnO1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xyXG5cclxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEluZmVyZW5jZVNlc3Npb24ge1xyXG4gIC8vICNyZWdpb24gaW5wdXQvb3V0cHV0IHR5cGVzXHJcblxyXG4gIHR5cGUgT25ueFZhbHVlTWFwVHlwZSA9IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9O1xyXG4gIHR5cGUgTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlID0geyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbCB9O1xyXG5cclxuICAvKipcclxuICAgKiBBIGZlZWRzIChtb2RlbCBpbnB1dHMpIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxyXG4gICAqL1xyXG4gIHR5cGUgRmVlZHNUeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBmZXRjaGVzIChtb2RlbCBvdXRwdXRzKSBjb3VsZCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcclxuICAgKlxyXG4gICAqIC0gT21pdHRlZC4gVXNlIG1vZGVsJ3Mgb3V0cHV0IG5hbWVzIGRlZmluaXRpb24uXHJcbiAgICogLSBBbiBhcnJheSBvZiBzdHJpbmcgaW5kaWNhdGluZyB0aGUgb3V0cHV0IG5hbWVzLlxyXG4gICAqIC0gQW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgb3IgbnVsbCBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEByZW1hcmtcclxuICAgKiBkaWZmZXJlbnQgZnJvbSBpbnB1dCBhcmd1bWVudCwgaW4gb3V0cHV0LCBPbm54VmFsdWUgaXMgb3B0aW9uYWwuIElmIGFuIE9ubnhWYWx1ZSBpcyBwcmVzZW50IGl0IHdpbGwgYmVcclxuICAgKiB1c2VkIGFzIGEgcHJlLWFsbG9jYXRlZCB2YWx1ZSBieSB0aGUgaW5mZXJlbmNlIGVuZ2luZTsgaWYgb21pdHRlZCwgaW5mZXJlbmNlIGVuZ2luZSB3aWxsIGFsbG9jYXRlIGJ1ZmZlclxyXG4gICAqIGludGVybmFsbHkuXHJcbiAgICovXHJcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHJlYWRvbmx5IHN0cmluZ1tdIHwgTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlO1xyXG5cclxuICAvKipcclxuICAgKiBBIGluZmVyZW5jaW5nIHJldHVybiB0eXBlIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cclxuICAgKi9cclxuICB0eXBlIFJldHVyblR5cGUgPSBPbm54VmFsdWVNYXBUeXBlO1xyXG5cclxuICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gIC8vICNyZWdpb24gc2Vzc2lvbiBvcHRpb25zXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBzZXNzaW9uIGJlaGF2aW9yLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbk9wdGlvbnMgZXh0ZW5kcyBPbm54TW9kZWxPcHRpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQW4gZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbiBjYW4gYmUgYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgbmFtZSBvZiB0aGUgZXhlY3V0aW9uIHByb3ZpZGVyLFxyXG4gICAgICogb3IgYW4gb2JqZWN0IG9mIGNvcnJlc3BvbmRpbmcgdHlwZS5cclxuICAgICAqL1xyXG4gICAgZXhlY3V0aW9uUHJvdmlkZXJzPzogcmVhZG9ubHkgRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbnRyYSBPUCB0aHJlYWRzIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cclxuICAgICAqL1xyXG4gICAgaW50cmFPcE51bVRocmVhZHM/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW50ZXIgT1AgdGhyZWFkcyBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXHJcbiAgICAgKi9cclxuICAgIGludGVyT3BOdW1UaHJlYWRzPzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcclxuICAgICAqL1xyXG4gICAgZnJlZURpbWVuc2lvbk92ZXJyaWRlcz86IHsgcmVhZG9ubHkgW2RpbWVuc2lvbk5hbWU6IHN0cmluZ106IG51bWJlciB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wdGltaXphdGlvbiBsZXZlbC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/OiAnZGlzYWJsZWQnIHwgJ2Jhc2ljJyB8ICdleHRlbmRlZCcgfCAnbGF5b3V0JyB8ICdhbGwnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBlbmFibGUgQ1BVIG1lbW9yeSBhcmVuYS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIGVuYWJsZUNwdU1lbUFyZW5hPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgZW5hYmxlIG1lbW9yeSBwYXR0ZXJuLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcclxuICAgICAqL1xyXG4gICAgZW5hYmxlTWVtUGF0dGVybj86IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRpb24gbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIGV4ZWN1dGlvbk1vZGU/OiAnc2VxdWVudGlhbCcgfCAncGFyYWxsZWwnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3B0aW1pemVkIG1vZGVsIGZpbGUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGlzIHNldHRpbmcgaXMgc3BlY2lmaWVkLCB0aGUgb3B0aW1pemVkIG1vZGVsIHdpbGwgYmUgZHVtcGVkLiBJbiBicm93c2VyLCBhIGJsb2Igd2lsbCBiZSBjcmVhdGVkXHJcbiAgICAgKiB3aXRoIGEgcG9wLXVwIHdpbmRvdy5cclxuICAgICAqL1xyXG4gICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aD86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgZW5hYmxlIHByb2ZpbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxyXG4gICAgICovXHJcbiAgICBlbmFibGVQcm9maWxpbmc/OiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsZSBwcmVmaXggZm9yIHByb2ZpbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxyXG4gICAgICovXHJcbiAgICBwcm9maWxlRmlsZVByZWZpeD86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBJRC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIGxvZ0lkPzogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcclxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9jb21tb24vbG9nZ2luZy9zZXZlcml0eS5oXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxyXG4gICAgICovXHJcbiAgICBsb2dTZXZlcml0eUxldmVsPzogMCB8IDEgfCAyIHwgMyB8IDQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcclxuICAgICAqL1xyXG4gICAgbG9nVmVyYm9zaXR5TGV2ZWw/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IHN0cmluZyBhcyBhIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGZvciBhbGwgb3V0cHV0cywgb3IgYW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBhXHJcbiAgICAgKiBwcmVmZXJyZWQgZGF0YSBsb2NhdGlvbiBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHTCBhbmQgV2ViR1BVIEVQLlxyXG4gICAgICovXHJcbiAgICBwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj86IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB8IHsgcmVhZG9ubHkgW291dHB1dE5hbWU6IHN0cmluZ106IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBlbmFibGUgZ3JhcGggY2FwdHVyZS5cclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSBXZWIgZm9yIFdlYkdQVSBFUC5cclxuICAgICAqL1xyXG4gICAgZW5hYmxlR3JhcGhDYXB0dXJlPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlIGNvbmZpZ3VyYXRpb25zIGZvciBhIHNlc3Npb24uIFNlZVxyXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXHJcbiAgICAgKiBvbm54cnVudGltZV9zZXNzaW9uX29wdGlvbnNfY29uZmlnX2tleXMuaFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBganNcclxuICAgICAqIGV4dHJhOiB7XHJcbiAgICAgKiAgIHNlc3Npb246IHtcclxuICAgICAqICAgICBzZXRfZGVub3JtYWxfYXNfemVybzogXCIxXCIsXHJcbiAgICAgKiAgICAgZGlzYWJsZV9wcmVwYWNraW5nOiBcIjFcIlxyXG4gICAgICogICB9LFxyXG4gICAgICogICBvcHRpbWl6YXRpb246IHtcclxuICAgICAqICAgICBlbmFibGVfZ2VsdV9hcHByb3hpbWF0aW9uOiBcIjFcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICB9XHJcblxyXG4gIC8vICNyZWdpb24gZXhlY3V0aW9uIHByb3ZpZGVyc1xyXG5cclxuICAvLyBDdXJyZW50bHksIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBiYWNrZW5kcyB0byBzdXBwb3J0IGV4ZWN1dGlvbiBwcm92aWRlcnM6XHJcbiAgLy8gQmFja2VuZCBOb2RlLmpzIGJpbmRpbmc6IHN1cHBvcnRzICdjcHUnLCAnZG1sJyAod2luMzIpLCAnY29yZW1sJyAobWFjT1MpIGFuZCAnY3VkYScgKGxpbnV4KS5cclxuICAvLyBCYWNrZW5kIFdlYkFzc2VtYmx5OiBzdXBwb3J0cyAnY3B1JywgJ3dhc20nLCAnd2ViZ3B1JyBhbmQgJ3dlYm5uJy5cclxuICAvLyBCYWNrZW5kIE9OTlguanM6IHN1cHBvcnRzICd3ZWJnbCcuXHJcbiAgLy8gQmFja2VuZCBSZWFjdCBOYXRpdmU6IHN1cHBvcnRzICdjcHUnLCAneG5ucGFjaycsICdjb3JlbWwnIChpT1MpLCAnbm5hcGknIChBbmRyb2lkKS5cclxuICBpbnRlcmZhY2UgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXAge1xyXG4gICAgY29yZW1sOiBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcclxuICAgIGNwdTogQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICBjdWRhOiBDdWRhRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICBkbWw6IERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xyXG4gICAgbm5hcGk6IE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICB0ZW5zb3JydDogVGVuc29yUnRFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcclxuICAgIHdhc206IFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICB3ZWJnbDogV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcclxuICAgIHdlYmdwdTogV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICB3ZWJubjogV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcclxuICAgIHFubjogUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICB4bm5wYWNrOiBYbm5wYWNrRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgfVxyXG5cclxuICB0eXBlIEV4ZWN1dGlvblByb3ZpZGVyTmFtZSA9IGtleW9mIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uTWFwO1xyXG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJDb25maWcgPVxyXG4gICAgfCBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcFtFeGVjdXRpb25Qcm92aWRlck5hbWVdXHJcbiAgICB8IEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uXHJcbiAgICB8IEV4ZWN1dGlvblByb3ZpZGVyTmFtZVxyXG4gICAgfCBzdHJpbmc7XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogJ2NwdSc7XHJcbiAgICB1c2VBcmVuYT86IGJvb2xlYW47XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogJ2N1ZGEnO1xyXG4gICAgZGV2aWNlSWQ/OiBudW1iZXI7XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgRG1sRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XHJcbiAgICByZWFkb25seSBuYW1lOiAnZG1sJztcclxuICAgIGRldmljZUlkPzogbnVtYmVyO1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XHJcbiAgICByZWFkb25seSBuYW1lOiAndGVuc29ycnQnO1xyXG4gICAgZGV2aWNlSWQ/OiBudW1iZXI7XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICd3YXNtJztcclxuICB9XHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYmdsJztcclxuICAgIC8vIFRPRE86IGFkZCBmbGFnc1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIFhubnBhY2tFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICd4bm5wYWNrJztcclxuICB9XHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJncHUnO1xyXG4gICAgcHJlZmVycmVkTGF5b3V0PzogJ05DSFcnIHwgJ05IV0MnO1xyXG4gIH1cclxuXHJcbiAgLy8gI3JlZ2lvbiBXZWJOTiBvcHRpb25zXHJcblxyXG4gIGludGVyZmFjZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJubic7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgV2ViTk4gTUxDb250ZXh0LlxyXG4gICAqXHJcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RpY3RkZWYtbWxjb250ZXh0b3B0aW9uc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5Db250ZXh0T3B0aW9ucyB7XHJcbiAgICBkZXZpY2VUeXBlPzogJ2NwdScgfCAnZ3B1JyB8ICducHUnO1xyXG4gICAgbnVtVGhyZWFkcz86IG51bWJlcjtcclxuICAgIHBvd2VyUHJlZmVyZW5jZT86ICdkZWZhdWx0JyB8ICdsb3ctcG93ZXInIHwgJ2hpZ2gtcGVyZm9ybWFuY2UnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aG91dCBNTENvbnRleHQuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXaXRob3V0TUxDb250ZXh0IGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUsIFdlYk5OQ29udGV4dE9wdGlvbnMge1xyXG4gICAgY29udGV4dD86IG5ldmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aCBNTENvbnRleHQuXHJcbiAgICpcclxuICAgKiBXaGVuIE1MQ29udGV4dCBpcyBwcm92aWRlZCwgdGhlIGRldmljZVR5cGUgaXMgYWxzbyByZXF1aXJlZCBzbyB0aGF0IHRoZSBXZWJOTiBFUCBjYW4gZGV0ZXJtaW5lIHRoZSBwcmVmZXJyZWRcclxuICAgKiBjaGFubmVsIGxheW91dC5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dFxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dFxyXG4gICAgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSxcclxuICAgICAgT21pdDxXZWJOTkNvbnRleHRPcHRpb25zLCAnZGV2aWNlVHlwZSc+LFxyXG4gICAgICBSZXF1aXJlZDxQaWNrPFdlYk5OQ29udGV4dE9wdGlvbnMsICdkZXZpY2VUeXBlJz4+IHtcclxuICAgIGNvbnRleHQ6IFRyeUdldEdsb2JhbFR5cGU8J01MQ29udGV4dCc+O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aCBNTENvbnRleHQgd2hpY2ggaXMgY3JlYXRlZCBmcm9tIEdQVURldmljZS5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dC1ncHVkZXZpY2VcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dlYkdwdSBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lIHtcclxuICAgIGNvbnRleHQ6IFRyeUdldEdsb2JhbFR5cGU8J01MQ29udGV4dCc+O1xyXG4gICAgZ3B1RGV2aWNlOiBUcnlHZXRHbG9iYWxUeXBlPCdHUFVEZXZpY2UnPjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlci5cclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uID1cclxuICAgIHwgV2ViTk5PcHRpb25zV2l0aG91dE1MQ29udGV4dFxyXG4gICAgfCBXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0XHJcbiAgICB8IFdlYk5OT3B0aW9uc1dlYkdwdTtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogJ3Fubic7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgdGhlIFFOTiBiYWNrZW5kIHR5cGUuIEUuZy4sICdjcHUnIG9yICdodHAnLlxyXG4gICAgICogTXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggYGJhY2tlbmRQYXRoYC5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdCAnaHRwJ1xyXG4gICAgICovXHJcbiAgICBiYWNrZW5kVHlwZT86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSBhIHBhdGggdG8gdGhlIFFOTiBiYWNrZW5kIGxpYnJhcnkuXHJcbiAgICAgKiBNdXR1YWxseSBleGNsdXNpdmUgd2l0aCBgYmFja2VuZFR5cGVgLlxyXG4gICAgICovXHJcbiAgICBiYWNrZW5kUGF0aD86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIGVuYWJsZSBIVFAgRlAxNiBwcmVjaXNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcbiAgICBlbmFibGVGcDE2UHJlY2lzaW9uPzogYm9vbGVhbjtcclxuICB9XHJcbiAgZXhwb3J0IGludGVyZmFjZSBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICdjb3JlbWwnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYml0IGZsYWdzIGZvciBDb3JlTUwgZXhlY3V0aW9uIHByb3ZpZGVyLlxyXG4gICAgICpcclxuICAgICAqIGBgYFxyXG4gICAgICogQ09SRU1MX0ZMQUdfVVNFX0NQVV9PTkxZID0gMHgwMDFcclxuICAgICAqIENPUkVNTF9GTEFHX0VOQUJMRV9PTl9TVUJHUkFQSCA9IDB4MDAyXHJcbiAgICAgKiBDT1JFTUxfRkxBR19PTkxZX0VOQUJMRV9ERVZJQ0VfV0lUSF9BTkUgPSAweDAwNFxyXG4gICAgICogQ09SRU1MX0ZMQUdfT05MWV9BTExPV19TVEFUSUNfSU5QVVRfU0hBUEVTID0gMHgwMDhcclxuICAgICAqIENPUkVNTF9GTEFHX0NSRUFURV9NTFBST0dSQU0gPSAweDAxMFxyXG4gICAgICogQ09SRU1MX0ZMQUdfVVNFX0NQVV9BTkRfR1BVID0gMHgwMjBcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIFNlZSBpbmNsdWRlL29ubnhydW50aW1lL2NvcmUvcHJvdmlkZXJzL2NvcmVtbC9jb3JlbWxfcHJvdmlkZXJfZmFjdG9yeS5oIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmbGFnIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcpLlxyXG4gICAgICovXHJcbiAgICBjb3JlTWxGbGFncz86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIHVzZSBDUFUgb25seSBpbiBDb3JlTUwgRVAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxyXG4gICAgICovXHJcbiAgICB1c2VDUFVPbmx5PzogYm9vbGVhbjtcclxuICAgIHVzZUNQVUFuZEdQVT86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBlbmFibGUgQ29yZU1MIEVQIG9uIHN1YmdyYXBoLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cclxuICAgICAqL1xyXG4gICAgZW5hYmxlT25TdWJncmFwaD86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBvbmx5IGVuYWJsZSBDb3JlTUwgRVAgZm9yIEFwcGxlIGRldmljZXMgd2l0aCBBTkUgKEFwcGxlIE5ldXJhbCBFbmdpbmUpLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cclxuICAgICAqL1xyXG4gICAgb25seUVuYWJsZURldmljZVdpdGhBTkU/OiBib29sZWFuO1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XHJcbiAgICByZWFkb25seSBuYW1lOiAnbm5hcGknO1xyXG4gICAgdXNlRlAxNj86IGJvb2xlYW47XHJcbiAgICB1c2VOQ0hXPzogYm9vbGVhbjtcclxuICAgIGNwdURpc2FibGVkPzogYm9vbGVhbjtcclxuICAgIGNwdU9ubHk/OiBib29sZWFuO1xyXG4gIH1cclxuICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBydW4gb3B0aW9uc1xyXG5cclxuICAvKipcclxuICAgKiBBIHNldCBvZiBjb25maWd1cmF0aW9ucyBmb3IgaW5mZXJlbmNlIHJ1biBiZWhhdmlvclxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUnVuT3B0aW9ucyB7XHJcbiAgICAvKipcclxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXHJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcclxuICAgICAqL1xyXG4gICAgbG9nU2V2ZXJpdHlMZXZlbD86IDAgfCAxIHwgMiB8IDMgfCA0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIHZlcmJvc2l0eSBsZXZlbC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXHJcbiAgICAgKi9cclxuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVybWluYXRlIGFsbCBpbmNvbXBsZXRlIE9ydFJ1biBjYWxscyBhcyBzb29uIGFzIHBvc3NpYmxlIGlmIHRydWVcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXHJcbiAgICAgKi9cclxuICAgIHRlcm1pbmF0ZT86IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHRhZyBmb3IgdGhlIFJ1bigpIGNhbGxzIHVzaW5nIHRoaXNcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIHRhZz86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIHNpbmdsZSBydW4gY29uZmlndXJhdGlvbiBlbnRyeS4gU2VlXHJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvc2Vzc2lvbi9cclxuICAgICAqIG9ubnhydW50aW1lX3J1bl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogZXh0cmE6IHtcclxuICAgICAqICAgbWVtb3J5OiB7XHJcbiAgICAgKiAgICAgZW5hYmxlX21lbW9yeV9hcmVuYV9zaHJpbmthZ2U6IFwiMVwiLFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICB9XHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiB2YWx1ZSBtZXRhZGF0YVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgY29tbW9uIHBhcnQgb2YgdGhlIHZhbHVlIG1ldGFkYXRhIHR5cGUgZm9yIGJvdGggdGVuc29yIGFuZCBub24tdGVuc29yIHZhbHVlcy5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlTWV0YWRhdGFCYXNlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNwZWNpZmllZCBpbnB1dCBvciBvdXRwdXQuXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgdGhlIG1ldGFkYXRhIG9mIGEgbm9uLXRlbnNvciB2YWx1ZS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE5vblRlbnNvclZhbHVlTWV0YWRhdGEgZXh0ZW5kcyBWYWx1ZU1ldGFkYXRhQmFzZSB7XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdmFsdWUgaXMgYSB0ZW5zb3IuXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IGlzVGVuc29yOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgdGhlIG1ldGFkYXRhIG9mIGEgdGVuc29yIHZhbHVlLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVmFsdWVNZXRhZGF0YSBleHRlbmRzIFZhbHVlTWV0YWRhdGFCYXNlIHtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHRlbnNvci5cclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgaXNUZW5zb3I6IHRydWU7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHR5cGU6IFRlbnNvci5UeXBlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNoYXBlIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIHNoYXBlIGlzIG5vdCBkZWZpbmVkLCB0aGUgdmFsdWUgd2lsbCBhbiBlbXB0eSBhcnJheS4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgc2hhcGVcclxuICAgICAqIG9mIHRoZSB0ZW5zb3IuIEVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nLiBJZiB0aGUgZWxlbWVudCBpcyBhIG51bWJlciwgaXQgcmVwcmVzZW50c1xyXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgZGltZW5zaW9uIHNpemUuIElmIHRoZSBlbGVtZW50IGlzIGEgc3RyaW5nLCBpdCByZXByZXNlbnRzIGEgc3ltYm9saWMgZGltZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBzaGFwZTogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyB0aGUgbWV0YWRhdGEgb2YgYSB2YWx1ZS5cclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBWYWx1ZU1ldGFkYXRhID0gTm9uVGVuc29yVmFsdWVNZXRhZGF0YSB8IFRlbnNvclZhbHVlTWV0YWRhdGE7XHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudCBhIHJ1bnRpbWUgaW5zdGFuY2Ugb2YgYW4gT05OWCBtb2RlbC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XHJcbiAgLy8gI3JlZ2lvbiBydW4oKVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlIHRoZSBtb2RlbCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcyBhbmQgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3IgZGV0YWlsLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgaW5mZXJlbmNlLlxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXHJcbiAgICovXHJcbiAgcnVuKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZSB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMsIGZldGNoZXMgYW5kIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cclxuICAgKiBAcGFyYW0gZmV0Y2hlcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLk91dHB1dFR5cGVgIGZvclxyXG4gICAqIGRldGFpbC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cclxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxyXG4gICAqL1xyXG4gIHJ1bihcclxuICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSxcclxuICAgIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXHJcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxyXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxyXG4gICAqL1xyXG4gIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAvLyAjcmVnaW9uIHByb2ZpbGluZ1xyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBwcm9maWxpbmcuXHJcbiAgICovXHJcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogRW5kIHByb2ZpbGluZy5cclxuICAgKi9cclxuICBlbmRQcm9maWxpbmcoKTogdm9pZDtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAvLyAjcmVnaW9uIG1ldGFkYXRhXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBpbnB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIG1vZGVsLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgaW5wdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cclxuICAgKi9cclxuICByZWFkb25seSBpbnB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG91dHB1dCBtZXRhZGF0YSBvZiB0aGUgbG9hZGVkIG1vZGVsLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb25GYWN0b3J5IHtcclxuICAvLyAjcmVnaW9uIGNyZWF0ZSgpXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGFuIE9OTlggbW9kZWwgZmlsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB1cmkgLSBUaGUgVVJJIG9yIGZpbGUgcGF0aCBvZiB0aGUgbW9kZWwgdG8gbG9hZC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXHJcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgY3JlYXRlKHVyaTogc3RyaW5nLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGFuIGFycmF5IGJ1ZmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIGNyZWF0ZShidWZmZXI6IEFycmF5QnVmZmVyTGlrZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBzZWdtZW50IG9mIGFuIGFycmF5IGJ1ZmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXHJcbiAgICogQHBhcmFtIGJ5dGVPZmZzZXQgLSBUaGUgYmVnaW5uaW5nIG9mIHRoZSBzcGVjaWZpZWQgcG9ydGlvbiBvZiB0aGUgYXJyYXkgYnVmZmVyLlxyXG4gICAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBpbiBieXRlcyBvZiB0aGUgYXJyYXkgYnVmZmVyLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cclxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cclxuICAgKi9cclxuICBjcmVhdGUoXHJcbiAgICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZSxcclxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcclxuICAgIGJ5dGVMZW5ndGg/OiBudW1iZXIsXHJcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcclxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhIFVpbnQ4QXJyYXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYnVmZmVyIC0gQSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIGNyZWF0ZShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG59XHJcblxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uOiBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSA9IEluZmVyZW5jZVNlc3Npb25JbXBsO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycywgT3B0aW9uc1RlbnNvckxheW91dCB9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0RhdGFVcmxPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyBleHRlbmRzIE9wdGlvbnNUZW5zb3JMYXlvdXQsIE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzaW9uVXRpbHMge1xyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZXMgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGVuc29yXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGhlIHRlbnNvci5cclxuICAgKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XHJcbiAgICogLSBgZm9ybWF0YDogYCdSR0InYFxyXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXHJcbiAgICogQHJldHVybnMgYSBEYXRhVVJMIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXHJcbiAgICovXHJcbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGVzIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRlbnNvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRoZSB0ZW5zb3IuXHJcbiAgICpcclxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxyXG4gICAqIC0gYGZvcm1hdGA6IGAnUkdCJ2BcclxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxyXG4gICAqIEByZXR1cm5zIGFuIEltYWdlRGF0YSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXHJcbiAgICovXHJcbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YTtcclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IFRlbnNvciwgVHlwZWRUZW5zb3IgfSBmcm9tICcuL3RlbnNvci5qcyc7XHJcblxyXG5leHBvcnQgdHlwZSBJbWFnZUZvcm1hdCA9ICdSR0InIHwgJ1JHQkEnIHwgJ0JHUicgfCAnUkJHJztcclxuZXhwb3J0IHR5cGUgSW1hZ2VUZW5zb3JMYXlvdXQgPSAnTkhXQycgfCAnTkNIVyc7XHJcblxyXG4vLyB0aGUgZm9sbG93aW5nIHJlZ2lvbiBjb250YWlucyB0eXBlIGRlZmluaXRpb25zIGZvciBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cclxuXHJcbi8vICNyZWdpb24gdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb25cclxuXHJcbi8qKlxyXG4gKiByZXByZXNlbnQgY29tbW9uIHByb3BlcnRpZXMgb2YgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cclxuICovXHJcbmludGVyZmFjZSBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgdHlwZTogVDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIEdQVSByZXNvdXJjZS5cclxuICovXHJcbmludGVyZmFjZSBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IHtcclxuICAvKipcclxuICAgKiBhbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBkb3dubG9hZCBkYXRhIGZyb20gR1BVIHRvIENQVS5cclxuICAgKlxyXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIHRlbnNvciB0cmVhdCB0aGUgR1BVIGRhdGEgYXMgZXh0ZXJuYWwgcmVzb3VyY2UuXHJcbiAgICovXHJcbiAgZG93bmxvYWQ/KCk6IFByb21pc2U8VGVuc29yLkRhdGFUeXBlTWFwW1RdPjtcclxuXHJcbiAgLyoqXHJcbiAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuXHJcbiAgICpcclxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0ZW5zb3IgdHJlYXQgdGhlIEdQVSBkYXRhIGFzIGV4dGVybmFsIHJlc291cmNlLlxyXG4gICAqL1xyXG4gIGRpc3Bvc2U/KCk6IHZvaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBwaW5uZWQgQ1BVIGJ1ZmZlclxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5DcHVQaW5uZWREYXRhVHlwZXMgPSBUZW5zb3IuQ3B1UGlubmVkRGF0YVR5cGVzPlxyXG4gIGV4dGVuZHMgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcclxuICAvKipcclxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAnY3B1LXBpbm5lZCcuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgbG9jYXRpb246ICdjcHUtcGlubmVkJztcclxuICAvKipcclxuICAgKiBTcGVjaWZ5IHRoZSBDUFUgcGlubmVkIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKi9cclxuICByZWFkb25seSBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHTCB0ZXh0dXJlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXHJcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ3RleHR1cmUnLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAndGV4dHVyZSc7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKi9cclxuICByZWFkb25seSB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9IFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXHJcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2dwdS1idWZmZXInLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcic7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKi9cclxuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXMgPSBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXHJcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ21sLXRlbnNvcicuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgbG9jYXRpb246ICdtbC10ZW5zb3InO1xyXG5cclxuICAvKipcclxuICAgKiBTcGVjaWZ5IHRoZSBXZWJOTiBNTFRlbnNvciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKi9cclxuICByZWFkb25seSBtbFRlbnNvcjogVGVuc29yLk1MVGVuc29yVHlwZTtcclxufVxyXG5cclxuLy8gI2VuZHJlZ2lvblxyXG5cclxuLy8gdGhlIGZvbGxvd2luZyByZWdpb24gY29udGFpbnMgdHlwZSBkZWZpbml0aW9ucyBvZiBlYWNoIGluZGl2aWR1YWwgb3B0aW9ucy5cclxuLy8gdGhlIHRlbnNvciBmYWN0b3J5IGZ1bmN0aW9ucyB1c2UgYSBjb21wb3NpdGlvbiBvZiB0aG9zZSBvcHRpb25zIGFzIHRoZSBwYXJhbWV0ZXIgdHlwZS5cclxuXHJcbi8vICNyZWdpb24gT3B0aW9ucyBmaWVsZHNcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0Zvcm1hdCB7XHJcbiAgLyoqXHJcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBmb3JtYXQgcmVwcmVzZW50ZWQgaW4gUkdCQSBjb2xvciBzcGFjZS5cclxuICAgKi9cclxuICBmb3JtYXQ/OiBJbWFnZUZvcm1hdDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yRm9ybWF0IHtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCBvZiB0aGUgdGVuc29yLlxyXG4gICAqXHJcbiAgICogTk9URTogdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBvcHRpb24gJ2Zvcm1hdCcuIFdoaWxlIG9wdGlvbiAnZm9ybWF0JyByZXByZXNlbnRzIHRoZSBvcmlnaW5hbCBpbWFnZSwgJ3RlbnNvckZvcm1hdCdcclxuICAgKiByZXByZXNlbnRzIHRoZSB0YXJnZXQgZm9ybWF0IG9mIHRoZSB0ZW5zb3IuIEEgdHJhbnNwb3NlIHdpbGwgYmUgcGVyZm9ybWVkIGlmIHRoZXkgYXJlIGRpZmZlcmVudC5cclxuICAgKi9cclxuICB0ZW5zb3JGb3JtYXQ/OiBJbWFnZUZvcm1hdDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yRGF0YVR5cGUge1xyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICovXHJcbiAgZGF0YVR5cGU/OiAnZmxvYXQzMicgfCAndWludDgnO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JMYXlvdXQge1xyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyB0aGUgdGVuc29yIGxheW91dCB3aGVuIHJlcHJlc2VudGluZyBkYXRhIG9mIG9uZSBvciBtb3JlIGltYWdlKHMpLlxyXG4gICAqL1xyXG4gIHRlbnNvckxheW91dD86IEltYWdlVGVuc29yTGF5b3V0O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNEaW1lbnNpb25zIHtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGhlaWdodCBpbiBwaXhlbFxyXG4gICAqL1xyXG4gIGhlaWdodD86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIHdpZHRoIGluIHBpeGVsXHJcbiAgICovXHJcbiAgd2lkdGg/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMge1xyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyB0aGUgcmVzaXplZCBoZWlnaHQuIElmIG9taXR0ZWQsIG9yaWdpbmFsIGhlaWdodCB3aWxsIGJlIHVzZWQuXHJcbiAgICovXHJcbiAgcmVzaXplZEhlaWdodD86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgcmVzaXplZCB3aWR0aCAtIGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGVuc29yIGRpbWVuc2lvbnMgYXMgd2VsbFxyXG4gICAqL1xyXG4gIHJlc2l6ZWRXaWR0aD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge1xyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyBub3JtYWxpemF0aW9uIHBhcmFtZXRlcnMgd2hlbiBwcmVwcm9jZXNzaW5nIHRoZSBpbWFnZSBhcyBtb2RlbCBpbnB1dC5cclxuICAgKlxyXG4gICAqIERhdGEgZWxlbWVudCBhcmUgcmFuZ2VkIGZyb20gMCB0byAyNTUuXHJcbiAgICovXHJcbiAgbm9ybT86IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdiaWFzJyB2YWx1ZSBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cclxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMC5cclxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxyXG4gICAgICogLSBJZiBpdCdzIGFuIGFycmF5IG9mIDMgb3IgNCBudW1iZXJzLCBhcHBseSBlbGVtZW50LXdpc2UuIE51bWJlciBvZiBlbGVtZW50cyBuZWVkIHRvIG1hdGNoIHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcclxuICAgICAqIGZvciB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBmb3JtYXRcclxuICAgICAqL1xyXG4gICAgYmlhcz86IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ21lYW4nIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxyXG4gICAgICogLSBJZiBvbWl0dGVkLCB1c2UgZGVmYXVsdCB2YWx1ZSAyNTUuXHJcbiAgICAgKiAtIElmIGl0J3MgYSBzaW5nbGUgbnVtYmVyLCBhcHBseSB0byBlYWNoIGNoYW5uZWxcclxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXHJcbiAgICAgKiBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZm9ybWF0XHJcbiAgICAgKi9cclxuICAgIG1lYW4/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuICB9O1xyXG59XHJcblxyXG4vLyAjZW5kcmVnaW9uXHJcblxyXG4vLyAjcmVnaW9uIE9wdGlvbnMgY29tcG9zaXRpb25cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnNcclxuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxyXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcclxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXHJcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXHJcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcclxuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxyXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcclxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXHJcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXHJcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbVVybE9wdGlvbnNcclxuICBleHRlbmRzIE9wdGlvbnNEaW1lbnNpb25zLFxyXG4gICAgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXHJcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxyXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcclxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcclxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zXHJcbiAgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcclxuICAgIE9wdGlvbnNUZW5zb3JGb3JtYXQsXHJcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxyXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxyXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBSZXF1aXJlZDxPcHRpb25zRGltZW5zaW9ucz4sXHJcbiAgICBPcHRpb25zRm9ybWF0LFxyXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gLyogVE9ETzogYWRkIG1vcmUgKi8ge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPixcclxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxyXG4gICAqL1xyXG4gIGRhdGFUeXBlPzogVDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPixcclxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxyXG4gICAqL1xyXG4gIGRhdGFUeXBlPzogVDtcclxufVxyXG5cclxuLy8gI2VuZHJlZ2lvblxyXG5cclxuLyoqXHJcbiAqIHR5cGUgVGVuc29yRmFjdG9yeSBkZWZpbmVzIHRoZSBmYWN0b3J5IGZ1bmN0aW9ucyBvZiAnVGVuc29yJyB0byBjcmVhdGUgdGVuc29yIGluc3RhbmNlcyBmcm9tIGV4aXN0aW5nIGRhdGEgb3JcclxuICogcmVzb3VyY2VzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGYWN0b3J5IHtcclxuICAvKipcclxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZURhdGEgb2JqZWN0XHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW1hZ2VEYXRhIC0gdGhlIEltYWdlRGF0YSBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEltYWdlRGF0YS5cclxuICAgKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XHJcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxyXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXHJcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxyXG4gICAqL1xyXG4gIGZyb21JbWFnZShcclxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxyXG4gICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxyXG4gICk6IFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcclxuXHJcbiAgLyoqXHJcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGltYWdlRWxlbWVudCAtIHRoZSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gSFRNTEltYWdlRWxlbWVudC5cclxuICAgKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XHJcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxyXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXHJcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxyXG4gICAqL1xyXG4gIGZyb21JbWFnZShcclxuICAgIGltYWdlRWxlbWVudDogSFRNTEltYWdlRWxlbWVudCxcclxuICAgIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcclxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIFVSTFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHVybFNvdXJjZSAtIGEgc3RyaW5nIGFzIGEgVVJMIHRvIHRoZSBpbWFnZSBvciBhIGRhdGEgVVJMIGNvbnRhaW5pbmcgdGhlIGltYWdlIGRhdGEuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cclxuICAgKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XHJcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxyXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXHJcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxyXG4gICAqL1xyXG4gIGZyb21JbWFnZSh1cmxTb3VyY2U6IHN0cmluZywgb3B0aW9ucz86IFRlbnNvckZyb21VcmxPcHRpb25zKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZUJpdG1hcCBvYmplY3RcclxuICAgKlxyXG4gICAqIEBwYXJhbSBiaXRtYXAgLSB0aGUgSW1hZ2VCaXRtYXAgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBVUkwuXHJcbiAgICpcclxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxyXG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcclxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxyXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcclxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcclxuICAgKi9cclxuICBmcm9tSW1hZ2UoXHJcbiAgICBiaXRtYXA6IEltYWdlQml0bWFwLFxyXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcclxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHRleHR1cmUgLSB0aGUgV2ViR0xUZXh0dXJlIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR0wgdGV4dHVyZS5cclxuICAgKlxyXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICogLSBgd2lkdGhgOiB0aGUgd2lkdGggb2YgdGhlIHRleHR1cmUuIFJlcXVpcmVkLlxyXG4gICAqIC0gYGhlaWdodGA6IHRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmUuIFJlcXVpcmVkLlxyXG4gICAqIC0gYGZvcm1hdGA6IHRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIElmIG9taXR0ZWQsIGFzc3VtZSAnUkdCQScuXHJcbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcclxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcclxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cclxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXHJcbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XHJcbiAgICovXHJcbiAgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInPihcclxuICAgIHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZSxcclxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUPixcclxuICApOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSBidWZmZXIgLSB0aGUgR1BVQnVmZmVyIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR1BVIGJ1ZmZlci5cclxuICAgKlxyXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXHJcbiAgICogLSBgZGltc2A6IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gUmVxdWlyZWQuXHJcbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcclxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcclxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cclxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXHJcbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XHJcbiAgICovXHJcbiAgZnJvbUdwdUJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXHJcbiAgICBidWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlLFxyXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXHJcbiAgKTogVHlwZWRUZW5zb3I8VD47XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViTk4gTUxUZW5zb3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB0ZW5zb3IgLSB0aGUgTUxUZW5zb3Igb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yLlxyXG4gICAqXHJcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgKiAtIGBkYXRhVHlwZWA6IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYXNzdW1lICdmbG9hdDMyJy5cclxuICAgKiAtIGBkaW1zYDogdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBSZXF1aXJlZC5cclxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIHRoZSBNTFRlbnNvciB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvclxyXG4gICAqIGRhdGEgd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSB0aGUgV2ViTk4gYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLlxyXG4gICAqIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiB0aGUgV2ViTk4gTUxUZW5zb3IuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvciB3aWxsXHJcbiAgICogbm90IGJlIGRpc3Bvc2VkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IHRoZSBXZWJOTiBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG9cclxuICAgKiBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcclxuICAgKi9cclxuICBmcm9tTUxUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcz4oXHJcbiAgICB0ZW5zb3I6IFRlbnNvci5NTFRlbnNvclR5cGUsXHJcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQ+LFxyXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIHByZS1hbGxvY2F0ZWQgYnVmZmVyLiBUaGUgYnVmZmVyIHdpbGwgYmUgdXNlZCBhcyBhIHBpbm5lZCBidWZmZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgZWxlbWVudCB0eXBlLlxyXG4gICAqIEBwYXJhbSBidWZmZXIgLSBhIFR5cGVkQXJyYXkgY29ycmVzcG9uZGluZyB0byB0aGUgdHlwZS5cclxuICAgKiBAcGFyYW0gZGltcyAtIHNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxyXG4gICAqL1xyXG4gIGZyb21QaW5uZWRCdWZmZXI8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPj4oXHJcbiAgICB0eXBlOiBULFxyXG4gICAgYnVmZmVyOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0sXHJcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKTogVHlwZWRUZW5zb3I8VD47XHJcbn1cclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG4vKipcclxuICogQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmlsZSdzIFVSTCBvciBwYXRoLlxyXG4gKlxyXG4gKiBQYXRoIGlzIHZhaWxhYmxlIG9ubHkgaW4gb25ueHJ1bnRpbWUtbm9kZSBvciBvbm54cnVudGltZS13ZWIgcnVubmluZyBpbiBOb2RlLmpzLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgRmlsZVVybE9yUGF0aCA9IHN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBBIEJsb2Igb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGZpbGUuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBGaWxlQmxvYiA9IEJsb2I7XHJcblxyXG4vKipcclxuICogQSBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZSBjb250ZW50LlxyXG4gKlxyXG4gKiBXaGVuIGl0IGlzIGFuIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyLCB0aGUgd2hvbGUgYnVmZmVyIGlzIGFzc3VtZWQgdG8gYmUgdGhlIGZpbGUgY29udGVudC5cclxuICovXHJcbmV4cG9ydCB0eXBlIEZpbGVEYXRhID0gVWludDhBcnJheSB8IEFycmF5QnVmZmVyTGlrZTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgZmlsZSB0aGF0IGNhbiBiZSBsb2FkZWQgYnkgdGhlIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSS5cclxuICovXHJcbmV4cG9ydCB0eXBlIEZpbGVUeXBlID0gRmlsZVVybE9yUGF0aCB8IEZpbGVCbG9iIHwgRmlsZURhdGE7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBleHRlcm5hbCBkYXRhIGZpbGUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybmFsRGF0YUZpbGVEZXNjcmlwdGlvbiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgZXh0ZXJuYWwgZGF0YSBmaWxlLlxyXG4gICAqL1xyXG4gIGRhdGE6IEZpbGVUeXBlO1xyXG4gIC8qKlxyXG4gICAqIFNwZWNpZnkgdGhlIGZpbGUgcGF0aC5cclxuICAgKi9cclxuICBwYXRoOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGV4dGVybmFsIGRhdGEgZmlsZS5cclxuICpcclxuICogV2hlbiB1c2luZyBhIHN0cmluZywgaXQgc2hvdWxkIGJlIGEgZmlsZSBVUkwgb3IgcGF0aCB0aGF0IGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyB0aGUgbW9kZWwgZmlsZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIEV4dGVybmFsRGF0YUZpbGVUeXBlID0gRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHwgRmlsZVVybE9yUGF0aDtcclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIGZvciBtb2RlbCBsb2FkaW5nLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBPbm54TW9kZWxPcHRpb25zIHtcclxuICAvKipcclxuICAgKiBTcGVjaWZ5aW5nIGEgbGlzdCBvZiBmaWxlcyB0aGF0IHJlcHJlc2VudHMgdGhlIGV4dGVybmFsIGRhdGEuXHJcbiAgICovXHJcbiAgZXh0ZXJuYWxEYXRhPzogcmVhZG9ubHkgRXh0ZXJuYWxEYXRhRmlsZVR5cGVbXTtcclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcclxuXHJcbmV4cG9ydCB0eXBlIE5vblRlbnNvclR5cGUgPSBuZXZlcjtcclxuXHJcbi8qKlxyXG4gKiBUeXBlIE9ubnhWYWx1ZSBSZXByZXNlbnRzIGJvdGggdGVuc29ycyBhbmQgbm9uLXRlbnNvcnMgdmFsdWUgZm9yIG1vZGVsJ3MgaW5wdXRzL291dHB1dHMuXHJcbiAqXHJcbiAqIE5PVEU6IGN1cnJlbnRseSBub3Qgc3VwcG9ydCBub24tdGVuc29yXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBPbm54VmFsdWUgPSBUZW5zb3IgfCBOb25UZW5zb3JUeXBlO1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgT25ueFZhbHVlRGF0YUxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIG9mIGFuIE9ubnhWYWx1ZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiA9IFRlbnNvci5EYXRhTG9jYXRpb247XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuLyoqXHJcbiAqICMgT05OWCBSdW50aW1lIEphdmFTY3JpcHQgQVBJXHJcbiAqXHJcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcclxuICpcclxuICogLSBbb25ueHJ1bnRpbWUtbm9kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtbm9kZSlcclxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXHJcbiAqIC0gW29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtcmVhY3QtbmF0aXZlKVxyXG4gKlxyXG4gKiBTZWUgYWxzbzpcclxuICogLSBbR2V0IFN0YXJ0ZWRdKGh0dHBzOi8vb25ueHJ1bnRpbWUuYWkvZG9jcy9nZXQtc3RhcnRlZC93aXRoLWphdmFzY3JpcHQvKVxyXG4gKiAtIFtJbmZlcmVuY2UgZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUtaW5mZXJlbmNlLWV4YW1wbGVzL3RyZWUvbWFpbi9qcylcclxuICpcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5cclxuZXhwb3J0ICogZnJvbSAnLi9iYWNrZW5kLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9lbnYuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3IuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdHJhY2UuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL29ubngtbW9kZWwuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL29ubngtdmFsdWUuanMnO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmV4cG9ydCBjb25zdCBpc05vZGUgPSAhISh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbi8vLyA8cmVmZXJlbmNlIGxpYj1cIndlYndvcmtlclwiIC8+XHJcblxyXG4vL1xyXG4vLyAqIHR5cGUgaGFjayBmb3IgXCJIVE1MSW1hZ2VFbGVtZW50XCJcclxuLy9cclxuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJIVE1MSW1hZ2VFbGVtZW50XCIgaXMgZGVmaW5lZCBpbiBsaWIuZG9tLmQudHMsIHdoaWNoIGlzIGNvbmZsaWN0IHdpdGggbGliLndlYndvcmtlci5kLnRzLlxyXG4vLyB3aGVuIHdlIHVzZSB3ZWJ3b3JrZXIsIHRoZSBsaWIud2Vid29ya2VyLmQudHMgd2lsbCBiZSB1c2VkLCB3aGljaCBkb2VzIG5vdCBoYXZlIEhUTUxJbWFnZUVsZW1lbnQgZGVmaW5lZC5cclxuLy9cclxuLy8gd2Ugd2lsbCBnZXQgdGhlIGZvbGxvd2luZyBlcnJvcnMgY29tcGxhaW5pbmcgdGhhdCBIVE1MSW1hZ2VFbGVtZW50IGlzIG5vdCBkZWZpbmVkOlxyXG4vL1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL1xyXG4vLyAuLi9jb21tb24vZGlzdC9janMvdGVuc29yLWZhY3RvcnkuZC50czoxODc6MjkgLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxJbWFnZUVsZW1lbnQnLiBEaWQgeW91IG1lYW5cclxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xyXG4vL1xyXG4vLyAxODcgICAgIGZyb21JbWFnZShpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyk6XHJcbi8vIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XHJcbi8vXHJcbi8vIG5vZGVfbW9kdWxlcy9Ad2ViZ3B1L3R5cGVzL2Rpc3QvaW5kZXguZC50czo4Mzo3IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MSW1hZ2VFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXHJcbi8vICdIVE1MTElFbGVtZW50Jz9cclxuLy9cclxuLy8gODMgICAgIHwgSFRNTEltYWdlRWxlbWVudFxyXG4vLyAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XHJcbi8vXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vXHJcbi8vIGBIVE1MSW1hZ2VFbGVtZW50YCBpcyBvbmx5IHVzZWQgaW4gdHlwZSBkZWNsYXJhdGlvbiBhbmQgbm90IGluIHJlYWwgY29kZS4gU28gd2UgZGVmaW5lIGl0IGFzIGB1bmtub3duYCBoZXJlIHRvXHJcbi8vIGJ5cGFzcyB0aGUgdHlwZSBjaGVjay5cclxuXHJcbi8vXHJcbi8vICogdHlwZSBoYWNrIGZvciBcImRvY3VtZW50XCJcclxuLy9cclxuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJkb2N1bWVudFwiIGlzIGRlZmluZWQgaW4gbGliLmRvbS5kLnRzLCBzbyBpdCdzIG5vdCBhdmFpbGFibGUgaW4gd2Vid29ya2VyLlxyXG4vL1xyXG4vLyB3ZSB3aWxsIGdldCB0aGUgZm9sbG93aW5nIGVycm9ycyBjb21wbGFpbmluZyB0aGF0IGRvY3VtZW50IGlzIG5vdCBkZWZpbmVkOlxyXG4vL1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL1xyXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3OjMzIC0gZXJyb3IgVFMyNTg0OiBDYW5ub3QgZmluZCBuYW1lICdkb2N1bWVudCcuIERvIHlvdSBuZWVkIHRvIGNoYW5nZSB5b3VyIHRhcmdldFxyXG4vLyBsaWJyYXJ5PyBUcnkgY2hhbmdpbmcgdGhlICdsaWInIGNvbXBpbGVyIG9wdGlvbiB0byBpbmNsdWRlICdkb20nLlxyXG4vL1xyXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XHJcbi8vXHJcbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6NjEgLSBlcnJvciBUUzI1ODQ6IENhbm5vdCBmaW5kIG5hbWUgJ2RvY3VtZW50Jy4gRG8geW91IG5lZWQgdG8gY2hhbmdlIHlvdXIgdGFyZ2V0XHJcbi8vIGxpYnJhcnk/IFRyeSBjaGFuZ2luZyB0aGUgJ2xpYicgY29tcGlsZXIgb3B0aW9uIHRvIGluY2x1ZGUgJ2RvbScuXHJcbi8vXHJcbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XHJcbi8vXHJcbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6ODggLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxTY3JpcHRFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXHJcbi8vICdIVE1MTElFbGVtZW50Jz9cclxuLy9cclxuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5+fn5+fn5+fn5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy9cclxuLy8gYGRvY3VtZW50YCBpcyB1c2VkIHRvIGdldCB0aGUgY3VycmVudCBzY3JpcHQgVVJMLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluIHdlYndvcmtlci4gVGhpcyBmaWxlIGlzIHNlcnZlZCBhcyBhXHJcbi8vIFwiZHVhbFwiIGZpbGUgZm9yIGVudHJpZXMgb2YgYm90aCB3ZWJ3b3JrZXIgYW5kIHRoZSBlc20gbW9kdWxlLlxyXG4vL1xyXG5kZWNsYXJlIGdsb2JhbCB7XHJcbiAgdHlwZSBIVE1MSW1hZ2VFbGVtZW50ID0gdW5rbm93bjtcclxuICB0eXBlIEhUTUxTY3JpcHRFbGVtZW50ID0geyBzcmM/OiBzdHJpbmcgfTtcclxuICBjb25zdCBkb2N1bWVudDogdW5kZWZpbmVkIHwgeyBjdXJyZW50U2NyaXB0PzogSFRNTFNjcmlwdEVsZW1lbnQgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBzdW1tYXJ5XHJcbiAqXHJcbiAqIFRoaXMgZmlsZSBpcyBzZXJ2ZWQgYXMgYSBcImR1YWxcIiBmaWxlIGZvciBib3RoIGVudHJpZXMgb2YgdGhlIGZvbGxvd2luZzpcclxuICogLSBUaGUgcHJveHkgd29ya2VyIGl0c2VsZi5cclxuICogICAtIFdoZW4gdXNlZCBhcyBhIHdvcmtlciwgaXQgbGlzdGVucyB0byB0aGUgbWVzc2FnZXMgZnJvbSB0aGUgbWFpbiB0aHJlYWQgYW5kIHBlcmZvcm1zIHRoZSBjb3JyZXNwb25kaW5nIG9wZXJhdGlvbnMuXHJcbiAqICAgLSBTaG91bGQgYmUgaW1wb3J0ZWQgZGlyZWN0bHkgdXNpbmcgYG5ldyBXb3JrZXIoKWAgaW4gdGhlIG1haW4gdGhyZWFkLlxyXG4gKlxyXG4gKiAtIFRoZSBFU00gbW9kdWxlIHRoYXQgY3JlYXRlcyB0aGUgcHJveHkgd29ya2VyIChhcyBhIHdvcmtlciBsYXVuY2hlcikuXHJcbiAqICAgLSBXaGVuIHVzZWQgYXMgYSB3b3JrZXIgbGF1bmNoZXIsIGl0IGNyZWF0ZXMgdGhlIHByb3h5IHdvcmtlciBhbmQgcmV0dXJucyBpdC5cclxuICogICAtIFNob3VsZCBiZSBpbXBvcnRlZCB1c2luZyBgaW1wb3J0KClgIGluIHRoZSBtYWluIHRocmVhZCwgd2l0aCB0aGUgcXVlcnkgcGFyYW1ldGVyIGBpbXBvcnQ9MWAuXHJcbiAqXHJcbiAqIFRoaXMgZmlsZSB3aWxsIGJlIGFsd2F5cyBjb21waWxpbmcgaW50byBFU00gZm9ybWF0LlxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1lc3NhZ2UsIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhIH0gZnJvbSAnLi4vcHJveHktbWVzc2FnZXMuanMnO1xyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVNlc3Npb24sXHJcbiAgY29weUZyb21FeHRlcm5hbEJ1ZmZlcixcclxuICBlbmRQcm9maWxpbmcsXHJcbiAgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMsXHJcbiAgaW5pdEVwLFxyXG4gIGluaXRSdW50aW1lLFxyXG4gIHJlbGVhc2VTZXNzaW9uLFxyXG4gIHJ1bixcclxufSBmcm9tICcuLi93YXNtLWNvcmUtaW1wbC5qcyc7XHJcbmltcG9ydCB7IGluaXRpYWxpemVXZWJBc3NlbWJseSB9IGZyb20gJy4uL3dhc20tZmFjdG9yeS5qcyc7XHJcbmltcG9ydCB7IHNjcmlwdFNyYyB9IGZyb20gJy4uL3dhc20tdXRpbHMtaW1wb3J0LmpzJztcclxuXHJcbmNvbnN0IFdPUktFUl9OQU1FID0gJ29ydC13YXNtLXByb3h5LXdvcmtlcic7XHJcbmNvbnN0IGlzUHJveHlXb3JrZXIgPSBnbG9iYWxUaGlzLnNlbGY/Lm5hbWUgPT09IFdPUktFUl9OQU1FO1xyXG5cclxuaWYgKGlzUHJveHlXb3JrZXIpIHtcclxuICAvLyBXb3JrZXIgdGhyZWFkXHJcbiAgc2VsZi5vbm1lc3NhZ2UgPSAoZXY6IE1lc3NhZ2VFdmVudDxPcnRXYXNtTWVzc2FnZT4pOiB2b2lkID0+IHtcclxuICAgIGNvbnN0IHsgdHlwZSwgaW46IG1lc3NhZ2UgfSA9IGV2LmRhdGE7XHJcbiAgICB0cnkge1xyXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlICdpbml0LXdhc20nOlxyXG4gICAgICAgICAgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KG1lc3NhZ2UhLndhc20pLnRoZW4oXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICBpbml0UnVudGltZShtZXNzYWdlISkudGhlbihcclxuICAgICAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdpbml0LWVwJzoge1xyXG4gICAgICAgICAgY29uc3QgeyBlcE5hbWUsIGVudiB9ID0gbWVzc2FnZSE7XHJcbiAgICAgICAgICBpbml0RXAoZW52LCBlcE5hbWUpLnRoZW4oXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnY29weS1mcm9tJzoge1xyXG4gICAgICAgICAgY29uc3QgeyBidWZmZXIgfSA9IG1lc3NhZ2UhO1xyXG4gICAgICAgICAgY29uc3QgYnVmZmVyRGF0YSA9IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIoYnVmZmVyKTtcclxuICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgb3V0OiBidWZmZXJEYXRhIH0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ2NyZWF0ZSc6IHtcclxuICAgICAgICAgIGNvbnN0IHsgbW9kZWwsIG9wdGlvbnMgfSA9IG1lc3NhZ2UhO1xyXG4gICAgICAgICAgY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucykudGhlbihcclxuICAgICAgICAgICAgKHNlc3Npb25NZXRhZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgb3V0OiBzZXNzaW9uTWV0YWRhdGEgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAncmVsZWFzZSc6XHJcbiAgICAgICAgICByZWxlYXNlU2Vzc2lvbihtZXNzYWdlISk7XHJcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdydW4nOiB7XHJcbiAgICAgICAgICBjb25zdCB7IHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG9wdGlvbnMgfSA9IG1lc3NhZ2UhO1xyXG4gICAgICAgICAgcnVuKHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG5ldyBBcnJheShvdXRwdXRJbmRpY2VzLmxlbmd0aCkuZmlsbChudWxsKSwgb3B0aW9ucykudGhlbihcclxuICAgICAgICAgICAgKG91dHB1dHMpID0+IHtcclxuICAgICAgICAgICAgICBpZiAob3V0cHV0cy5zb21lKChvKSA9PiBvWzNdICE9PSAnY3B1JykpIHtcclxuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyOiAnUHJveHkgZG9lcyBub3Qgc3VwcG9ydCBub24tY3B1IHRlbnNvciBsb2NhdGlvbi4nIH0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZShcclxuICAgICAgICAgICAgICAgICAgeyB0eXBlLCBvdXQ6IG91dHB1dHMgfSBhcyBPcnRXYXNtTWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMoWy4uLmlucHV0cywgLi4ub3V0cHV0c10gYXMgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSksXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdlbmQtcHJvZmlsaW5nJzpcclxuICAgICAgICAgIGVuZFByb2ZpbGluZyhtZXNzYWdlISk7XHJcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgaXNQcm94eVdvcmtlclxyXG4gID8gbnVsbFxyXG4gIDogKHVybE92ZXJyaWRlPzogc3RyaW5nKSA9PlxyXG4gICAgICBuZXcgV29ya2VyKHVybE92ZXJyaWRlID8/IHNjcmlwdFNyYyEsIHsgdHlwZTogQlVJTERfREVGUy5JU19FU00gPyAnbW9kdWxlJyA6ICdjbGFzc2ljJywgbmFtZTogV09SS0VSX05BTUUgfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHR5cGUgeyBPcnRXYXNtTW9kdWxlIH0gZnJvbSAnLi93YXNtLXR5cGVzJztcclxuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XHJcblxyXG4vKipcclxuICogVGhlIG9yaWdpbiBvZiB0aGUgY3VycmVudCBsb2NhdGlvbi5cclxuICpcclxuICogSW4gTm9kZS5qcywgdGhpcyBpcyB1bmRlZmluZWQuXHJcbiAqL1xyXG5jb25zdCBvcmlnaW4gPSBpc05vZGUgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uLm9yaWdpbjtcclxuXHJcbi8qKlxyXG4gKiBTb21lIGJ1bmRsZXJzIChlZy4gV2VicGFjaykgd2lsbCByZXdyaXRlIGBpbXBvcnQubWV0YS51cmxgIHRvIGEgZmlsZSBVUkwgYXQgY29tcGlsZSB0aW1lLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiBgaW1wb3J0Lm1ldGEudXJsYCBzdGFydHMgd2l0aCBgZmlsZTpgLCBidXQgdXNpbmcgdGhlIGA+YCBhbmQgYDxgIG9wZXJhdG9ycyBpbnN0ZWFkIG9mXHJcbiAqIGBzdGFydHNXaXRoYCBmdW5jdGlvbiBzbyB0aGF0IGNvZGUgbWluaW1pemVycyBjYW4gcmVtb3ZlIHRoZSBkZWFkIGNvZGUgY29ycmVjdGx5LlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgaWYgd2UgdXNlIHRlcnNlciB0byBtaW5pZnkgdGhlIGZvbGxvd2luZyBjb2RlOlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoXCJmaWxlOi8vaGFyZC1jb2RlZC1maWxlbmFtZVwiLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSkge1xyXG4gKiAgIGNvbnNvbGUubG9nKDEpXHJcbiAqIH0gZWxzZSB7XHJcbiAqICAgY29uc29sZS5sb2coMilcclxuICogfVxyXG4gKlxyXG4gKiBpZiAoXCJmaWxlOi8vaGFyZC1jb2RlZC1maWxlbmFtZVwiID4gXCJmaWxlOlwiICYmIFwiZmlsZTovL2hhcmQtY29kZWQtZmlsZW5hbWVcIiA8IFwiZmlsZTtcIikge1xyXG4gKiAgIGNvbnNvbGUubG9nKDMpXHJcbiAqIH0gZWxzZSB7XHJcbiAqICAgY29uc29sZS5sb2coNClcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIG1pbmlmaWVkIGNvZGUgd2lsbCBiZTpcclxuICogYGBganNcclxuICogXCJmaWxlOi8vaGFyZC1jb2RlZC1maWxlbmFtZVwiLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKT9jb25zb2xlLmxvZygxKTpjb25zb2xlLmxvZygyKSxjb25zb2xlLmxvZygzKTtcclxuICogYGBgXHJcbiAqXHJcbiAqICh1c2UgVGVyc2VyIDUuMzkuMCB3aXRoIGRlZmF1bHQgb3B0aW9ucywgaHR0cHM6Ly90cnkudGVyc2VyLm9yZy8pXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGltcG9ydC5tZXRhLnVybCBpcyBoYXJkY29kZWQgYXMgYSBmaWxlIFVSSS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBpc0VzbUltcG9ydE1ldGFVcmxIYXJkY29kZWRBc0ZpbGVVcmkgPVxyXG4gIEJVSUxEX0RFRlMuSVNfRVNNICYmIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCEgPiAnZmlsZTonICYmIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCEgPCAnZmlsZTsnO1xyXG5cclxuY29uc3QgZ2V0U2NyaXB0U3JjID0gKCk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XHJcbiAgLy8gaWYgTm9kZWpzLCByZXR1cm4gdW5kZWZpbmVkXHJcbiAgaWYgKGlzTm9kZSkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbiAgLy8gaWYgSXQncyBFU00sIHVzZSBpbXBvcnQubWV0YS51cmxcclxuICBpZiAoQlVJTERfREVGUy5JU19FU00pIHtcclxuICAgIC8vIEZvciBFU00sIGlmIHRoZSBpbXBvcnQubWV0YS51cmwgaXMgYSBmaWxlIFVSTCwgdGhpcyB1c3VhbGx5IG1lYW5zIHRoZSBidW5kbGVyIHJld3JpdGVzIGBpbXBvcnQubWV0YS51cmxgIHRvXHJcbiAgICAvLyB0aGUgZmlsZSBwYXRoIGF0IGNvbXBpbGUgdGltZS4gSW4gdGhpcyBjYXNlLCB0aGlzIGZpbGUgcGF0aCBjYW5ub3QgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJ1bnRpbWUgVVJMLlxyXG4gICAgLy9cclxuICAgIC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBVUkwgY29uc3RydWN0b3IgbGlrZSB0aGlzOlxyXG4gICAgLy8gYGBganNcclxuICAgIC8vIG5ldyBVUkwoJ2FjdHVhbC1idW5kbGUtbmFtZS5qcycsIGltcG9ydC5tZXRhLnVybCkuaHJlZlxyXG4gICAgLy8gYGBgXHJcbiAgICAvLyBTbyB0aGF0IGJ1bmRsZXIgY2FuIHByZXByb2Nlc3MgdGhlIFVSTCBjb3JyZWN0bHkuXHJcbiAgICBpZiAoaXNFc21JbXBvcnRNZXRhVXJsSGFyZGNvZGVkQXNGaWxlVXJpKSB7XHJcbiAgICAgIC8vIGlmIHRoZSByZXdyaXR0ZW4gVVJMIGlzIGEgcmVsYXRpdmUgcGF0aCwgd2UgbmVlZCB0byB1c2UgdGhlIG9yaWdpbiB0byByZXNvbHZlIHRoZSBVUkwuXHJcblxyXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgd29ya2Fyb3VuZCBmb3IgVml0ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVml0ZSB1c2VzIGEgYnVuZGxlcihyb2xsdXAvcm9sbGRvd24pIHRoYXQgZG9lcyBub3QgcmV3cml0ZSBgaW1wb3J0Lm1ldGEudXJsYCB0byBhIGZpbGUgVVJMLiBTbyBpbiB0aGVvcnksIHRoaXNcclxuICAgICAgLy8gY29kZSBwYXRoIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQgaW4gVml0ZS4gSG93ZXZlciwgdGhlIGJ1bmRsZXIgZG9lcyBub3Qga25vdyBpdCBhbmQgaXQgc3RpbGwgdHJ5IHRvIGxvYWQgdGhlXHJcbiAgICAgIC8vIGZvbGxvd2luZyBwYXR0ZXJuOlxyXG4gICAgICAvLyAtIGByZXR1cm4gbmV3IFVSTCgnZmlsZW5hbWUnLCBpbXBvcnQubWV0YS51cmwpLmhyZWZgXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIEJ5IHJlcGxhY2luZyB0aGUgcGF0dGVybiBhYm92ZSB3aXRoIHRoZSBmb2xsb3dpbmcgY29kZSwgd2UgY2FuIHNraXAgdGhlIHJlc291cmNlIGxvYWRpbmcgYmVoYXZpb3I6XHJcbiAgICAgIC8vIC0gYGNvbnN0IFVSTDIgPSBVUkw7IHJldHVybiBuZXcgVVJMMignZmlsZW5hbWUnLCBpbXBvcnQubWV0YS51cmwpLmhyZWY7YFxyXG4gICAgICAvL1xyXG4gICAgICAvLyBBbmQgaXQgc3RpbGwgd29ya3MgaW4gV2VicGFjay5cclxuICAgICAgY29uc3QgVVJMMiA9IFVSTDtcclxuICAgICAgcmV0dXJuIG5ldyBVUkwobmV3IFVSTDIoQlVJTERfREVGUy5CVU5ETEVfRklMRU5BTUUsIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCkuaHJlZiwgb3JpZ2luKS5ocmVmO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkw7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgPyAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyY1xyXG4gICAgOiAvLyB1c2UgYHNlbGYubG9jYXRpb24uaHJlZmAgaWYgYXZhaWxhYmxlXHJcbiAgICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICA/IHNlbGYubG9jYXRpb24/LmhyZWZcclxuICAgICAgOiB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGNsYXNzaWMgc2NyaXB0IHNvdXJjZSBVUkwuIFRoaXMgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gbm9uIEVTTW9kdWxlIGVudmlyb25tZW50cy5cclxuICpcclxuICogSW4gTm9kZS5qcywgdGhpcyBpcyB1bmRlZmluZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gZ2V0U2NyaXB0U3JjKCk7XHJcblxyXG4vKipcclxuICogSW5mZXIgdGhlIHdhc20gcGF0aCBwcmVmaXggZnJvbSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBpbmZlcnJlZCB3YXNtIHBhdGggcHJlZml4LCBvciB1bmRlZmluZWQgaWYgdGhlIHNjcmlwdCBzb3VyY2UgVVJMIGlzIG5vdCBhdmFpbGFibGUgb3IgaXMgYSBibG9iIFVSTC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBpbmZlcldhc21QYXRoUHJlZml4RnJvbVNjcmlwdFNyYyA9ICgpOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xyXG4gIGlmIChzY3JpcHRTcmMgJiYgIXNjcmlwdFNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XHJcbiAgICByZXR1cm4gc2NyaXB0U3JjLnN1YnN0cmluZygwLCBzY3JpcHRTcmMubGFzdEluZGV4T2YoJy8nKSArIDEpO1xyXG4gIH1cclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBmaWxlbmFtZSB3aXRoIHByZWZpeCBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cclxuICovXHJcbmNvbnN0IGlzU2FtZU9yaWdpbiA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBiYXNlVXJsID0gcHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0U3JjO1xyXG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XHJcbiAgICByZXR1cm4gdXJsLm9yaWdpbiA9PT0gb3JpZ2luO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgdGhlIGlucHV0cyB0byBhbiBhYnNvbHV0ZSBVUkwgd2l0aCB0aGUgZ2l2ZW4gcHJlZml4IG92ZXJyaWRlLiBJZiBmYWlsZWQsIHJldHVybiB1bmRlZmluZWQuXHJcbiAqL1xyXG5jb25zdCBub3JtYWxpemVVcmwgPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IHtcclxuICBjb25zdCBiYXNlVXJsID0gcHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0U3JjO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1cmwgPSBiYXNlVXJsID8gbmV3IFVSTChmaWxlbmFtZSwgYmFzZVVybCkgOiBuZXcgVVJMKGZpbGVuYW1lKTtcclxuICAgIHJldHVybiB1cmwuaHJlZjtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGZhbGxiYWNrIFVSTCBpZiBhbiBhYnNvbHV0ZSBVUkwgY2Fubm90IGJlIGNyZWF0ZWQgYnkgdGhlIG5vcm1hbGl6ZVVybCBmdW5jdGlvbi5cclxuICovXHJcbmNvbnN0IGZhbGxiYWNrVXJsID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiBgJHtwcmVmaXhPdmVycmlkZSA/PyAnLi8nfSR7ZmlsZW5hbWV9YDtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiBpcyB1c2VkIHRvIHByZWxvYWQgYSBtb2R1bGUgZnJvbSBhIFVSTC5cclxuICpcclxuICogSWYgdGhlIG9yaWdpbiBvZiB0aGUgd29ya2VyIFVSTCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBvcmlnaW4sIHRoZSB3b3JrZXIgY2Fubm90IGJlIGxvYWRlZCBkaXJlY3RseS5cclxuICogU2VlIGRpc2N1c3Npb25zIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvd29ya2VyLWxvYWRlci9pc3N1ZXMvMTU0XHJcbiAqXHJcbiAqIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBmZXRjaCB0aGUgd29ya2VyIFVSTCBhbmQgY3JlYXRlIGEgbmV3IEJsb2IgVVJMIHdpdGggdGhlIHNhbWUgb3JpZ2luIGFzIGEgd29ya2Fyb3VuZC5cclxuICpcclxuICogQHBhcmFtIGFic29sdXRlVXJsIC0gVGhlIGFic29sdXRlIFVSTCB0byBwcmVsb2FkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IEJsb2IgVVJMXHJcbiAqL1xyXG5jb25zdCBwcmVsb2FkID0gYXN5bmMgKGFic29sdXRlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYWJzb2x1dGVVcmwsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSk7XHJcbiAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcclxuICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiBpcyB1c2VkIHRvIGR5bmFtaWNhbGx5IGltcG9ydCBhIG1vZHVsZSBmcm9tIGEgVVJMLlxyXG4gKlxyXG4gKiBUaGUgYnVpbGQgc2NyaXB0IGhhcyBzcGVjaWFsIGhhbmRsaW5nIGZvciB0aGlzIGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0IHRoZSBVUkwgaXMgbm90IGJ1bmRsZWQgaW50byB0aGUgZmluYWwgb3V0cHV0LlxyXG4gKlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBpbXBvcnQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlZmF1bHQgZXhwb3J0IG9mIHRoZSBtb2R1bGUuXHJcbiAqL1xyXG5jb25zdCBkeW5hbWljSW1wb3J0RGVmYXVsdCA9IGFzeW5jIDxUPih1cmw6IHN0cmluZyk6IFByb21pc2U8VD4gPT5cclxuICAoYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gdXJsKSkuZGVmYXVsdDtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcHJveHkgd29ya2VyIGZhY3RvcnkgaW1wb3J0ZWQgZnJvbSB0aGUgcHJveHkgd29ya2VyIG1vZHVsZS5cclxuICpcclxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBXZWJBc3NlbWJseSBwcm94eSBpcyBub3QgZGlzYWJsZWQuXHJcbiAqL1xyXG5jb25zdCBjcmVhdGVQcm94eVdvcmtlcjogKCh1cmxPdmVycmlkZT86IHN0cmluZykgPT4gV29ya2VyKSB8IHVuZGVmaW5lZCA9XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcclxuICBCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSA/IHVuZGVmaW5lZCA6IHJlcXVpcmUoJy4vcHJveHktd29ya2VyL21haW4nKS5kZWZhdWx0O1xyXG5cclxuLyoqXHJcbiAqIEltcG9ydCB0aGUgcHJveHkgd29ya2VyLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxyXG4gKiAxLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxyXG4gKiAyLiBVc2UgdGhlIHByb3h5IHdvcmtlciBmYWN0b3J5IHRvIGNyZWF0ZSB0aGUgcHJveHkgd29ya2VyLlxyXG4gKlxyXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgMiBlbGVtZW50czpcclxuICogICAgICAgICAgICAtIFRoZSBvYmplY3QgVVJMIG9mIHRoZSBwcmVsb2FkZWQgbW9kdWxlLCBvciB1bmRlZmluZWQgaWYgbm8gcHJlbG9hZCBpcyBuZWVkZWQuXHJcbiAqICAgICAgICAgICAgLSBUaGUgcHJveHkgd29ya2VyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGltcG9ydFByb3h5V29ya2VyID0gYXN5bmMgKCk6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgV29ya2VyXT4gPT4ge1xyXG4gIGlmICghc2NyaXB0U3JjKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHByb3h5IHdvcmtlcjogY2Fubm90IGRldGVybWluZSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuJyk7XHJcbiAgfVxyXG5cclxuICAvLyBJZiB0aGUgc2NyaXB0IHNvdXJjZSBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbiwgd2UgY2FuIHVzZSB0aGUgZW1iZWRkZWQgcHJveHkgbW9kdWxlIGRpcmVjdGx5LlxyXG4gIGlmIChpc1NhbWVPcmlnaW4oc2NyaXB0U3JjKSkge1xyXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGNyZWF0ZVByb3h5V29ya2VyISgpXTtcclxuICB9XHJcblxyXG4gIC8vIE90aGVyd2lzZSwgbmVlZCB0byBwcmVsb2FkXHJcbiAgY29uc3QgdXJsID0gYXdhaXQgcHJlbG9hZChzY3JpcHRTcmMpO1xyXG4gIHJldHVybiBbdXJsLCBjcmVhdGVQcm94eVdvcmtlciEodXJsKV07XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGVtYmVkZGVkIFdlYkFzc2VtYmx5IG1vZHVsZS5cclxuICpcclxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBFU00gYW5kIHdoZW4gZW1iZWRkaW5nIGlzIG5vdCBkaXNhYmxlZC5cclxuICovXHJcbmNvbnN0IGVtYmVkZGVkV2FzbU1vZHVsZTogRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT4gfCB1bmRlZmluZWQgPVxyXG4gIEJVSUxEX0RFRlMuSVNfRVNNICYmIEJVSUxEX0RFRlMuRU5BQkxFX0JVTkRMRV9XQVNNX0pTXHJcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXHJcbiAgICAgIHJlcXVpcmUoXHJcbiAgICAgICAgIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQXHJcbiAgICAgICAgICA/ICcuLi8uLi9kaXN0L29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanMnXHJcbiAgICAgICAgICA6ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVXHJcbiAgICAgICAgICAgID8gJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5hc3luY2lmeS5tanMnXHJcbiAgICAgICAgICAgIDogJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanMnLFxyXG4gICAgICApLmRlZmF1bHRcclxuICAgIDogdW5kZWZpbmVkO1xyXG5cclxuLyoqXHJcbiAqIEltcG9ydCB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxyXG4gKiAxLiBJZiB0aGUgZW1iZWRkZWQgbW9kdWxlIGV4aXN0cyBhbmQgbm8gY3VzdG9tIFVSTCBpcyBzcGVjaWZpZWQsIHVzZSB0aGUgZW1iZWRkZWQgbW9kdWxlLlxyXG4gKiAyLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxyXG4gKiAzLiBPdGhlcndpc2UsIGl0IHdpbGwgcGVyZm9ybSBhIGR5bmFtaWMgaW1wb3J0IG9mIHRoZSBtb2R1bGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiAyIGVsZW1lbnRzOlxyXG4gKiAgICAgICAgICAgIC0gVGhlIG9iamVjdCBVUkwgb2YgdGhlIHByZWxvYWRlZCBtb2R1bGUsIG9yIHVuZGVmaW5lZCBpZiBubyBwcmVsb2FkIGlzIG5lZWRlZC5cclxuICogICAgICAgICAgICAtIFRoZSBkZWZhdWx0IGV4cG9ydCBvZiB0aGUgbW9kdWxlLCB3aGljaCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaW1wb3J0V2FzbU1vZHVsZSA9IGFzeW5jIChcclxuICB1cmxPdmVycmlkZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxyXG4gIHByZWZpeE92ZXJyaWRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXHJcbiAgaXNNdWx0aVRocmVhZGVkOiBib29sZWFuLFxyXG4gIGlzV2FzbU92ZXJyaWRkZW46IGJvb2xlYW4sXHJcbik6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT5dPiA9PiB7XHJcbiAgLy9cclxuICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgdXNlIHRoZSBlbWJlZGRlZCBtb2R1bGUuXHJcbiAgLy9cclxuXHJcbiAgLy8gVG8gdXNlIHRoZSBlbWJlZGRlZCBtb2R1bGUsIGl0IHNob3VsZCBiZSBhdmFpbGFibGUsIGFuZCBubyBVUkwgb3ZlcnJpZGUgb3IgcHJlZml4IG92ZXJyaWRlIHNob3VsZCBiZSBzcGVjaWZpZWQuXHJcbiAgbGV0IHVzZUVtYmVkZGVkTW9kdWxlID0gZW1iZWRkZWRXYXNtTW9kdWxlICYmICEodXJsT3ZlcnJpZGUgfHwgcHJlZml4T3ZlcnJpZGUpO1xyXG4gIGlmICh1c2VFbWJlZGRlZE1vZHVsZSkge1xyXG4gICAgaWYgKCFzY3JpcHRTcmMpIHtcclxuICAgICAgLy8gbm8gVVJMIGluZm8gYXZhaWxhYmxlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBOb3RlOiB3aGVuIHRoZSBlbWJlZGRlZCBtb2R1bGUgaXMgYXZhaWxhYmxlLCBpdCBtZWFucyB0aGUgY3VycmVudCBzY3JpcHQgaXMgRVNNLiBVc3VhbGx5LCBpbiBFU00sIHRoZVxyXG4gICAgICAvLyBgaW1wb3J0Lm1ldGEudXJsYCBpcyBhdmFpbGFibGUuIEJ1dCBpbiBzb21lIGNhc2VzIChlZy4gQ2xvdWRmbGFyZSBXb3JrZXJzKSwgdGhlIHZhbHVlIG9mIGBpbXBvcnQubWV0YS51cmxgXHJcbiAgICAgIC8vIGNhbiBiZSBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuIEluIHRoaXMgY2FzZSwgd2UgY2FuIG9ubHkgbG9hZCB0aGUgZW1iZWRkZWQgbW9kdWxlIHdoZW46XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIDEuIFRoZSBXZWJBc3NlbWJseSBtb2R1bGUgYmluYXJ5IGlzIG92ZXJyaWRkZW46XHJcbiAgICAgIC8vICAgIGBgYGpzXHJcbiAgICAgIC8vICAgIGVudi53YXNtLndhc21QYXRocyA9IHVuZGVmaW5lZDsgIC8vIG9yIG5vdCBzcGVjaWZpZWRcclxuICAgICAgLy8gICAgZW52Lndhc20ud2FzbUJpbmFyeSA9IC8qIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBXZWJBc3NlbWJseSBiaW5hcnkgKi87XHJcbiAgICAgIC8vICAgIGBgYFxyXG4gICAgICAvL1xyXG4gICAgICAvLyAyLiBUaGUgXCIud2FzbVwiIG9ubHkgaXMgb3ZlcnJpZGRlbi5cclxuICAgICAgLy8gICAgYGBganNcclxuICAgICAgLy8gICAgZW52Lndhc20ud2FzbVBhdGhzID0geyB3YXNtOiAvKiBVUkwgb2YgdGhlIC53YXNtIGZpbGUgKi8gfTtcclxuICAgICAgLy8gICAgYGBgXHJcbiAgICAgIC8vXHJcbiAgICAgIGlmIChpc1dhc21PdmVycmlkZGVuICYmICFpc011bHRpVGhyZWFkZWQpIHtcclxuICAgICAgICB1c2VFbWJlZGRlZE1vZHVsZSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC4nKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaWYgdGhlIHNjcmlwdCBzb3VyY2UgaXMgYXZhaWxhYmxlLCB3ZSBjYW4gY2hlY2sgaWYgaXQgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4uXHJcbiAgICAgIHVzZUVtYmVkZGVkTW9kdWxlID0gaXNTYW1lT3JpZ2luKHNjcmlwdFNyYyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh1c2VFbWJlZGRlZE1vZHVsZSkge1xyXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGVtYmVkZGVkV2FzbU1vZHVsZSFdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCB3YXNtTW9kdWxlRmlsZW5hbWUgPSAhQlVJTERfREVGUy5ESVNBQkxFX0pTRVBcclxuICAgICAgPyAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qcydcclxuICAgICAgOiAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVVxyXG4gICAgICAgID8gJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQuYXN5bmNpZnkubWpzJ1xyXG4gICAgICAgIDogJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzJztcclxuICAgIGNvbnN0IHdhc21Nb2R1bGVVcmwgPSB1cmxPdmVycmlkZSA/PyBub3JtYWxpemVVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSk7XHJcbiAgICAvLyBuZWVkIHRvIHByZWxvYWQgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gICAgLy8gMS4gbm90IGluIE5vZGUuanMuXHJcbiAgICAvLyAgICAtIE5vZGUuanMgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBvcmlnaW4gcG9saWN5IGZvciBjcmVhdGluZyB3b3JrZXJzLlxyXG4gICAgLy8gMi4gbXVsdGktdGhyZWFkZWQgaXMgZW5hYmxlZC5cclxuICAgIC8vICAgIC0gSWYgbXVsdGktdGhyZWFkZWQgaXMgZGlzYWJsZWQsIG5vIHdvcmtlciB3aWxsIGJlIGNyZWF0ZWQuIFNvIHdlIGRvbid0IG5lZWQgdG8gcHJlbG9hZCB0aGUgbW9kdWxlLlxyXG4gICAgLy8gMy4gdGhlIGFic29sdXRlIFVSTCBpcyBhdmFpbGFibGUuXHJcbiAgICAvLyAgICAtIElmIHRoZSBhYnNvbHV0ZSBVUkwgaXMgZmFpbGVkIHRvIGJlIGNyZWF0ZWQsIHRoZSBvcmlnaW4gY2Fubm90IGJlIGRldGVybWluZWQuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBub3RcclxuICAgIC8vICAgIHByZWxvYWQgdGhlIG1vZHVsZS5cclxuICAgIC8vIDQuIHRoZSB3b3JrZXIgVVJMIGlzIG5vdCBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cclxuICAgIC8vICAgIC0gSWYgdGhlIHdvcmtlciBVUkwgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4sIHdlIGNhbiBjcmVhdGUgdGhlIHdvcmtlciBkaXJlY3RseS5cclxuICAgIGNvbnN0IG5lZWRQcmVsb2FkID0gIWlzTm9kZSAmJiBpc011bHRpVGhyZWFkZWQgJiYgd2FzbU1vZHVsZVVybCAmJiAhaXNTYW1lT3JpZ2luKHdhc21Nb2R1bGVVcmwsIHByZWZpeE92ZXJyaWRlKTtcclxuICAgIGNvbnN0IHVybCA9IG5lZWRQcmVsb2FkXHJcbiAgICAgID8gYXdhaXQgcHJlbG9hZCh3YXNtTW9kdWxlVXJsKVxyXG4gICAgICA6ICh3YXNtTW9kdWxlVXJsID8/IGZhbGxiYWNrVXJsKHdhc21Nb2R1bGVGaWxlbmFtZSwgcHJlZml4T3ZlcnJpZGUpKTtcclxuICAgIHJldHVybiBbbmVlZFByZWxvYWQgPyB1cmwgOiB1bmRlZmluZWQsIGF3YWl0IGR5bmFtaWNJbXBvcnREZWZhdWx0PEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+Pih1cmwpXTtcclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcclxuXHJcbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1vZHVsZSB9IGZyb20gJy4vd2FzbS10eXBlcyc7XHJcbmltcG9ydCB7IGltcG9ydFdhc21Nb2R1bGUsIGluZmVyV2FzbVBhdGhQcmVmaXhGcm9tU2NyaXB0U3JjIH0gZnJvbSAnLi93YXNtLXV0aWxzLWltcG9ydCc7XHJcblxyXG5sZXQgd2FzbTogT3J0V2FzbU1vZHVsZSB8IHVuZGVmaW5lZDtcclxubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XHJcbmxldCBpbml0aWFsaXppbmcgPSBmYWxzZTtcclxubGV0IGFib3J0ZWQgPSBmYWxzZTtcclxuXHJcbmNvbnN0IGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XHJcbiAgLy8gSWYgJ1NoYXJlZEFycmF5QnVmZmVyJyBpcyBub3QgYXZhaWxhYmxlLCBXZWJBc3NlbWJseSB0aHJlYWRzIHdpbGwgbm90IHdvcmsuXHJcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBUZXN0IGZvciB0cmFuc2ZlcmFiaWxpdHkgb2YgU0FCcyAoZm9yIGJyb3dzZXJzLiBuZWVkZWQgZm9yIEZpcmVmb3gpXHJcbiAgICAvLyBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhbXNnL21vemlsbGEuZGV2LnBsYXRmb3JtL0lIa0JabEhFVHBBL2R3c01OY2hXRVFBSlxyXG4gICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSB0aHJlYWRzIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxyXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyB0aHJlYWRlZCBpbnN0cnVjdGlvbnMuXHJcbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUoXHJcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCA1LCA0LCAxLCAzLCAxLCAxLCAxMCwgMTEsIDEsIDksIDAsIDY1LCAwLCAyNTQsIDE2LFxyXG4gICAgICAgIDIsIDAsIDI2LCAxMSxcclxuICAgICAgXSksXHJcbiAgICApO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBpc1NpbWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFRlc3QgZm9yIFdlYkFzc2VtYmx5IFNJTUQgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXHJcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIFNJTUQgaW5zdHJ1Y3Rpb25zLlxyXG5cclxuICAgIC8vIFRoZSBiaW5hcnkgZGF0YSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgZm9sbG93aW5nIGNvZGUgYnkgd2F0Mndhc206XHJcbiAgICAvL1xyXG4gICAgLy8gKG1vZHVsZVxyXG4gICAgLy8gICAodHlwZSAkdDAgKGZ1bmMpKVxyXG4gICAgLy8gICAoZnVuYyAkZjAgKHR5cGUgJHQwKVxyXG4gICAgLy8gICAgIChkcm9wXHJcbiAgICAvLyAgICAgICAoaTMyeDQuZG90X2kxNng4X3NcclxuICAgIC8vICAgICAgICAgKGk4eDE2LnNwbGF0XHJcbiAgICAvLyAgICAgICAgICAgKGkzMi5jb25zdCAwKSlcclxuICAgIC8vICAgICAgICAgKHYxMjguY29uc3QgaTMyeDQgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDAgMHgwMDAwMDAwMCkpKSkpXHJcblxyXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxyXG4gICAgICBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCA0LCAxLCA5NiwgMCwgMCwgMywgMiwgMSwgMCwgMTAsIDMwLCAxLCAyOCwgMCwgNjUsIDAsIDI1MywgMTUsIDI1MywgMTIsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjUzLCAxODYsIDEsIDI2LCAxMSxcclxuICAgICAgXSksXHJcbiAgICApO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBpc1JlbGF4ZWRTaW1kU3VwcG9ydGVkID0gKCk6IGJvb2xlYW4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSBSZWxheGVkIFNJTUQgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXHJcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIFJlbGF4ZWQgU0lNRCBpbnN0cnVjdGlvbnMuXHJcblxyXG4gICAgLy8gVGhlIGJpbmFyeSBkYXRhIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBmb2xsb3dpbmcgY29kZSBieSB3YXQyd2FzbTpcclxuICAgIC8vIChtb2R1bGVcclxuICAgIC8vICAgKGZ1bmMgKHJlc3VsdCB2MTI4KVxyXG4gICAgLy8gICAgICBpMzIuY29uc3QgMVxyXG4gICAgLy8gICAgICBpOHgxNi5zcGxhdFxyXG4gICAgLy8gICAgICBpMzIuY29uc3QgMlxyXG4gICAgLy8gICAgICBpOHgxNi5zcGxhdFxyXG4gICAgLy8gICAgICBpMzIuY29uc3QgM1xyXG4gICAgLy8gICAgICBpOHgxNi5zcGxhdFxyXG4gICAgLy8gICAgICBpMzJ4NC5yZWxheGVkX2RvdF9pOHgxNl9pN3gxNl9hZGRfc1xyXG4gICAgLy8gICApXHJcbiAgICAvLyAgKVxyXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxyXG4gICAgICBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCA1LCAxLCA5NiwgMCwgMSwgMTIzLCAzLCAyLCAxLCAwLCAxMCwgMTksIDEsIDE3LCAwLCA2NSwgMSwgMjUzLCAxNSwgNjUsIDIsIDI1MyxcclxuICAgICAgICAxNSwgNjUsIDMsIDI1MywgMTUsIDI1MywgMTQ3LCAyLCAxMSxcclxuICAgICAgXSksXHJcbiAgICApO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5ID0gYXN5bmMgKGZsYWdzOiBFbnYuV2ViQXNzZW1ibHlGbGFncyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGlmIChpbml0aWFsaXplZCkge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH1cclxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtcclxuICB9XHJcbiAgaWYgKGFib3J0ZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO1xyXG4gIH1cclxuXHJcbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcclxuXHJcbiAgLy8gd2FzbSBmbGFncyBhcmUgYWxyZWFkeSBpbml0aWFsaXplZFxyXG4gIGNvbnN0IHRpbWVvdXQgPSBmbGFncy5pbml0VGltZW91dCE7XHJcbiAgbGV0IG51bVRocmVhZHMgPSBmbGFncy5udW1UaHJlYWRzITtcclxuXHJcbiAgLy8gZW5zdXJlIFNJTUQgaXMgc3VwcG9ydGVkXHJcbiAgaWYgKGZsYWdzLnNpbWQgPT09IGZhbHNlKSB7XHJcbiAgICAvLyBza2lwIFNJTUQgZmVhdHVyZSBjaGVja2luZyBhcyBpdCBpcyBkaXNhYmxlZCBleHBsaWNpdGx5IGJ5IHVzZXJcclxuICB9IGVsc2UgaWYgKGZsYWdzLnNpbWQgPT09ICdyZWxheGVkJykge1xyXG4gICAgLy8gY2hlY2sgaWYgcmVsYXhlZCBTSU1EIGlzIHN1cHBvcnRlZFxyXG4gICAgaWYgKCFpc1JlbGF4ZWRTaW1kU3VwcG9ydGVkKCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWxheGVkIFdlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4nKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKCFpc1NpbWRTdXBwb3J0ZWQoKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuJyk7XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBpZiBtdWx0aS10aHJlYWRpbmcgaXMgc3VwcG9ydGVkXHJcbiAgY29uc3QgbXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSBpc011bHRpVGhyZWFkU3VwcG9ydGVkKCk7XHJcbiAgaWYgKG51bVRocmVhZHMgPiAxICYmICFtdWx0aVRocmVhZFN1cHBvcnRlZCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAnZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gJyArXHJcbiAgICAgICAgICBudW1UaHJlYWRzICtcclxuICAgICAgICAgICcsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiAnICtcclxuICAgICAgICAgICdTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uJyxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgY29uc29sZS53YXJuKFxyXG4gICAgICAnV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICcgKyAnRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuJyxcclxuICAgICk7XHJcblxyXG4gICAgLy8gc2V0IGZsYWdzLm51bVRocmVhZHMgdG8gMSBzbyB0aGF0IE9ydEluaXQoKSB3aWxsIG5vdCBjcmVhdGUgYSBnbG9iYWwgdGhyZWFkIHBvb2wuXHJcbiAgICBmbGFncy5udW1UaHJlYWRzID0gbnVtVGhyZWFkcyA9IDE7XHJcbiAgfVxyXG5cclxuICBjb25zdCB3YXNtUGF0aHMgPSBmbGFncy53YXNtUGF0aHM7XHJcbiAgY29uc3Qgd2FzbVByZWZpeE92ZXJyaWRlID0gdHlwZW9mIHdhc21QYXRocyA9PT0gJ3N0cmluZycgPyB3YXNtUGF0aHMgOiB1bmRlZmluZWQ7XHJcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy5tanM7XHJcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlID0gKG1qc1BhdGhPdmVycmlkZUZsYWcgYXMgVVJMKT8uaHJlZiA/PyBtanNQYXRoT3ZlcnJpZGVGbGFnO1xyXG4gIGNvbnN0IHdhc21QYXRoT3ZlcnJpZGVGbGFnID0gKHdhc21QYXRocyBhcyBFbnYuV2FzbUZpbGVQYXRocyk/Lndhc207XHJcbiAgY29uc3Qgd2FzbVBhdGhPdmVycmlkZSA9ICh3YXNtUGF0aE92ZXJyaWRlRmxhZyBhcyBVUkwpPy5ocmVmID8/IHdhc21QYXRoT3ZlcnJpZGVGbGFnO1xyXG4gIGNvbnN0IHdhc21CaW5hcnlPdmVycmlkZSA9IGZsYWdzLndhc21CaW5hcnk7XHJcblxyXG4gIGNvbnN0IFtvYmplY3RVcmwsIG9ydFdhc21GYWN0b3J5XSA9IGF3YWl0IGltcG9ydFdhc21Nb2R1bGUoXHJcbiAgICBtanNQYXRoT3ZlcnJpZGUsXHJcbiAgICB3YXNtUHJlZml4T3ZlcnJpZGUsXHJcbiAgICBudW1UaHJlYWRzID4gMSxcclxuICAgICEhd2FzbUJpbmFyeU92ZXJyaWRlIHx8ICEhd2FzbVBhdGhPdmVycmlkZSxcclxuICApO1xyXG5cclxuICBsZXQgaXNUaW1lb3V0ID0gZmFsc2U7XHJcblxyXG4gIGNvbnN0IHRhc2tzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IFtdO1xyXG5cclxuICAvLyBwcm9taXNlIGZvciB0aW1lb3V0XHJcbiAgaWYgKHRpbWVvdXQgPiAwKSB7XHJcbiAgICB0YXNrcy5wdXNoKFxyXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgaXNUaW1lb3V0ID0gdHJ1ZTtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gcHJvbWlzZSBmb3IgbW9kdWxlIGluaXRpYWxpemF0aW9uXHJcbiAgdGFza3MucHVzaChcclxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgY29uZmlnOiBQYXJ0aWFsPE9ydFdhc21Nb2R1bGU+ID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGhyZWFkcy4gV2ViQXNzZW1ibHkgd2lsbCBjcmVhdGUgKE1vZHVsZS5udW1UaHJlYWRzIC0gMSkgd29ya2Vycy4gSWYgaXQgaXMgMSwgbm8gd29ya2VyIHdpbGwgYmVcclxuICAgICAgICAgKiBjcmVhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG51bVRocmVhZHMsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAod2FzbUJpbmFyeU92ZXJyaWRlKSB7XHJcbiAgICAgICAgLy8gU2V0IGEgY3VzdG9tIGJ1ZmZlciB3aGljaCBjb250YWlucyB0aGUgV2ViQXNzZW1ibHkgYmluYXJ5LiBUaGlzIHdpbGwgc2tpcCB0aGUgd2FzbSBmaWxlIGZldGNoaW5nLlxyXG4gICAgICAgIGNvbmZpZy53YXNtQmluYXJ5ID0gd2FzbUJpbmFyeU92ZXJyaWRlO1xyXG4gICAgICB9IGVsc2UgaWYgKHdhc21QYXRoT3ZlcnJpZGUgfHwgd2FzbVByZWZpeE92ZXJyaWRlKSB7XHJcbiAgICAgICAgLy8gQSBjYWxsYmFjayBmdW5jdGlvbiB0byBsb2NhdGUgdGhlIFdlYkFzc2VtYmx5IGZpbGUuIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRoZSBmdWxsIHBhdGggb2YgdGhlIGZpbGUuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBTaW5jZSBFbXNjcmlwdGVuIDMuMS41OCwgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgdGhlIC53YXNtIGZpbGUuXHJcbiAgICAgICAgY29uZmlnLmxvY2F0ZUZpbGUgPSAoZmlsZU5hbWUpID0+IHdhc21QYXRoT3ZlcnJpZGUgPz8gd2FzbVByZWZpeE92ZXJyaWRlICsgZmlsZU5hbWU7XHJcbiAgICAgIH0gZWxzZSBpZiAobWpzUGF0aE92ZXJyaWRlICYmIG1qc1BhdGhPdmVycmlkZS5pbmRleE9mKCdibG9iOicpICE9PSAwKSB7XHJcbiAgICAgICAgLy8gaWYgbWpzIHBhdGggaXMgc3BlY2lmaWVkLCB1c2UgaXQgYXMgdGhlIGJhc2UgcGF0aCBmb3IgdGhlIC53YXNtIGZpbGUuXHJcbiAgICAgICAgY29uZmlnLmxvY2F0ZUZpbGUgPSAoZmlsZU5hbWUpID0+IG5ldyBVUkwoZmlsZU5hbWUsIG1qc1BhdGhPdmVycmlkZSkuaHJlZjtcclxuICAgICAgfSBlbHNlIGlmIChvYmplY3RVcmwpIHtcclxuICAgICAgICBjb25zdCBpbmZlcnJlZFdhc21QYXRoUHJlZml4ID0gaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMoKTtcclxuICAgICAgICBpZiAoaW5mZXJyZWRXYXNtUGF0aFByZWZpeCkge1xyXG4gICAgICAgICAgLy8gaWYgdGhlIHdhc20gbW9kdWxlIGlzIHByZWxvYWRlZCwgdXNlIHRoZSBpbmZlcnJlZCB3YXNtIHBhdGggYXMgdGhlIGJhc2UgcGF0aCBmb3IgdGhlIC53YXNtIGZpbGUuXHJcbiAgICAgICAgICBjb25maWcubG9jYXRlRmlsZSA9IChmaWxlTmFtZSkgPT4gaW5mZXJyZWRXYXNtUGF0aFByZWZpeCArIGZpbGVOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgb3J0V2FzbUZhY3RvcnkoY29uZmlnKS50aGVuKFxyXG4gICAgICAgIC8vIHdhc20gbW9kdWxlIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVxyXG4gICAgICAgIChtb2R1bGUpID0+IHtcclxuICAgICAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgd2FzbSA9IG1vZHVsZTtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgIGlmIChvYmplY3RVcmwpIHtcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgZmFpbGVkIHRvIGluaXRpYWxpemVcclxuICAgICAgICAod2hhdCkgPT4ge1xyXG4gICAgICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHJlamVjdCh3aGF0KTtcclxuICAgICAgICB9LFxyXG4gICAgICApO1xyXG4gICAgfSksXHJcbiAgKTtcclxuXHJcbiAgYXdhaXQgUHJvbWlzZS5yYWNlKHRhc2tzKTtcclxuXHJcbiAgaWYgKGlzVGltZW91dCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dGltZW91dH1tc2ApO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRJbnN0YW5jZSA9ICgpOiBPcnRXYXNtTW9kdWxlID0+IHtcclxuICBpZiAoaW5pdGlhbGl6ZWQgJiYgd2FzbSkge1xyXG4gICAgcmV0dXJuIHdhc207XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGlzcG9zZSA9ICgpOiB2b2lkID0+IHtcclxuICBpZiAoaW5pdGlhbGl6ZWQgJiYgIWluaXRpYWxpemluZyAmJiAhYWJvcnRlZCkge1xyXG4gICAgLy8gVE9ETzogY3VycmVudGx5IFwiUFRocmVhZC50ZXJtaW5hdGVBbGxUaHJlYWRzKClcIiBpcyBub3QgZXhwb3NlZCBpbiB0aGUgd2FzbSBtb2R1bGUuXHJcbiAgICAvLyAgICAgICBBbmQgdGhpcyBmdW5jdGlvbiBpcyBub3QgeWV0IGNhbGxlZCBieSBhbnkgY29kZS5cclxuICAgIC8vICAgICAgIElmIGl0IGlzIG5lZWRlZCBpbiB0aGUgZnV0dXJlLCB3ZSBzaG91bGQgZXhwb3NlIGl0IGluIHRoZSB3YXNtIG1vZHVsZSBhbmQgdW5jb21tZW50IHRoZSBmb2xsb3dpbmcgbGluZS5cclxuXHJcbiAgICAvLyB3YXNtPy5QVGhyZWFkPy50ZXJtaW5hdGVBbGxUaHJlYWRzKCk7XHJcbiAgICB3YXNtID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIGFib3J0ZWQgPSB0cnVlO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcclxuXHJcbmV4cG9ydCBjb25zdCBhbGxvY1dhc21TdHJpbmcgPSAoZGF0YTogc3RyaW5nLCBhbGxvY3M6IG51bWJlcltdKTogbnVtYmVyID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuXHJcbiAgY29uc3QgZGF0YUxlbmd0aCA9IHdhc20ubGVuZ3RoQnl0ZXNVVEY4KGRhdGEpICsgMTtcclxuICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFMZW5ndGgpO1xyXG4gIHdhc20uc3RyaW5nVG9VVEY4KGRhdGEsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xyXG4gIGFsbG9jcy5wdXNoKGRhdGFPZmZzZXQpO1xyXG5cclxuICByZXR1cm4gZGF0YU9mZnNldDtcclxufTtcclxuXHJcbmludGVyZmFjZSBFeHRyYU9wdGlvbnNIYW5kbGVyIHtcclxuICAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGl0ZXJhdGVFeHRyYU9wdGlvbnMgPSAoXHJcbiAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXHJcbiAgcHJlZml4OiBzdHJpbmcsXHJcbiAgc2VlbjogV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4sXHJcbiAgaGFuZGxlcjogRXh0cmFPcHRpb25zSGFuZGxlcixcclxuKTogdm9pZCA9PiB7XHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcclxuICAgIGlmIChzZWVuLmhhcyhvcHRpb25zKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZWVuLmFkZChvcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgY29uc3QgbmFtZSA9IHByZWZpeCA/IHByZWZpeCArIGtleSA6IGtleTtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnModmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIG5hbWUgKyAnLicsIHNlZW4sIGhhbmRsZXIpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZSA/ICcxJyA6ICcwJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgdmFsdWV9YCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogY2hlY2sgd2ViIGFzc2VtYmx5IEFQSSdzIGxhc3QgZXJyb3IgYW5kIHRocm93IGVycm9yIGlmIGFueSBlcnJvciBvY2N1cnJlZC5cclxuICogQHBhcmFtIG1lc3NhZ2UgYSBtZXNzYWdlIHVzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjaGVja0xhc3RFcnJvciA9IChtZXNzYWdlOiBzdHJpbmcpOiB2b2lkID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuXHJcbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcclxuICAgIGNvbnN0IHBhcmFtc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYygyICogcHRyU2l6ZSk7XHJcbiAgICB3YXNtLl9PcnRHZXRMYXN0RXJyb3IocGFyYW1zT2Zmc2V0LCBwYXJhbXNPZmZzZXQgKyBwdHJTaXplKTtcclxuICAgIGNvbnN0IGVycm9yQ29kZSA9IE51bWJlcih3YXNtLmdldFZhbHVlKHBhcmFtc09mZnNldCwgcHRyU2l6ZSA9PT0gNCA/ICdpMzInIDogJ2k2NCcpKTtcclxuICAgIGNvbnN0IGVycm9yTWVzc2FnZVBvaW50ZXIgPSB3YXNtLmdldFZhbHVlKHBhcmFtc09mZnNldCArIHB0clNpemUsICcqJyk7XHJcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2VQb2ludGVyID8gd2FzbS5VVEY4VG9TdHJpbmcoZXJyb3JNZXNzYWdlUG9pbnRlcikgOiAnJztcclxuICAgIHRocm93IG5ldyBFcnJvcihgJHttZXNzYWdlfSBFUlJPUl9DT0RFOiAke2Vycm9yQ29kZX0sIEVSUk9SX01FU1NBR0U6ICR7ZXJyb3JNZXNzYWdlfWApO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XHJcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnMgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNldFJ1bk9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XHJcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICBjb25zdCBydW5PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB0cnkge1xyXG4gICAgaWYgKG9wdGlvbnM/LmxvZ1NldmVyaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBydW5PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPSAyOyAvLyBEZWZhdWx0IHRvIHdhcm5pbmdcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIHR5cGVvZiBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCkgfHxcclxuICAgICAgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsIDwgMCB8fFxyXG4gICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPiA0XHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2V2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucz8ubG9nVmVyYm9zaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID0gMDsgLy8gRGVmYXVsdCB0byAwXHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWx9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnM/LnRlcm1pbmF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJ1bk9wdGlvbnMudGVybWluYXRlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRhZ0RhdGFPZmZzZXQgPSAwO1xyXG4gICAgaWYgKG9wdGlvbnM/LnRhZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRhZ0RhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcob3B0aW9ucy50YWcsIGFsbG9jcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcnVuT3B0aW9uc0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZVJ1bk9wdGlvbnMoXHJcbiAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCEsXHJcbiAgICAgIHJ1bk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwhLFxyXG4gICAgICAhIXJ1bk9wdGlvbnMudGVybWluYXRlISxcclxuICAgICAgdGFnRGF0YU9mZnNldCxcclxuICAgICk7XHJcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSA9PT0gMCkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnM/LmV4dHJhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyhvcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xyXG5cclxuICAgICAgICBpZiAod2FzbS5fT3J0QWRkUnVuQ29uZmlnRW50cnkocnVuT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xyXG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtydW5PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmIChydW5PcHRpb25zSGFuZGxlICE9PSAwKSB7XHJcbiAgICAgIHdhc20uX09ydFJlbGVhc2VSdW5PcHRpb25zKHJ1bk9wdGlvbnNIYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XHJcbiAgICB0aHJvdyBlO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgdHlwZSB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XHJcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnMgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xyXG5cclxuY29uc3QgZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsID0gKGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw6IHN0cmluZyB8IHVua25vd24pOiBudW1iZXIgPT4ge1xyXG4gIHN3aXRjaCAoZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCkge1xyXG4gICAgY2FzZSAnZGlzYWJsZWQnOlxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGNhc2UgJ2Jhc2ljJzpcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICBjYXNlICdleHRlbmRlZCc6XHJcbiAgICAgIHJldHVybiAyO1xyXG4gICAgY2FzZSAnbGF5b3V0JzpcclxuICAgICAgcmV0dXJuIDM7XHJcbiAgICBjYXNlICdhbGwnOlxyXG4gICAgICByZXR1cm4gOTk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtncmFwaE9wdGltaXphdGlvbkxldmVsfWApO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGdldEV4ZWN1dGlvbk1vZGUgPSAoZXhlY3V0aW9uTW9kZTogJ3NlcXVlbnRpYWwnIHwgJ3BhcmFsbGVsJyk6IG51bWJlciA9PiB7XHJcbiAgc3dpdGNoIChleGVjdXRpb25Nb2RlKSB7XHJcbiAgICBjYXNlICdzZXF1ZW50aWFsJzpcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICBjYXNlICdwYXJhbGxlbCc6XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtleGVjdXRpb25Nb2RlfWApO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGFwcGVuZERlZmF1bHRPcHRpb25zID0gKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiB2b2lkID0+IHtcclxuICBpZiAoIW9wdGlvbnMuZXh0cmEpIHtcclxuICAgIG9wdGlvbnMuZXh0cmEgPSB7fTtcclxuICB9XHJcbiAgaWYgKCFvcHRpb25zLmV4dHJhLnNlc3Npb24pIHtcclxuICAgIG9wdGlvbnMuZXh0cmEuc2Vzc2lvbiA9IHt9O1xyXG4gIH1cclxuICBjb25zdCBzZXNzaW9uID0gb3B0aW9ucy5leHRyYS5zZXNzaW9uIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbiAgaWYgKCFzZXNzaW9uLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcclxuICAgIHNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSA9ICcxJztcclxuICB9XHJcblxyXG4gIC8vIGlmIHVzaW5nIEpTRVAgd2l0aCBXZWJHUFUsIGFsd2F5cyBkaXNhYmxlIG1lbW9yeSBwYXR0ZXJuXHJcbiAgaWYgKFxyXG4gICAgb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgJiZcclxuICAgIG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUoKGVwKSA9PiAodHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZSkgPT09ICd3ZWJncHUnKVxyXG4gICkge1xyXG4gICAgb3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuID0gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgYXBwZW5kU2Vzc2lvbkNvbmZpZyA9IChzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLCBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgYWxsb2NzOiBudW1iZXJbXSk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoa2V5LCBhbGxvY3MpO1xyXG4gIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcclxuICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XHJcbiAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGFwcGVuZEVwT3B0aW9uID0gKGVwT3B0aW9uczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4sIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBhbGxvY3M6IG51bWJlcltdKTogdm9pZCA9PiB7XHJcbiAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XHJcbiAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xyXG4gIGVwT3B0aW9ucy5wdXNoKFtrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXRdKTtcclxufTtcclxuXHJcbmNvbnN0IHNldEV4ZWN1dGlvblByb3ZpZGVycyA9IGFzeW5jIChcclxuICBzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLFxyXG4gIGV4ZWN1dGlvblByb3ZpZGVyczogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5FeGVjdXRpb25Qcm92aWRlckNvbmZpZ1tdLFxyXG4gIGFsbG9jczogbnVtYmVyW10sXHJcbik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGZvciAoY29uc3QgZXAgb2YgZXhlY3V0aW9uUHJvdmlkZXJzKSB7XHJcbiAgICBsZXQgZXBOYW1lID0gdHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZTtcclxuICAgIGNvbnN0IGVwT3B0aW9uczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcclxuXHJcbiAgICAvLyBjaGVjayBFUCBuYW1lXHJcbiAgICBzd2l0Y2ggKGVwTmFtZSkge1xyXG4gICAgICBjYXNlICd3ZWJubic6XHJcbiAgICAgICAgZXBOYW1lID0gJ1dFQk5OJztcclxuICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gZXAgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xyXG4gICAgICAgICAgLy8gY29uc3QgY29udGV4dCA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0KT8uY29udGV4dDtcclxuICAgICAgICAgIGNvbnN0IGRldmljZVR5cGUgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LmRldmljZVR5cGU7XHJcbiAgICAgICAgICBpZiAoZGV2aWNlVHlwZSkge1xyXG4gICAgICAgICAgICBhcHBlbmRTZXNzaW9uQ29uZmlnKHNlc3Npb25PcHRpb25zSGFuZGxlLCAnZGV2aWNlVHlwZScsIGRldmljZVR5cGUsIGFsbG9jcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd3ZWJncHUnOlxyXG4gICAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xyXG4gICAgICAgICAgZXBOYW1lID0gJ1dlYkdQVSc7XHJcbiAgICAgICAgICBsZXQgY3VzdG9tRGV2aWNlOiBHUFVEZXZpY2UgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VzdG9tT3B0aW9ucyA9IGVwIGFzIHVua25vd24gYXMgeyBkZXZpY2U6IEdQVURldmljZSB9O1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tT3B0aW9ucy5kZXZpY2UpIHtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIEdQVURldmljZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY3VzdG9tT3B0aW9ucy5kZXZpY2UgaW5zdGFuY2VvZiBHUFVEZXZpY2UpIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbURldmljZSA9IGN1c3RvbU9wdGlvbnMuZGV2aWNlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR1BVIGRldmljZSBzZXQgaW4gV2ViR1BVIEVQIG9wdGlvbnMuJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbW9yZSBvcHRpb25zXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgaW5mbyA9IGdldEluc3RhbmNlKCkud2ViZ3B1UmVnaXN0ZXJEZXZpY2UhKGN1c3RvbURldmljZSk7XHJcbiAgICAgICAgICBpZiAoaW5mbykge1xyXG4gICAgICAgICAgICBjb25zdCBbZGV2aWNlSWQsIGluc3RhbmNlSGFuZGxlLCBkZXZpY2VIYW5kbGVdID0gaW5mbztcclxuICAgICAgICAgICAgYXBwZW5kRXBPcHRpb24oZXBPcHRpb25zLCAnZGV2aWNlSWQnLCBkZXZpY2VJZC50b1N0cmluZygpLCBhbGxvY3MpO1xyXG4gICAgICAgICAgICBhcHBlbmRFcE9wdGlvbihlcE9wdGlvbnMsICd3ZWJncHVJbnN0YW5jZScsIGluc3RhbmNlSGFuZGxlLnRvU3RyaW5nKCksIGFsbG9jcyk7XHJcbiAgICAgICAgICAgIGFwcGVuZEVwT3B0aW9uKGVwT3B0aW9ucywgJ3dlYmdwdURldmljZScsIGRldmljZUhhbmRsZS50b1N0cmluZygpLCBhbGxvY3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlcE5hbWUgPSAnSlMnO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3Qgd2ViZ3B1T3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICAgICAgICAgIGlmICh3ZWJncHVPcHRpb25zPy5wcmVmZXJyZWRMYXlvdXQpIHtcclxuICAgICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOQ0hXJyAmJiB3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCAhPT0gJ05IV0MnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke3dlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0fWApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBhcHBlbmRTZXNzaW9uQ29uZmlnKHNlc3Npb25PcHRpb25zSGFuZGxlLCAncHJlZmVycmVkTGF5b3V0Jywgd2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQsIGFsbG9jcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3dhc20nOlxyXG4gICAgICBjYXNlICdjcHUnOlxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZXBOYW1lfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGVwTmFtZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZXBOYW1lLCBhbGxvY3MpO1xyXG4gICAgY29uc3QgZXBPcHRpb25zQ291bnQgPSBlcE9wdGlvbnMubGVuZ3RoO1xyXG4gICAgbGV0IGtleXNPZmZzZXQgPSAwO1xyXG4gICAgbGV0IHZhbHVlc09mZnNldCA9IDA7XHJcbiAgICBpZiAoZXBPcHRpb25zQ291bnQgPiAwKSB7XHJcbiAgICAgIGtleXNPZmZzZXQgPSBnZXRJbnN0YW5jZSgpLl9tYWxsb2MoZXBPcHRpb25zQ291bnQgKiBnZXRJbnN0YW5jZSgpLlBUUl9TSVpFKTtcclxuICAgICAgYWxsb2NzLnB1c2goa2V5c09mZnNldCk7XHJcbiAgICAgIHZhbHVlc09mZnNldCA9IGdldEluc3RhbmNlKCkuX21hbGxvYyhlcE9wdGlvbnNDb3VudCAqIGdldEluc3RhbmNlKCkuUFRSX1NJWkUpO1xyXG4gICAgICBhbGxvY3MucHVzaCh2YWx1ZXNPZmZzZXQpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVwT3B0aW9uc0NvdW50OyBpKyspIHtcclxuICAgICAgICBnZXRJbnN0YW5jZSgpLnNldFZhbHVlKGtleXNPZmZzZXQgKyBpICogZ2V0SW5zdGFuY2UoKS5QVFJfU0laRSwgZXBPcHRpb25zW2ldWzBdLCAnKicpO1xyXG4gICAgICAgIGdldEluc3RhbmNlKCkuc2V0VmFsdWUodmFsdWVzT2Zmc2V0ICsgaSAqIGdldEluc3RhbmNlKCkuUFRSX1NJWkUsIGVwT3B0aW9uc1tpXVsxXSwgJyonKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKFxyXG4gICAgICAoYXdhaXQgZ2V0SW5zdGFuY2UoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoXHJcbiAgICAgICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUsXHJcbiAgICAgICAgZXBOYW1lRGF0YU9mZnNldCxcclxuICAgICAgICBrZXlzT2Zmc2V0LFxyXG4gICAgICAgIHZhbHVlc09mZnNldCxcclxuICAgICAgICBlcE9wdGlvbnNDb3VudCxcclxuICAgICAgKSkgIT09IDBcclxuICAgICkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlcE5hbWV9LmApO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzZXRTZXNzaW9uT3B0aW9ucyA9IGFzeW5jIChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8W251bWJlciwgbnVtYmVyW11dPiA9PiB7XHJcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XHJcbiAgbGV0IHNlc3Npb25PcHRpb25zSGFuZGxlID0gMDtcclxuICBjb25zdCBhbGxvY3M6IG51bWJlcltdID0gW107XHJcblxyXG4gIGNvbnN0IHNlc3Npb25PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBhcHBlbmREZWZhdWx0T3B0aW9ucyhzZXNzaW9uT3B0aW9ucyk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBncmFwaE9wdGltaXphdGlvbkxldmVsID0gZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsKHNlc3Npb25PcHRpb25zLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPz8gJ2FsbCcpO1xyXG4gICAgY29uc3QgZXhlY3V0aW9uTW9kZSA9IGdldEV4ZWN1dGlvbk1vZGUoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uTW9kZSA/PyAnc2VxdWVudGlhbCcpO1xyXG4gICAgY29uc3QgbG9nSWREYXRhT2Zmc2V0ID1cclxuICAgICAgdHlwZW9mIHNlc3Npb25PcHRpb25zLmxvZ0lkID09PSAnc3RyaW5nJyA/IGFsbG9jV2FzbVN0cmluZyhzZXNzaW9uT3B0aW9ucy5sb2dJZCwgYWxsb2NzKSA6IDA7XHJcblxyXG4gICAgY29uc3QgbG9nU2V2ZXJpdHlMZXZlbCA9IHNlc3Npb25PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPz8gMjsgLy8gRGVmYXVsdCB0byAyIC0gd2FybmluZ1xyXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1NldmVyaXR5TGV2ZWwpIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPiA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHNldmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtsb2dTZXZlcml0eUxldmVsfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxvZ1ZlcmJvc2l0eUxldmVsID0gc2Vzc2lvbk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgPz8gMDsgLy8gRGVmYXVsdCB0byAwIC0gdmVyYm9zZVxyXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1ZlcmJvc2l0eUxldmVsKSB8fCBsb2dWZXJib3NpdHlMZXZlbCA8IDAgfHwgbG9nVmVyYm9zaXR5TGV2ZWwgPiA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bG9nVmVyYm9zaXR5TGV2ZWx9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCA9XHJcbiAgICAgIHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoID09PSAnc3RyaW5nJ1xyXG4gICAgICAgID8gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsIGFsbG9jcylcclxuICAgICAgICA6IDA7XHJcblxyXG4gICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhcclxuICAgICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCxcclxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVDcHVNZW1BcmVuYSxcclxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuLFxyXG4gICAgICBleGVjdXRpb25Nb2RlLFxyXG4gICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZVByb2ZpbGluZyxcclxuICAgICAgMCxcclxuICAgICAgbG9nSWREYXRhT2Zmc2V0LFxyXG4gICAgICBsb2dTZXZlcml0eUxldmVsLFxyXG4gICAgICBsb2dWZXJib3NpdHlMZXZlbCxcclxuICAgICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCxcclxuICAgICk7XHJcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPT09IDApIHtcclxuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzKSB7XHJcbiAgICAgIGF3YWl0IHNldEV4ZWN1dGlvblByb3ZpZGVycyhzZXNzaW9uT3B0aW9uc0hhbmRsZSwgc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLCBhbGxvY3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAodHlwZW9mIHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZSAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7c2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlfWApO1xyXG4gICAgICB9XHJcbiAgICAgIGFwcGVuZFNlc3Npb25Db25maWcoXHJcbiAgICAgICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUsXHJcbiAgICAgICAgJ2VuYWJsZUdyYXBoQ2FwdHVyZScsXHJcbiAgICAgICAgc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgYWxsb2NzLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke25hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3ZhbHVlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuYW1lT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKG5hbWUsIGFsbG9jcyk7XHJcbiAgICAgICAgaWYgKHdhc20uX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShzZXNzaW9uT3B0aW9uc0hhbmRsZSwgbmFtZU9mZnNldCwgdmFsdWUpICE9PSAwKSB7XHJcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7bmFtZX0gLSAke3ZhbHVlfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXh0cmEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHNlc3Npb25PcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgYXBwZW5kU2Vzc2lvbkNvbmZpZyhzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5LCB2YWx1ZSwgYWxsb2NzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcclxuICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSkgIT09IDApIHtcclxuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XHJcbiAgICB0aHJvdyBlO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuLy8gYSBkdW1teSB0eXBlIGRlY2xhcmF0aW9uIGZvciBGbG9hdDE2QXJyYXkgaW4gY2FzZSBhbnkgcG9seWZpbGwgaXMgYXZhaWxhYmxlLlxyXG5kZWNsYXJlIGdsb2JhbCB7XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gIGNvbnN0IEZsb2F0MTZBcnJheTogYW55O1xyXG59XHJcblxyXG4vLyBUaGlzIGZpbGUgaW5jbHVkZXMgY29tbW9uIGRlZmluaXRpb25zLiBUaGV5IGRvIE5PVCBoYXZlIGRlcGVuZGVuY3kgb24gdGhlIFdlYkFzc2VtYmx5IGluc3RhbmNlLlxyXG5cclxuLyoqXHJcbiAqIENvcGllZCBmcm9tIE9OTlggZGVmaW5pdGlvbi4gVXNlIHRoaXMgdG8gZHJvcCBkZXBlbmRlbmN5ICdvbm54X3Byb3RvJyB0byBkZWNyZWFzZSBjb21waWxlZCAuanMgZmlsZSBzaXplLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVudW0gRGF0YVR5cGUge1xyXG4gIHVuZGVmaW5lZCA9IDAsXHJcbiAgZmxvYXQgPSAxLFxyXG4gIHVpbnQ4ID0gMixcclxuICBpbnQ4ID0gMyxcclxuICB1aW50MTYgPSA0LFxyXG4gIGludDE2ID0gNSxcclxuICBpbnQzMiA9IDYsXHJcbiAgaW50NjQgPSA3LFxyXG4gIHN0cmluZyA9IDgsXHJcbiAgYm9vbCA9IDksXHJcbiAgZmxvYXQxNiA9IDEwLFxyXG4gIGRvdWJsZSA9IDExLFxyXG4gIHVpbnQzMiA9IDEyLFxyXG4gIHVpbnQ2NCA9IDEzLFxyXG4gIGNvbXBsZXg2NCA9IDE0LFxyXG4gIGNvbXBsZXgxMjggPSAxNSxcclxuICBiZmxvYXQxNiA9IDE2LFxyXG5cclxuICAvLyA0LWJpdCBkYXRhLXR5cGVzXHJcbiAgdWludDQgPSAyMSxcclxuICBpbnQ0ID0gMjIsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXAgc3RyaW5nIHRlbnNvciBkYXRhIHRvIGVudW0gdmFsdWVcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSA9ICh0eXBlOiBzdHJpbmcpOiBEYXRhVHlwZSA9PiB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICdpbnQ4JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDg7XHJcbiAgICBjYXNlICd1aW50OCc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50ODtcclxuICAgIGNhc2UgJ2Jvb2wnOlxyXG4gICAgICByZXR1cm4gRGF0YVR5cGUuYm9vbDtcclxuICAgIGNhc2UgJ2ludDE2JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDE2O1xyXG4gICAgY2FzZSAndWludDE2JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQxNjtcclxuICAgIGNhc2UgJ2ludDMyJzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDMyO1xyXG4gICAgY2FzZSAndWludDMyJzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQzMjtcclxuICAgIGNhc2UgJ2Zsb2F0MTYnOlxyXG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQxNjtcclxuICAgIGNhc2UgJ2Zsb2F0MzInOlxyXG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQ7XHJcbiAgICBjYXNlICdmbG9hdDY0JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmRvdWJsZTtcclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS5zdHJpbmc7XHJcbiAgICBjYXNlICdpbnQ2NCc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ2NDtcclxuICAgIGNhc2UgJ3VpbnQ2NCc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50NjQ7XHJcbiAgICBjYXNlICdpbnQ0JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDQ7XHJcbiAgICBjYXNlICd1aW50NCc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50NDtcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXAgZW51bSB2YWx1ZSB0byBzdHJpbmcgdGVuc29yIGRhdGFcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyA9ICh0eXBlUHJvdG86IERhdGFUeXBlKTogVGVuc29yLlR5cGUgPT4ge1xyXG4gIHN3aXRjaCAodHlwZVByb3RvKSB7XHJcbiAgICBjYXNlIERhdGFUeXBlLmludDg6XHJcbiAgICAgIHJldHVybiAnaW50OCc7XHJcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ4OlxyXG4gICAgICByZXR1cm4gJ3VpbnQ4JztcclxuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcclxuICAgICAgcmV0dXJuICdib29sJztcclxuICAgIGNhc2UgRGF0YVR5cGUuaW50MTY6XHJcbiAgICAgIHJldHVybiAnaW50MTYnO1xyXG4gICAgY2FzZSBEYXRhVHlwZS51aW50MTY6XHJcbiAgICAgIHJldHVybiAndWludDE2JztcclxuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XHJcbiAgICAgIHJldHVybiAnaW50MzInO1xyXG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XHJcbiAgICAgIHJldHVybiAndWludDMyJztcclxuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcclxuICAgICAgcmV0dXJuICdmbG9hdDE2JztcclxuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XHJcbiAgICAgIHJldHVybiAnZmxvYXQzMic7XHJcbiAgICBjYXNlIERhdGFUeXBlLmRvdWJsZTpcclxuICAgICAgcmV0dXJuICdmbG9hdDY0JztcclxuICAgIGNhc2UgRGF0YVR5cGUuc3RyaW5nOlxyXG4gICAgICByZXR1cm4gJ3N0cmluZyc7XHJcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxyXG4gICAgICByZXR1cm4gJ2ludDY0JztcclxuICAgIGNhc2UgRGF0YVR5cGUudWludDY0OlxyXG4gICAgICByZXR1cm4gJ3VpbnQ2NCc7XHJcbiAgICBjYXNlIERhdGFUeXBlLmludDQ6XHJcbiAgICAgIHJldHVybiAnaW50NCc7XHJcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ0OlxyXG4gICAgICByZXR1cm4gJ3VpbnQ0JztcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlUHJvdG99YCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGdldCB0ZW5zb3Igc2l6ZSBpbiBieXRlcyBieSB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCBkaW1lbnNpb25zXHJcbiAqIEByZXR1cm5zIHNpemUgaW4gaW50ZWdlciBvciB1bmRlZmluZWQgaWYgdGhlIGRhdGEgdHlwZSBpcyBub3Qgc3VwcG9ydGVkXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMgPSAoXHJcbiAgZGF0ZVR5cGU6IG51bWJlcixcclxuICBkaW1zT3JTaXplOiByZWFkb25seSBudW1iZXJbXSB8IG51bWJlcixcclxuKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcclxuICBjb25zdCBlbGVtZW50U2l6ZSA9IFtcclxuICAgIC0xLCAvLyB1bmRlZmluZWQgPSAwXHJcbiAgICA0LCAvLyBmbG9hdCA9IDFcclxuICAgIDEsIC8vIHVpbnQ4ID0gMlxyXG4gICAgMSwgLy8gaW50OCA9IDNcclxuICAgIDIsIC8vIHVpbnQxNiA9IDRcclxuICAgIDIsIC8vIGludDE2ID0gNVxyXG4gICAgNCwgLy8gaW50MzIgPSA2XHJcbiAgICA4LCAvLyBpbnQ2NCA9IDdcclxuICAgIC0xLCAvLyBzdHJpbmcgPSA4XHJcbiAgICAxLCAvLyBib29sID0gOVxyXG4gICAgMiwgLy8gZmxvYXQxNiA9IDEwXHJcbiAgICA4LCAvLyBkb3VibGUgPSAxMVxyXG4gICAgNCwgLy8gdWludDMyID0gMTJcclxuICAgIDgsIC8vIHVpbnQ2NCA9IDEzXHJcbiAgICAtMSwgLy8gY29tcGxleDY0ID0gMTRcclxuICAgIC0xLCAvLyBjb21wbGV4MTI4ID0gMTVcclxuICAgIC0xLCAvLyBiZmxvYXQxNiA9IDE2XHJcbiAgICAtMSwgLy8gRkxPQVQ4RTRNM0ZOID0gMTdcclxuICAgIC0xLCAvLyBGTE9BVDhFNE0zRk5VWiA9IDE4XHJcbiAgICAtMSwgLy8gRkxPQVQ4RTVNMiA9IDE5XHJcbiAgICAtMSwgLy8gRkxPQVQ4RTVNMkZOVVogPSAyMFxyXG4gICAgMC41LCAvLyB1aW50NCA9IDIxXHJcbiAgICAwLjUsIC8vIGludDQgPSAyMlxyXG4gIF1bZGF0ZVR5cGVdO1xyXG5cclxuICBjb25zdCBzaXplID0gdHlwZW9mIGRpbXNPclNpemUgPT09ICdudW1iZXInID8gZGltc09yU2l6ZSA6IGRpbXNPclNpemUucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XHJcbiAgcmV0dXJuIGVsZW1lbnRTaXplID4gMCA/IE1hdGguY2VpbChzaXplICogZWxlbWVudFNpemUpIDogdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGdldCB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciBieSB0aGUgZ2l2ZW4gdGVuc29yIHR5cGVcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IgPSAoXHJcbiAgdHlwZTogVGVuc29yLlR5cGUsXHJcbik6XHJcbiAgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcclxuICB8IEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgQmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvciA9PiB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICdmbG9hdDE2JzpcclxuICAgICAgLy8gYWxsb3cgRmxvYXQxNkFycmF5IHBvbHlmaWxsLlxyXG4gICAgICByZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb20gPyBGbG9hdDE2QXJyYXkgOiBVaW50MTZBcnJheTtcclxuICAgIGNhc2UgJ2Zsb2F0MzInOlxyXG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xyXG4gICAgY2FzZSAndWludDgnOlxyXG4gICAgICByZXR1cm4gVWludDhBcnJheTtcclxuICAgIGNhc2UgJ2ludDgnOlxyXG4gICAgICByZXR1cm4gSW50OEFycmF5O1xyXG4gICAgY2FzZSAndWludDE2JzpcclxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xyXG4gICAgY2FzZSAnaW50MTYnOlxyXG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcclxuICAgIGNhc2UgJ2ludDMyJzpcclxuICAgICAgcmV0dXJuIEludDMyQXJyYXk7XHJcbiAgICBjYXNlICdib29sJzpcclxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XHJcbiAgICBjYXNlICdmbG9hdDY0JzpcclxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcclxuICAgIGNhc2UgJ3VpbnQzMic6XHJcbiAgICAgIHJldHVybiBVaW50MzJBcnJheTtcclxuICAgIGNhc2UgJ2ludDY0JzpcclxuICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XHJcbiAgICBjYXNlICd1aW50NjQnOlxyXG4gICAgICByZXR1cm4gQmlnVWludDY0QXJyYXk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogTWFwIHN0cmluZyBsb2cgbGV2ZWwgdG8gaW50ZWdlciB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxvZ0xldmVsU3RyaW5nVG9FbnVtID0gKGxvZ0xldmVsPzogJ3ZlcmJvc2UnIHwgJ2luZm8nIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJyB8ICdmYXRhbCcpOiBudW1iZXIgPT4ge1xyXG4gIHN3aXRjaCAobG9nTGV2ZWwpIHtcclxuICAgIGNhc2UgJ3ZlcmJvc2UnOlxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGNhc2UgJ2luZm8nOlxyXG4gICAgICByZXR1cm4gMTtcclxuICAgIGNhc2UgJ3dhcm5pbmcnOlxyXG4gICAgICByZXR1cm4gMjtcclxuICAgIGNhc2UgJ2Vycm9yJzpcclxuICAgICAgcmV0dXJuIDM7XHJcbiAgICBjYXNlICdmYXRhbCc6XHJcbiAgICAgIHJldHVybiA0O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2xvZ0xldmVsfWApO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgR1BVIGJ1ZmZlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IHR5cGUgaXMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9PlxyXG4gIHR5cGUgPT09ICdmbG9hdDMyJyB8fFxyXG4gIHR5cGUgPT09ICdmbG9hdDE2JyB8fFxyXG4gIHR5cGUgPT09ICdpbnQzMicgfHxcclxuICB0eXBlID09PSAnaW50NjQnIHx8XHJcbiAgdHlwZSA9PT0gJ3VpbnQzMicgfHxcclxuICB0eXBlID09PSAndWludDgnIHx8XHJcbiAgdHlwZSA9PT0gJ2Jvb2wnIHx8XHJcbiAgdHlwZSA9PT0gJ3VpbnQ0JyB8fFxyXG4gIHR5cGUgPT09ICdpbnQ0JztcclxuXHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgV2ViTk4gTUxUZW5zb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IHR5cGUgaXMgVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzID0+XHJcbiAgdHlwZSA9PT0gJ2Zsb2F0MzInIHx8XHJcbiAgdHlwZSA9PT0gJ2Zsb2F0MTYnIHx8XHJcbiAgdHlwZSA9PT0gJ2ludDMyJyB8fFxyXG4gIHR5cGUgPT09ICdpbnQ2NCcgfHxcclxuICB0eXBlID09PSAndWludDMyJyB8fFxyXG4gIHR5cGUgPT09ICd1aW50NjQnIHx8XHJcbiAgdHlwZSA9PT0gJ2ludDgnIHx8XHJcbiAgdHlwZSA9PT0gJ3VpbnQ4JyB8fFxyXG4gIHR5cGUgPT09ICdib29sJyB8fFxyXG4gIHR5cGUgPT09ICd1aW50NCcgfHxcclxuICB0eXBlID09PSAnaW50NCc7XHJcblxyXG4vKipcclxuICogTWFwIHN0cmluZyBkYXRhIGxvY2F0aW9uIHRvIGludGVnZXIgdmFsdWVcclxuICovXHJcbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0gPSAobG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb24pOiBudW1iZXIgPT4ge1xyXG4gIHN3aXRjaCAobG9jYXRpb24pIHtcclxuICAgIGNhc2UgJ25vbmUnOlxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGNhc2UgJ2NwdSc6XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XHJcbiAgICAgIHJldHVybiAyO1xyXG4gICAgY2FzZSAndGV4dHVyZSc6XHJcbiAgICAgIHJldHVybiAzO1xyXG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XHJcbiAgICAgIHJldHVybiA0O1xyXG4gICAgY2FzZSAnbWwtdGVuc29yJzpcclxuICAgICAgcmV0dXJuIDU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7bG9jYXRpb259YCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hcCBpbnRlZ2VyIGRhdGEgbG9jYXRpb24gdG8gc3RyaW5nIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGF0YUxvY2F0aW9uRW51bVRvU3RyaW5nID0gKGxvY2F0aW9uOiBudW1iZXIpOiBUZW5zb3IuRGF0YUxvY2F0aW9uIHwgdW5kZWZpbmVkID0+XHJcbiAgKFsnbm9uZScsICdjcHUnLCAnY3B1LXBpbm5lZCcsICd0ZXh0dXJlJywgJ2dwdS1idWZmZXInLCAnbWwtdGVuc29yJ10gYXMgY29uc3QpW2xvY2F0aW9uXTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcclxuXHJcbi8qKlxyXG4gKiBMb2FkIGEgZmlsZSBpbnRvIGEgVWludDhBcnJheS5cclxuICpcclxuICogQHBhcmFtIGZpbGUgLSB0aGUgZmlsZSB0byBsb2FkLiBDYW4gYmUgYSBVUkwvcGF0aCwgYSBCbG9iLCBhbiBBcnJheUJ1ZmZlciwgb3IgYSBVaW50OEFycmF5LlxyXG4gKiBAcmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZmlsZSBkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxvYWRGaWxlID0gYXN5bmMgKGZpbGU6IHN0cmluZyB8IEJsb2IgfCBBcnJheUJ1ZmZlckxpa2UgfCBVaW50OEFycmF5KTogUHJvbWlzZTxVaW50OEFycmF5PiA9PiB7XHJcbiAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xyXG4gICAgaWYgKGlzTm9kZSkge1xyXG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBOb2RlLmpzXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyByZWFkRmlsZSB9ID0gcmVxdWlyZSgnbm9kZTpmcy9wcm9taXNlcycpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCByZWFkRmlsZShmaWxlKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZS5jb2RlID09PSAnRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFJykge1xyXG4gICAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBmcy5jcmVhdGVSZWFkU3RyZWFtIGluc3RlYWRcclxuICAgICAgICAgIGNvbnN0IHsgY3JlYXRlUmVhZFN0cmVhbSB9ID0gcmVxdWlyZSgnbm9kZTpmcycpO1xyXG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbShmaWxlKTtcclxuICAgICAgICAgIGNvbnN0IGNodW5rczogVWludDhBcnJheVtdID0gW107XHJcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gbG9hZCBmaWxlIGludG8gQXJyYXlCdWZmZXIgaW4gYnJvd3NlcnNcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlKTtcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2ZpbGV9YCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY29udGVudExlbmd0aEhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpO1xyXG4gICAgICBjb25zdCBmaWxlU2l6ZSA9IGNvbnRlbnRMZW5ndGhIZWFkZXIgPyBwYXJzZUludChjb250ZW50TGVuZ3RoSGVhZGVyLCAxMCkgOiAwO1xyXG4gICAgICBpZiAoZmlsZVNpemUgPCAxMDczNzQxODI0IC8qIDFHQiAqLykge1xyXG4gICAgICAgIC8vIHdoZW4gQ29udGVudC1MZW5ndGggaGVhZGVyIGlzIG5vdCBzZXQsIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGZpbGUgc2l6ZS4gV2UgYXNzdW1lIGl0IGlzIHNtYWxsIGVub3VnaCB0b1xyXG4gICAgICAgIC8vIGxvYWQgaW50byBtZW1vcnkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGZpbGUgaXMgdG9vIGxhcmdlLCB1c2Ugc3RyZWFtIGluc3RlYWRcclxuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2ZpbGV9LCBubyByZXNwb25zZSBib2R5LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xyXG5cclxuICAgICAgICBsZXQgYnVmZmVyO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyB0cnkgdG8gY3JlYXRlIEFycmF5QnVmZmVyIGRpcmVjdGx5XHJcbiAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZmlsZVNpemUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xyXG4gICAgICAgICAgICAvLyB1c2UgV2ViQXNzZW1ibHkgTWVtb3J5IHRvIGFsbG9jYXRlIGxhcmdlciBBcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IE1hdGguY2VpbChmaWxlU2l6ZSAvIDY1NTM2KTtcclxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7IGluaXRpYWw6IHBhZ2VzLCBtYXhpbXVtOiBwYWdlcyB9KS5idWZmZXI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBjaHVua1NpemUgPSB2YWx1ZS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgY2h1bmtTaXplKTtcclxuICAgICAgICAgIGNodW5rLnNldCh2YWx1ZSk7XHJcbiAgICAgICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCBmaWxlU2l6ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBCbG9iKSB7XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpKTtcclxuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICByZXR1cm4gZmlsZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGZpbGUpO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgbG9nTGV2ZWxTdHJpbmdUb0VudW0gfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XHJcblxyXG50eXBlIExvZ0xldmVsID0gTm9uTnVsbGFibGU8RW52Wydsb2dMZXZlbCddPjtcclxudHlwZSBNZXNzYWdlU3RyaW5nID0gc3RyaW5nO1xyXG50eXBlIE1lc3NhZ2VGdW5jdGlvbiA9ICgpID0+IHN0cmluZztcclxudHlwZSBNZXNzYWdlID0gTWVzc2FnZVN0cmluZyB8IE1lc3NhZ2VGdW5jdGlvbjtcclxuXHJcbmNvbnN0IGxvZ0xldmVsUHJlZml4ID0gWydWJywgJ0knLCAnVycsICdFJywgJ0YnXTtcclxuXHJcbmNvbnN0IGRvTG9nID0gKGxldmVsOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQgPT4ge1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgY29uc29sZS5sb2coYFske2xvZ0xldmVsUHJlZml4W2xldmVsXX0sJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSR7bWVzc2FnZX1gKTtcclxufTtcclxuXHJcbmxldCBjb25maWdMb2dMZXZlbDogTG9nTGV2ZWwgfCB1bmRlZmluZWQ7XHJcbmxldCBkZWJ1ZzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuXHJcbmV4cG9ydCBjb25zdCBjb25maWd1cmVMb2dnZXIgPSAoJGNvbmZpZ0xvZ0xldmVsOiBMb2dMZXZlbCwgJGRlYnVnOiBib29sZWFuKTogdm9pZCA9PiB7XHJcbiAgY29uZmlnTG9nTGV2ZWwgPSAkY29uZmlnTG9nTGV2ZWw7XHJcbiAgZGVidWcgPSAkZGVidWc7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBzaW1wbGUgbG9nZ2luZyB1dGlsaXR5IHRvIGxvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBMT0cgPSAobG9nTGV2ZWw6IExvZ0xldmVsLCBtc2c6IE1lc3NhZ2UpOiB2b2lkID0+IHtcclxuICBjb25zdCBtZXNzYWdlTGV2ZWwgPSBsb2dMZXZlbFN0cmluZ1RvRW51bShsb2dMZXZlbCk7XHJcbiAgY29uc3QgY29uZmlnTGV2ZWwgPSBsb2dMZXZlbFN0cmluZ1RvRW51bShjb25maWdMb2dMZXZlbCk7XHJcbiAgaWYgKG1lc3NhZ2VMZXZlbCA+PSBjb25maWdMZXZlbCkge1xyXG4gICAgZG9Mb2cobWVzc2FnZUxldmVsLCB0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nID8gbXNnKCkgOiBtc2cpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIHNpbXBsZSBsb2dnaW5nIHV0aWxpdHkgdG8gbG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlLiBPbmx5IGxvZ3Mgd2hlbiBkZWJ1ZyBpcyBlbmFibGVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IExPR19ERUJVRzogdHlwZW9mIExPRyA9ICguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBMT0c+KSA9PiB7XHJcbiAgaWYgKGRlYnVnKSB7XHJcbiAgICBMT0coLi4uYXJncyk7XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXHJcblxyXG5leHBvcnQgY2xhc3MgTWF0TXVsVXRpbCB7XHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSB3aGVuIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxyXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xyXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xyXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGNNYXRNdWxTaGFwZShhOiBbbnVtYmVyLCBudW1iZXJdLCBiOiBbbnVtYmVyLCBudW1iZXJdKTogW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gYVsxXSAhPT0gYlswXSA/IHVuZGVmaW5lZCA6IFthWzBdLCBiWzFdXTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCcm9hZGNhc3RVdGlsIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gYnJvYWRjYXN0aW5nIDIgdGVuc29yc1xyXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXHJcbiAgICogQHBhcmFtIGIgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50ZWdlcnNcclxuICAgKiBAcGFyYW0gaXNNYXRNdWwgV2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIE1hdE11bFxyXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGNTaGFwZShcclxuICAgIGFkaW1zOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIGJkaW1zOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIGlzTWF0TXVsID0gZmFsc2UsXHJcbiAgKTogcmVhZG9ubHkgbnVtYmVyW10gfCB1bmRlZmluZWQge1xyXG4gICAgY29uc3QgYXJhbmsgPSBhZGltcy5sZW5ndGg7XHJcbiAgICBjb25zdCBicmFuayA9IGJkaW1zLmxlbmd0aDtcclxuICAgIGlmIChhcmFuayA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gYmRpbXM7XHJcbiAgICB9XHJcbiAgICBpZiAoYnJhbmsgPT09IDApIHtcclxuICAgICAgcmV0dXJuIGFkaW1zO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY3JhbmsgPSBNYXRoLm1heChhZGltcy5sZW5ndGgsIGJkaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBjZGltcyA9IG5ldyBBcnJheTxudW1iZXI+KGNyYW5rKTtcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGxhc3QgMiBkaW1lbnNpb24gaWYgaXQgaXMgTWF0TXVsXHJcbiAgICBpZiAoaXNNYXRNdWwpIHtcclxuICAgICAgaWYgKGFyYW5rIDwgMiB8fCBicmFuayA8IDIpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNTaGFwZU1hdE11bCA9IE1hdE11bFV0aWwuY2FsY01hdE11bFNoYXBlKFxyXG4gICAgICAgIFthZGltc1thcmFuayAtIDJdLCBhZGltc1thcmFuayAtIDFdXSxcclxuICAgICAgICBbYmRpbXNbYnJhbmsgLSAyXSwgYmRpbXNbYnJhbmsgLSAxXV0sXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChjU2hhcGVNYXRNdWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgW2NkaW1zW2NyYW5rIC0gMl0sIGNkaW1zW2NyYW5rIC0gMV1dID0gY1NoYXBlTWF0TXVsO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSBpc01hdE11bCA/IDMgOiAxOyBpIDw9IGNyYW5rOyBpKyspIHtcclxuICAgICAgY29uc3QgYUxlbiA9IGFyYW5rIC0gaSA8IDAgPyAxIDogYWRpbXNbYXJhbmsgLSBpXTtcclxuICAgICAgY29uc3QgYkxlbiA9IGJyYW5rIC0gaSA8IDAgPyAxIDogYmRpbXNbYnJhbmsgLSBpXTtcclxuXHJcbiAgICAgIGlmIChhTGVuICE9PSBiTGVuICYmIGFMZW4gPiAxICYmIGJMZW4gPiAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChhTGVuLCBiTGVuKTtcclxuICAgICAgaWYgKGFMZW4gJiYgYkxlbikge1xyXG4gICAgICAgIGNkaW1zW2NyYW5rIC0gaV0gPSBNYXRoLm1heChhTGVuLCBiTGVuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB3aGVuIGVpdGhlciBhTGVuIG9yIGJMZW4gaXMgMCwgdGhlIG90aGVyIHNob3VsZCBiZSBlaXRoZXIgMCBvciAxLCBvdGhlcndpc2UgaXQgaXMgbm90IGJyb2FkY2FzdGFibGUuXHJcbiAgICAgICAgaWYgKG1heCA+IDEpIHtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNkaW1zW2NyYW5rIC0gaV0gPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNkaW1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2hhcGUgaXMgdW5pZGlyZWN0aW9uYWwgYnJvYWRjYXN0YWJsZSB0byBhbm90aGVyIHNoYXBlXHJcbiAgICogQHBhcmFtIHNoYXBlIFRoZSBpbnB1dCBzaGFwZVxyXG4gICAqIEBwYXJhbSBmaW5hbFNoYXBlIFRoZSBkZXNpcmVkIHNoYXBlIGFmdGVyIGJyb2FkY2FzdGluZ1xyXG4gICAqL1xyXG4gIHN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZmluYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcclxuICAgIC8vIGFsaWduIHNoYXBlIHRvIHRoZSByaWdodFxyXG4gICAgY29uc3QgaW5wdXRSYW5rID0gc2hhcGUubGVuZ3RoO1xyXG4gICAgY29uc3QgZmluYWxSYW5rID0gZmluYWxTaGFwZS5sZW5ndGg7XHJcbiAgICBpZiAoaW5wdXRSYW5rID4gZmluYWxSYW5rKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGlucHV0UmFuazsgaSsrKSB7XHJcbiAgICAgIGlmIChzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gMSAmJiBzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gZmluYWxTaGFwZVtmaW5hbFJhbmsgLSBpXSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2hhcGVVdGlsIHtcclxuICAvKipcclxuICAgKiBjYWxjdWxhdGUgdGhlIHNpemUgKG51bWJlciBvZiBlbGVtZW50cylcclxuICAgKi9cclxuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgMCwgZGltcy5sZW5ndGgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY29udmVydCBkaW1zIGNvcnJlc3BvbmRpbmcgdG8gdHlwZSBjaGFuZ2UgdG8gcGFjay4gZXguIHVpbnQ4IGRhdGEgdG8gdWludDMyXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbnZlcnRTaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgc2l6ZSA9IDQpOiByZWFkb25seSBudW1iZXJbXSB7XHJcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XHJcbiAgICBpZiAocmFuayA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdEaW1zID0gbmV3IEFycmF5KHJhbmspO1xyXG4gICAgbGV0IGkgPSByYW5rIC0gMTtcclxuICAgIHdoaWxlIChpID49IDApIHtcclxuICAgICAgaWYgKGRpbXNbaV0gJSBzaXplID09PSAwKSB7XHJcbiAgICAgICAgbmV3RGltc1tpXSA9IGRpbXNbaV0gLyBzaXplO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaXplICUgZGltc1tpXSAhPT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNvbnZlcnQgc2hhcGUnKTtcclxuICAgICAgfVxyXG4gICAgICBuZXdEaW1zW2ldID0gMTtcclxuICAgICAgc2l6ZSAvPSBkaW1zW2ldO1xyXG4gICAgICBpLS07XHJcbiAgICB9XHJcbiAgICBmb3IgKGktLTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgbmV3RGltc1tpXSA9IGRpbXNbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3RGltcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIHRoZSBnaXZlbiBheGlzIChpbmNsdXNpdmUpXHJcbiAgICovXHJcbiAgc3RhdGljIHNpemVGcm9tRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7YXhpc30gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCBheGlzLCBkaW1zLmxlbmd0aCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjYWxjdWxhdGUgdGhlIHNpemUgKG51bWJlciBvZiBlbGVtZW50cykgdG8gdGhlIGdpdmVuIGF4aXMgKGV4Y2x1c2l2ZSlcclxuICAgKi9cclxuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7YXhpc30gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgMCwgYXhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjYWxjdWxhdGUgdGhlIHNpemUgKG51bWJlciBvZiBlbGVtZW50cykgZnJvbSBhbmQgdG8gdGhlIGdpdmVuIGF4aXMgW3N0YXJ0LCBlbmQpXHJcbiAgICovXHJcbiAgc3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGxldCBzaXplID0gMTtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgIC8vIHNhZmV0eSBjaGVjayBhcyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgbXVsdGlwbGUgb3RoZXIgbWV0aG9kcyByZXF1aXJpbmcgc2l6ZS5cclxuICAgICAgLy8gc2l6ZSBjYW5ub3QgYmUgbmVnYXRpdmUuXHJcbiAgICAgIGlmIChkaW1zW2ldIDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXHJcbiAgICAgICAgICAnY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLicsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBzaXplICo9IE51bWJlcihkaW1zW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaXplO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNvbXB1dGVTdHJpZGVzKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xyXG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xyXG4gICAgaWYgKHJhbmsgPT09IDApIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBbMV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmspO1xyXG4gICAgc3RyaWRlc1tyYW5rIC0gMV0gPSAxO1xyXG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBkaW1zW3JhbmsgLSAxXTtcclxuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogZGltc1tpICsgMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyaWRlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG5vcm1hbGl6ZSBheGlzIG9mIHJhbmdlIFstciwgcikgaW50byBbMCwgcikuXHJcbiAgICovXHJcbiAgc3RhdGljIG5vcm1hbGl6ZUF4aXMoYXhpczogbnVtYmVyLCB0ZW5zb3JSYW5rOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgaWYgKGF4aXMgPCAtdGVuc29yUmFuayAmJiBheGlzID49IHRlbnNvclJhbmspIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBheGlzIDwgMCA/IGF4aXMgKyB0ZW5zb3JSYW5rIDogYXhpcztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBub3JtYWxpemVBeGVzKGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCB0ZW5zb3JSYW5rPzogbnVtYmVyKTogbnVtYmVyW10ge1xyXG4gICAgcmV0dXJuIGF4ZXMubWFwKCh4KSA9PiB0aGlzLm5vcm1hbGl6ZUF4aXMoeCwgdGVuc29yUmFuayA/PyBheGVzLmxlbmd0aCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydHMgYSBnaXZlbiBhcnJheSBiYXNlZCBvbiB0aGUgaW5kaWNlcyBpbiB0aGUgUGVybSBhcnJheVxyXG4gICAqIFVzZWQgaW4gVHJhbnNwb3NlXHJcbiAgICogQHBhcmFtIGEgQXJyYXkgdG8gYmUgc29ydGVkIHN1Y2ggYXMgZGltcyBvciBzdHJpZGVzXHJcbiAgICogQHBhcmFtIHBlcm0gUGVybSBnaXZlbjsgaWYgbnVsbCBhIHdpbGwgYmUgcmV2ZXJzZWRcclxuICAgKi9cclxuICBzdGF0aWMgc29ydEJhc2VkT25QZXJtKGE6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtPzogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XHJcbiAgICBpZiAocGVybSkge1xyXG4gICAgICByZXR1cm4gcGVybS5tYXAoKHYpID0+IGFbdl0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGEuc2xpY2UoKS5yZXZlcnNlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYWRzIGEgZ2l2ZW4gc2hhcGUgYWNjb3JkaW5nIHRvIHRoZSBwYWRkaW5nIHZhbHVlc1xyXG4gICAqIEBwYXJhbSBkaW1zIHNoYXBlIG9mIHRoZSBUZW5zb3IgdG8gYmUgcGFkZGVkXHJcbiAgICogQHBhcmFtIHBhZCBwYWQgdmFsdWVzXHJcbiAgICovXHJcbiAgc3RhdGljIHBhZFNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBwYWQ6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xyXG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGRpbXMubWFwKCh2LCBpKSA9PiB2ICsgcGFkW2ldICsgcGFkW2kgKyByYW5rXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSB0d28gc2hhcGVzIGFyZSBpZGVudGljYWxcclxuICAgKiBAcGFyYW0gc2hhcGUxXHJcbiAgICogQHBhcmFtIHNoYXBlMlxyXG4gICAqL1xyXG4gIHN0YXRpYyBhcmVFcXVhbChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoc2hhcGUxLmxlbmd0aCAhPT0gc2hhcGUyLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhcGUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBzaGFwZTJbaV0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFBvb2xDb252VXRpbCB7XHJcbiAgLyoqXHJcbiAgICogQWRqdXN0IHRoZSBrZXJuZWwsIHN0cmlkZXMsIHBhZHMgdG8gY29ycmVjdCByYW5rLiBTZXQgdG8gZGVmYXVsdCB2YWx1ZSBpZiBub3QgcHJlc2VudFxyXG4gICAqIEBwYXJhbSBpc0dsb2JhbE9wZXJhdG9yIElmIHRydWUsIHBlcmZvcm0gZ2xvYmFsIHBvb2xpbmcuXHJcbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi5cclxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICogQHBhcmFtIHN0cmlkZXMgU3RyaWRlIGFsb25nIGVhY2ggYXhpcy5cclxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cclxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyhcclxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXHJcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxyXG4gICAgc3RyaWRlczogbnVtYmVyW10sXHJcbiAgICBkaWxhdGlvbnM6IG51bWJlcltdLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAoIWlzR2xvYmFsT3BlcmF0b3IgJiYga2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xyXG4gICAgICAvLyBhZGp1c3Qga2VybmVsIHNoYXBlIHRvIGNvdmVyIHRoZSBpbnB1dCBkaW1zXHJcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xyXG4gICAgICAgIGlmIChkaW0gPj0ga2VybmVsU2hhcGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0RGltc1tkaW0gKyAyXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0gPSBpbnB1dERpbXNbZGltICsgMl07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRqdXN0IHN0cmlkZXMgbGVuZ3RoIHRvIG1hdGNoIGtlcm5lbCBzaGFwZSBsZW5ndGhcclxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcclxuICAgICAgaWYgKGRpbSA8IHN0cmlkZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHN0cmlkZXNbZGltXSA8IDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RyaWRlcy5wdXNoKDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRqdXN0IGRpbGF0aW9uIHZhbHVlXHJcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XHJcbiAgICAgIGlmIChkaW0gPCBkaWxhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGRpbGF0aW9uc1tkaW1dIDwgMCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpbGF0aW9ucy5wdXNoKDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRqdXN0IHBhZHMgbGVuZ3RoIHRvIG1hdGNoIDIgKiBrZXJuZWwgc2hhcGUgbGVuZ3RoXHJcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGggKiAyOyBkaW0rKykge1xyXG4gICAgICBpZiAoZGltIDwgcGFkcy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocGFkc1tkaW1dIDwgMCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhZHMucHVzaCgwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNhbml0eSBjaGVja3MgZm9yIHZhbHVlcyBpbiBrZXJuZWwgc2hhcGVzIGFuZCBwYWRzXHJcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XHJcbiAgICAgIGlmIChrZXJuZWxTaGFwZVtkaW1dIDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocGFkc1tkaW1dID49IGtlcm5lbFNoYXBlW2RpbV0gfHwgcGFkc1tkaW0gKyBrZXJuZWxTaGFwZS5sZW5ndGhdID49IGtlcm5lbFNoYXBlW2RpbV0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWwnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gYWRqdXN0IHBhZCB2YWx1ZXMgYmFzZWQgb24gJ2F1dG9QYWQnIGF0dHJpYnV0ZVxyXG4gIHN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXHJcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgICBpc0NoYW5uZWxMYXN0OiBib29sZWFuLFxyXG4gICAgYXV0b1BhZD86IHN0cmluZyxcclxuICApOiB2b2lkIHtcclxuICAgIGlmICghYXV0b1BhZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhZHMubGVuZ3RoICE9PSAyICogKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdHJpZGVzLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xyXG4gICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXHJcbiAgICAgICAgaW5wdXREaW1zW2RpbSArIChpc0NoYW5uZWxMYXN0ID8gMSA6IDIpXSxcclxuICAgICAgICBzdHJpZGVzW2RpbV0sXHJcbiAgICAgICAgZGlsYXRpb25zW2RpbV0sXHJcbiAgICAgICAga2VybmVsU2hhcGVbZGltXSxcclxuICAgICAgICBwYWRzLFxyXG4gICAgICAgIGRpbSxcclxuICAgICAgICBkaW0gKyBpbnB1dERpbXMubGVuZ3RoIC0gMixcclxuICAgICAgICBhdXRvUGFkLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcclxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxyXG4gICAqIEBwYXJhbSBpbnB1dERpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb24uIChpbnB1dHNbMF0uZGltcylcclxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqIEBwYXJhbSBrZXJuZWxTaGFwZSBUaGUgc2l6ZSBvZiB0aGUga2VybmVsIGFsb25nIGVhY2ggYXhpcy5cclxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcclxuICAgKiAgICAgZGltZW5zaW9uLiBDYW4gdGFrZSB2YWx1ZXMgTk9UU0VULCBTQU1FX1VQUEVSLCBTQU1FX0xPV0VSLCBvciBWQUxJRC5cclxuICAgKi9cclxuICBzdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShcclxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXHJcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgc3RyaWRlczogbnVtYmVyW10sXHJcbiAgICBkaWxhdGlvbnM6IG51bWJlcltdLFxyXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxyXG4gICk6IG51bWJlcltdIHtcclxuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGNoYW5uZWxzIG9mIG91dHB1dFxyXG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGlucHV0RGltc1sxXV07XHJcblxyXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihcclxuICAgICAgaXNHbG9iYWxPcGVyYXRvcixcclxuICAgICAgaW5wdXREaW1zLFxyXG4gICAgICBvdXRwdXREaW1zLFxyXG4gICAgICBzdHJpZGVzLFxyXG4gICAgICBkaWxhdGlvbnMsXHJcbiAgICAgIGtlcm5lbFNoYXBlLFxyXG4gICAgICBwYWRzLFxyXG4gICAgICBhdXRvUGFkLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBvdXRwdXREaW1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIENvbnYgb3AgYmFzZWQgb24gaW5wdXQgYXR0cmlidXRlcy4gKFNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIENvbnYgb3ApXHJcbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxyXG4gICAqIEBwYXJhbSBmaWx0ZXJEaW1zIFRoZSBmaWx0ZXIgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1sxXS5kaW1zKVxyXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICogQHBhcmFtIGF1dG9QYWQgREVQUkVDQVRFRCBhdHRyaWJ1dGUgc3VwcG9ydGVkIGZvciBsZWdhY3kgbW9kZWxzLiBTcGVjaWZpZXMgaG93IHRvIGltcGxpY2l0bHkgY2FsY3VsYXRlIHBhZHMgaW4gZWFjaFxyXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxyXG4gICAqL1xyXG4gIHN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKFxyXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgc3RyaWRlczogbnVtYmVyW10sXHJcbiAgICBkaWxhdGlvbnM6IG51bWJlcltdLFxyXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxyXG4gICk6IG51bWJlcltdIHtcclxuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDAgfHwgZmlsdGVyRGltcy5sZW5ndGggPD0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXMnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGNoYW5uZWxzIG9mIG91dHB1dFxyXG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGZpbHRlckRpbXNbMF1dO1xyXG5cclxuICAgIFBvb2xDb252VXRpbC5jb21wdXRlU2hhcGVIZWxwZXIoZmFsc2UsIGlucHV0RGltcywgb3V0cHV0RGltcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXV0b1BhZCk7XHJcbiAgICByZXR1cm4gb3V0cHV0RGltcztcclxuICB9XHJcblxyXG4gIC8vIHdpbGwgY29tcHV0ZSBvdXRwdXQgc2hhcGVzIGZvciBkYXRhIGRpbWVuc2lvbnMgT05MWSAoaS5lLikgbm8gYmF0Y2ggc2l6ZSBhbmQgY2hhbm5lbHNcclxuICAvLyBjYWxsZWQgYnkgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSgpIGFuZCBjb21wdXRlQ29udk91dHB1dFNoYXBlKClcclxuICAvLyBhZGp1c3QgcGFkcyBiYXNlZCBvbiAnYXV0b1BhZCcgYXR0cmlidXRlIHByaW9yIHRvIHNoYXBlIGNvbXB1dGF0aW9uXHJcbiAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKFxyXG4gICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcclxuICAgIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgICBvdXRwdXREaW1zOiBudW1iZXJbXSxcclxuICAgIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIHBhZHM6IG51bWJlcltdLFxyXG4gICAgYXV0b1BhZD86IHN0cmluZyxcclxuICApIHtcclxuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XHJcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xyXG4gICAgICAgIG91dHB1dERpbXMucHVzaCgxKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XHJcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKFxyXG4gICAgICAgICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxyXG4gICAgICAgICAgICBpbnB1dERpbXNbZGltICsgMl0sXHJcbiAgICAgICAgICAgIHN0cmlkZXNbZGltXSxcclxuICAgICAgICAgICAgZGlsYXRpb25zW2RpbV0sXHJcbiAgICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0sXHJcbiAgICAgICAgICAgIHBhZHMsXHJcbiAgICAgICAgICAgIGRpbSxcclxuICAgICAgICAgICAgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXHJcbiAgICAgICAgICAgIGF1dG9QYWQsXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGhlbHBlciBmb3IgY29tcHV0ZVNoYXBlSGVscGVyKCkgYW5kIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCgpXHJcbiAgLy8gYWRqdXN0cyBwYWQgdmFsdWUgZm9yIGdpdmVuICdhdXRvUGFkJyBzdHJpbmcgYW5kIGNvbXB1dGVzIG91dHB1dCBzaGFwZSBhbG9uZyBhIHBhcnRpY3VsYXIgZGltZW5zaW9uXHJcbiAgcHJpdmF0ZSBzdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXHJcbiAgICBpblNpemU6IG51bWJlcixcclxuICAgIHN0cmlkZTogbnVtYmVyLFxyXG4gICAgZGlsYXRpb246IG51bWJlcixcclxuICAgIGtlcm5lbDogbnVtYmVyLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgICBwYWRIZWFkSW5kZXg6IG51bWJlcixcclxuICAgIHBhZFRhaWxJbmRleDogbnVtYmVyLFxyXG4gICAgYXV0b1BhZD86IHN0cmluZyxcclxuICApOiBudW1iZXIge1xyXG4gICAgY29uc3QgZGtlcm5lbCA9IGRpbGF0aW9uICogKGtlcm5lbCAtIDEpICsgMTtcclxuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XHJcbiAgICAgIHN3aXRjaCAoYXV0b1BhZCkge1xyXG4gICAgICAgIGNhc2UgJ1ZBTElEJzpcclxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XHJcbiAgICAgICAgICBwYWRzW3BhZFRhaWxJbmRleF0gPSAwO1xyXG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGluU2l6ZSAtIGRrZXJuZWwpIC8gc3RyaWRlICsgMSk7XHJcbiAgICAgICAgY2FzZSAnU0FNRV9MT1dFUic6XHJcbiAgICAgICAgY2FzZSAnU0FNRV9VUFBFUic6XHJcbiAgICAgICAgICBpZiAoZGlsYXRpb24gIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVInKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZ2FjeVRhcmdldFNpemUgPSAoaW5TaXplICsgc3RyaWRlIC0gMSkgLyBzdHJpZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZE5lZWRlZCA9IChsZWdhY3lUYXJnZXRTaXplIC0gMSkgKiBzdHJpZGUgKyBrZXJuZWwgLSBpblNpemU7XHJcbiAgICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJyA/IE1hdGguZmxvb3IoKHBhZE5lZWRlZCArIDEpIC8gMikgOiBNYXRoLmZsb29yKHBhZE5lZWRlZCAvIDIpO1xyXG4gICAgICAgICAgICBwYWRzW3BhZFRhaWxJbmRleF0gPSBwYWROZWVkZWQgLSBwYWRzW3BhZEhlYWRJbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWROZWVkZWQgLSBrZXJuZWwpIC8gc3RyaWRlICsgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSArIDEpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdlbW1VdGlsIHtcclxuICAvLyB3aWxsIG1ha2Ugc3VyZSBpbnB1dCBzaGFwZXMgYXJlIGNvbXBhdGlibGUgZm9yIHRoaXMgb3BcclxuICAvLyBhbmQgcmV0dXJuIGJhY2sgdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgaW4gdGhlIGZvcm0gb2YgYSB0dXBsZVxyXG4gIC8vIHdpbGwgdGhyb3cgZXhjZXB0aW9uIGlmIHRoZSBpbnB1dCBzaGFwZXMgYXJlIG5vdCBjb21wYXRpYmxlXHJcbiAgc3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KFxyXG4gICAgbGVmdFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIHRyYW5zTGVmdDogYm9vbGVhbixcclxuICAgIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgdHJhbnNSaWdodDogYm9vbGVhbixcclxuICAgIGJpYXNTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHtcclxuICAgIGlmIChsZWZ0U2hhcGUubGVuZ3RoICE9PSAyIHx8IHJpZ2h0U2hhcGUubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDInKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgTTogbnVtYmVyO1xyXG4gICAgbGV0IEs6IG51bWJlcjtcclxuICAgIGxldCBOOiBudW1iZXI7XHJcblxyXG4gICAgaWYgKHRyYW5zTGVmdCkge1xyXG4gICAgICBNID0gbGVmdFNoYXBlWzFdO1xyXG4gICAgICBLID0gbGVmdFNoYXBlWzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgTSA9IGxlZnRTaGFwZVswXTtcclxuICAgICAgSyA9IGxlZnRTaGFwZVsxXTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQga0RpbSA9IC0xO1xyXG5cclxuICAgIGlmICh0cmFuc1JpZ2h0KSB7XHJcbiAgICAgIE4gPSByaWdodFNoYXBlWzBdO1xyXG4gICAgICBrRGltID0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIE4gPSByaWdodFNoYXBlWzFdO1xyXG4gICAgICBrRGltID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmlnaHRTaGFwZVtrRGltXSAhPT0gSykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpbWVuc2lvbiBtaXNtYXRjaCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNIDw9IDAgfHwgTiA8PSAwIHx8IEsgPD0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2hhcGUgc3BlY2lmaWVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJpYXNTaGFwZSAmJiAhQnJvYWRjYXN0VXRpbC5pc1ZhbGlkQnJvYWRjYXN0KGJpYXNTaGFwZSwgW00sIE5dKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtNLCBOLCBLXTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBNSU5fQ0xJUCA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XHJcbmV4cG9ydCBjb25zdCBNQVhfQ0xJUCA9IDMuNDAyODIzNDY2Mzg1Mjg4NmUzODtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoXHJcbiAgZGF0YUJ1ZmZlcjogQXJyYXlCdWZmZXIsXHJcbiAgdHlwZTogVGVuc29yLlR5cGUsXHJcbik6XHJcbiAgfCBJbnQzMkFycmF5XHJcbiAgfCBVaW50MzJBcnJheVxyXG4gIHwgQmlnSW50NjRBcnJheVxyXG4gIHwgQmlnVWludDY0QXJyYXlcclxuICB8IFVpbnQ4QXJyYXlcclxuICB8IEZsb2F0MzJBcnJheVxyXG4gIHwgRmxvYXQ2NEFycmF5XHJcbiAgfCBJbnQ4QXJyYXlcclxuICB8IEludDE2QXJyYXlcclxuICB8IFVpbnQxNkFycmF5ID0+IG5ldyAodGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKHR5cGUpKShkYXRhQnVmZmVyKTtcclxuXHJcbi8qKlxyXG4gKiBhIFRlbnNvclZpZXcgZG9lcyBub3Qgb3duIHRoZSBkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JWaWV3IHtcclxuICByZWFkb25seSBkYXRhOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgZGF0YVR5cGU6IG51bWJlcjtcclxuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogZ2V0IGEgRmxvYXQxNkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxyXG4gICAqL1xyXG4gIGdldFVpbnQxNkFycmF5KCk6IFVpbnQxNkFycmF5O1xyXG5cclxuICAvKipcclxuICAgKiBnZXQgYSBGbG9hdDMyQXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXHJcbiAgICovXHJcbiAgZ2V0RmxvYXQzMkFycmF5KCk6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgLyoqXHJcbiAgICogZ2V0IGEgQmlnSW50NjRBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cclxuICAgKi9cclxuICBnZXRCaWdJbnQ2NEFycmF5KCk6IEJpZ0ludDY0QXJyYXk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGdldCBhIEludDMyQXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXHJcbiAgICovXHJcbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5O1xyXG5cclxuICAvKipcclxuICAgKiBnZXQgYSBVaW50MTZBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cclxuICAgKi9cclxuICBnZXRVaW50MTZBcnJheSgpOiBVaW50MTZBcnJheTtcclxuXHJcbiAgLyoqXHJcbiAgICogY3JlYXRlIGEgbmV3IHRlbnNvciB2aWV3IHdpdGggdGhlIHNhbWUgZGF0YSBidXQgZGlmZmVyZW50IGRpbWVuc2lvbnMuXHJcbiAgICovXHJcbiAgcmVzaGFwZShuZXdEaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXc7XHJcbn1cclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBXZWJOTkJhY2tlbmQgfSBmcm9tICcuLi9iYWNrZW5kLXdlYm5uJztcclxuaW1wb3J0IHsgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi9sb2cnO1xyXG5cclxuLy8gV2ViTk4gQVBJIGN1cnJlbnRseSBkb2VzIG5vdCBoYXZlIGEgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZpbGUuIFRoaXMgZmlsZSBpcyBhIHdvcmthcm91bmQgd2l0aCB0eXBlcyBnZW5lcmF0ZWQgZnJvbVxyXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYm1hY2hpbmVsZWFybmluZy93ZWJubi9pc3N1ZXMvNjc3XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJ3ZWJubi5kLnRzXCIgLz5cclxuXHJcbi8qKlxyXG4gKiBNYXAgZnJvbSBNTE9wZXJhbmREYXRhVHlwZSB0byBzaXplIGluIGJpdHMuIFVzaW5nIGJpdHMgaW5zdGVhZCBvZiBieXRlcyB0byBhdm9pZCBwb3NzaWJsZSBwcmVjaXNpb24gbG9zcyBvbiBpbnQ0IGFuZCB1aW50NC5cclxuICovXHJcbmNvbnN0IHdlYm5uRGF0YVR5cGVUb1NpemUgPSBuZXcgTWFwPE1MT3BlcmFuZERhdGFUeXBlLCBudW1iZXI+KFtcclxuICBbJ2Zsb2F0MzInLCAzMl0sXHJcbiAgWydmbG9hdDE2JywgMTZdLFxyXG4gIFsnaW50MzInLCAzMl0sXHJcbiAgWyd1aW50MzInLCAzMl0sXHJcbiAgWydpbnQ2NCcsIDY0XSxcclxuICBbJ3VpbnQ2NCcsIDY0XSxcclxuICBbJ2ludDgnLCA4XSxcclxuICBbJ3VpbnQ4JywgOF0sXHJcbiAgWydpbnQ0JywgNF0sXHJcbiAgWyd1aW50NCcsIDRdLFxyXG5dKTtcclxuXHJcbi8vIENvbnZlcnQgaW50ZWdlciBkYXRhIHRvIGFuIEludDMyQXJyYXkgYnVmZmVyLlxyXG4vLyBTdXBwb3J0cyBjb252ZXJzaW9uIGZyb20gaW50NjQsIHVpbnQ2NCwgdWludDMyLCBpbnQ4IGFuZCB1aW50OCB0byBpbnQzMi5cclxuZXhwb3J0IGNvbnN0IGNvbnZlcnREYXRhVG9JbnQzMiA9IChkYXRhOiBVaW50OEFycmF5LCBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUpOiBVaW50OEFycmF5ID0+IHtcclxuICBpZiAoZGF0YVR5cGUgPT09ICdpbnQzMicpIHtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZGF0YVR5cGVTaXplID0gd2Vibm5EYXRhVHlwZVRvU2l6ZS5nZXQoZGF0YVR5cGUpO1xyXG4gIGlmICghZGF0YVR5cGVTaXplKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYk5OIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhIHR5cGU6ICR7ZGF0YVR5cGV9YCk7XHJcbiAgfVxyXG4gIGNvbnN0IGJ5dGVzUGVyRWxlbWVudCA9IGRhdGFUeXBlU2l6ZSAvIDg7XHJcbiAgLy8gTWFrZSBzdXJlIHRoZSBkYXRhIGxlbmd0aCBpcyBhIG11bHRpcGxlIG9mIHRoZSBkYXRhIHR5cGUgc2l6ZS5cclxuICBpZiAoZGF0YS5ieXRlTGVuZ3RoICUgYnl0ZXNQZXJFbGVtZW50ICE9PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVWludDhBcnJheSBsZW5ndGggLSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtieXRlc1BlckVsZW1lbnR9LmApO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBVaW50OEFycmF5IHRvIG9yaWdpbmFsIHR5cGVkIGFycmF5LlxyXG4gIGNvbnN0IG51bUVsZW1lbnRzID0gZGF0YS5ieXRlTGVuZ3RoIC8gYnl0ZXNQZXJFbGVtZW50O1xyXG4gIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBuZXcgKHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhVHlwZSkpKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIG51bUVsZW1lbnRzKTtcclxuXHJcbiAgc3dpdGNoIChkYXRhVHlwZSkge1xyXG4gICAgY2FzZSAnaW50NjQnOlxyXG4gICAgY2FzZSAndWludDY0Jzoge1xyXG4gICAgICAvLyBDb252ZXJ0IG9yaWdpbmFsIHR5cGVkIGFycmF5IHRvIEludDMyQXJyYXkuXHJcbiAgICAgIGNvbnN0IGludDMyQXJyYXkgPSBuZXcgSW50MzJBcnJheShudW1FbGVtZW50cyk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRWxlbWVudHM7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3JpZ2luYWxBcnJheVtpXTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJmbG93LlxyXG4gICAgICAgIGlmICh2YWx1ZSA+IDIxNDc0ODM2NDduIHx8IHZhbHVlIDwgLTIxNDc0ODM2NDhuKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgY29udmVydCBpbnQ2NCBkYXRhIHRvIGludDMyIC0gdmFsdWUgb3V0IG9mIHJhbmdlLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50MzJBcnJheVtpXSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnQzMkFycmF5LmJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBjYXNlICdpbnQ4JzpcclxuICAgIGNhc2UgJ3VpbnQ4JzpcclxuICAgIGNhc2UgJ3VpbnQzMic6IHtcclxuICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJmbG93LlxyXG4gICAgICBpZiAoZGF0YVR5cGUgPT09ICd1aW50MzInKSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsQXJyYXkuc29tZSgodmFsdWUpID0+IHZhbHVlID4gMjE0NzQ4MzY0NykpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBjb252ZXJ0IHVpbnQzMiBkYXRhIHRvIGludDMyIC0gdmFsdWUgb3V0IG9mIHJhbmdlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBDb252ZXJ0IG9yaWdpbmFsIHR5cGVkIGFycmF5IHRvIEludDMyQXJyYXkuXHJcbiAgICAgIGNvbnN0IGludDMyQXJyYXkgPSBJbnQzMkFycmF5LmZyb20ob3JpZ2luYWxBcnJheSwgTnVtYmVyKTtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGludDMyQXJyYXkuYnVmZmVyKTtcclxuICAgIH1cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSBjb252ZXJzaW9uIGZyb20gJHtkYXRhVHlwZX0gdG8gJ2ludDMyJ2ApO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIENvbnZlcnQgSW50MzJBcnJheSBkYXRhIHRvIG9yaWdpbmFsIGludGVnZXIgZGF0YSBidWZmZXIuXHJcbi8vIFN1cHBvcnRzIGNvbnZlcnNpb24gZnJvbSBpbnQzMiB0byBpbnQ2NCwgdWludDY0LCB1aW50MzIsIGludDggYW5kIHVpbnQ4LlxyXG5leHBvcnQgY29uc3QgY29udmVydEludDMyVG9EYXRhID0gKGRhdGE6IFVpbnQ4QXJyYXksIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSk6IFVpbnQ4QXJyYXkgPT4ge1xyXG4gIGlmIChkYXRhVHlwZSA9PT0gJ2ludDMyJykge1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICAvLyBNYWtlIHN1cmUgdGhlIGRhdGEgbGVuZ3RoIGlzIGEgbXVsdGlwbGUgb2YgNCBieXRlcyAoSW50MzJBcnJheSkuXHJcbiAgaWYgKGRhdGEuYnl0ZUxlbmd0aCAlIDQgIT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVaW50OEFycmF5IGxlbmd0aCAtIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0IChpbnQzMikuJyk7XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IFVpbnQ4QXJyYXkgdG8gSW50MzJBcnJheS5cclxuICBjb25zdCBudW1FbGVtZW50cyA9IGRhdGEuYnl0ZUxlbmd0aCAvIDQ7XHJcbiAgY29uc3QgaW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIG51bUVsZW1lbnRzKTtcclxuXHJcbiAgc3dpdGNoIChkYXRhVHlwZSkge1xyXG4gICAgY2FzZSAnaW50NjQnOiB7XHJcbiAgICAgIGNvbnN0IGJpZ0ludDY0QXJyYXkgPSBCaWdJbnQ2NEFycmF5LmZyb20oaW50MzJBcnJheSwgQmlnSW50KTtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJpZ0ludDY0QXJyYXkuYnVmZmVyKTtcclxuICAgIH1cclxuICAgIGNhc2UgJ3VpbnQ2NCc6IHtcclxuICAgICAgaWYgKGludDMyQXJyYXkuc29tZSgodmFsdWUpID0+IHZhbHVlIDwgMCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIHVpbjY0IC0gbmVnYXRpdmUgdmFsdWUgZm91bmQuJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYmlnVWludDY0QXJyYXkgPSBCaWdVaW50NjRBcnJheS5mcm9tKGludDMyQXJyYXksIEJpZ0ludCk7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiaWdVaW50NjRBcnJheS5idWZmZXIpO1xyXG4gICAgfVxyXG4gICAgY2FzZSAnaW50OCc6IHtcclxuICAgICAgaWYgKGludDMyQXJyYXkuc29tZSgodmFsdWUpID0+IHZhbHVlIDwgLTEyOCB8fCB2YWx1ZSA+IDEyNykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIGludDggLSB2YWx1ZSBvdXQgb2YgcmFuZ2UuJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaW50OEFycmF5ID0gSW50OEFycmF5LmZyb20oaW50MzJBcnJheSwgTnVtYmVyKTtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGludDhBcnJheS5idWZmZXIpO1xyXG4gICAgfVxyXG4gICAgY2FzZSAndWludDgnOiB7XHJcbiAgICAgIGlmIChpbnQzMkFycmF5LnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAyNTUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGNvbnZlcnQgaW50MzIgZGF0YSB0byB1aW50OCAtIHZhbHVlIG91dCBvZiByYW5nZS4nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGludDMyQXJyYXksIE51bWJlcik7XHJcbiAgICB9XHJcbiAgICBjYXNlICd1aW50MzInOiB7XHJcbiAgICAgIGlmIChpbnQzMkFycmF5LnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSA8IDApKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGNvbnZlcnQgaW50MzIgZGF0YSB0byB1aW50MzIgLSBuZWdhdGl2ZSB2YWx1ZSBmb3VuZC4nKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB1aW50MzJBcnJheSA9IFVpbnQzMkFycmF5LmZyb20oaW50MzJBcnJheSwgTnVtYmVyKTtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHVpbnQzMkFycmF5LmJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgY29udmVyc2lvbiBmcm9tICdpbnQzMicgdG8gJHtkYXRhVHlwZX1gKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBUZW5zb3JJZCA9IG51bWJlcjtcclxuXHJcbi8qKlxyXG4gKiBNYW5hZ2VzIFRlbnNvcklkIHRvIE1MVGVuc29yIG1hcHBpbmcuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvck1hbmFnZXIge1xyXG4gIC8qKlxyXG4gICAqIFJlc2VydmUgYSBuZXcgVGVuc29ySWQuXHJcbiAgICovXHJcbiAgcmVzZXJ2ZVRlbnNvcklkKCk6IFRlbnNvcklkO1xyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2UgYSBUZW5zb3JJZC5cclxuICAgKi9cclxuICByZWxlYXNlVGVuc29ySWQodGVuc29ySWQ6IFRlbnNvcklkKTogdm9pZDtcclxuICAvKipcclxuICAgKiBFbnN1cmUgYSBNTFRlbnNvciBpcyBjcmVhdGVkIGZvciB0aGUgVGVuc29ySWQuXHJcbiAgICovXHJcbiAgZW5zdXJlVGVuc29yKFxyXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXHJcbiAgICB0ZW5zb3JJZDogVGVuc29ySWQsXHJcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXHJcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgICBjb3B5T2xkOiBib29sZWFuLFxyXG4gICk6IFByb21pc2U8TUxUZW5zb3I+O1xyXG4gIC8qKlxyXG4gICAqIFVwbG9hZCBkYXRhIHRvIGEgTUxUZW5zb3IuXHJcbiAgICovXHJcbiAgdXBsb2FkKHRlbnNvcklkOiBUZW5zb3JJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQ7XHJcbiAgLyoqXHJcbiAgICogRG93bmxvYWQgZGF0YSBmcm9tIGEgTUxUZW5zb3IuXHJcbiAgICovXHJcbiAgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj47XHJcbiAgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkLCBkc3RUZW5zb3I6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTx1bmRlZmluZWQ+O1xyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2UgYWxsIHRlbnNvcnMgZm9yIGEgZ2l2ZW4gc2Vzc2lvbi5cclxuICAgKi9cclxuICByZWxlYXNlVGVuc29yc0ZvclNlc3Npb24oc2Vzc2lvbjogbnVtYmVyKTogdm9pZDtcclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgTUxUZW5zb3Igd2l0aCBhIGdpdmVuIHNlc3Npb24gaWQgYW5kIHJldHVybiBhIFRlbnNvcklkLlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyVGVuc29yKHNlc3Npb25JZDogbnVtYmVyLCBtbFRlbnNvcjogTUxUZW5zb3IsIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSwgc2hhcGU6IG51bWJlcltdKTogVGVuc29ySWQ7XHJcbn1cclxuXHJcbmxldCB0ZW5zb3JHdWlkID0gMTtcclxuY29uc3QgY3JlYXRlTmV3VGVuc29ySWQgPSAoKTogVGVuc29ySWQgPT4gdGVuc29yR3VpZCsrO1xyXG5cclxuLyoqXHJcbiAqIE1hcCBmcm9tIGRhdGEgdHlwZSB0byBmYWxsYmFjayBkYXRhIHR5cGUuXHJcbiAqIFdoZW4gdGhlIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgb3JpZ2luYWwgZGF0YSB0eXBlLCB1c2UgZmFsbGJhY2sgZGF0YSB0eXBlIGFzIHdvcmthcm91bmQuXHJcbiAqIE5vdGU6IEN1cnJlbnRseSwgd2Ugb25seSBzdXBwb3J0IGZhbGxiYWNrIHRvIGludDMyIGZvciBjZXJ0YWluIGludGVnZXIgZGF0YSB0eXBlcy5cclxuICovXHJcbmNvbnN0IHdlYm5uRGF0YVR5cGVUb0ZhbGxiYWNrID0gbmV3IE1hcDxNTE9wZXJhbmREYXRhVHlwZSwgTUxPcGVyYW5kRGF0YVR5cGU+KFtcclxuICBbJ2ludDgnLCAnaW50MzInXSxcclxuICBbJ3VpbnQ4JywgJ2ludDMyJ10sXHJcbiAgWyd1aW50MzInLCAnaW50MzInXSxcclxuICBbJ2ludDY0JywgJ2ludDMyJ10sXHJcbl0pO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgYnl0ZSBsZW5ndGggb2YgYSB0ZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCBzaGFwZS5cclxuICovXHJcbmNvbnN0IGNhbGN1bGF0ZUJ5dGVMZW5ndGggPSAoZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIgPT4ge1xyXG4gIGNvbnN0IGRhdGFUeXBlU2l6ZSA9IHdlYm5uRGF0YVR5cGVUb1NpemUuZ2V0KGRhdGFUeXBlKTtcclxuICBpZiAoIWRhdGFUeXBlU2l6ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfWApO1xyXG4gIH1cclxuICByZXR1cm4gc2hhcGUubGVuZ3RoID4gMCA/IE1hdGguY2VpbCgoc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYikgKiBkYXRhVHlwZVNpemUpIC8gOCkgOiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlbnNvcldyYXBwZXIgd3JhcHMgYW4gTUxUZW5zb3IgYW5kIHByb3ZpZGVzIGEgd2F5IHRvIHRyYWNrIHRoZSBsYXN0IHNlc3Npb24gdGhhdCB1c2VkIGl0LlxyXG4gKi9cclxuY2xhc3MgVGVuc29yV3JhcHBlciB7XHJcbiAgLy8gVGhlIGlkIG9mIHRoZSBsYXN0IHNlc3Npb24gdGhhdCB1c2VkIHRoaXMgdGVuc29yLlxyXG4gIHB1YmxpYyBzZXNzaW9uSWQ6IG51bWJlcjtcclxuICAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBkYXRhIGhhcyBiZWVuIGNvbnZlcnRlZCB0byBmYWxsYmFjayBkYXRhIHR5cGUuXHJcbiAgcHVibGljIGlzRGF0YUNvbnZlcnRlZCA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIG1sQ29udGV4dDogTUxDb250ZXh0O1xyXG4gIHByaXZhdGUgbWxUZW5zb3I6IE1MVGVuc29yO1xyXG4gIHByaXZhdGUgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlO1xyXG4gIC8vIEZhbGxiYWNrIGRhdGEgdHlwZSB0byB1c2Ugd2hlbiB0aGUgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBvcmlnaW5hbCBkYXRhIHR5cGUuXHJcbiAgcHJpdmF0ZSBmYWxsYmFja0RhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSB8IHVuZGVmaW5lZDtcclxuICBwcml2YXRlIHRlbnNvclNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcclxuXHJcbiAgY29uc3RydWN0b3IoZGVzY3JpcHRvcjoge1xyXG4gICAgc2Vzc2lvbklkOiBudW1iZXI7XHJcbiAgICBjb250ZXh0OiBNTENvbnRleHQ7XHJcbiAgICB0ZW5zb3I6IE1MVGVuc29yO1xyXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlO1xyXG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gICAgZmFsbGJhY2tEYXRhVHlwZT86IE1MT3BlcmFuZERhdGFUeXBlO1xyXG4gIH0pIHtcclxuICAgIGNvbnN0IHsgc2Vzc2lvbklkLCBjb250ZXh0LCB0ZW5zb3IsIGRhdGFUeXBlLCBzaGFwZSwgZmFsbGJhY2tEYXRhVHlwZSB9ID0gZGVzY3JpcHRvcjtcclxuICAgIHRoaXMuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gICAgdGhpcy5tbENvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5tbFRlbnNvciA9IHRlbnNvcjtcclxuICAgIHRoaXMuZGF0YVR5cGUgPSBkYXRhVHlwZTtcclxuICAgIHRoaXMudGVuc29yU2hhcGUgPSBzaGFwZTtcclxuICAgIHRoaXMuZmFsbGJhY2tEYXRhVHlwZSA9IGZhbGxiYWNrRGF0YVR5cGU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHRlbnNvcigpOiBNTFRlbnNvciB7XHJcbiAgICByZXR1cm4gdGhpcy5tbFRlbnNvcjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgdHlwZSgpOiBNTE9wZXJhbmREYXRhVHlwZSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhVHlwZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgZmFsbGJhY2tUeXBlKCk6IE1MT3BlcmFuZERhdGFUeXBlIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLmZhbGxiYWNrRGF0YVR5cGU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHNoYXBlKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcclxuICAgIHJldHVybiB0aGlzLnRlbnNvclNoYXBlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBieXRlTGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gY2FsY3VsYXRlQnl0ZUxlbmd0aCh0aGlzLmRhdGFUeXBlLCB0aGlzLnRlbnNvclNoYXBlKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xyXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gJ1tXZWJOTl0gVGVuc29yV3JhcHBlci5kZXN0cm95Jyk7XHJcbiAgICB0aGlzLm1sVGVuc29yLmRlc3Ryb3koKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyB3cml0ZShkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XHJcbiAgICB0aGlzLm1sQ29udGV4dC53cml0ZVRlbnNvcih0aGlzLm1sVGVuc29yLCBkYXRhKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyByZWFkKCk6IFByb21pc2U8QXJyYXlCdWZmZXI+O1xyXG4gIHB1YmxpYyBhc3luYyByZWFkKGRzdEJ1ZmZlcj86IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZD47XHJcbiAgcHVibGljIGFzeW5jIHJlYWQoZHN0QnVmZmVyPzogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyIHwgdW5kZWZpbmVkPiB7XHJcbiAgICBpZiAodGhpcy5mYWxsYmFja0RhdGFUeXBlKSB7XHJcbiAgICAgIC8vIFRoaXMgdGVuc29yIGhhcyBiZWVuIGZhbGxiYWNrIHRvIGludDMyIGFzIHdvcmthcm91bmQsIHdlIG5lZWQgdG8gcmVhZCBpdCBhcyBpdHMgb3JpZ2luYWwgaW50ZWdlciBkYXRhIHR5cGUuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpO1xyXG4gICAgICBjb25zdCBvcmlnaW5hbERhdGEgPSBjb252ZXJ0SW50MzJUb0RhdGEobmV3IFVpbnQ4QXJyYXkoZGF0YSksIHRoaXMuZGF0YVR5cGUpO1xyXG5cclxuICAgICAgaWYgKGRzdEJ1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEJ1ZmZlciA9XHJcbiAgICAgICAgICBkc3RCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICA/IG5ldyBVaW50OEFycmF5KGRzdEJ1ZmZlcilcclxuICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShkc3RCdWZmZXIuYnVmZmVyLCBkc3RCdWZmZXIuYnl0ZU9mZnNldCwgZHN0QnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRhcmdldEJ1ZmZlci5zZXQob3JpZ2luYWxEYXRhKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBvcmlnaW5hbERhdGEuYnVmZmVyO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZHN0QnVmZmVyID8gdGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yLCBkc3RCdWZmZXIpIDogdGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBjYW5SZXVzZVRlbnNvcihjb250ZXh0OiBNTENvbnRleHQsIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB0aGlzLm1sQ29udGV4dCA9PT0gY29udGV4dCAmJlxyXG4gICAgICB0aGlzLmRhdGFUeXBlID09PSBkYXRhVHlwZSAmJlxyXG4gICAgICB0aGlzLnRlbnNvclNoYXBlLmxlbmd0aCA9PT0gc2hhcGUubGVuZ3RoICYmXHJcbiAgICAgIHRoaXMudGVuc29yU2hhcGUuZXZlcnkoKHYsIGkpID0+IHYgPT09IHNoYXBlW2ldKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXRJc0RhdGFDb252ZXJ0ZWQoaXNDb252ZXJ0ZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIHRoaXMuaXNEYXRhQ29udmVydGVkID0gaXNDb252ZXJ0ZWQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGVuc29yVHJhY2tlciB0cmFja3MgdGhlIE1MVGVuc29yIGFuZCBwZW5kaW5nIHVwbG9hZCBkYXRhLlxyXG4gKlxyXG4gKiBXZSBuZWVkIHRvIHRyYWNrIHRoZSBNTFRlbnNvciBhbmQgcGVuZGluZyB1cGxvYWQgZGF0YSBiZWNhdXNlIHdlIGRlbGF5IHRoZSBjcmVhdGlvbiBvZiBNTFRlbnNvciB1bnRpbFxyXG4gKiB3ZSBrbm93IHRoZSBkYXRhIHR5cGUgYW5kIHNoYXBlLiBUaGlzIGlzIGJlY2F1c2UgV2ViTk4gb25seSBzdXBwb3J0IGNyZWF0aW5nIE1MVGVuc29ycyB3aXRoIGRhdGFUeXBlcyBhbmQgc2hhcGUuXHJcbiAqL1xyXG5jbGFzcyBUZW5zb3JJZFRyYWNrZXIge1xyXG4gIHByaXZhdGUgYWN0aXZlVXBsb2FkPzogVWludDhBcnJheTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIHRlbnNvck1hbmFnZXI6IFRlbnNvck1hbmFnZXJJbXBsLFxyXG4gICAgcHJpdmF0ZSB3cmFwcGVyPzogVGVuc29yV3JhcHBlcixcclxuICApIHt9XHJcblxyXG4gIHB1YmxpYyBnZXQgdGVuc29yV3JhcHBlcigpOiBUZW5zb3JXcmFwcGVyIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLndyYXBwZXI7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgcmVsZWFzZVRlbnNvcigpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnRlbnNvcldyYXBwZXIpIHtcclxuICAgICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy50ZW5zb3JXcmFwcGVyKTtcclxuICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGVuc3VyZVRlbnNvcihcclxuICAgIHNlc3Npb25JZDogbnVtYmVyLFxyXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLFxyXG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgY29weU9sZDogYm9vbGVhbixcclxuICApOiBQcm9taXNlPE1MVGVuc29yPiB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy50ZW5zb3JNYW5hZ2VyLmdldE1MQ29udGV4dChzZXNzaW9uSWQpO1xyXG4gICAgY29uc3Qgb3BMaW1pdHMgPSB0aGlzLnRlbnNvck1hbmFnZXIuZ2V0TUxPcFN1cHBvcnRMaW1pdHMoc2Vzc2lvbklkKTtcclxuICAgIGxldCBmYWxsYmFja0RhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSB8IHVuZGVmaW5lZDtcclxuICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IHN1cHBvcnRzIHRoZSBkYXRhIHR5cGUuIElmIG5vdCwgdHJ5IHRvIHVzZSB0aGUgZmFsbGJhY2sgZGF0YSB0eXBlLlxyXG4gICAgaWYgKCFvcExpbWl0cz8uaW5wdXQuZGF0YVR5cGVzLmluY2x1ZGVzKGRhdGFUeXBlKSkge1xyXG4gICAgICBmYWxsYmFja0RhdGFUeXBlID0gd2Vibm5EYXRhVHlwZVRvRmFsbGJhY2suZ2V0KGRhdGFUeXBlKTtcclxuICAgICAgaWYgKCFmYWxsYmFja0RhdGFUeXBlIHx8IG9wTGltaXRzPy5pbnB1dC5kYXRhVHlwZXMuaW5jbHVkZXMoZmFsbGJhY2tEYXRhVHlwZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYk5OIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhIHR5cGU6ICR7ZGF0YVR5cGV9YCk7XHJcbiAgICAgIH1cclxuICAgICAgTE9HX0RFQlVHKFxyXG4gICAgICAgICd2ZXJib3NlJyxcclxuICAgICAgICAoKSA9PiBgW1dlYk5OXSBUZW5zb3JJZFRyYWNrZXIuZW5zdXJlVGVuc29yOiBmYWxsYmFjayBkYXRhVHlwZSBmcm9tICR7ZGF0YVR5cGV9IHRvICR7ZmFsbGJhY2tEYXRhVHlwZX1gLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLndyYXBwZXIpIHtcclxuICAgICAgaWYgKHRoaXMud3JhcHBlci5jYW5SZXVzZVRlbnNvcihjb250ZXh0LCBkYXRhVHlwZSwgc2hhcGUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlci50ZW5zb3I7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGNvcHlPbGQpIHtcclxuICAgICAgICAgIGlmICh0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCAhPT0gY2FsY3VsYXRlQnl0ZUxlbmd0aChkYXRhVHlwZSwgc2hhcGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNvcHkgZGF0YSB0byB0ZW5zb3Igd2l0aCBkaWZmZXJlbnQgc2l6ZS4nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuYWN0aXZlVXBsb2FkID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy53cmFwcGVyLnJlYWQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMud3JhcHBlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgY29uc3QgdXNhZ2UgPSB0eXBlb2YgTUxUZW5zb3JVc2FnZSA9PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1MVGVuc29yVXNhZ2UuUkVBRCB8IE1MVGVuc29yVXNhZ2UuV1JJVEU7XHJcbiAgICB0aGlzLndyYXBwZXIgPSBhd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZ2V0Q2FjaGVkVGVuc29yKFxyXG4gICAgICBzZXNzaW9uSWQsXHJcbiAgICAgIGRhdGFUeXBlLFxyXG4gICAgICBzaGFwZSxcclxuICAgICAgdXNhZ2UsXHJcbiAgICAgIHRydWUsXHJcbiAgICAgIHRydWUsXHJcbiAgICAgIGZhbGxiYWNrRGF0YVR5cGUsXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChjb3B5T2xkICYmIHRoaXMuYWN0aXZlVXBsb2FkKSB7XHJcbiAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29udmVydCB0aGUgb3JpZ2luYWwgaW50ZWdlciBkYXRhIHRvIGludDMyLFxyXG4gICAgICAvLyBiZWNhdXNlIGl0IGhhcyBiZWVuIGNvbnZlcnRlZCB3aGVuIGl0IHdhcyB1cGxvYWRlZC5cclxuICAgICAgdGhpcy53cmFwcGVyLndyaXRlKHRoaXMuYWN0aXZlVXBsb2FkKTtcclxuICAgICAgdGhpcy5hY3RpdmVVcGxvYWQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMud3JhcHBlci50ZW5zb3I7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdXBsb2FkKGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcclxuICAgIGxldCBuZXdEYXRhID0gZGF0YTtcclxuICAgIGlmICh0aGlzLndyYXBwZXIpIHtcclxuICAgICAgaWYgKHRoaXMud3JhcHBlci5mYWxsYmFja1R5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy53cmFwcGVyLmZhbGxiYWNrVHlwZSA9PT0gJ2ludDMyJykge1xyXG4gICAgICAgICAgLy8gQ29udmVydCBvcmlnaW5hbCBpbnRlZ2VyIGRhdGEgdG8gaW50MzIuXHJcbiAgICAgICAgICBuZXdEYXRhID0gY29udmVydERhdGFUb0ludDMyKGRhdGEsIHRoaXMud3JhcHBlci50eXBlKTtcclxuICAgICAgICAgIHRoaXMud3JhcHBlci5zZXRJc0RhdGFDb252ZXJ0ZWQodHJ1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZmFsbGJhY2sgZGF0YSB0eXBlOiAke3RoaXMud3JhcHBlci5mYWxsYmFja1R5cGV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZGF0YSBzaXplIG1hdGNoZXMgdGhlIHRlbnNvciBzaXplLlxyXG4gICAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID09PSB0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIC8vIFdyaXRlIHRoZSBuZXdEYXRhIHRvIHRoZSB0ZW5zb3IuXHJcbiAgICAgICAgdGhpcy53cmFwcGVyLndyaXRlKG5ld0RhdGEpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiAnRGF0YSBzaXplIGRvZXMgbm90IG1hdGNoIHRlbnNvciBzaXplLiBSZWxlYXNpbmcgdGVuc29yLicpO1xyXG4gICAgICAgIHRoaXMucmVsZWFzZVRlbnNvcigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuYWN0aXZlVXBsb2FkKSB7XHJcbiAgICAgIHRoaXMuYWN0aXZlVXBsb2FkLnNldChuZXdEYXRhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYWN0aXZlVXBsb2FkID0gbmV3IFVpbnQ4QXJyYXkobmV3RGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZG93bmxvYWQoZHN0QnVmZmVyPzogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyIHwgdW5kZWZpbmVkPiB7XHJcbiAgICBpZiAodGhpcy5hY3RpdmVVcGxvYWQpIHtcclxuICAgICAgLy8gSWYgdGhpcy5hY3RpdmVVcGxvYWQgaGFzIGJlZW4gY29udmVydGVkIHRvIGludDMyLCB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgYmFjayB0byBvcmlnaW5hbCBpbnRlZ2VyIGRhdGEgdHlwZS5cclxuICAgICAgY29uc3QgZHN0RGF0YSA9IHRoaXMud3JhcHBlcj8uaXNEYXRhQ29udmVydGVkXHJcbiAgICAgICAgPyBjb252ZXJ0SW50MzJUb0RhdGEodGhpcy5hY3RpdmVVcGxvYWQsIHRoaXMud3JhcHBlcj8udHlwZSlcclxuICAgICAgICA6IHRoaXMuYWN0aXZlVXBsb2FkO1xyXG5cclxuICAgICAgaWYgKGRzdEJ1ZmZlcikge1xyXG4gICAgICAgIGlmIChkc3RCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZHN0QnVmZmVyKS5zZXQoZHN0RGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRzdEJ1ZmZlci5idWZmZXIsIGRzdEJ1ZmZlci5ieXRlT2Zmc2V0LCBkc3RCdWZmZXIuYnl0ZUxlbmd0aCkuc2V0KGRzdERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRzdERhdGEuYnVmZmVyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMud3JhcHBlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBoYXMgbm90IGJlZW4gY3JlYXRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWRzdEJ1ZmZlcikge1xyXG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVyLnJlYWQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLndyYXBwZXIucmVhZChkc3RCdWZmZXIpO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgVGVuc29yTWFuYWdlckltcGwgaW1wbGVtZW50cyBUZW5zb3JNYW5hZ2VyIHtcclxuICBwcml2YXRlIHRlbnNvclRyYWNrZXJzQnlJZDogTWFwPFRlbnNvcklkLCBUZW5zb3JJZFRyYWNrZXI+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgZnJlZVRlbnNvcnM6IFRlbnNvcldyYXBwZXJbXSA9IFtdO1xyXG4gIHByaXZhdGUgZXh0ZXJuYWxUZW5zb3JzOiBTZXQ8VGVuc29yV3JhcHBlcj4gPSBuZXcgU2V0KCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFja2VuZDogV2ViTk5CYWNrZW5kKSB7fVxyXG5cclxuICBwdWJsaWMgZ2V0TUxDb250ZXh0KHNlc3Npb25JZDogbnVtYmVyKTogTUxDb250ZXh0IHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmJhY2tlbmQuZ2V0TUxDb250ZXh0KHNlc3Npb25JZCk7XHJcbiAgICBpZiAoIWNvbnRleHQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNTENvbnRleHQgbm90IGZvdW5kIGZvciBzZXNzaW9uLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0TUxPcFN1cHBvcnRMaW1pdHMoc2Vzc2lvbklkOiBudW1iZXIpOiBNTE9wU3VwcG9ydExpbWl0cyB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmdldE1MT3BTdXBwb3J0TGltaXRzKHNlc3Npb25JZCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgcmVzZXJ2ZVRlbnNvcklkKCk6IFRlbnNvcklkIHtcclxuICAgIGNvbnN0IHRlbnNvcklkID0gY3JlYXRlTmV3VGVuc29ySWQoKTtcclxuICAgIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldCh0ZW5zb3JJZCwgbmV3IFRlbnNvcklkVHJhY2tlcih0aGlzKSk7XHJcbiAgICByZXR1cm4gdGVuc29ySWQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgcmVsZWFzZVRlbnNvcklkKHRlbnNvcklkOiBUZW5zb3JJZCk6IHZvaWQge1xyXG4gICAgY29uc3QgdGVuc29yVHJhY2tlciA9IHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0ZW5zb3JJZCk7XHJcbiAgICBpZiAoIXRlbnNvclRyYWNrZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZGVsZXRlKHRlbnNvcklkKTtcclxuICAgIGlmICh0ZW5zb3JUcmFja2VyLnRlbnNvcldyYXBwZXIpIHtcclxuICAgICAgdGhpcy5yZWxlYXNlVGVuc29yKHRlbnNvclRyYWNrZXIudGVuc29yV3JhcHBlcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZW5zdXJlVGVuc29yKFxyXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXHJcbiAgICB0ZW5zb3JJZDogVGVuc29ySWQsXHJcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXHJcbiAgICBzaGFwZTogbnVtYmVyW10sXHJcbiAgICBjb3B5T2xkOiBib29sZWFuLFxyXG4gICk6IFByb21pc2U8TUxUZW5zb3I+IHtcclxuICAgIExPR19ERUJVRyhcclxuICAgICAgJ3ZlcmJvc2UnLFxyXG4gICAgICAoKSA9PlxyXG4gICAgICAgIGBbV2ViTk5dIFRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yIHt0ZW5zb3JJZDogJHt0ZW5zb3JJZH0sIGRhdGFUeXBlOiAke1xyXG4gICAgICAgICAgZGF0YVR5cGVcclxuICAgICAgICB9LCBzaGFwZTogJHtzaGFwZX0sIGNvcHlPbGQ6ICR7Y29weU9sZH19YCxcclxuICAgICk7XHJcbiAgICBjb25zdCB0ZW5zb3IgPSB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodGVuc29ySWQpO1xyXG4gICAgaWYgKCF0ZW5zb3IpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3Igbm90IGZvdW5kLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRlbnNvci5lbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCBkYXRhVHlwZSwgc2hhcGUsIGNvcHlPbGQpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHVwbG9hZCh0ZW5zb3JJZDogVGVuc29ySWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcclxuICAgIGNvbnN0IHRlbnNvciA9IHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0ZW5zb3JJZCk7XHJcbiAgICBpZiAoIXRlbnNvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBub3QgZm91bmQuJyk7XHJcbiAgICB9XHJcbiAgICB0ZW5zb3IudXBsb2FkKGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGRvd25sb2FkKHRlbnNvcklkOiBUZW5zb3JJZCk6IFByb21pc2U8QXJyYXlCdWZmZXI+O1xyXG4gIHB1YmxpYyBhc3luYyBkb3dubG9hZCh0ZW5zb3JJZDogVGVuc29ySWQsIGRzdEJ1ZmZlcjogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPHVuZGVmaW5lZD47XHJcbiAgYXN5bmMgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkLCBkc3RCdWZmZXI/OiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IFByb21pc2U8QXJyYXlCdWZmZXIgfCB1bmRlZmluZWQ+IHtcclxuICAgIExPR19ERUJVRyhcclxuICAgICAgJ3ZlcmJvc2UnLFxyXG4gICAgICAoKSA9PiBgW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmRvd25sb2FkIHt0ZW5zb3JJZDogJHt0ZW5zb3JJZH0sIGRzdEJ1ZmZlcjogJHtkc3RCdWZmZXI/LmJ5dGVMZW5ndGh9fWAsXHJcbiAgICApO1xyXG4gICAgY29uc3QgdGVuc29yVHJhY2tlciA9IHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0ZW5zb3JJZCk7XHJcbiAgICBpZiAoIXRlbnNvclRyYWNrZXIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3Igbm90IGZvdW5kLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRlbnNvclRyYWNrZXIuZG93bmxvYWQoZHN0QnVmZmVyKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZWxlYXNlVGVuc29yc0ZvclNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGZvciAoY29uc3QgdGVuc29yIG9mIHRoaXMuZnJlZVRlbnNvcnMpIHtcclxuICAgICAgaWYgKHRlbnNvci5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCkge1xyXG4gICAgICAgIHRlbnNvci5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuZnJlZVRlbnNvcnMgPSB0aGlzLmZyZWVUZW5zb3JzLmZpbHRlcigodGVuc29yKSA9PiB0ZW5zb3Iuc2Vzc2lvbklkICE9PSBzZXNzaW9uSWQpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlZ2lzdGVyVGVuc29yKFxyXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXHJcbiAgICBtbFRlbnNvcjogTUxUZW5zb3IsXHJcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXHJcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKTogVGVuc29ySWQge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0TUxDb250ZXh0KHNlc3Npb25JZCk7XHJcbiAgICBjb25zdCB0ZW5zb3JJZCA9IGNyZWF0ZU5ld1RlbnNvcklkKCk7XHJcbiAgICAvLyBEZWZhdWx0aW5nIHRvIFJFQUQgfCBXUklURSBpZiB1c2FnZSBpcyBub3QgcHJvdmlkZWQuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgY29uc3Qgd3JhcHBlciA9IG5ldyBUZW5zb3JXcmFwcGVyKHtcclxuICAgICAgc2Vzc2lvbklkLFxyXG4gICAgICBjb250ZXh0LFxyXG4gICAgICB0ZW5zb3I6IG1sVGVuc29yLFxyXG4gICAgICBkYXRhVHlwZSxcclxuICAgICAgc2hhcGUsXHJcbiAgICB9KTtcclxuICAgIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldCh0ZW5zb3JJZCwgbmV3IFRlbnNvcklkVHJhY2tlcih0aGlzLCB3cmFwcGVyKSk7XHJcbiAgICB0aGlzLmV4dGVybmFsVGVuc29ycy5hZGQod3JhcHBlcik7XHJcbiAgICByZXR1cm4gdGVuc29ySWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3IgY3JlYXRlIGFuIE1MVGVuc29yIHdpdGggdGhlIGdpdmVuIGRhdGEgdHlwZSBhbmQgc2hhcGUuXHJcbiAgICovXHJcbiAgcHVibGljIGFzeW5jIGdldENhY2hlZFRlbnNvcihcclxuICAgIHNlc3Npb25JZDogbnVtYmVyLFxyXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLFxyXG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgdXNhZ2U6IE1MVGVuc29yVXNhZ2VGbGFncyB8IHVuZGVmaW5lZCxcclxuICAgIHdyaXRhYmxlOiBib29sZWFuLFxyXG4gICAgcmVhZGFibGU6IGJvb2xlYW4sXHJcbiAgICBmYWxsYmFja0RhdGFUeXBlPzogTUxPcGVyYW5kRGF0YVR5cGUsXHJcbiAgKTogUHJvbWlzZTxUZW5zb3JXcmFwcGVyPiB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRNTENvbnRleHQoc2Vzc2lvbklkKTtcclxuICAgIGZvciAoY29uc3QgW2luZGV4LCB0ZW5zb3JdIG9mIHRoaXMuZnJlZVRlbnNvcnMuZW50cmllcygpKSB7XHJcbiAgICAgIGlmICh0ZW5zb3IuY2FuUmV1c2VUZW5zb3IoY29udGV4dCwgZGF0YVR5cGUsIHNoYXBlKSkge1xyXG4gICAgICAgIExPR19ERUJVRyhcclxuICAgICAgICAgICd2ZXJib3NlJyxcclxuICAgICAgICAgICgpID0+XHJcbiAgICAgICAgICAgIGBbV2ViTk5dIFJldXNpbmcgdGVuc29yIHtkYXRhVHlwZTogJHtkYXRhVHlwZX0sICR7XHJcbiAgICAgICAgICAgICAgZmFsbGJhY2tEYXRhVHlwZSA/IGBmYWxsYmFja0RhdGFUeXBlOiAke2ZhbGxiYWNrRGF0YVR5cGV9LGAgOiAnJ1xyXG4gICAgICAgICAgICB9IHNoYXBlOiAke3NoYXBlfWAsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy5mcmVlVGVuc29ycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xyXG4gICAgICAgIHdyYXBwZXIuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBMT0dfREVCVUcoXHJcbiAgICAgICd2ZXJib3NlJyxcclxuICAgICAgKCkgPT5cclxuICAgICAgICBgW1dlYk5OXSBNTENvbnRleHQuY3JlYXRlVGVuc29yIHtkYXRhVHlwZTogJHtkYXRhVHlwZX0sICR7XHJcbiAgICAgICAgICBmYWxsYmFja0RhdGFUeXBlID8gYGZhbGxiYWNrRGF0YVR5cGU6ICR7ZmFsbGJhY2tEYXRhVHlwZX0sYCA6ICcnXHJcbiAgICAgICAgfSBzaGFwZTogJHtzaGFwZX19YCxcclxuICAgICk7XHJcbiAgICBjb25zdCB0ZW5zb3IgPSBhd2FpdCBjb250ZXh0LmNyZWF0ZVRlbnNvcih7XHJcbiAgICAgIGRhdGFUeXBlOiBmYWxsYmFja0RhdGFUeXBlID8/IGRhdGFUeXBlLCAvLyBJZiBmYWxsYmFjayBkYXRhIHR5cGUgaXMgcHJvdmlkZWQsIHVzZSBpdC5cclxuICAgICAgc2hhcGUsXHJcbiAgICAgIGRpbWVuc2lvbnM6IHNoYXBlLFxyXG4gICAgICB1c2FnZSxcclxuICAgICAgd3JpdGFibGUsXHJcbiAgICAgIHJlYWRhYmxlLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3IFRlbnNvcldyYXBwZXIoeyBzZXNzaW9uSWQsIGNvbnRleHQsIHRlbnNvciwgZGF0YVR5cGUsIHNoYXBlLCBmYWxsYmFja0RhdGFUeXBlIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVsZWFzZSB0ZW5zb3IgZm9yIHJldXNlIHVubGVzcyBleHRlcm5hbC5cclxuICAgKi9cclxuICBwdWJsaWMgcmVsZWFzZVRlbnNvcih0ZW5zb3JXcmFwcGVyOiBUZW5zb3JXcmFwcGVyKSB7XHJcbiAgICBpZiAodGhpcy5leHRlcm5hbFRlbnNvcnMuaGFzKHRlbnNvcldyYXBwZXIpKSB7XHJcbiAgICAgIHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmRlbGV0ZSh0ZW5zb3JXcmFwcGVyKTtcclxuICAgIH1cclxuICAgIHRoaXMuZnJlZVRlbnNvcnMucHVzaCh0ZW5zb3JXcmFwcGVyKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVUZW5zb3JNYW5hZ2VyID0gKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgVGVuc29yTWFuYWdlckltcGw+KTogVGVuc29yTWFuYWdlciA9PlxyXG4gIG5ldyBUZW5zb3JNYW5hZ2VySW1wbCguLi5hcmdzKTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG4vLyBXZWJOTiBBUEkgY3VycmVudGx5IGRvZXMgbm90IGhhdmUgYSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZS4gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCB3aXRoIHR5cGVzIGdlbmVyYXRlZCBmcm9tXHJcbi8vIFdlYk5OIEFQSSBzcGVjaWZpY2F0aW9uLlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VibWFjaGluZWxlYXJuaW5nL3dlYm5uL2lzc3Vlcy82NzdcclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIndlYm5uL3dlYm5uLmQudHNcIiAvPlxyXG5cclxuaW1wb3J0IHsgRW52LCBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUsIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4uL3dhc20tZmFjdG9yeSc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVWaWV3IH0gZnJvbSAnLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFRlbnNvcklkLCBjcmVhdGVUZW5zb3JNYW5hZ2VyLCBjb252ZXJ0RGF0YVRvSW50MzIgfSBmcm9tICcuL3dlYm5uL3RlbnNvci1tYW5hZ2VyJztcclxuaW1wb3J0IHsgY29uZmlndXJlTG9nZ2VyLCBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XHJcblxyXG4vKlxyXG4gKiBUZW5zb3JQcm90bzo6ZGF0YV90eXBlIHRvIFdlYk5OIE9wZXJhbmRUeXBlIG1hcHBpbmcuXHJcbiAqL1xyXG5jb25zdCBvbm54RGF0YVR5cGVUb1dlYm5uRGF0YVR5cGUgPSBuZXcgTWFwPERhdGFUeXBlLCBNTE9wZXJhbmREYXRhVHlwZT4oW1xyXG4gIFtEYXRhVHlwZS5mbG9hdCwgJ2Zsb2F0MzInXSxcclxuICBbRGF0YVR5cGUuZmxvYXQxNiwgJ2Zsb2F0MTYnXSxcclxuICBbRGF0YVR5cGUuaW50MzIsICdpbnQzMiddLFxyXG4gIFtEYXRhVHlwZS51aW50MzIsICd1aW50MzInXSxcclxuICBbRGF0YVR5cGUuaW50NjQsICdpbnQ2NCddLFxyXG4gIFtEYXRhVHlwZS51aW50NjQsICd1aW50NjQnXSxcclxuICBbRGF0YVR5cGUuaW50NCwgJ2ludDQnXSxcclxuICBbRGF0YVR5cGUudWludDQsICd1aW50NCddLFxyXG4gIFtEYXRhVHlwZS5pbnQ4LCAnaW50OCddLFxyXG4gIFtEYXRhVHlwZS51aW50OCwgJ3VpbnQ4J10sXHJcbiAgW0RhdGFUeXBlLmJvb2wsICd1aW50OCddLFxyXG5dKTtcclxuXHJcbnR5cGUgTUxDb250ZXh0RW50cnkgPSB7XHJcbiAgZ3B1RGV2aWNlPzogR1BVRGV2aWNlO1xyXG4gIG9wdGlvbnM/OiBNTENvbnRleHRPcHRpb25zO1xyXG4gIG1sQ29udGV4dDogTUxDb250ZXh0O1xyXG59O1xyXG5cclxuY29uc3QgY29tcGFyZU1MQ29udGV4dE9wdGlvbnMgPSAoYT86IE1MQ29udGV4dE9wdGlvbnMsIGI/OiBNTENvbnRleHRPcHRpb25zKTogYm9vbGVhbiA9PiB7XHJcbiAgaWYgKGEgPT09IGIpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEpLnNvcnQoKSBhcyBBcnJheTxrZXlvZiB0eXBlb2YgYT47XHJcbiAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKS5zb3J0KCkgYXMgQXJyYXk8a2V5b2YgdHlwZW9mIGI+O1xyXG4gIHJldHVybiBhS2V5cy5sZW5ndGggPT09IGJLZXlzLmxlbmd0aCAmJiBhS2V5cy5ldmVyeSgoa2V5LCBpbmRleCkgPT4ga2V5ID09PSBiS2V5c1tpbmRleF0gJiYgYVtrZXldID09PSBiW2tleV0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdlYk5OIGJhY2tlbmQgaW1wbGVtZW50YXRpb24uIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBNTFRlbnNvcnMgY3JlYXRlZCBieSB0aGUgYmFja2VuZCBhbmQga2VlcCB0cmFja1xyXG4gKiBvZiB0aGUgY3VycmVudCBNTENvbnRleHQgYmVpbmcgdXNlZCBieSB0aGUgc2Vzc2lvbnMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViTk5CYWNrZW5kIHtcclxuICAvKipcclxuICAgKiBUZW5zb3IgbWFuYWdlcnMgZm9yIGVhY2ggc2Vzc2lvbi5cclxuICAgKi9cclxuICBwcml2YXRlIHRlbnNvck1hbmFnZXIgPSBjcmVhdGVUZW5zb3JNYW5hZ2VyKHRoaXMpO1xyXG4gIC8qKlxyXG4gICAqIE1hcHMgZnJvbSBzZXNzaW9uIGlkIHRvIE1MQ29udGV4dHMuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBtbENvbnRleHRCeVNlc3Npb25JZCA9IG5ldyBNYXA8bnVtYmVyLCBNTENvbnRleHQ+KCk7XHJcbiAgLyoqXHJcbiAgICogTWFwcyBmcm9tIE1MQ29udGV4dCB0byBzZXNzaW9uIGlkcy5cclxuICAgKi9cclxuICBwcml2YXRlIHNlc3Npb25JZHNCeU1MQ29udGV4dCA9IG5ldyBNYXA8TUxDb250ZXh0LCBTZXQ8bnVtYmVyPj4oKTtcclxuICAvKipcclxuICAgKiBDYWNoZSBvZiBNTENvbnRleHRzLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgbWxDb250ZXh0Q2FjaGU6IE1MQ29udGV4dEVudHJ5W10gPSBbXTtcclxuICAvKipcclxuICAgKiBDdXJyZW50IHNlc3Npb24gaWQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhY3RpdmVTZXNzaW9uSWQ/OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogTWFwcyBmcm9tIHNlc3Npb24gaWQgdG8gbGlzdCBvZiBncmFwaCBpbnB1dHMuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzZXNzaW9uR3JhcGhJbnB1dHM6IE1hcDxudW1iZXIsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcclxuICAvKipcclxuICAgKiBNYXBzIGZyb20gc2Vzc2lvbiBpZCB0byBsaXN0IG9mIGdyYXBoIG91dHB1dHMuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzZXNzaW9uR3JhcGhPdXRwdXRzOiBNYXA8bnVtYmVyLCBzdHJpbmdbXT4gPSBuZXcgTWFwKCk7XHJcbiAgLyoqXHJcbiAgICogVGVtcG9yYXJ5IGdyYXBoIGlucHV0cyBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cclxuICAgKiBUaGVzZSBpbnB1dHMgd2lsbCBiZSByZWdpc3RlcmVkIHdoZW4gdGhlIHNlc3Npb24gaXMgY3JlYXRlZC5cclxuICAgKi9cclxuICBwcml2YXRlIHRlbXBvcmFyeUdyYXBoSW5wdXRzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIC8qKlxyXG4gICAqIFRlbXBvcmFyeSBncmFwaCBvdXRwdXRzIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLlxyXG4gICAqIFRoZXNlIG91dHB1dHMgd2lsbCBiZSByZWdpc3RlcmVkIHdoZW4gdGhlIHNlc3Npb24gaXMgY3JlYXRlZC5cclxuICAgKi9cclxuICBwcml2YXRlIHRlbXBvcmFyeUdyYXBoT3V0cHV0czogc3RyaW5nW10gPSBbXTtcclxuICAvKipcclxuICAgKiBUZW1wb3JhcnkgdGVuc29ycyBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbi5cclxuICAgKi9cclxuICBwcml2YXRlIHRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHM6IE1hcDxudW1iZXIsIFRlbnNvcklkW10+ID0gbmV3IE1hcCgpO1xyXG4gIC8qKlxyXG4gICAqIE1hcHMgZnJvbSBzZXNzaW9uIGlkIHRvIE1MT3BTdXBwb3J0TGltaXRzLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgbWxPcFN1cHBvcnRMaW1pdHNCeVNlc3Npb25JZCA9IG5ldyBNYXA8bnVtYmVyLCBNTE9wU3VwcG9ydExpbWl0cz4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IoZW52OiBFbnYpIHtcclxuICAgIGNvbmZpZ3VyZUxvZ2dlcihlbnYubG9nTGV2ZWwhLCAhIWVudi5kZWJ1Zyk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IGN1cnJlbnRTZXNzaW9uSWQoKTogbnVtYmVyIHtcclxuICAgIGlmICh0aGlzLmFjdGl2ZVNlc3Npb25JZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWN0aXZlIHNlc3Npb24nKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmFjdGl2ZVNlc3Npb25JZDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBvblJ1blN0YXJ0KHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSBvblJ1blN0YXJ0IHtzZXNzaW9uSWQ6ICR7c2Vzc2lvbklkfX1gKTtcclxuICAgIHRoaXMuYWN0aXZlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIG9uUnVuRW5kKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSBvblJ1bkVuZCB7c2Vzc2lvbklkOiAke3Nlc3Npb25JZH19YCk7XHJcbiAgICBjb25zdCB0ZW5zb3JJZHMgPSB0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZ2V0KHNlc3Npb25JZCk7XHJcbiAgICBpZiAoIXRlbnNvcklkcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHRlbnNvcklkIG9mIHRlbnNvcklkcykge1xyXG4gICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSByZWxlYXNpbmcgdGVtcG9yYXJ5IHRlbnNvciB7dGVuc29ySWQ6ICR7dGVuc29ySWR9fWApO1xyXG4gICAgICB0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHRlbnNvcklkKTtcclxuICAgIH1cclxuICAgIHRoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5kZWxldGUoc2Vzc2lvbklkKTtcclxuICAgIHRoaXMuYWN0aXZlU2Vzc2lvbklkID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGNyZWF0ZU1MQ29udGV4dChvcHRpb25zT3JEZXZpY2U/OiBNTENvbnRleHRPcHRpb25zIHwgR1BVRGV2aWNlKTogUHJvbWlzZTxNTENvbnRleHQ+IHtcclxuICAgIGlmIChvcHRpb25zT3JEZXZpY2UgaW5zdGFuY2VvZiBHUFVEZXZpY2UpIHtcclxuICAgICAgY29uc3QgbWxDb250ZXh0SW5kZXggPSB0aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5LmdwdURldmljZSA9PT0gb3B0aW9uc09yRGV2aWNlKTtcclxuICAgICAgaWYgKG1sQ29udGV4dEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW21sQ29udGV4dEluZGV4XS5tbENvbnRleHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbWxDb250ZXh0ID0gYXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQob3B0aW9uc09yRGV2aWNlKTtcclxuICAgICAgICB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goeyBncHVEZXZpY2U6IG9wdGlvbnNPckRldmljZSwgbWxDb250ZXh0IH0pO1xyXG4gICAgICAgIHJldHVybiBtbENvbnRleHQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAob3B0aW9uc09yRGV2aWNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3QgbWxDb250ZXh0SW5kZXggPSB0aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChcclxuICAgICAgICAoZW50cnkpID0+IGVudHJ5Lm9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiBlbnRyeS5ncHVEZXZpY2UgPT09IHVuZGVmaW5lZCxcclxuICAgICAgKTtcclxuICAgICAgaWYgKG1sQ29udGV4dEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW21sQ29udGV4dEluZGV4XS5tbENvbnRleHQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbWxDb250ZXh0ID0gYXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtcclxuICAgICAgICB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goeyBtbENvbnRleHQgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1sQ29udGV4dDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1sQ29udGV4dEluZGV4ID0gdGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoKGVudHJ5KSA9PlxyXG4gICAgICBjb21wYXJlTUxDb250ZXh0T3B0aW9ucyhlbnRyeS5vcHRpb25zLCBvcHRpb25zT3JEZXZpY2UpLFxyXG4gICAgKTtcclxuICAgIGlmIChtbENvbnRleHRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbWxDb250ZXh0SW5kZXhdLm1sQ29udGV4dDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IG1sQ29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KG9wdGlvbnNPckRldmljZSk7XHJcbiAgICAgIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7IG9wdGlvbnM6IG9wdGlvbnNPckRldmljZSwgbWxDb250ZXh0IH0pO1xyXG4gICAgICByZXR1cm4gbWxDb250ZXh0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlZ2lzdGVyTUxDb250ZXh0KHNlc3Npb25JZDogbnVtYmVyLCBtbENvbnRleHQ6IE1MQ29udGV4dCk6IHZvaWQge1xyXG4gICAgdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5zZXQoc2Vzc2lvbklkLCBtbENvbnRleHQpO1xyXG4gICAgbGV0IHNlc3Npb25JZHMgPSB0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQobWxDb250ZXh0KTtcclxuICAgIGlmICghc2Vzc2lvbklkcykge1xyXG4gICAgICBzZXNzaW9uSWRzID0gbmV3IFNldCgpO1xyXG4gICAgICB0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5zZXQobWxDb250ZXh0LCBzZXNzaW9uSWRzKTtcclxuICAgIH1cclxuICAgIHNlc3Npb25JZHMuYWRkKHNlc3Npb25JZCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLm1sT3BTdXBwb3J0TGltaXRzQnlTZXNzaW9uSWQuaGFzKHNlc3Npb25JZCkpIHtcclxuICAgICAgdGhpcy5tbE9wU3VwcG9ydExpbWl0c0J5U2Vzc2lvbklkLnNldChzZXNzaW9uSWQsIG1sQ29udGV4dC5vcFN1cHBvcnRMaW1pdHMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLnNlc3Npb25HcmFwaElucHV0cy5zZXQoc2Vzc2lvbklkLCB0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzKTtcclxuICAgICAgdGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cyA9IFtdO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMudGVtcG9yYXJ5R3JhcGhPdXRwdXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5zZXNzaW9uR3JhcGhPdXRwdXRzLnNldChzZXNzaW9uSWQsIHRoaXMudGVtcG9yYXJ5R3JhcGhPdXRwdXRzKTtcclxuICAgICAgdGhpcy50ZW1wb3JhcnlHcmFwaE91dHB1dHMgPSBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLnNlc3Npb25HcmFwaElucHV0cy5kZWxldGUoc2Vzc2lvbklkKTtcclxuICAgIHRoaXMuc2Vzc2lvbkdyYXBoT3V0cHV0cy5kZWxldGUoc2Vzc2lvbklkKTtcclxuICAgIGNvbnN0IG1sQ29udGV4dCA9IHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZ2V0KHNlc3Npb25JZCkhO1xyXG4gICAgaWYgKCFtbENvbnRleHQpIHtcclxuICAgICAgLy8gQ3VycmVudCBzZXNzaW9uIGlzIG5vdCBhIFdlYk5OIHNlc3Npb24uXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24oc2Vzc2lvbklkKTtcclxuICAgIHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICB0aGlzLm1sT3BTdXBwb3J0TGltaXRzQnlTZXNzaW9uSWQuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICBjb25zdCBzZXNzaW9uSWRzID0gdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KG1sQ29udGV4dCkhO1xyXG4gICAgc2Vzc2lvbklkcy5kZWxldGUoc2Vzc2lvbklkKTtcclxuICAgIGlmIChzZXNzaW9uSWRzLnNpemUgPT09IDApIHtcclxuICAgICAgdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZGVsZXRlKG1sQ29udGV4dCk7XHJcbiAgICAgIGNvbnN0IG1sQ29udGV4dEluZGV4ID0gdGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5tbENvbnRleHQgPT09IG1sQ29udGV4dCk7XHJcbiAgICAgIGlmIChtbENvbnRleHRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICB0aGlzLm1sQ29udGV4dENhY2hlLnNwbGljZShtbENvbnRleHRJbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRNTENvbnRleHQoc2Vzc2lvbklkOiBudW1iZXIpOiBNTENvbnRleHQgfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZ2V0KHNlc3Npb25JZCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0TUxPcFN1cHBvcnRMaW1pdHMoc2Vzc2lvbklkOiBudW1iZXIpOiBNTE9wU3VwcG9ydExpbWl0cyB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5tbE9wU3VwcG9ydExpbWl0c0J5U2Vzc2lvbklkLmdldChzZXNzaW9uSWQpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlc2VydmVUZW5zb3JJZCgpOiBUZW5zb3JJZCB7XHJcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZDogVGVuc29ySWQpOiB2b2lkIHtcclxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViTk5dIHJlbGVhc2VUZW5zb3JJZCB7dGVuc29ySWQ6ICR7dGVuc29ySWR9fWApO1xyXG4gICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZW5zdXJlVGVuc29yKFxyXG4gICAgc2Vzc2lvbklkOiBudW1iZXIgfCB1bmRlZmluZWQsXHJcbiAgICB0ZW5zb3JJZDogVGVuc29ySWQsXHJcbiAgICBvbm54RGF0YVR5cGU6IERhdGFUeXBlLFxyXG4gICAgZGltZW5zaW9uczogbnVtYmVyW10sXHJcbiAgICBjb3B5T2xkOiBib29sZWFuLFxyXG4gICk6IFByb21pc2U8TUxUZW5zb3I+IHtcclxuICAgIGNvbnN0IHdlYm5uRGF0YVR5cGUgPSBvbm54RGF0YVR5cGVUb1dlYm5uRGF0YVR5cGUuZ2V0KG9ubnhEYXRhVHlwZSk7XHJcbiAgICBpZiAoIXdlYm5uRGF0YVR5cGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtvbm54RGF0YVR5cGV9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvcihcclxuICAgICAgc2Vzc2lvbklkID8/IHRoaXMuY3VycmVudFNlc3Npb25JZCxcclxuICAgICAgdGVuc29ySWQsXHJcbiAgICAgIHdlYm5uRGF0YVR5cGUsXHJcbiAgICAgIGRpbWVuc2lvbnMsXHJcbiAgICAgIGNvcHlPbGQsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGNyZWF0ZVRlbXBvcmFyeVRlbnNvcihcclxuICAgIHNlc3Npb25JZDogbnVtYmVyLFxyXG4gICAgb25ueERhdGFUeXBlOiBEYXRhVHlwZSxcclxuICAgIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICApOiBQcm9taXNlPFRlbnNvcklkPiB7XHJcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSBjcmVhdGVUZW1wb3JhcnlUZW5zb3Ige29ubnhEYXRhVHlwZTogJHtvbm54RGF0YVR5cGV9LCBzaGFwZTogJHtzaGFwZX19YCk7XHJcbiAgICBjb25zdCBkYXRhVHlwZSA9IG9ubnhEYXRhVHlwZVRvV2Vibm5EYXRhVHlwZS5nZXQob25ueERhdGFUeXBlKTtcclxuICAgIGlmICghZGF0YVR5cGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtvbm54RGF0YVR5cGV9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0ZW5zb3JJZCA9IHRoaXMudGVuc29yTWFuYWdlci5yZXNlcnZlVGVuc29ySWQoKTtcclxuICAgIGF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCB0ZW5zb3JJZCwgZGF0YVR5cGUsIHNoYXBlLCBmYWxzZSk7XHJcbiAgICBjb25zdCB0ZW5zb3JJZHMgPSB0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZ2V0KHNlc3Npb25JZCk7XHJcbiAgICBpZiAoIXRlbnNvcklkcykge1xyXG4gICAgICB0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuc2V0KHNlc3Npb25JZCwgW3RlbnNvcklkXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0ZW5zb3JJZHMucHVzaCh0ZW5zb3JJZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVuc29ySWQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdXBsb2FkVGVuc29yKHRlbnNvcklkOiBUZW5zb3JJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xyXG4gICAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XHJcbiAgICBpZiAoIXdhc20uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHVwbG9hZCB0byBhIE1MVGVuc29yIHdoaWxlIHNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciBpcyBmYWxzZScpO1xyXG4gICAgfVxyXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gdXBsb2FkVGVuc29yIHt0ZW5zb3JJZDogJHt0ZW5zb3JJZH0sIGRhdGE6ICR7ZGF0YS5ieXRlTGVuZ3RofX1gKTtcclxuICAgIHRoaXMudGVuc29yTWFuYWdlci51cGxvYWQodGVuc29ySWQsIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGRvd25sb2FkVGVuc29yKHRlbnNvcklkOiBUZW5zb3JJZCwgZHN0QnVmZmVyOiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IFByb21pc2U8dW5kZWZpbmVkPiB7XHJcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHRlbnNvcklkLCBkc3RCdWZmZXIpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0ZW5zb3JJZDogVGVuc29ySWQsIHR5cGU6IFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcyk6ICgpID0+IFByb21pc2U8VGVuc29yLkRhdGFUeXBlPiB7XHJcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHRlbnNvcklkKTtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVZpZXcoZGF0YSwgdHlwZSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlZ2lzdGVyTUxUZW5zb3Ioc2Vzc2lvbklkOiBudW1iZXIsIHRlbnNvcjogTUxUZW5zb3IsIG9ubnhEYXRhVHlwZTogRGF0YVR5cGUsIGRpbWVuc2lvbnM6IG51bWJlcltdKTogVGVuc29ySWQge1xyXG4gICAgY29uc3Qgd2Vibm5EYXRhVHlwZSA9IG9ubnhEYXRhVHlwZVRvV2Vibm5EYXRhVHlwZS5nZXQob25ueERhdGFUeXBlKTtcclxuICAgIGlmICghd2Vibm5EYXRhVHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke29ubnhEYXRhVHlwZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpZCA9IHRoaXMudGVuc29yTWFuYWdlci5yZWdpc3RlclRlbnNvcihzZXNzaW9uSWQsIHRlbnNvciwgd2Vibm5EYXRhVHlwZSwgZGltZW5zaW9ucyk7XHJcbiAgICBMT0dfREVCVUcoXHJcbiAgICAgICd2ZXJib3NlJyxcclxuICAgICAgKCkgPT5cclxuICAgICAgICBgW1dlYk5OXSByZWdpc3Rlck1MVGVuc29yIHt0ZW5zb3I6ICR7dGVuc29yfSwgZGF0YVR5cGU6ICR7d2Vibm5EYXRhVHlwZX0sIGRpbWVuc2lvbnM6ICR7XHJcbiAgICAgICAgICBkaW1lbnNpb25zXHJcbiAgICAgICAgfX0gLT4ge3RlbnNvcklkOiAke2lkfX1gLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBpZDtcclxuICB9XHJcblxyXG4gIC8vIFJlZ2lzdGVyIGEgV2ViTk4gQ29uc3RhbnQgb3BlcmFuZCBmcm9tIGV4dGVybmFsIGRhdGEuXHJcbiAgcHVibGljIHJlZ2lzdGVyTUxDb25zdGFudChcclxuICAgIGV4dGVybmFsRmlsZVBhdGg6IHN0cmluZyxcclxuICAgIGRhdGFPZmZzZXQ6IG51bWJlcixcclxuICAgIGRhdGFMZW5ndGg6IG51bWJlcixcclxuICAgIGJ1aWxkZXI6IE1MR3JhcGhCdWlsZGVyLFxyXG4gICAgZGVzYzogTUxPcGVyYW5kRGVzY3JpcHRvcixcclxuICAgIG1vdW50ZWRGaWxlczogTWFwPHN0cmluZywgVWludDhBcnJheT4gfCB1bmRlZmluZWQsXHJcbiAgICBzaG91bGRDb252ZXJ0SW50NjRUb0ludDMyID0gZmFsc2UsXHJcbiAgKTogTUxPcGVyYW5kIHtcclxuICAgIC8vIElmIGF2YWlsYWJsZSwgXCJNb2R1bGUuTW91bnRlZEZpbGVzXCIgaXMgYSBNYXAgZm9yIGFsbCBwcmVsb2FkZWQgZmlsZXMuXHJcbiAgICBpZiAoIW1vdW50ZWRGaWxlcykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVybmFsIG1vdW50ZWQgZmlsZXMgYXJlIG5vdCBhdmFpbGFibGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGZpbGVQYXRoID0gZXh0ZXJuYWxGaWxlUGF0aDtcclxuICAgIGlmIChleHRlcm5hbEZpbGVQYXRoLnN0YXJ0c1dpdGgoJy4vJykpIHtcclxuICAgICAgZmlsZVBhdGggPSBleHRlcm5hbEZpbGVQYXRoLnN1YnN0cmluZygyKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbGVEYXRhID0gbW91bnRlZEZpbGVzLmdldChmaWxlUGF0aCk7XHJcbiAgICBpZiAoIWZpbGVEYXRhKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHtmaWxlUGF0aH0gbm90IGZvdW5kIGluIHByZWxvYWRlZCBmaWxlcy5gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0YU9mZnNldCArIGRhdGFMZW5ndGggPiBmaWxlRGF0YS5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3V0IG9mIGJvdW5kczogZGF0YSBvZmZzZXQgYW5kIGxlbmd0aCBleGNlZWQgdGhlIGV4dGVybmFsIGZpbGUgZGF0YSBzaXplLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJ1ZmZlciA9IGZpbGVEYXRhLnNsaWNlKGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBkYXRhTGVuZ3RoKS5idWZmZXI7XHJcbiAgICBsZXQgYnVmZmVyVmlldzogQXJyYXlCdWZmZXJWaWV3O1xyXG4gICAgc3dpdGNoIChkZXNjLmRhdGFUeXBlKSB7XHJcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2Zsb2F0MTYnOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPVxyXG4gICAgICAgICAgdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb20gPyBuZXcgRmxvYXQxNkFycmF5KGJ1ZmZlcikgOiBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnaW50MzInOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgSW50MzJBcnJheShidWZmZXIpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd1aW50MzInOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnaW50NjQnOlxyXG4gICAgICAgIGlmIChzaG91bGRDb252ZXJ0SW50NjRUb0ludDMyKSB7XHJcbiAgICAgICAgICAvLyBJbnQ2NCBpcyBub3Qgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgY29udGV4dCwgdXNlIGludDMyIGluc3RlYWQuXHJcbiAgICAgICAgICBjb25zdCBpbnQzMkJ1ZmZlciA9IGNvbnZlcnREYXRhVG9JbnQzMihuZXcgVWludDhBcnJheShidWZmZXIpLCAnaW50NjQnKTtcclxuICAgICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgSW50MzJBcnJheShpbnQzMkJ1ZmZlci5idWZmZXIpO1xyXG4gICAgICAgICAgZGVzYy5kYXRhVHlwZSA9ICdpbnQzMic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgQmlnSW50NjRBcnJheShidWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndWludDY0JzpcclxuICAgICAgICBidWZmZXJWaWV3ID0gbmV3IEJpZ1VpbnQ2NEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2ludDgnOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgSW50OEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2ludDQnOlxyXG4gICAgICBjYXNlICd1aW50NCc6XHJcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcclxuICAgICAgICBidWZmZXJWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkZXNjLmRhdGFUeXBlfSBpbiBjcmVhdGluZyBXZWJOTiBDb25zdGFudCBmcm9tIGV4dGVybmFsIGRhdGEuYCk7XHJcbiAgICB9XHJcblxyXG4gICAgTE9HX0RFQlVHKFxyXG4gICAgICAndmVyYm9zZScsXHJcbiAgICAgICgpID0+XHJcbiAgICAgICAgYFtXZWJOTl0gcmVnaXN0ZXJNTENvbnN0YW50IHtkYXRhVHlwZTogJHtkZXNjLmRhdGFUeXBlfSwgc2hhcGU6ICR7ZGVzYy5zaGFwZX19fSAke1xyXG4gICAgICAgICAgc2hvdWxkQ29udmVydEludDY0VG9JbnQzMiA/ICcoTm90ZTogaXQgd2FzIGludDY0IGRhdGEgdHlwZSBhbmQgcmVnaXN0ZXJlZCB0byBpbnQzMiBhcyB3b3JrYXJvdW5kKScgOiAnJ1xyXG4gICAgICAgIH1gLFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gYnVpbGRlci5jb25zdGFudChkZXNjLCBidWZmZXJWaWV3KTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZWdpc3RlckdyYXBoSW5wdXQoaW5wdXROYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMucHVzaChpbnB1dE5hbWUpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlZ2lzdGVyR3JhcGhPdXRwdXQob3V0cHV0TmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cy5wdXNoKG91dHB1dE5hbWUpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGlzR3JhcGhJbnB1dChzZXNzaW9uSWQ6IG51bWJlciwgaW5wdXROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGlucHV0TmFtZXMgPSB0aGlzLnNlc3Npb25HcmFwaElucHV0cy5nZXQoc2Vzc2lvbklkKTtcclxuICAgIGlmICghaW5wdXROYW1lcykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5wdXROYW1lcy5pbmNsdWRlcyhpbnB1dE5hbWUpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGlzR3JhcGhPdXRwdXQoc2Vzc2lvbklkOiBudW1iZXIsIG91dHB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgb3V0cHV0TmFtZXMgPSB0aGlzLnNlc3Npb25HcmFwaE91dHB1dHMuZ2V0KHNlc3Npb25JZCk7XHJcbiAgICBpZiAoIW91dHB1dE5hbWVzKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXROYW1lcy5pbmNsdWRlcyhvdXRwdXROYW1lKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBpc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkKHNlc3Npb25JZDogbnVtYmVyLCB0eXBlOiBUZW5zb3IuVHlwZSwgaXNJbnB1dCA9IHRydWUpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGRhdGFUeXBlID0gb25ueERhdGFUeXBlVG9XZWJubkRhdGFUeXBlLmdldCh0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSh0eXBlKSk7XHJcbiAgICBjb25zdCBvcExpbWl0cyA9IHRoaXMubWxPcFN1cHBvcnRMaW1pdHNCeVNlc3Npb25JZC5nZXQoc2Vzc2lvbklkKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGFUeXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzSW5wdXQpIHtcclxuICAgICAgcmV0dXJuICEhb3BMaW1pdHM/LmlucHV0LmRhdGFUeXBlcy5pbmNsdWRlcyhkYXRhVHlwZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gISFvcExpbWl0cz8ub3V0cHV0LmRhdGFUeXBlcy5pbmNsdWRlcyhkYXRhVHlwZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZmx1c2goKTogdm9pZCB7XHJcbiAgICAvLyBVbmxpa2UgdGhlIFdlYkdQVSBiYWNrZW5kLCB0aGUgV2ViTk4gYmFja2VuZCBkb2VzIG5vdCBuZWVkIHRvIGZsdXNoIGFueSBwZW5kaW5nIG9wZXJhdGlvbnMuXHJcbiAgfVxyXG59XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi90ZW5zb3Itdmlldyc7XHJcblxyXG5pbXBvcnQgeyBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL29wcy9jb21tb24nO1xyXG5cclxuZXhwb3J0IHR5cGUgU2Vzc2lvblN0YXRlID0gJ2RlZmF1bHQnIHwgJ2NhcHR1cmluZycgfCAncmVwbGF5aW5nJztcclxuXHJcbmV4cG9ydCBlbnVtIEdwdURhdGFUeXBlIHtcclxuICBkZWZhdWx0ID0gMCxcclxuICB1cGxvYWQgPSAxLFxyXG4gIHByb2ZpbGUgPSAyLFxyXG59XHJcbmV4cG9ydCB0eXBlIEdwdURhdGFJZCA9IG51bWJlcjtcclxuXHJcbmV4cG9ydCB0eXBlIEdwdUFyY2hpdGVjdHVyZSA9ICdhbXBlcmUnIHwgJ2dlbi0xMmxwJztcclxuZXhwb3J0IHR5cGUgR3B1VmVuZG9yID0gJ2FtZCcgfCAnaW50ZWwnIHwgJ252aWRpYSc7XHJcbmV4cG9ydCBpbnRlcmZhY2UgQWRhcHRlckluZm8ge1xyXG4gIGlzQXJjaGl0ZWN0dXJlOiAoYXJjaGl0ZWN0dXJlOiBHcHVBcmNoaXRlY3R1cmUpID0+IGJvb2xlYW47XHJcbiAgaXNWZW5kb3I6ICh2ZW5kb3I6IEdwdVZlbmRvcikgPT4gYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHcHVEYXRhIHtcclxuICB0eXBlOiBHcHVEYXRhVHlwZTtcclxuICBpZDogR3B1RGF0YUlkO1xyXG4gIGJ1ZmZlcjogR1BVQnVmZmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckluZm8ge1xyXG4gIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gIGRhdGFUeXBlOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVVuaWZvcm0ge1xyXG4gIHR5cGU6IERhdGFUeXBlO1xyXG4gIGRhdGE6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBQcm9ncmFtVW5pZm9ybVZhcmlhYmxlSW5mbyA9IFt0eXBlOiBEYXRhVHlwZSwgbGVuZ3RoOiBudW1iZXJdO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudCB0aGUgZGVwZW5kZW5jeSBvZiBhIHByb2dyYW0gb24gYSBzcGVjaWZpYyBpbnB1dCB0ZW5zb3IuXHJcbiAqXHJcbiAqIC0gJ25vbmUnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZG9lcyBub3QgZGVwZW5kIG9uIHRoaXMgaW5wdXQncyBpbmZvXHJcbiAqIC0gJ3R5cGUnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgb2YgdGhpcyBpbnB1dFxyXG4gKiAtICdyYW5rJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIGFuZCB0aGUgcmFuayBvZiB0aGlzIGlucHV0XHJcbiAqIC0gJ2RpbXMnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgYW5kIHRoZSBkaW1zIG9mIHRoaXMgaW5wdXRcclxuICogLSAnZGF0YSc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSwgdGhlIGRpbXMgYW5kIHRoZSBkYXRhIG9mIHRoaXMgaW5wdXRcclxuICovXHJcbmV4cG9ydCB0eXBlIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5ID0gJ25vbmUnIHwgJ3R5cGUnIHwgJ3JhbmsnIHwgJ2RpbXMnIHwgJ2RhdGEnO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIHByb2dyYW0ncyBjYWNoZSBmb3Igc2hhZGVyLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvIHtcclxuICAvKipcclxuICAgKiBhbiBvcHRpb25hbCBzdHJpbmcgYXMgYSBjYWNoZSBoaW50IGluIHRoZSBhcnRpZmFjdCBjYWNoZS4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgY2FjaGUgaGludCB3aWxsIGJlIGVtcHR5LlxyXG4gICAqXHJcbiAgICogVGhpcyBoaW50IHN0cmluZyBzaG91bGQgb25seSBjb250YWlucyBpbml0aWFsaXppbmctdGltZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgYXR0cmlidXRlcyBvciBhbnkgaW5mb3JtYXRpb24gb2ZcclxuICAgKiBpbml0aWFsaXplcnMuIEl0IHNob3VsZCBOT1QgY29udGFpbiBhbnkgcnVudGltZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgc2hhcGUgb2YgaW5wdXRzLlxyXG4gICAqL1xyXG4gIGhpbnQ/OiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIGFuIG9wdGlvbmFsIGxpc3Qgb2YgZGVwZW5kZW5jaWVzIG9mIHRoZSBwcm9ncmFtIG9uIHRoZSBpbnB1dCB0ZW5zb3JzLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBwcm9ncmFtIGRlcGVuZHNcclxuICAgKiBvbiAnZGltcycgb2YgYWxsIGlucHV0cy5cclxuICAgKi9cclxuICBpbnB1dERlcGVuZGVuY2llcz86IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBwcm9ncmFtJ3MgY2FjaGUgZm9yIHVuaWZvcm0uXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1Vbmlmb3JtQ2FjaGVJbmZvIHtcclxuICAvKipcclxuICAgKiBhbiBvcHRpb25hbCBzdHJpbmcgYXMgYSBjYWNoZSBoaW50IGluIHRoZSB1bmlmb3JtIGNhY2hlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjYWNoZSBoaW50IHdpbGwgYmUgZW1wdHkuXHJcbiAgICpcclxuICAgKiBUaGlzIGhpbnQgc3RyaW5nIHNob3VsZCBvbmx5IGNvbnRhaW5zIHJ1bnRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIHNoYXBlIG9mIGlucHV0cy5cclxuICAgKi9cclxuICBoaW50Pzogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBhbiBvcHRpb25hbCBsaXN0IG9mIGRlcGVuZGVuY2llcyBvZiB0aGUgcHJvZ3JhbSBvbiB0aGUgaW5wdXQgdGVuc29ycy4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgcHJvZ3JhbSBkZXBlbmRzXHJcbiAgICogb24gJ25vbmUnIG9mIGFsbCBpbnB1dHMuXHJcbiAgICovXHJcbiAgaW5wdXREZXBlbmRlbmNpZXM/OiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdO1xyXG59XHJcblxyXG4vKipcclxuICogQSBzZXQgb2YgZGF0YSB0aGF0IHJlcHJlc2VudCBhIHNoYWRlciBwcm9ncmFtXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1JbmZvIHtcclxuICAvKipcclxuICAgKiB0aGUgbmFtZSBvZiB0aGUgcHJvZ3JhbS4gdXNlZCBmb3IgZGVidWdnaW5nIGFuZCBwcm9maWxpbmdcclxuICAgKi9cclxuICBuYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIGFuIG9wdGlvbmFsIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjYWNoZSBpbmZvcm1hdGlvbiBvZiB0aGUgcHJvZ3JhbSBzaGFkZXIuXHJcbiAgICpcclxuICAgKiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBoaW50IGlzIGVtcHR5IGFuZCBpbnB1dERlcGVuZGVuY2llcyBhcmUgWydkaW1zJ10gZm9yIGFsbCBpbnB1dHMuXHJcbiAgICovXHJcbiAgc2hhZGVyQ2FjaGU/OiBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvO1xyXG5cclxuICAvKipcclxuICAgKiB0aGUgc2hhZGVyJ3MgcHJvY2Vzc2luZyBzb3VyY2UgY29kZS5cclxuICAgKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBzaGFkZXIgY2FjaGUgbWlzc2VkLlxyXG4gICAqL1xyXG4gIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgZnVuY3Rpb24gdG8gZ2V0IHJ1biBkYXRhIHJlcXVpcmVkIHRvIHJ1biB0aGUgcHJvZ3JhbS5cclxuICAgKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgcHJvZ3JhbSBpcyBleGVjdXRlZC4gU2hvdWxkIGtlZXAgdGhpcyBmdW5jdGlvbiBhcyBzaW1wbGUgYXMgcG9zc2libGUuXHJcbiAgICovXHJcbiAgZ2V0UnVuRGF0YTogKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKSA9PiB7XHJcbiAgICBvdXRwdXRzOiByZWFkb25seSBUZW5zb3JJbmZvW107XHJcbiAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IG51bWJlcjsgeT86IG51bWJlcjsgej86IG51bWJlciB9O1xyXG4gICAgcHJvZ3JhbVVuaWZvcm1zPzogcmVhZG9ubHkgUHJvZ3JhbVVuaWZvcm1bXTtcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFydGlmYWN0IHtcclxuICBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm87XHJcbiAgY29tcHV0ZVBpcGVsaW5lOiBHUFVDb21wdXRlUGlwZWxpbmU7XHJcbiAgdW5pZm9ybVZhcmlhYmxlc0luZm86IHJlYWRvbmx5IFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvW10gfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyB7XHJcbiAgLyoqXHJcbiAgICogc3BlY2lmeSB0aGUgbWFwcGluZyB0byB0aGUgcHJvZ3JhbSdzIGlucHV0cy4gdGhlIHZhbHVlIGNhbiBiZSBhIG51bWJlciBvciBhIHRlbnNvciB2aWV3LlxyXG4gICAqIC0gaWYgaXQncyBhIG51bWJlciwgaXQncyB0aGUgaW5kZXggb2YgdGhlIGtlcm5lbCdzIGlucHV0XHJcbiAgICogLSBpZiBpdCdzIGEgdGVuc29yIHZpZXcsIGl0J3MgYW4gZXhpc3RpbmcgdGVuc29yIHZpZXcgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGlucHV0XHJcbiAgICpcclxuICAgKiBpZiBpbnB1dHMgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1hcHBpbmcgd2lsbCBiZSB0aGUga2VybmVsJ3MgaW5wdXRzIGluIG9yZGVyLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGlucHV0cz86IFJlYWRvbmx5QXJyYXk8VGVuc29yVmlldyB8IG51bWJlcj47XHJcbiAgLyoqXHJcbiAgICogc3BlY2lmeSB0aGUgbWFwcGluZyB0byB0aGUgcHJvZ3JhbSdzIG91dHB1dHMuIHRoZSB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLlxyXG4gICAqIC0gaWYgaXQncyBhIG5vbi1uZWdhdGl2ZSBudW1iZXIsIGl0J3MgdGhlIGluZGV4IG9mIHRoZSBrZXJuZWwncyBvdXRwdXRcclxuICAgKiAtIGlmIGl0J3MgLTEsIGl0J3MgYW4gb3V0cHV0IHRoYXQgd2lsbCBiZSBjcmVhdGVkIGFzIGEgdGVtcG9yYXJ5IHZhbHVlLiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVsZWFzZWQgYWZ0ZXJcclxuICAgKiB0aGUga2VybmVsIGlzIGV4ZWN1dGVkLlxyXG4gICAqIC0gaWYgaXQncyAtMiwgaXQncyBhbiBvdXRwdXQgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgYXMgYSBwZXJzaXN0ZW50IHZhbHVlLiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB0aGVcclxuICAgKiBrZXJuZWwgaXMgcmVsZWFzZWQuXHJcbiAgICpcclxuICAgKiBpZiBvdXRwdXRzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBtYXBwaW5nIHdpbGwgYmUgdGhlIGtlcm5lbCdzIG91dHB1dHMgaW4gb3JkZXIuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgb3V0cHV0cz86IHJlYWRvbmx5IG51bWJlcltdO1xyXG59XHJcblxyXG4vKipcclxuICogQSBDb21wdXRlQ29udGV4dCBpbnN0YW5jZSBjYXJyaWVzIHRoZSBzdGF0ZXMgdGhhdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcnVubmluZyBvZiBhIGtlcm5lbC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHV0ZUNvbnRleHQge1xyXG4gIC8qKlxyXG4gICAqIGdwdSBhZGFwdGVyIGluZm9cclxuICAgKi9cclxuICByZWFkb25seSBhZGFwdGVySW5mbzogQWRhcHRlckluZm87XHJcblxyXG4gIC8qKlxyXG4gICAqIHN0b3JlcyB0aGUgcG9pbnRlciB0byBPcEtlcm5lbENvbnRleHRcclxuICAgKi9cclxuICByZWFkb25seSBvcEtlcm5lbENvbnRleHQ6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogYSBsaXN0IG9mIGlucHV0cywgZWFjaCBpbnB1dCBpcyBhbiBpbnN0YW5jZSBvZiBUZW5zb3JWaWV3XHJcbiAgICovXHJcbiAgcmVhZG9ubHkgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W107XHJcblxyXG4gIC8qKlxyXG4gICAqIGEgY3VzdG9tIGRhdGEgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYW55IGRhdGEgdGhhdCBpcyBuZWVkZWQgYnkgdGhlIGtlcm5lbFxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGtlcm5lbEN1c3RvbURhdGE6IHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9O1xyXG5cclxuICAvKipcclxuICAgKiBhIGJ1ZmZlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGFjY2VzcyBjdXN0b20gZGF0YSBjcmVhdGVkIGVhY2ggdGltZSB0aGUga2VybmVsIGlzIGV4ZWN1dGVkXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgY3VzdG9tRGF0YUJ1ZmZlcjogVWludDhBcnJheTtcclxuXHJcbiAgLyoqXHJcbiAgICogYSBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhlIG5vZGVcclxuICAgKi9cclxuICByZWFkb25seSBvdXRwdXRDb3VudDogbnVtYmVyO1xyXG5cclxuICBjb21wdXRlKHByb2dyYW06IFByb2dyYW1JbmZvLCBpbnB1dHNPdXRwdXRzTWFwcGluZz86IENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcpOiBUZW5zb3JWaWV3W107XHJcbiAgb3V0cHV0KGluZGV4OiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBUaW1lc3RhbXBRdWVyeSA9ICdub25lJyB8ICdpbnNpZGUtcGFzc2VzJyB8ICdhdC1wYXNzZXMnO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IFdlYkdwdUJhY2tlbmQgfSBmcm9tICcuLi9iYWNrZW5kLXdlYmdwdSc7XHJcbmltcG9ydCB7IExPR19ERUJVRyB9IGZyb20gJy4uL2xvZyc7XHJcblxyXG5pbXBvcnQgeyBHcHVEYXRhLCBHcHVEYXRhSWQsIEdwdURhdGFUeXBlIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG4vKipcclxuICogbWFuYWdlcyBHcHVEYXRhSWQgLT4gR3B1QnVmZmVyXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEdwdURhdGFNYW5hZ2VyIHtcclxuICAvKipcclxuICAgKiBjb3B5IGRhdGEgZnJvbSBDUFUgdG8gR1BVLlxyXG4gICAqL1xyXG4gIHVwbG9hZChpZDogR3B1RGF0YUlkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZDtcclxuICAvKipcclxuICAgKiBjb3B5IGRhdGEgZnJvbSBHUFUgdG8gR1BVLlxyXG4gICAqL1xyXG4gIG1lbWNweShzb3VyY2VJZDogR3B1RGF0YUlkLCBkZXN0aW5hdGlvbklkOiBHcHVEYXRhSWQpOiB2b2lkO1xyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBuZXcgZGF0YSBvbiBHUFUuXHJcbiAgICovXHJcbiAgY3JlYXRlKHNpemU6IG51bWJlciwgdXNhZ2U/OiBudW1iZXIpOiBHcHVEYXRhO1xyXG4gIC8qKlxyXG4gICAqIGdldCBHUFUgZGF0YSBieSBJRC5cclxuICAgKi9cclxuICBnZXQoaWQ6IEdwdURhdGFJZCk6IEdwdURhdGEgfCB1bmRlZmluZWQ7XHJcbiAgLyoqXHJcbiAgICogcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUgYnkgSUQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHNpemUgb2YgdGhlIGRhdGEgcmVsZWFzZWRcclxuICAgKi9cclxuICByZWxlYXNlKGlkOiBHcHVEYXRhSWQpOiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogY29weSBkYXRhIGZyb20gR1BVIHRvIENQVS5cclxuICAgKi9cclxuICBkb3dubG9hZChpZDogR3B1RGF0YUlkLCBnZXRUYXJnZXRCdWZmZXI6ICgpID0+IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAvKipcclxuICAgKiByZWZyZXNoIHRoZSBidWZmZXJzIHRoYXQgbWFya2VkIGZvciByZWxlYXNlLlxyXG4gICAqXHJcbiAgICogd2hlbiByZWxlYXNlKCkgaXMgY2FsbGVkLCB0aGUgYnVmZmVyIGlzIG5vdCByZWxlYXNlZCBpbW1lZGlhdGVseS4gdGhpcyBpcyBiZWNhdXNlIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGNvbW1hbmRzXHJcbiAgICogdG8gYmUgc3VibWl0dGVkIHRvIHRoZSBHUFUuIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBjb21tYW5kcyBhcmUgc3VibWl0dGVkIHNvIHRoYXQgdGhlIGJ1ZmZlcnMgY2FuIGJlXHJcbiAgICogYWN0dWFsbHkgcmVsZWFzZWQuXHJcbiAgICovXHJcbiAgcmVmcmVzaFBlbmRpbmdCdWZmZXJzKCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIHJlZ2lzdGVyIGFuIGV4dGVybmFsIGJ1ZmZlciBmb3IgSU8gQmluZGluZy4gSWYgdGhlIGJ1ZmZlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIHJldHVybiB0aGUgZXhpc3RpbmcgR1BVIGRhdGEgSUQuXHJcbiAgICpcclxuICAgKiBHUFUgZGF0YSBtYW5hZ2VyIG9ubHkgbWFuYWdlcyBhIG1hcHBpbmcgYmV0d2VlbiB0aGUgYnVmZmVyIGFuZCB0aGUgR1BVIGRhdGEgSUQuIEl0IHdpbGwgbm90IG1hbmFnZSB0aGUgbGlmZWN5Y2xlIG9mXHJcbiAgICogdGhlIGV4dGVybmFsIGJ1ZmZlci5cclxuICAgKi9cclxuICByZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgcHJldmlvdXM/OiBbR3B1RGF0YUlkLCBHUFVCdWZmZXJdKTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiB1bnJlZ2lzdGVyIGFuIGV4dGVybmFsIGJ1ZmZlciBmb3IgSU8gQmluZGluZy5cclxuICAgKi9cclxuICB1bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoaWQ6IEdwdURhdGFJZCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIGRlc3Ryb3kgYWxsIGdwdSBidWZmZXJzLlxyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogY3JlYXRlIHNlc3Npb24gcmVsYXRlZCBkYXRhLlxyXG4gICAqL1xyXG4gIG9uQ3JlYXRlU2Vzc2lvbigpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiByZWxlYXNlIHNlc3Npb24gcmVsYXRlZCBkYXRhLlxyXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgLSBzcGVjaWZ5IHRoZSBzZXNzaW9uIElELlxyXG4gICAqL1xyXG4gIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU3RvcmFnZUNhY2hlVmFsdWUge1xyXG4gIGdwdURhdGE6IEdwdURhdGE7XHJcbiAgb3JpZ2luYWxTaXplOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IGJ1Y2tldEZyZWVsaXN0OiBNYXA8bnVtYmVyLCBudW1iZXI+ID0gbmV3IE1hcChbXHJcbiAgWzY0LCAyNTBdLFxyXG4gIFsxMjgsIDIwMF0sXHJcbiAgWzI1NiwgMjAwXSxcclxuICBbNTEyLCAyMDBdLFxyXG4gIFsyMDQ4LCAyMzBdLFxyXG4gIFs0MDk2LCAyMDBdLFxyXG4gIFs4MTkyLCA1MF0sXHJcbiAgWzE2Mzg0LCA1MF0sXHJcbiAgWzMyNzY4LCA1MF0sXHJcbiAgWzY1NTM2LCA1MF0sXHJcbiAgWzEzMTA3MiwgNTBdLFxyXG4gIFsyNjIxNDQsIDUwXSxcclxuICBbNTI0Mjg4LCA1MF0sXHJcbiAgWzEwNDg1NzYsIDUwXSxcclxuICBbMjA5NzE1MiwgMzBdLFxyXG4gIFs0MTk0MzA0LCAyMF0sXHJcbiAgWzgzODg2MDgsIDEwXSxcclxuICBbMTI1ODI5MTIsIDEwXSxcclxuICBbMTY3NzcyMTYsIDEwXSxcclxuICBbMjYyMTQ0MDAsIDE1XSxcclxuICBbMzM1NTQ0MzIsIDIyXSxcclxuICBbNDQyMzY4MDAsIDJdLFxyXG4gIFs1ODk4MjQwMCwgNl0sXHJcbiAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjYWNoZSB0aGUgYnVja2V0IHNpemVzIGJlbG93IGJ1dCBub3QgY2FjaGluZyB0aGVtXHJcbiAgLy8gcmVzdWx0cyBpbiBzb21lIG1ham9yIHBlcmZvcm1hbmNlIGhpdHMgZm9yIG1vZGVscyBsaWtlIHNkLXR1cmJvLlxyXG4gIFs2NzEwODg2NCwgNl0sXHJcbiAgWzEzNDIxNzcyOCwgNl0sXHJcbiAgWzE2Nzc3MjE2MCwgNl0sXHJcbl0pO1xyXG5cclxuY29uc3QgYnVja2V0QXJyOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIG5vcm1hbGl6ZSB0aGUgYnVmZmVyIHNpemUgc28gdGhhdCBpdCBmaXRzIHRoZSAxMjgtYml0cyAoMTYgYnl0ZXMpIGFsaWdubWVudC5cclxuICovXHJcbmNvbnN0IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZSA9IChzaXplOiBudW1iZXIpID0+IE1hdGguY2VpbChOdW1iZXIoc2l6ZSkgLyAxNikgKiAxNjtcclxuXHJcbi8qKlxyXG4gKiBjYWxjdWxhdGUgdGhlIGJ1ZmZlciBzaXplIHNvIHRoYXQgaXQgZml0cyBpbnRvIGJ1Y2tldHMuXHJcbiAqL1xyXG5jb25zdCBjYWxjQnVja2V0QnVmZmVyU2l6ZSA9IChzaXplOiBudW1iZXIpID0+IHtcclxuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBidWNrZXRBcnIubGVuZ3RoOyBpZHgrKykge1xyXG4gICAgY29uc3Qgc2l6ZUZvckJ1Y2tldCA9IGJ1Y2tldEFycltpZHhdO1xyXG4gICAgaWYgKHNpemUgPD0gc2l6ZUZvckJ1Y2tldCkge1xyXG4gICAgICByZXR1cm4gc2l6ZUZvckJ1Y2tldDtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gbm90IGluIGJ1Y2tldCBsaXN0IC0+IGNhbGxlciB3aWxsIG5vdCBjYWNoZSwgcm91bmQgdXAgdG8gMTYuXHJcbiAgcmV0dXJuIE1hdGguY2VpbChzaXplIC8gMTYpICogMTY7XHJcbn07XHJcblxyXG5sZXQgZ3VpZCA9IDE7XHJcbmNvbnN0IGNyZWF0ZU5ld0dwdURhdGFJZCA9ICgpID0+IGd1aWQrKztcclxuXHJcbi8qKlxyXG4gKiBleHBvcnRlZCBzdGFuZGFyZCBkb3dubG9hZCBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IHRoZSBzZXNzaW9uIHRvIGRvd25sb2FkIHRoZSBkYXRhIGZyb20gR1BVLCBhbmQgYWxzbyBieVxyXG4gKiBmYWN0b3J5IHRvIGNyZWF0ZSBHUFUgdGVuc29ycyB3aXRoIHRoZSBjYXBhY2l0eSBvZiBkb3dubG9hZGluZyBkYXRhIGZyb20gR1BVLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBXZWJHUFUgYmFja2VuZFxyXG4gKiBAcGFyYW0gZ3B1QnVmZmVyIC0gdGhlIEdQVSBidWZmZXIgdG8gZG93bmxvYWRcclxuICogQHBhcmFtIG9yaWdpbmFsU2l6ZSAtIHRoZSBvcmlnaW5hbCBzaXplIG9mIHRoZSBkYXRhXHJcbiAqIEBwYXJhbSBnZXRUYXJnZXRCdWZmZXIgLSBvcHRpb25hbC4gSWYgcHJvdmlkZWQsIHRoZSBkYXRhIHdpbGwgYmUgY29waWVkIHRvIHRoZSB0YXJnZXQgYnVmZmVyLiBPdGhlcndpc2UsIGEgbmV3IGJ1ZmZlclxyXG4gKiB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRvd25sb2FkR3B1RGF0YSA9IGFzeW5jIChcclxuICBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kLFxyXG4gIGdwdUJ1ZmZlcjogR1BVQnVmZmVyLFxyXG4gIG9yaWdpbmFsU2l6ZTogbnVtYmVyLFxyXG4gIGdldFRhcmdldEJ1ZmZlcj86ICgpID0+IFVpbnQ4QXJyYXksXHJcbik6IFByb21pc2U8VWludDhBcnJheT4gPT4ge1xyXG4gIGNvbnN0IGJ1ZmZlclNpemUgPSBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUob3JpZ2luYWxTaXplKTtcclxuICBjb25zdCBncHVSZWFkQnVmZmVyID0gYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgIHsgc2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQgfSxcclxuICApO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IGJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTtcclxuICAgIGJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcclxuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcclxuICAgICAgZ3B1QnVmZmVyIC8qIHNvdXJjZSBidWZmZXIgKi8sXHJcbiAgICAgIDAgLyogc291cmNlIG9mZnNldCAqLyxcclxuICAgICAgZ3B1UmVhZEJ1ZmZlciAvKiBkZXN0aW5hdGlvbiBidWZmZXIgKi8sXHJcbiAgICAgIDAgLyogZGVzdGluYXRpb24gb2Zmc2V0ICovLFxyXG4gICAgICBidWZmZXJTaXplIC8qIHNpemUgKi8sXHJcbiAgICApO1xyXG4gICAgYmFja2VuZC5mbHVzaCgpO1xyXG5cclxuICAgIGF3YWl0IGdwdVJlYWRCdWZmZXIubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtcclxuXHJcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGdwdVJlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKTtcclxuICAgIGlmIChnZXRUYXJnZXRCdWZmZXIpIHtcclxuICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgQ1BVIGJ1ZmZlciB0byBhY2NlcHQgdGhlIGRhdGEsIG5vIG5lZWQgdG8gY2xvbmUgdGhlIEFycmF5QnVmZmVyLlxyXG4gICAgICBjb25zdCB0YXJnZXRCdWZmZXIgPSBnZXRUYXJnZXRCdWZmZXIoKTtcclxuICAgICAgdGFyZ2V0QnVmZmVyLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgMCwgb3JpZ2luYWxTaXplKSk7XHJcbiAgICAgIHJldHVybiB0YXJnZXRCdWZmZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB0aGUgbWFwcGVkIEFycmF5QnVmZmVyIHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB0aGUgR1BVIGJ1ZmZlciBpcyBkZXN0cm95ZWQuIE5lZWQgdG8gY2xvbmUgdGhlXHJcbiAgICAgIC8vIEFycmF5QnVmZmVyLlxyXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoMCwgb3JpZ2luYWxTaXplKSk7XHJcbiAgICB9XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIGdwdVJlYWRCdWZmZXIuZGVzdHJveSgpO1xyXG4gIH1cclxufTtcclxuXHJcbmNsYXNzIEdwdURhdGFNYW5hZ2VySW1wbCBpbXBsZW1lbnRzIEdwdURhdGFNYW5hZ2VyIHtcclxuICAvLyBHUFUgRGF0YSBJRCA9PiBHUFUgRGF0YSAoIHN0b3JhZ2UgYnVmZmVyIClcclxuICBwcml2YXRlIHN0b3JhZ2VDYWNoZTogTWFwPEdwdURhdGFJZCwgU3RvcmFnZUNhY2hlVmFsdWU+O1xyXG5cclxuICAvLyBwZW5kaW5nIGJ1ZmZlcnMgZm9yIGNvbXB1dGluZ1xyXG4gIHByaXZhdGUgYnVmZmVyc1BlbmRpbmc6IEdQVUJ1ZmZlcltdO1xyXG5cclxuICAvLyBUaGUgcmV1c2FibGUgc3RvcmFnZSBidWZmZXJzIGZvciBjb21wdXRpbmcuXHJcbiAgcHJpdmF0ZSBmcmVlQnVmZmVyczogTWFwPG51bWJlciwgR1BVQnVmZmVyW10+O1xyXG4gIC8vIFRoZSByZXVzYWJsZSB1bmlmb3JtIGJ1ZmZlcnNcclxuICBwcml2YXRlIGZyZWVVbmlmb3JtQnVmZmVyczogTWFwPG51bWJlciwgR1BVQnVmZmVyW10+O1xyXG5cclxuICAvLyBUaGUgcGVuZGluZ0J1ZmZlcnMgZm9yIGNhcHR1cmUgZ3JhcGguXHJcbiAgLy8gYSBTZXNzaW9uSUQgLT4gR1BVQnVmZmVyW10gbWFwcGluZy5cclxuICBwcml2YXRlIGNhcHR1cmVkUGVuZGluZ0J1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcclxuXHJcbiAgLy8gVGhlIHNlc3Npb24gY291bnQuXHJcbiAgcHJpdmF0ZSBzZXNzaW9uQ291bnQ6IG51bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kKSB7XHJcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuZnJlZUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcclxuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtrZXldIG9mIGJ1Y2tldEZyZWVsaXN0KSB7XHJcbiAgICAgIGJ1Y2tldEFyci5wdXNoKGtleSk7XHJcbiAgICAgIHRoaXMuZnJlZUJ1ZmZlcnMuc2V0KGtleSwgW10pO1xyXG4gICAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5zZXQoa2V5LCBbXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXNzaW9uQ291bnQgPSAwO1xyXG4gIH1cclxuXHJcbiAgdXBsb2FkKGlkOiBHcHVEYXRhSWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcclxuICAgIGNvbnN0IHNyY0FycmF5QnVmZmVyID0gZGF0YS5idWZmZXI7XHJcbiAgICBjb25zdCBzcmNPZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQ7XHJcbiAgICBjb25zdCBzcmNMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICBjb25zdCBzaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNyY0xlbmd0aCk7XHJcblxyXG4gICAgLy8gZ2V0IGRlc3RpbmF0aW9uIGdwdSBidWZmZXJcclxuICAgIGNvbnN0IGdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XHJcbiAgICBpZiAoIWdwdURhdGFDYWNoZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dwdSBkYXRhIGZvciB1cGxvYWRpbmcgZG9lcyBub3QgZXhpc3QnKTtcclxuICAgIH1cclxuICAgIGlmIChOdW1iZXIoZ3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSkgIT09IHNyY0xlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtncHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7c3JjTGVuZ3RofWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNyZWF0ZSBncHUgYnVmZmVyXHJcbiAgICBjb25zdCBncHVCdWZmZXJGb3JVcGxvYWRpbmcgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgICAgeyBtYXBwZWRBdENyZWF0aW9uOiB0cnVlLCBzaXplLCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfSxcclxuICAgICk7XHJcblxyXG4gICAgLy8gY29weSAodXBsb2FkKSBkYXRhXHJcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGdwdUJ1ZmZlckZvclVwbG9hZGluZy5nZXRNYXBwZWRSYW5nZSgpO1xyXG4gICAgbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLnNldChuZXcgVWludDhBcnJheShzcmNBcnJheUJ1ZmZlciwgc3JjT2Zmc2V0LCBzcmNMZW5ndGgpKTtcclxuICAgIGdwdUJ1ZmZlckZvclVwbG9hZGluZy51bm1hcCgpO1xyXG5cclxuICAgIC8vIEdQVSBjb3B5XHJcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcclxuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihncHVCdWZmZXJGb3JVcGxvYWRpbmcsIDAsIGdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlciwgMCwgc2l6ZSk7XHJcbiAgICB0aGlzLmJhY2tlbmQuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcclxuICAgIGdwdUJ1ZmZlckZvclVwbG9hZGluZy5kZXN0cm95KCk7XHJcblxyXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke2lkfSlgKTtcclxuICB9XHJcblxyXG4gIG1lbWNweShzb3VyY2VJZDogR3B1RGF0YUlkLCBkZXN0aW5hdGlvbklkOiBHcHVEYXRhSWQpOiB2b2lkIHtcclxuICAgIC8vIGdldCBzb3VyY2UgZ3B1IGJ1ZmZlclxyXG4gICAgY29uc3Qgc291cmNlR3B1RGF0YUNhY2hlID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHNvdXJjZUlkKTtcclxuICAgIGlmICghc291cmNlR3B1RGF0YUNhY2hlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3QnKTtcclxuICAgIH1cclxuICAgIC8vIGdldCBkZXN0aW5hdGlvbiBncHUgYnVmZmVyXHJcbiAgICBjb25zdCBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChkZXN0aW5hdGlvbklkKTtcclxuICAgIGlmICghZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoc291cmNlR3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSAhPT0gZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNpemUgPSBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUoc291cmNlR3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSk7XHJcblxyXG4gICAgLy8gR1BVIGNvcHlcclxuICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gdGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7XHJcbiAgICB0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcclxuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcclxuICAgICAgc291cmNlR3B1RGF0YUNhY2hlLmdwdURhdGEuYnVmZmVyLFxyXG4gICAgICAwLFxyXG4gICAgICBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlcixcclxuICAgICAgMCxcclxuICAgICAgc2l6ZSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgcHJldmlvdXM/OiBbR3B1RGF0YUlkLCBHUFVCdWZmZXJdKTogbnVtYmVyIHtcclxuICAgIGxldCBpZDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgaWYgKHByZXZpb3VzKSB7XHJcbiAgICAgIGlkID0gcHJldmlvdXNbMF07XHJcbiAgICAgIGlmIChidWZmZXIgPT09IHByZXZpb3VzWzFdKSB7XHJcbiAgICAgICAgTE9HX0RFQlVHKFxyXG4gICAgICAgICAgJ3ZlcmJvc2UnLFxyXG4gICAgICAgICAgKCkgPT5cclxuICAgICAgICAgICAgYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke29yaWdpbmFsU2l6ZX0pID0+IGlkPSR7aWR9LCBidWZmZXIgaXMgdGhlIHNhbWUsIHNraXAuYCxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXModGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVnaXN0ZXJpbmcgYSBkaWZmZXJlbnQgZXh0ZXJuYWwgYnVmZmVyIHVuZGVyIGdyYXBoIGNhcHR1cmUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cclxuICAgICAgICAgICAgIFBsZWFzZSB1c2UgdGhlIHByZXZpb3VzIGV4dGVybmFsIGJ1ZmZlciFgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWQgPSBjcmVhdGVOZXdHcHVEYXRhSWQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoaWQsIHsgZ3B1RGF0YTogeyBpZCwgdHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCwgYnVmZmVyIH0sIG9yaWdpbmFsU2l6ZSB9KTtcclxuICAgIExPR19ERUJVRyhcclxuICAgICAgJ3ZlcmJvc2UnLFxyXG4gICAgICAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7b3JpZ2luYWxTaXplfSkgPT4gaWQ9JHtpZH0sIHJlZ2lzdGVyZWQuYCxcclxuICAgICk7XHJcbiAgICByZXR1cm4gaWQ7XHJcbiAgfVxyXG5cclxuICB1bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoaWQ6IEdwdURhdGFJZCk6IHZvaWQge1xyXG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKGlkKTtcclxuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcigpID0+IGlkPSR7aWR9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gIGNyZWF0ZShzaXplOiBudW1iZXIsIHVzYWdlID0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpOiBHcHVEYXRhIHtcclxuICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBjYWxjQnVja2V0QnVmZmVyU2l6ZShzaXplKTtcclxuXHJcbiAgICBsZXQgZ3B1QnVmZmVyO1xyXG4gICAgLy8gQ3VycmVudGx5LCBvbmx5IHN0b3JhZ2UgYnVmZmVycyBhcmUgcmV1c2VkLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgIGNvbnN0IGlzU3RvcmFnZSA9ICh1c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpID09PSBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgIGNvbnN0IGlzVW5pZm9ybSA9ICh1c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pID09PSBHUFVCdWZmZXJVc2FnZS5VTklGT1JNO1xyXG4gICAgaWYgKGlzU3RvcmFnZSB8fCBpc1VuaWZvcm0pIHtcclxuICAgICAgY29uc3QgZnJlZUJ1ZmZlcnMgPSBpc1N0b3JhZ2UgPyB0aGlzLmZyZWVCdWZmZXJzIDogdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBmcmVlQnVmZmVycy5nZXQoYnVmZmVyU2l6ZSk7XHJcbiAgICAgIGlmICghYnVmZmVycykge1xyXG4gICAgICAgIC8vIG5vIHN1Y2ggYnVja2V0L2ZyZWVsaXN0IC0gY3JlYXRlIGdwdSBidWZmZXJcclxuICAgICAgICBncHVCdWZmZXIgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7IHNpemU6IGJ1ZmZlclNpemUsIHVzYWdlIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIC8vIGluIGZyZWVsaXN0LCB1c2UgaXRcclxuICAgICAgICAgIGdwdUJ1ZmZlciA9IGJ1ZmZlcnMucG9wKCkgYXMgR1BVQnVmZmVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBidWNrZXQgZW1wdHksIGNyZWF0ZSBncHUgYnVmZmVyXHJcbiAgICAgICAgICBncHVCdWZmZXIgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7IHNpemU6IGJ1ZmZlclNpemUsIHVzYWdlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gY3JlYXRlIGdwdSBidWZmZXJcclxuICAgICAgZ3B1QnVmZmVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoeyBzaXplOiBidWZmZXJTaXplLCB1c2FnZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBncHVEYXRhID0geyBpZDogY3JlYXRlTmV3R3B1RGF0YUlkKCksIHR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQsIGJ1ZmZlcjogZ3B1QnVmZmVyIH07XHJcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoZ3B1RGF0YS5pZCwgeyBncHVEYXRhLCBvcmlnaW5hbFNpemU6IE51bWJlcihzaXplKSB9KTtcclxuXHJcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHtzaXplfSkgPT4gaWQ9JHtncHVEYXRhLmlkfWApO1xyXG4gICAgcmV0dXJuIGdwdURhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQoaWQ6IEdwdURhdGFJZCk6IEdwdURhdGEgfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk/LmdwdURhdGE7XHJcbiAgfVxyXG5cclxuICByZWxlYXNlKGlkSW5wdXQ6IEdwdURhdGFJZCk6IG51bWJlciB7XHJcbiAgICBjb25zdCBpZCA9IHR5cGVvZiBpZElucHV0ID09PSAnYmlnaW50JyA/IE51bWJlcihpZElucHV0KSA6IGlkSW5wdXQ7XHJcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKTtcclxuICAgIGlmICghY2FjaGVkRGF0YSkge1xyXG4gICAgICBpZiAodGhpcy5zdG9yYWdlQ2FjaGUuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIC8vIGNhY2hlIHdhcyBwcmV2aW91c2x5IGNsZWFyZWQsIG5vIG5lZWQgdG8gcmVsZWFzZSBhbnl0aGluZy5cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbGVhc2luZyBkYXRhIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke2lkfSksIGdwdURhdGFJZD0ke2NhY2hlZERhdGEuZ3B1RGF0YS5pZH1gKTtcclxuXHJcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUoaWQpO1xyXG4gICAgdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIpO1xyXG4gICAgLy8gY2FjaGVkRGF0YS5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCk7XHJcblxyXG4gICAgcmV0dXJuIGNhY2hlZERhdGEub3JpZ2luYWxTaXplO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZG93bmxvYWQoaWQ6IEdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KE51bWJlcihpZCkpO1xyXG4gICAgaWYgKCFjYWNoZWREYXRhKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBkb2VzIG5vdCBleGlzdCcpO1xyXG4gICAgfVxyXG4gICAgYXdhaXQgZG93bmxvYWRHcHVEYXRhKHRoaXMuYmFja2VuZCwgY2FjaGVkRGF0YS5ncHVEYXRhLmJ1ZmZlciwgY2FjaGVkRGF0YS5vcmlnaW5hbFNpemUsIGdldFRhcmdldEJ1ZmZlcik7XHJcbiAgfVxyXG5cclxuICByZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5idWZmZXJzUGVuZGluZy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cyA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpIHtcclxuICAgICAgICBjb25zdCBtYXhJbkZyZWVMaXN0ID0gYnVja2V0RnJlZWxpc3QuZ2V0KGJ1ZmZlci5zaXplKTtcclxuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgICAgICBpZiAoKGJ1ZmZlci51c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpID09PSBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSB7XHJcbiAgICAgICAgICAvLyBQdXQgdGhlIHBlbmRpbmcgYnVmZmVyIHRvIGZyZWVCdWZmZXJzIGxpc3QgaW5zdGVhZCBvZiByZWFsbHkgZGVzdHJveWluZyBpdCBmb3IgYnVmZmVyIHJldXNpbmcuXHJcbiAgICAgICAgICBjb25zdCBmcmVlbGlzdCA9IHRoaXMuZnJlZUJ1ZmZlcnMuZ2V0KGJ1ZmZlci5zaXplKSB8fCBbXTtcclxuICAgICAgICAgIGlmIChtYXhJbkZyZWVMaXN0ID09PSB1bmRlZmluZWQgfHwgZnJlZWxpc3QubGVuZ3RoID49IG1heEluRnJlZUxpc3QpIHtcclxuICAgICAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZyZWVsaXN0LnB1c2goYnVmZmVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgfSBlbHNlIGlmICgoYnVmZmVyLnVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSkgPT09IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pIHtcclxuICAgICAgICAgIC8vIFB1dCB0aGUgcGVuZGluZyBidWZmZXIgdG8gZnJlZVVuaWZvcm1CdWZmZXJzIGxpc3QgaW5zdGVhZCBvZiByZWFsbHkgZGVzdHJveWluZyBpdCBmb3IgYnVmZmVyIHJldXNpbmcuXHJcbiAgICAgICAgICBjb25zdCBmcmVlbGlzdCA9IHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldChidWZmZXIuc2l6ZSkgfHwgW107XHJcbiAgICAgICAgICBpZiAobWF4SW5GcmVlTGlzdCA9PT0gdW5kZWZpbmVkIHx8IGZyZWVsaXN0Lmxlbmd0aCA+PSBtYXhJbkZyZWVMaXN0KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmcmVlbGlzdC5wdXNoKGJ1ZmZlcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIERvbid0IHJlbGVhc2UgaW50ZXJtZWRpYXRlIHRlbnNvcnMgaW4gbm9uLWRlZmF1bHQgbW9kZS5cclxuICAgICAgLy8gVE9ETzogcmV1c2UgdGhlIHN0b3JhZ2UgYnVmZmVycyBpbiBub24tZGVmYXVsdCBtb2RlLlxyXG4gICAgICBsZXQgY2FwdHVyZWRCdWZmZXJzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCEpO1xyXG4gICAgICBpZiAoIWNhcHR1cmVkQnVmZmVycykge1xyXG4gICAgICAgIGNhcHR1cmVkQnVmZmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5zZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhLCBjYXB0dXJlZEJ1ZmZlcnMpO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpIHtcclxuICAgICAgICBjYXB0dXJlZEJ1ZmZlcnMucHVzaChidWZmZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLmZyZWVCdWZmZXJzLmZvckVhY2goKGJ1ZmZlcnMpID0+IHtcclxuICAgICAgYnVmZmVycy5mb3JFYWNoKChidWZmZXIpID0+IHtcclxuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVycykgPT4ge1xyXG4gICAgICBidWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4ge1xyXG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xyXG4gICAgICBzdG9yYWdlLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5mb3JFYWNoKChidWZmZXJzKSA9PiB7XHJcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XHJcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5mcmVlQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzID0gbmV3IE1hcCgpO1xyXG4gIH1cclxuXHJcbiAgb25DcmVhdGVTZXNzaW9uKCkge1xyXG4gICAgdGhpcy5zZXNzaW9uQ291bnQgKz0gMTtcclxuICB9XHJcblxyXG4gIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpIHtcclxuICAgIC8vIHJlbGVhc2UgdGhlIGNhcHR1cmVkIHBlbmRpbmcgYnVmZmVycy5cclxuICAgIGNvbnN0IHBlbmRpbmdCdWZmZXJzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldChzZXNzaW9uSWQpO1xyXG4gICAgaWYgKHBlbmRpbmdCdWZmZXJzKSB7XHJcbiAgICAgIHBlbmRpbmdCdWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4ge1xyXG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVsZWFzZSB0aGUgc3RvcmFnZSBjYWNoZSBpZiBubyBhY3RpdmUgc2Vzc2lvbnMuXHJcbiAgICB0aGlzLnNlc3Npb25Db3VudCAtPSAxO1xyXG4gICAgaWYgKHRoaXMuc2Vzc2lvbkNvdW50ID09PSAwKSB7XHJcbiAgICAgIExPR19ERUJVRygnd2FybmluZycsICgpID0+ICdbV2ViR1BVXSBDbGVhcmluZyB3ZWJncHUgYnVmZmVyIGNhY2hlJyk7XHJcbiAgICAgIHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2goKHN0b3JhZ2UpID0+IHtcclxuICAgICAgICBzdG9yYWdlLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdwdURhdGFNYW5hZ2VyID0gKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgR3B1RGF0YU1hbmFnZXJJbXBsPik6IEdwdURhdGFNYW5hZ2VyID0+XHJcbiAgbmV3IEdwdURhdGFNYW5hZ2VySW1wbCguLi5hcmdzKTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5jbGFzcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXlJbXBsIHtcclxuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGF0dHJpYnV0ZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGtleTogc3RyaW5nO1xyXG4gIHB1YmxpYyBnZXQgY2FjaGVLZXkoKTogc3RyaW5nIHtcclxuICAgIGlmICghdGhpcy5rZXkpIHtcclxuICAgICAgdGhpcy5rZXkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKVxyXG4gICAgICAgIC5zb3J0KClcclxuICAgICAgICAubWFwKChuYW1lKSA9PiBgJHsodGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbbmFtZV19YClcclxuICAgICAgICAuam9pbignOycpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMua2V5O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IGNhY2hlS2V5OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBuZXcgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGF0dHJpYnV0ZSwgYW5kIGFkZCBhIGNhY2hlS2V5IHByb3BlcnR5IHRvIGl0XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5ID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXHJcbiAgYXR0cmlidXRlOiBULFxyXG4pOiBUICYgQXR0cmlidXRlV2l0aENhY2hlS2V5ID0+IG5ldyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXlJbXBsKGF0dHJpYnV0ZSkgYXMgdW5rbm93biBhcyBUICYgQXR0cmlidXRlV2l0aENhY2hlS2V5O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgUHJvZ3JhbVVuaWZvcm0sIFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIGNvbnN0YW50IHZhbHVlIGZvciBhIHdvcmtncm91cCBzaXplLlxyXG4gKlxyXG4gKiBXZSBkZWZpbml0ZWx5IGNhbiBkbyBmdXJ0aGVyIG9wdGltaXphdGlvbiBpbiBmdXR1cmUsIGJ1dCBmb3Igbm93IHdlIHVzZSA2NC5cclxuICpcclxuICogcnVsZSBvZiB0aHVtYjogVXNlIFthIHdvcmtncm91cCBzaXplIG9mXSA2NCB1bmxlc3MgeW91IGtub3cgd2hhdCBHUFUgeW91IGFyZSB0YXJnZXRpbmcgb3IgdGhhdCB5b3VyIHdvcmtsb2FkXHJcbiAqICAgICAgICAgICAgICAgIG5lZWRzIHNvbWV0aGluZyBkaWZmZXJlbnQuXHJcbiAqXHJcbiAqIGZyb206IGh0dHBzOi8vc3VybWEuZGV2L3RoaW5ncy93ZWJncHUvXHJcbiAqKi9cclxuZXhwb3J0IGNvbnN0IFdPUktHUk9VUF9TSVpFID0gNjQ7XHJcblxyXG5pbnRlcmZhY2UgSW5kaWNlc0hlbHBlclR5cGVzIHtcclxuICAvKipcclxuICAgKiBXR1NMIHR5cGUgb2YgaW5kaWNlcyBleHByZXNzaW9uXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgaW5kaWNlczogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBXR1NMIHR5cGUgb2YgYSB2YWx1ZVxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IHZhbHVlOiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgdHlwZSBvZiBzdG9yYWdlIHR5cGUgcmVwcmVzZW50aW5nIGEgdmFsdWVcclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSB0byBgdmFsdWVgLCBidXQgZm9yIHNvbWUgdHlwZSAoZWcuIGJvb2wpLCB3ZSBuZWVkIHRvIHVzZSBgdTMyYCBhcyBzdG9yYWdlIHR5cGUgZm9yXHJcbiAgICogdmFsdWUgdHlwZSBgdmVjNDxib29sPmBcclxuICAgKi9cclxuICByZWFkb25seSBzdG9yYWdlOiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIHRlbnNvciB0eXBlIGFzIHJlcHJlc2VudGVkIGluIFRlbnNvclZpZXdcclxuICAgKi9cclxuICByZWFkb25seSB0ZW5zb3I6IG51bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIGNsYXNzIGZvciBnZW5lcmF0aW5nIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEgZm9yIGEgc2hhZGVyJ3MgaW5wdXQgb3Igb3V0cHV0LlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIGlzIGRlc2lnbmVkIHRvIG9mZmVyIGEgdW5pZmllZCB3YXkgdG8gZ2VuZXJhdGUgV0dTTCBjb2RlIGZvciBtYW5pcHVsYXRpbmcgaW5kaWNlcyBhbmQgZGF0YSBmb3IgYSBzaGFkZXInc1xyXG4gKiBpbnB1dCBvciBvdXRwdXQuXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgaXMgYSBsaXN0IG9mIHRlcm1pbm9sb2dpZXMgdXNlZCBpbiB0aGlzIGNsYXNzOlxyXG4gKiAtIGBvZmZzZXRgOiBhIHVpbnQzMiB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIG9mZnNldCBvZiBhbiBlbGVtZW50IGluIHRoZSBkYXRhIGJ1ZmZlci5cclxuICogLSBgaW5kaWNlc2A6IGFuIGFic3RyYWN0aW9uIG9mIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkncyBpbmRpY2VzIHJlcHJlc2VudGluZyB0aGUgZGF0YSdzIGluZGV4IG9uIGVhY2ggZGltZW5zaW9uLlxyXG4gKiAtIGB2YWx1ZWA6IGEgdmFsdWUgb2YgYSBkYXRhIGVsZW1lbnQuXHJcbiAqXHJcbiAqIFVzZXJzIGFyZSBleHBlY3RlZCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBmb3IgZWFjaCBzaGFkZXIncyBpbnB1dCBvciBvdXRwdXQsIGFuZCB1c2UgdGhlIGluc3RhbmNlIHRvXHJcbiAqIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEuIFRoZSBmb2xsb3dpbmcgMiBleHBvcnRlZCBmdW5jdGlvbnMgYXJlIGZvciB1c2VycyB0byBjYWxsIHRvXHJcbiAqIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhbiBpbmRpY2VzIGhlbHBlcjpcclxuICogLSBgaW5wdXRWYXJpYWJsZSgpYDogY3JlYXRlIGFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGZvciBhbiBpbnB1dC5cclxuICogLSBgb3V0cHV0VmFyaWFibGUoKWA6IGNyZWF0ZSBhbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBmb3IgYW4gb3V0cHV0LlxyXG4gKiAtIGBpbnRlcm5hbFZhcmlhYmxlKClgOiBjcmVhdGUgYW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgZm9yIGFuIGludGVybmFsIHZhcmlhYmxlLlxyXG4gKlxyXG4gKiBBbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBjb250YWlucyBoZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XHJcbiAqIC0gYWNjZXNzIHJlYWRvbmx5IGJhc2ljIGluZm9ybWF0aW9uLCBpbmNsdWRpbmc6IGBuYW1lYCh0aGUgbmFtZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0KSwgYHVzYWdlYCh3aGV0aGVyIGl0J3MgYW5cclxuICogaW5wdXQsIGFuIG91dHB1dCBvciBhbiBpbnRlcm5hbCB2YXJpYWJsZSkgYW5kIGBzaGFwZWAodGhlIHBhc3NlZCBpbiBzaGFwZSkuXHJcbiAqIC0gYHR5cGVgOiBhY2Nlc3MgcmVhZG9ubHkgdHlwZSBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nOiBgaW5kaWNlc2AodGhlIHR5cGUgb2YgaW5kaWNlcyksIGB2YWx1ZWAodGhlIHR5cGUgb2YgdmFsdWUgYXRcclxuICogcnVudGltZSksIGBzdG9yYWdlYCh0aGUgdHlwZSBvZiB2YWx1ZSBhdCBzdG9yYWdlKSBhbmQgYHRlbnNvcmAodGhlIHRlbnNvciB0eXBlIGFzIHJlcHJlc2VudGVkIGluIFRlbnNvclZpZXcpLlxyXG4gKiAtIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgZ2V0dGluZyBpbmRpY2VzIGZyb20gb2Zmc2V0LiBVc2UgYG9mZnNldFRvSW5kaWNlcygpYCBmb3IgV0dTTCBjb2RlIHNuaXBwZXQgdG8gY2FsY3VsYXRlXHJcbiAqIGluZGljZXMgZnJvbSBvZmZzZXQsIGFuZCB1c2UgYGluZGljZXNUb09mZnNldCgpYCBmb3IgV0dTTCBjb2RlIHNuaXBwZXQgdG8gY2FsY3VsYXRlIG9mZnNldCBmcm9tIGluZGljZXMuXHJcbiAqIC0gdG8gbWFuaXB1bGF0ZSBhbiBpbnN0YW5jZSBvZiBpbmRpY2VzLCB1c2UgYHNldEluZGljZXMoKWAgYW5kIGBnZXRJbmRpY2VzKClgIHRvIHNldCBhbmQgZ2V0IHRoZSBpbmRpY2VzIG9uIGFuXHJcbiAqIGluZGljZXMgdmFyaWFibGUuXHJcbiAqIC0gdG8gbWFuaXB1bGF0ZSBkYXRhLCB1c2UgYHNldCgpYC9gZ2V0KClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIGZyb20gcGFyYW1ldGVyIGxpc3QsIHVzZVxyXG4gKiBgc2V0QnlJbmRpY2VzKClgL2BnZXRCeUluZGljZXMoKWAgdG8gYWNjZXNzIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgZnJvbSBhbiBpbmRpY2VzIHZhcmlhYmxlLCBhbmQgdXNlXHJcbiAqIGBzZXRCeU9mZnNldCgpYC9gZ2V0QnlPZmZzZXQoKWAgdG8gYWNjZXNzIGRhdGEgYXQgdGhlIGdpdmVuIG9mZnNldC5cclxuICogLSBgaW1wbGA6IGdldCBXR1NMIGNvZGUgb2YgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1dGlsIGZ1bmN0aW9ucyBtZW50aW9uZWQgYWJvdmUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEluZGljZXNIZWxwZXIge1xyXG4gIC8qKlxyXG4gICAqIGdldCBXR1NMIGNvZGUgb2YgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1dGlsIGZ1bmN0aW9ucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGltcGw6ICgpID0+IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogZ2V0IHR5cGUgaW5mb1xyXG4gICAqL1xyXG4gIHJlYWRvbmx5IHR5cGU6IEluZGljZXNIZWxwZXJUeXBlcztcclxuXHJcbiAgLyoqXHJcbiAgICogV0dTTCBjb2RlIG9mIGEgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBpbmRpY2VzIGZyb20gb2Zmc2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZhck9mZnNldCAtIGEgdTMyIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBhbiBgdHlwZS5pbmRpY2VzYCBleHByZXNzaW9uXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgb2Zmc2V0VG9JbmRpY2VzOiAodmFyT2Zmc2V0OiBzdHJpbmcpID0+IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgb2Zmc2V0IGZyb20gaW5kaWNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSBgdHlwZS5pbmRpY2VzYCBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGFuIGB1MzJgIGV4cHJlc3Npb25cclxuICAgKi9cclxuICByZWFkb25seSBpbmRpY2VzVG9PZmZzZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgb3JpZ2luYWwgb2Zmc2V0IGZyb20gYnJvYWRjYXN0ZWQgaW5kaWNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSBgdHlwZS5pbmRpY2VzYCBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgb3V0cHV0IGluZGljZXMuXHJcbiAgICogQHBhcmFtIG91dHB1dCAtIG91dHB1dCBJbmRpY2VzSGVscGVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgYW4gYHUzMmAgZXhwcmVzc2lvblxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiAodmFySW5kaWNlczogc3RyaW5nLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpID0+IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogV0dTTCBjb2RlIG9mIGdlbmVyYXRpbmcgYW4gaW5kaWNlcyBsaXRlcmFsXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW5pdCAtIGluaXRpYWwgdmFsdWUuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgaW5kaWNlczogKC4uLmluaXQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBXR1NMIGNvZGUgb2YgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgaW5kaWNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cclxuICAgKiBAcGFyYW0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBpbmRpY2VzIHRvIHNldC4gY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pLlxyXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGEgV0dTTCBzdGF0ZW1lbnRcclxuICAgKi9cclxuICByZWFkb25seSBpbmRpY2VzU2V0OiAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlciB8IHN0cmluZywgdmFsdWU6IG51bWJlciB8IHN0cmluZykgPT4gdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgaW5kaWNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cclxuICAgKiBAcGFyYW0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBpbmRpY2VzIHRvIGdldC4gY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgYW4gYHUzMmAgZXhwcmVzc2lvblxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGluZGljZXNHZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyIHwgc3RyaW5nKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBmb3IgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpbmRpY2VzQW5kVmFsdWUgLSBhbiBhcnJheSBvZiBudW1iZXJzIG9yIHN0cmluZ3MgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBpbmRpY2VzLCBmb2xsb3dlZFxyXG4gICAqICAgICBieSB0aGUgdmFsdWUgdG8gc2V0LiBUaGlzIGFycmF5IHNob3VsZCBoYXZlIGV4YWN0bHkgYHNoYXBlLmxlbmd0aCArIDFgIGVsZW1lbnRzLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IHNldDogKC4uLmluZGljZXNBbmRWYWx1ZTogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBmb3IgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyB2YXJpYWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cclxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gc2V0LiBzaG91bGQgYmUgYSBXR1NMIGV4cHJlc3Npb24uXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgc2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBmb3IgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9mZnNldCAtIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0LlxyXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIHNob3VsZCBiZSBhIFdHU0wgZXhwcmVzc2lvbi5cclxuICAgKi9cclxuICByZWFkb25seSBzZXRCeU9mZnNldDogKG9mZnNldDogbnVtYmVyIHwgc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGluZGljZXMgLSBhbiBhcnJheSBvZiBudW1iZXJzIG9yIHN0cmluZ3MgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBpbmRpY2VzLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGdldDogKC4uLmluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyB2YXJpYWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cclxuICAgKi9cclxuICByZWFkb25seSBnZXRCeUluZGljZXM6ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogV0dTTCBjb2RlIGZvciBhbiBleHByZXNzaW9uIGZvciBnZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIG9mZnNldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cclxuICAgKi9cclxuICByZWFkb25seSBnZXRCeU9mZnNldDogKG9mZnNldDogbnVtYmVyIHwgc3RyaW5nKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIG5hbWUgb2YgdGhlIGRhdGEgdmFyaWFibGVcclxuICAgKi9cclxuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIHdoZXRoZXIgdGhlIGhlbHBlciBpcyBmb3IgYW4gaW5wdXQsIGFuIG91dHB1dCBvciBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cclxuICAgKi9cclxuICByZWFkb25seSB1c2FnZTogJ2lucHV0JyB8ICdvdXRwdXQnIHwgJ2F0b21pY091dHB1dCcgfCAnaW50ZXJuYWwnO1xyXG5cclxuICAvKipcclxuICAgKiB0aGUgcmFuayBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IHJhbms6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cclxuICAgKi9cclxuICByZWFkb25seSBzaGFwZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBzdHJpZGVzIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgc3RyaWRlczogc3RyaW5nO1xyXG59XHJcblxyXG5jb25zdCBnZXRXZ3NsTWFwcGVkVHlwZSA9ICh0eXBlOiBudW1iZXIsIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQpOiBzdHJpbmcgfCBbc3RyaW5nLCBzdHJpbmddID0+IHtcclxuICBpZiAoY29tcG9uZW50cyA9PT0gMykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkJyk7XHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm4gdHlwZSBpcyBbIHN0b3JhZ2UgdHlwZSwgcnVudGltZSB0eXBlIF0gb3IgYSBzaW5nbGUgc3RyaW5nIGZvciBib3RoXHJcbiAgc3dpdGNoIChOdW1iZXIodHlwZSkpIHtcclxuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcclxuICAgICAgcmV0dXJuIGNvbXBvbmVudHMgPiAxID8gYHZlYyR7Y29tcG9uZW50c308ZjE2PmAgOiAnZjE2JztcclxuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XHJcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGYzMj5gIDogJ2YzMic7XHJcbiAgICBjYXNlIERhdGFUeXBlLmludDMyOlxyXG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxpMzI+YCA6ICdpMzInO1xyXG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XHJcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PHUzMj5gIDogJ3UzMic7XHJcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxyXG4gICAgICBpZiAoY29tcG9uZW50cyA+IDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbJ3ZlYzI8dTMyPicsICdpMzInXTtcclxuICAgIGNhc2UgRGF0YVR5cGUudWludDY0OlxyXG4gICAgICBpZiAoY29tcG9uZW50cyA+IDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbJ3ZlYzI8dTMyPicsICd1MzInXTtcclxuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcclxuICAgICAgaWYgKGNvbXBvbmVudHMgIT09IDQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jvb2wgbXVzdCBiZSB2ZWM0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFsndTMyJywgJ3ZlYzQ8Ym9vbD4nXTtcclxuICAgIGNhc2UgRGF0YVR5cGUuaW50NDpcclxuICAgICAgcmV0dXJuICdpMzInO1xyXG4gICAgY2FzZSBEYXRhVHlwZS51aW50NDpcclxuICAgICAgcmV0dXJuICd1MzInO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHt0eXBlfWApO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUgPSAodHlwZTogRGF0YVR5cGUsIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQgPSAxKSA9PiB7XHJcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHR5cGUsIGNvbXBvbmVudHMpO1xyXG4gIHJldHVybiB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVswXTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlID0gKHR5cGU6IERhdGFUeXBlLCBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSkgPT4ge1xyXG4gIGNvbnN0IG1hcHBlZFR5cGUgPSBnZXRXZ3NsTWFwcGVkVHlwZSh0eXBlLCBjb21wb25lbnRzKTtcclxuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMV07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMgPSAoLi4uZGltczogUmVhZG9ubHlBcnJheTxyZWFkb25seSBudW1iZXJbXT4pOiBQcm9ncmFtVW5pZm9ybVtdID0+IHtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXTtcclxuICBkaW1zLmZvckVhY2goKGRpbSkgPT4ge1xyXG4gICAgaWYgKGRpbS5sZW5ndGggIT09IDApIHtcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGRpbSB9LFxyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZGltKSB9LFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBwcm9ncmFtVW5pZm9ybXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IG1heGltdW0gdmVjdG9yIHNpemUgZm9yIHNwZWNpZmllZCBkYXRhIGxlbmd0aFxyXG4gKiBAcGFyYW0gc2l6ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldE1heENvbXBvbmVudHMgPSAoc2l6ZTogbnVtYmVyKSA9PiB7XHJcbiAgLy8gd2UgY2Fubm90IHVzZSB2ZWMzIHR5cGUgc2luY2UgaXQgaGFzIGFsaWdubWVudCBvZiAxNiBieXRlc1xyXG4gIGlmIChzaXplICUgNCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIDQ7XHJcbiAgfSBlbHNlIGlmIChzaXplICUgMiA9PT0gMCkge1xyXG4gICAgcmV0dXJuIDI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIHZhcmlhYmxlIGFzIGEgc2NhbGFyIG9yIHZlY3Rvci4gZS5nLiBmMzIoMCkgb3IgdmVjNGYoMCwwLDAsMClcclxuICogQHBhcmFtIGRhdGFUeXBlXHJcbiAqIEBwYXJhbSBjb21wb25lbnRzXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGZpbGxWZWN0b3IgPSAoZGF0YVR5cGUgPSAnZjMyJywgY29tcG9uZW50cz86IG51bWJlciwgdmFsdWUgPSAnMCcpID0+IHtcclxuICBpZiAoIWNvbXBvbmVudHMgfHwgY29tcG9uZW50cyA9PT0gMSkge1xyXG4gICAgcmV0dXJuIGAke2RhdGFUeXBlfSgke3ZhbHVlfSlgO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGB2ZWMke2NvbXBvbmVudHN9PCR7ZGF0YVR5cGV9Pigke3ZhbHVlfSlgO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgY2FzdHMgdmFsdWUgb3IgdmVjdG9yIHRvIGYzMlxyXG4gKiBAcGFyYW0gZGF0YVR5cGVcclxuICogQHBhcmFtIGNvbXBvbmVudHNcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FzdFRvRjMyID0gKGRhdGFUeXBlOiBzdHJpbmcsIGNvbXBvbmVudHM6IG51bWJlciwgdmFsdWU6IHN0cmluZykgPT4ge1xyXG4gIGlmIChkYXRhVHlwZSA9PT0gJ2YzMicpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgaWYgKGNvbXBvbmVudHMgPT09IDEpIHtcclxuICAgIHJldHVybiBgZjMyKCR7dmFsdWV9KWA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYHZlYyR7Y29tcG9uZW50c308ZjMyPigke3ZhbHVlfSlgO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBzY2FsYXIgb3Igc3VtcyBhbGwgY29tcG9uZW50cyBvZiBhIHZlY3RvclxyXG4gKiBAcGFyYW0gbmFtZVxyXG4gKiBAcGFyYW0gY29tcG9uZW50c1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN1bVZlY3RvciA9IChuYW1lOiBzdHJpbmcsIGNvbXBvbmVudHM6IG51bWJlcikgPT4ge1xyXG4gIGlmIChjb21wb25lbnRzID09PSA0KSB7XHJcbiAgICByZXR1cm4gYCgke25hbWV9LnggKyAke25hbWV9LnkgKyAke25hbWV9LnogKyAke25hbWV9LncpYDtcclxuICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDIpIHtcclxuICAgIHJldHVybiBgKCR7bmFtZX0ueCArICR7bmFtZX0ueSlgO1xyXG4gIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMykge1xyXG4gICAgcmV0dXJuIGAoJHtuYW1lfS54ICsgJHtuYW1lfS55ICsgJHtuYW1lfS56KWA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmFtZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdmFyaWFibGUgZWxlbWVudCBhdCBpbmRleC5cclxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB2YXJpYWJsZS5cclxuICogQHBhcmFtIGluZGV4IC0gdGhlIGluZGV4IG9mIHZhcmlhYmxlIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHZhcmlhYmxlLlxyXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIHZhcmlhYmxlLCBvcHRpb25hbC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRFbGVtZW50QXQgPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIGluZGV4OiBudW1iZXIgfCBzdHJpbmcsXHJcbiAgbGVuZ3RoOiBudW1iZXIsXHJcbiAgdHlwZT86IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykgJiYgbGVuZ3RoID4gNCkge1xyXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgaWYgKHR5cGUgPT09ICdmMTYnKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke25hbWV9Wygke2luZGV4fSkgLyA4XVsoJHtpbmRleH0pICUgOCAvIDRdWygke2luZGV4fSkgJSA4ICUgNF1gO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVsoJHtpbmRleH0pIC8gNF1bKCR7aW5kZXh9KSAlIDRdYDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGUgPT09ICdmMTYnKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7TWF0aC5mbG9vcihpbmRleCAvIDgpfV1bJHtNYXRoLmZsb29yKChpbmRleCAlIDgpIC8gNCl9XVskeyhpbmRleCAlIDgpICUgNH1dYDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtNYXRoLmZsb29yKGluZGV4IC8gNCl9XVske2luZGV4ICUgNH1dYDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbGVuZ3RoID4gMSA/IGAke25hbWV9WyR7aW5kZXh9XWAgOiBuYW1lO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBJbmRpY2VzSGVscGVyIGZvciBhIGdpdmVuIGlucHV0IG9yIG91dHB1dC5cclxuICpcclxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxyXG4gKiBAcGFyYW0gdGVuc29yVHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxyXG4gKiBAcGFyYW0gc2hhcGVPclJhbmsgLSB0aGUgdGVuc29yIHNoYXBlIG9yIHRoZSByYW5rIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQuXHJcbiAqIEBwYXJhbSB1c2FnZSAtIHRoZSB1c2FnZSBvZiB0aGUgaW5kaWNlcyBoZWxwZXIuXHJcbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gaW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiBlYWNoIGVsZW1lbnQuIDEgZm9yIHNjYWxhciwgMiBmb3IgdmVjMiwgMyBmb3IgdmVjMywgNCBmb3JcclxuICogICAgdmVjNC5cclxuICovXHJcbmNvbnN0IGNyZWF0ZUluZGljZXNIZWxwZXIgPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIHRlbnNvclR5cGU6IG51bWJlcixcclxuICBzaGFwZU9yUmFuazogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgdXNhZ2U6IEluZGljZXNIZWxwZXJbJ3VzYWdlJ10sXHJcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCxcclxuKTogSW5kaWNlc0hlbHBlciA9PiB7XHJcbiAgY29uc3QgdXNlVW5pZm9ybSA9IHR5cGVvZiBzaGFwZU9yUmFuayA9PT0gJ251bWJlcic7XHJcbiAgY29uc3QgcmFuayA9IHVzZVVuaWZvcm0gPyBzaGFwZU9yUmFuayA6IHNoYXBlT3JSYW5rLmxlbmd0aDtcclxuICBjb25zdCByYW5rSWRlbnRpdHkgPSBbLi4ubmV3IEFycmF5KHJhbmspLmtleXMoKV07XHJcbiAgY29uc3QgaW5kaWNlc1R5cGUgPSByYW5rIDwgMiA/ICd1MzInIDogcmFuayA8PSA0ID8gYHZlYyR7cmFua308dTMyPmAgOiBgYXJyYXk8dTMyLCAke3Jhbmt9PmA7XHJcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHRlbnNvclR5cGUsIGNvbXBvbmVudHMpO1xyXG4gIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiBtYXBwZWRUeXBlID09PSAnc3RyaW5nJyA/IG1hcHBlZFR5cGUgOiBtYXBwZWRUeXBlWzFdO1xyXG4gIGNvbnN0IHN0b3JhZ2VUeXBlID0gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMF07XHJcbiAgY29uc3QgdHlwZSA9IHsgaW5kaWNlczogaW5kaWNlc1R5cGUsIHZhbHVlOiB2YWx1ZVR5cGUsIHN0b3JhZ2U6IHN0b3JhZ2VUeXBlLCB0ZW5zb3I6IHRlbnNvclR5cGUgfTtcclxuXHJcbiAgY29uc3Qgbm9ybWFsaXplRGltID0gKGRpbTogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nID0+ICh0eXBlb2YgZGltID09PSAnc3RyaW5nJyA/IGRpbSA6IGAke2RpbX11YCk7XHJcblxyXG4gIGNvbnN0IGltcGxlbWVudGF0aW9uVXNlZCA9IHtcclxuICAgIG9mZnNldFRvSW5kaWNlczogZmFsc2UsXHJcbiAgICBpbmRpY2VzVG9PZmZzZXQ6IGZhbHNlLFxyXG4gICAgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6IGZhbHNlLFxyXG4gICAgc2V0OiBmYWxzZSxcclxuICAgIHNldEJ5SW5kaWNlczogZmFsc2UsXHJcbiAgICBnZXQ6IGZhbHNlLFxyXG4gICAgZ2V0QnlJbmRpY2VzOiBmYWxzZSxcclxuICB9O1xyXG5cclxuICBjb25zdCB1bmlmb3JtUHJlZml4ID0gdXNlVW5pZm9ybSA/ICd1bmlmb3Jtcy4nIDogJyc7XHJcbiAgY29uc3Qgc2hhcGUgPSBgJHt1bmlmb3JtUHJlZml4fSR7bmFtZX1fc2hhcGVgO1xyXG4gIGNvbnN0IHN0cmlkZXMgPSBgJHt1bmlmb3JtUHJlZml4fSR7bmFtZX1fc3RyaWRlc2A7XHJcblxyXG4gIGxldCBvMmlTbmlwcGV0ID0gJyc7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMTsgaSsrKSB7XHJcbiAgICBvMmlTbmlwcGV0ICs9IGBcclxuICAgIGxldCBkaW0ke2l9ID0gY3VycmVudCAvICR7Z2V0RWxlbWVudEF0KHN0cmlkZXMsIGksIHJhbmspfTtcclxuICAgIGxldCByZXN0JHtpfSA9IGN1cnJlbnQgJSAke2dldEVsZW1lbnRBdChzdHJpZGVzLCBpLCByYW5rKX07XHJcbiAgICBpbmRpY2VzWyR7aX1dID0gZGltJHtpfTtcclxuICAgIGN1cnJlbnQgPSByZXN0JHtpfTtcclxuICAgIGA7XHJcbiAgfVxyXG4gIG8yaVNuaXBwZXQgKz0gYGluZGljZXNbJHtyYW5rIC0gMX1dID0gY3VycmVudDtgO1xyXG5cclxuICBjb25zdCBvZmZzZXRUb0luZGljZXNJbXBsZW1lbnRhdGlvbiA9XHJcbiAgICByYW5rIDwgMlxyXG4gICAgICA/ICcnXHJcbiAgICAgIDogYFxyXG4gIGZuIG8yaV8ke25hbWV9KG9mZnNldDogdTMyKSAtPiAke3R5cGUuaW5kaWNlc30ge1xyXG4gICAgdmFyIGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfTtcclxuICAgIHZhciBjdXJyZW50ID0gb2Zmc2V0O1xyXG4gICAgJHtvMmlTbmlwcGV0fVxyXG4gICAgcmV0dXJuIGluZGljZXM7XHJcbiAgfWA7XHJcblxyXG4gIGNvbnN0IG9mZnNldFRvSW5kaWNlcyA9ICh2YXJPZmZzZXQ6IHN0cmluZykgPT4ge1xyXG4gICAgaW1wbGVtZW50YXRpb25Vc2VkLm9mZnNldFRvSW5kaWNlcyA9IHRydWU7XHJcbiAgICByZXR1cm4gcmFuayA8IDIgPyB2YXJPZmZzZXQgOiBgbzJpXyR7bmFtZX0oJHt2YXJPZmZzZXR9KWA7XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgb2Zmc2V0czogc3RyaW5nW10gPSBbXTtcclxuICBpZiAocmFuayA+PSAyKSB7XHJcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIG9mZnNldHMucHVzaChgJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9ICogKGluZGljZXNbJHtpfV0pYCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBpbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbiA9XHJcbiAgICByYW5rIDwgMlxyXG4gICAgICA/ICcnXHJcbiAgICAgIDogYFxyXG4gIGZuIGkyb18ke25hbWV9KGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcclxuICAgIHJldHVybiAke29mZnNldHMuam9pbignKycpfTtcclxuICB9YDtcclxuXHJcbiAgY29uc3QgaW5kaWNlc1RvT2Zmc2V0ID0gKHZhckluZGljZXM6IHN0cmluZykgPT4ge1xyXG4gICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XHJcbiAgICByZXR1cm4gcmFuayA8IDIgPyB2YXJJbmRpY2VzIDogYGkyb18ke25hbWV9KCR7dmFySW5kaWNlc30pYDtcclxuICB9O1xyXG5cclxuICBjb25zdCBpbmRpY2VzID0gKC4uLmluaXQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT5cclxuICAgIHJhbmsgPT09IDAgPyAnMHUnIDogYCR7dHlwZS5pbmRpY2VzfSgke2luaXQubWFwKG5vcm1hbGl6ZURpbSkuam9pbignLCcpfSlgO1xyXG5cclxuICBjb25zdCBpbmRpY2VzR2V0ID0gKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcpID0+IHtcclxuICAgIGlmIChyYW5rIDwgMikge1xyXG4gICAgICByZXR1cm4gYCR7dmFySW5kaWNlc31gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGAke2dldEVsZW1lbnRBdCh2YXJJbmRpY2VzLCBpZHgsIHJhbmspfWA7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaW5kaWNlc1NldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyIHwgc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAocmFuayA8IDIpIHtcclxuICAgICAgcmV0dXJuIGAke3ZhckluZGljZXN9PSR7dmFsdWV9O2A7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gYCR7Z2V0RWxlbWVudEF0KHZhckluZGljZXMsIGlkeCwgcmFuayl9PSR7dmFsdWV9O2A7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xyXG4gIGNvbnN0IGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0ID0gKHZhckluZGljZXM6IHN0cmluZywgb3V0cHV0OiBJbmRpY2VzSGVscGVyKSA9PiB7XHJcbiAgICBpbXBsZW1lbnRhdGlvblVzZWQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xyXG4gICAgY29uc3QgaW1wbEtleSA9IGAke291dHB1dC5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtuYW1lfU9mZnNldGA7XHJcbiAgICBpZiAoaW1wbEtleSBpbiBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uKSB7XHJcbiAgICAgIHJldHVybiBgJHtpbXBsS2V5fSgke3ZhckluZGljZXN9KWA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvZmZzZXRzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGNvbnN0IGlkeCA9IG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgaSArIG91dHB1dC5yYW5rIC0gcmFuayk7XHJcbiAgICAgIG9mZnNldHMucHVzaChgJHtpbmRpY2VzR2V0KHN0cmlkZXMsIGkpfSAqICgke2lkeH0gJSAke2luZGljZXNHZXQoc2hhcGUsIGkpfSlgKTtcclxuICAgIH1cclxuICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb25baW1wbEtleV0gPSBgZm4gJHtpbXBsS2V5fShvdXRwdXRJbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiB1MzIge1xyXG4gICAgICAgICAgICAgcmV0dXJuICR7b2Zmc2V0cy5sZW5ndGggPiAwID8gb2Zmc2V0cy5qb2luKCcrJykgOiAnMHUnfTtcclxuICAgICAgICAgICB9YDtcclxuXHJcbiAgICByZXR1cm4gYCR7aW1wbEtleX0oJHt2YXJJbmRpY2VzfSlgO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNldEJ5T2Zmc2V0ID0gKG9mZnNldDogbnVtYmVyIHwgc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PlxyXG4gICAgKCgpID0+IHtcclxuICAgICAgaWYgKHR5cGUuc3RvcmFnZSA9PT0gdHlwZS52YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPSR7dmFsdWV9O2A7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAnaTMyJykge1xyXG4gICAgICAgIC8vIGludDY0LCBjb21wb25lbnRzID09PSAxXHJcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09dmVjMjx1MzI+KHUzMigke3ZhbHVlfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7dmFsdWV9IDwgMCkpO2A7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAndTMyJykge1xyXG4gICAgICAgIC8vIHVpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxyXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPXZlYzI8dTMyPih1MzIoJHt2YWx1ZX0pLCAwdSk7YDtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd1MzInICYmIHR5cGUudmFsdWUgPT09ICd2ZWM0PGJvb2w+Jykge1xyXG4gICAgICAgIC8vIGJvb2wsIGNvbXBvbmVudHMgPT09IDRcclxuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT1kb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPigke3ZhbHVlfSkpO2A7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3R5cGUuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHt0eXBlLnZhbHVlfSB5ZXRgKTtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcbiAgY29uc3QgZ2V0QnlPZmZzZXQgPSAob2Zmc2V0OiBudW1iZXIgfCBzdHJpbmcpID0+XHJcbiAgICAoKCkgPT4ge1xyXG4gICAgICBpZiAodHlwZS5zdG9yYWdlID09PSB0eXBlLnZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV1gO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ2kzMicpIHtcclxuICAgICAgICAvLyBpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxyXG4gICAgICAgIHJldHVybiBgaTMyKCR7bmFtZX1bJHtvZmZzZXR9XS54KWA7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAndTMyJykge1xyXG4gICAgICAgIC8vIHVpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxyXG4gICAgICAgIHJldHVybiBgdTMyKCR7bmFtZX1bJHtvZmZzZXR9XS54KWA7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndTMyJyAmJiB0eXBlLnZhbHVlID09PSAndmVjNDxib29sPicpIHtcclxuICAgICAgICAvLyBib29sLCBjb21wb25lbnRzID09PSA0XHJcbiAgICAgICAgcmV0dXJuIGB2ZWM0PGJvb2w+KGJvb2woJHtuYW1lfVske29mZnNldH1dICYgMHhGRnUpLCBib29sKCR7bmFtZX1bJHtvZmZzZXR9XSAmIDB4RkYwMHUpLCBib29sKCR7bmFtZX1bJHtcclxuICAgICAgICAgIG9mZnNldFxyXG4gICAgICAgIH1dICYgMHhGRjAwMDB1KSwgYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGMDAwMDAwdSkpYDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7dHlwZS5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke3R5cGUudmFsdWV9IHlldGApO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuICBjb25zdCBnZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbiA9XHJcbiAgICByYW5rIDwgMlxyXG4gICAgICA/ICcnXHJcbiAgICAgIDogYFxyXG4gIGZuIGdldF8ke25hbWV9QnlJbmRpY2VzKGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfSkgLT4gJHt2YWx1ZVR5cGV9IHtcclxuICAgIHJldHVybiAke2dldEJ5T2Zmc2V0KGBpMm9fJHtuYW1lfShpbmRpY2VzKWApfTtcclxuICB9YDtcclxuXHJcbiAgY29uc3QgZ2V0SW1wbGVtZW50YXRpb24gPVxyXG4gICAgcmFuayA8IDJcclxuICAgICAgPyAnJ1xyXG4gICAgICA6ICgoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBmdW5jdGlvblBhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoKGkpID0+IGBkJHtpfTogdTMyYCkuam9pbignLCAnKTtcclxuICAgICAgICAgIGNvbnN0IGRpbXNQYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKChpKSA9PiBgZCR7aX1gKS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgcmV0dXJuIGBcclxuICBmbiBnZXRfJHtuYW1lfSgke2Z1bmN0aW9uUGFyYW1zfSkgLT4gJHt2YWx1ZVR5cGV9IHtcclxuICAgIHJldHVybiBnZXRfJHtuYW1lfUJ5SW5kaWNlcygke2luZGljZXMoZGltc1BhcmFtcyl9KTtcclxuICB9YDtcclxuICAgICAgICB9KSgpO1xyXG5cclxuICBjb25zdCBnZXQgPSAoLi4uaW5kaWNlczogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PiB7XHJcbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggIT09IHJhbmspIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7cmFua31gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBub3JtYWxpemVkSW5kaWNlcyA9IGluZGljZXMubWFwKG5vcm1hbGl6ZURpbSkuam9pbignLCcpO1xyXG5cclxuICAgIGlmIChyYW5rID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBnZXRCeU9mZnNldCgnMHUnKTtcclxuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gZ2V0QnlPZmZzZXQobm9ybWFsaXplZEluZGljZXNbMF0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmdldCA9IHRydWU7XHJcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMgPSB0cnVlO1xyXG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGBnZXRfJHtuYW1lfSgke25vcm1hbGl6ZWRJbmRpY2VzfSlgO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGdldEJ5SW5kaWNlcyA9ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHtcclxuICAgIGlmIChyYW5rIDwgMikge1xyXG4gICAgICByZXR1cm4gZ2V0QnlPZmZzZXQodmFySW5kaWNlcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuZ2V0QnlJbmRpY2VzID0gdHJ1ZTtcclxuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XHJcbiAgICAgIHJldHVybiBgZ2V0XyR7bmFtZX1CeUluZGljZXMoJHt2YXJJbmRpY2VzfSlgO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uID1cclxuICAgIHJhbmsgPCAyXHJcbiAgICAgID8gJydcclxuICAgICAgOiBgXHJcbiAgZm4gc2V0XyR7bmFtZX1CeUluZGljZXMoaW5kaWNlczogJHt0eXBlLmluZGljZXN9LCB2YWx1ZTogJHt2YWx1ZVR5cGV9KSB7XHJcbiAgICAke3NldEJ5T2Zmc2V0KGBpMm9fJHtuYW1lfShpbmRpY2VzKWAsICd2YWx1ZScpfVxyXG4gIH1gO1xyXG5cclxuICBjb25zdCBzZXRJbXBsZW1lbnRhdGlvbiA9XHJcbiAgICByYW5rIDwgMlxyXG4gICAgICA/ICcnXHJcbiAgICAgIDogKCgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcCgoaSkgPT4gYGQke2l9OiB1MzJgKS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgY29uc3QgZGltc1BhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoKGkpID0+IGBkJHtpfWApLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICByZXR1cm4gYFxyXG4gIGZuIHNldF8ke25hbWV9KCR7ZnVuY3Rpb25QYXJhbXN9LCB2YWx1ZTogJHt2YWx1ZVR5cGV9KSB7XHJcbiAgICBzZXRfJHtuYW1lfUJ5SW5kaWNlcygke2luZGljZXMoZGltc1BhcmFtcyl9LCB2YWx1ZSk7XHJcbiAgfWA7XHJcbiAgICAgICAgfSkoKTtcclxuXHJcbiAgY29uc3Qgc2V0ID0gKC4uLmluZGljZXNBbmRWYWx1ZTogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PiB7XHJcbiAgICBpZiAoaW5kaWNlc0FuZFZhbHVlLmxlbmd0aCAhPT0gcmFuayArIDEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7cmFua31gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbHVlID0gaW5kaWNlc0FuZFZhbHVlW3JhbmtdO1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIHN0cmluZycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRpY2VzID0gaW5kaWNlc0FuZFZhbHVlLnNsaWNlKDAsIHJhbmspLm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKTtcclxuXHJcbiAgICBpZiAocmFuayA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gc2V0QnlPZmZzZXQoJzB1JywgdmFsdWUpO1xyXG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBzZXRCeU9mZnNldChub3JtYWxpemVkSW5kaWNlc1swXSwgdmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLnNldCA9IHRydWU7XHJcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMgPSB0cnVlO1xyXG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGBzZXRfJHtuYW1lfSgke25vcm1hbGl6ZWRJbmRpY2VzfSwgJHt2YWx1ZX0pYDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBzZXRCeUluZGljZXMgPSAodmFySW5kaWNlczogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAocmFuayA8IDIpIHtcclxuICAgICAgcmV0dXJuIHNldEJ5T2Zmc2V0KHZhckluZGljZXMsIHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMgPSB0cnVlO1xyXG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGBzZXRfJHtuYW1lfUJ5SW5kaWNlcygke3ZhckluZGljZXN9LCAke3ZhbHVlfSk7YDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBpbXBsID0gKCkgPT4ge1xyXG4gICAgY29uc3QgaW1wbHMgPSBbXTtcclxuICAgIGxldCBuZWVkU2hhcGVTdHJpZGVzID0gZmFsc2U7XHJcbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLm9mZnNldFRvSW5kaWNlcykge1xyXG4gICAgICBpbXBscy5wdXNoKG9mZnNldFRvSW5kaWNlc0ltcGxlbWVudGF0aW9uKTtcclxuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCkge1xyXG4gICAgICBpbXBscy5wdXNoKGluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uKTtcclxuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KSB7XHJcbiAgICAgIE9iamVjdC52YWx1ZXMoYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbikuZm9yRWFjaCgoaW1wbCkgPT4gaW1wbHMucHVzaChpbXBsKSk7XHJcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5zZXQpIHtcclxuICAgICAgaW1wbHMucHVzaChzZXRJbXBsZW1lbnRhdGlvbik7XHJcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMpIHtcclxuICAgICAgaW1wbHMucHVzaChzZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbik7XHJcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5nZXQpIHtcclxuICAgICAgaW1wbHMucHVzaChnZXRJbXBsZW1lbnRhdGlvbik7XHJcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMpIHtcclxuICAgICAgaW1wbHMucHVzaChnZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbik7XHJcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKCF1c2VVbmlmb3JtICYmIG5lZWRTaGFwZVN0cmlkZXMpIHtcclxuICAgICAgaW1wbHMudW5zaGlmdChcclxuICAgICAgICBgY29uc3QgJHtzaGFwZX0gPSAke3R5cGUuaW5kaWNlc30oJHtzaGFwZU9yUmFuay5qb2luKCcsJyl9KTtgLFxyXG4gICAgICAgIGBjb25zdCAke3N0cmlkZXN9ID0gJHt0eXBlLmluZGljZXN9KCR7U2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHNoYXBlT3JSYW5rKS5qb2luKCcsJyl9KTtgLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGltcGxzLmpvaW4oJ1xcbicpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBpbXBsLFxyXG4gICAgdHlwZSxcclxuICAgIG9mZnNldFRvSW5kaWNlcyxcclxuICAgIGluZGljZXNUb09mZnNldCxcclxuICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0LFxyXG4gICAgaW5kaWNlcyxcclxuICAgIGluZGljZXNHZXQsXHJcbiAgICBpbmRpY2VzU2V0LFxyXG4gICAgc2V0LFxyXG4gICAgc2V0QnlPZmZzZXQsXHJcbiAgICBzZXRCeUluZGljZXMsXHJcbiAgICBnZXQsXHJcbiAgICBnZXRCeU9mZnNldCxcclxuICAgIGdldEJ5SW5kaWNlcyxcclxuICAgIC8vIGlzVmVjNCxcclxuICAgIHVzYWdlLFxyXG4gICAgbmFtZSxcclxuICAgIHN0cmlkZXMsXHJcbiAgICBzaGFwZSxcclxuICAgIHJhbmssXHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBpbnB1dC5cclxuICpcclxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaW5wdXQuXHJcbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSBpbnB1dC5cclxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgaW5wdXQuXHJcbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSBpbnB1dC4gYXZhaWxhYmxlIHZhbHVlcyBhcmUgMSwgMiwgMywgNC4gZGVmYXVsdCBpcyAxLlxyXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgaW5wdXQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaW5wdXRWYXJpYWJsZSA9IChcclxuICBuYW1lOiBzdHJpbmcsXHJcbiAgdHlwZTogbnVtYmVyLFxyXG4gIHNoYXBlT3JSYW5rOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXSxcclxuICBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSxcclxuKTogSW5kaWNlc0hlbHBlciA9PiBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnaW5wdXQnLCBjb21wb25lbnRzKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBvdXRwdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIG91dHB1dC5cclxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIG91dHB1dC5cclxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgb3V0cHV0LlxyXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgb3V0cHV0LiBhdmFpbGFibGUgdmFsdWVzIGFyZSAxLCAyLCAzLCA0LiBkZWZhdWx0IGlzIDEuXHJcbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSBvdXRwdXQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgb3V0cHV0VmFyaWFibGUgPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIHR5cGU6IG51bWJlcixcclxuICBzaGFwZU9yUmFuazogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEsXHJcbik6IEluZGljZXNIZWxwZXIgPT4gY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ291dHB1dCcsIGNvbXBvbmVudHMpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIEluZGljZXNIZWxwZXIgZm9yIGFuIGF0b21pYyBvdXRwdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIG91dHB1dC5cclxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIG91dHB1dC5cclxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgb3V0cHV0LlxyXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgb3V0cHV0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGF0b21pY091dHB1dFZhcmlhYmxlID0gKFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICB0eXBlOiBudW1iZXIsXHJcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxyXG4pOiBJbmRpY2VzSGVscGVyID0+IGNyZWF0ZUluZGljZXNIZWxwZXIobmFtZSwgdHlwZSwgc2hhcGVPclJhbmssICdhdG9taWNPdXRwdXQnLCAxKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cclxuICpcclxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUuXHJcbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSB2YXJpYWJsZS5cclxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgdmFyaWFibGUuXHJcbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSB2YXJpYWJsZS4gYXZhaWxhYmxlIHZhbHVlcyBhcmUgMSwgMiwgMywgNC4gZGVmYXVsdCBpcyAxLlxyXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaW50ZXJuYWxWYXJpYWJsZSA9IChcclxuICBuYW1lOiBzdHJpbmcsXHJcbiAgdHlwZTogbnVtYmVyLFxyXG4gIHNoYXBlT3JSYW5rOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXSxcclxuICBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSxcclxuKTogSW5kaWNlc0hlbHBlciA9PiBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnaW50ZXJuYWwnLCBjb21wb25lbnRzKTtcclxuXHJcbmV4cG9ydCB0eXBlIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgPSAndTMyJyB8ICdmMTYnIHwgJ2YzMicgfCAnaTMyJztcclxuZXhwb3J0IHR5cGUgVW5pZm9ybXNBcnJheVR5cGUgPSBBcnJheTx7IG5hbWU6IHN0cmluZzsgdHlwZTogVW5pZm9ybURhdGFFbGVtZW50VHlwZTsgbGVuZ3RoPzogbnVtYmVyIH0+O1xyXG5cclxuLyoqXHJcbiAqIEEgU2hhZGVySGVscGVyIGlzIGEgaGVscGVyIGNsYXNzIGZvciBnZW5lcmF0aW5nIFdHU0wgY29kZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVySGVscGVyIHtcclxuICAvKipcclxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgc3RhcnQgb2YgbWFpbiBmdW5jdGlvbiBpbiBXR1NMIHNvdXJjZSBjb2RlLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICAgKiAgLi4uXHJcbiAgICpcclxuICAgKiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICogICAgLy8geW91ciBjb2RlIGhlcmUgaW5zaWRlIG1haW4oKSBmdW5jdGlvblxyXG4gICAqICAgIC4uLlxyXG4gICAqICB9XHJcbiAgICogYDtcclxuICAgKlxyXG4gICAqIEBwYXJhbSB3b3JrZ3JvdXBTaXplIC0gYW4gb3B0aW9uYWwgd29ya2dyb3VwIHNpemUuIGRlZmF1bHQgaXMgV09SS0dST1VQX1NJWkUuXHJcbiAgICovXHJcbiAgbWFpblN0YXJ0KHdvcmtncm91cFNpemU/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHNuaXBwZXQgZm9yIGd1YXJkaW5nIGFnYWluc3Qgb3V0LW9mLWJvdW5kcyBzaXplLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICAgKiAgLi4uXHJcbiAgICpcclxuICAgKiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICogICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cclxuICAgKlxyXG4gICAqICAgIC8vIHlvdXIgY29kZSBoZXJlIGluc2lkZSBtYWluKCkgZnVuY3Rpb25cclxuICAgKiAgICAuLi5cclxuICAgKiAgfVxyXG4gICAqIGA7XHJcbiAgICpcclxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIG9mIHRoZSBkYXRhIHRvIGd1YXJkIGFnYWluc3QuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cclxuICAgKi9cclxuICBndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHNpemU6IHVua25vd24pOiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHNuaXBwZXQgZm9yIGRlY2xhcmluZyBtdWx0aXBsZSBpbnB1dHMgb3Igb3V0cHV0cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YXJpYWJsZXMgLSBhbiBhcnJheSBvZiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGVzLlxyXG4gICAqL1xyXG4gIGRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG9uZSB1bmlmb3JtLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHRoZSB1bmlmb3JtLCBkZWZhdWx0IHRvIDEgd2hlbiBpdCBpcyBub3QgcHJvdmlkZWQuXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJVbmlmb3JtKG5hbWU6IHN0cmluZywgdHlwZTogc3RyaW5nLCBsZW5ndGg/OiBudW1iZXIpOiBTaGFkZXJIZWxwZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHVuaWZvcm1zIC0gYW4gYXJyYXkgb2YgdW5pZm9ybXMuIEVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgYW4gb2JqZWN0IHdpdGggMiBwcm9wZXJ0aWVzOiBgbmFtZWAgYW5kXHJcbiAgICogICAgIGB0eXBlYC5cclxuICAgKi9cclxuICByZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSk6IFNoYWRlckhlbHBlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgbXVsdGlwbGUgaW50ZXJuYWwgdmFyaWFibGVzLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlXHJcbiAgICogaW50ZXJuYWwgdmFyaWFibGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHZhcmlhYmxlcyAtIGFuIGFycmF5IG9mIEluZGljZXNIZWxwZXIgZm9yIHRoZSB2YXJpYWJsZXMuXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IFNoYWRlckhlbHBlcjtcclxufVxyXG5cclxuY2xhc3MgU2hhZGVySGVscGVySW1wbCBpbXBsZW1lbnRzIFNoYWRlckhlbHBlciB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgICBwcml2YXRlIGxpbWl0czogR1BVU3VwcG9ydGVkTGltaXRzLFxyXG4gICkge31cclxuXHJcbiAgZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzaXplOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgLy8gR3VhcmQgYWdhaW5zdCBvdXQtb2YtYm91bmRzIHdvcmsgZ3JvdXAgc2l6ZXNcclxuICAgIGNvbnN0IHNpemVJbkNvZGUgPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBgJHtzaXplfXVgIDogc2l6ZTtcclxuICAgIHJldHVybiBgaWYgKGdsb2JhbF9pZHggPj0gJHtzaXplSW5Db2RlfSkgeyByZXR1cm47IH1gO1xyXG4gIH1cclxuXHJcbiAgbWFpblN0YXJ0KHdvcmtncm91cFNpemU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFdPUktHUk9VUF9TSVpFKSB7XHJcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplWCA9IHR5cGVvZiB3b3JrZ3JvdXBTaXplID09PSAnbnVtYmVyJyA/IHdvcmtncm91cFNpemUgOiB3b3JrZ3JvdXBTaXplWzBdO1xyXG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVkgPSB0eXBlb2Ygd29ya2dyb3VwU2l6ZSA9PT0gJ251bWJlcicgPyAxIDogd29ya2dyb3VwU2l6ZVsxXTtcclxuICAgIGNvbnN0IHdvcmtncm91cFNpemVaID0gdHlwZW9mIHdvcmtncm91cFNpemUgPT09ICdudW1iZXInID8gMSA6IHdvcmtncm91cFNpemVbMl07XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICB3b3JrZ3JvdXBTaXplWCA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCB8fFxyXG4gICAgICB3b3JrZ3JvdXBTaXplWSA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSB8fFxyXG4gICAgICB3b3JrZ3JvdXBTaXplWiA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWlxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgd29ya2dyb3VwIHNpemUgWyR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHtcclxuICAgICAgICAgIHdvcmtncm91cFNpemVaXHJcbiAgICAgICAgfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgc2l6ZSBbJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVh9LCAke1xyXG4gICAgICAgICAgdGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZXHJcbiAgICAgICAgfSwgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVp9XS5gLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh3b3JrZ3JvdXBTaXplWCAqIHdvcmtncm91cFNpemVZICogd29ya2dyb3VwU2l6ZVogPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGB3b3JrZ3JvdXAgc2l6ZSBbJHt3b3JrZ3JvdXBTaXplWH0sICR7d29ya2dyb3VwU2l6ZVl9LCAke1xyXG4gICAgICAgICAgd29ya2dyb3VwU2l6ZVpcclxuICAgICAgICB9XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBpbnZvY2F0aW9ucyAke3RoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cH0uYCxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpczFEaW1lbnNpb25EaXNwYXRjaCA9IHRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV0gPT09IDEgJiYgdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXSA9PT0gMTtcclxuICAgIGNvbnN0IHBhcmFtTGlzdCA9IGlzMURpbWVuc2lvbkRpc3BhdGNoXHJcbiAgICAgID8gYEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXHJcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcclxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcclxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+YFxyXG4gICAgICA6IGBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPixcclxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcclxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxyXG4gICAgQGJ1aWx0aW4obnVtX3dvcmtncm91cHMpIG51bV93b3JrZ3JvdXBzIDogdmVjMzx1MzI+YDtcclxuICAgIGNvbnN0IGdsb2JhbElkeERlZmluaXRpb24gPSBpczFEaW1lbnNpb25EaXNwYXRjaFxyXG4gICAgICA/IGBsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1xyXG4gICAgICAgICBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLng7YFxyXG4gICAgICA6IGBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLnogKiBudW1fd29ya2dyb3Vwc1swXSAqIG51bV93b3JrZ3JvdXBzWzFdICtcclxuICAgICAgICAgICAgIHdvcmtncm91cF9pZC55ICogbnVtX3dvcmtncm91cHNbMF0gKyB3b3JrZ3JvdXBfaWQueDtcclxuICAgICAgICAgbGV0IGdsb2JhbF9pZHggPSB3b3JrZ3JvdXBfaW5kZXggKiAke3dvcmtncm91cFNpemVYICogd29ya2dyb3VwU2l6ZVkgKiB3b3JrZ3JvdXBTaXplWn11ICsgbG9jYWxfaWR4O2A7XHJcblxyXG4gICAgcmV0dXJuIGBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt3b3JrZ3JvdXBTaXplWH0sICR7d29ya2dyb3VwU2l6ZVl9LCAke3dvcmtncm91cFNpemVafSlcclxuICBmbiBtYWluKCR7cGFyYW1MaXN0fSkge1xyXG4gICAgJHtnbG9iYWxJZHhEZWZpbml0aW9ufVxyXG4gIGA7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGU6IEluZGljZXNIZWxwZXIpOiB2b2lkIHtcclxuICAgIGlmICh2YXJpYWJsZS5yYW5rICE9PSAwKSB7XHJcbiAgICAgIGlmICh2YXJpYWJsZS5zaGFwZS5zdGFydHNXaXRoKCd1bmlmb3Jtcy4nKSkge1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMucHVzaCh7IG5hbWU6IHZhcmlhYmxlLnNoYXBlLnJlcGxhY2UoJ3VuaWZvcm1zLicsICcnKSwgdHlwZTogJ3UzMicsIGxlbmd0aDogdmFyaWFibGUucmFuayB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmFyaWFibGUuc3RyaWRlcy5zdGFydHNXaXRoKCd1bmlmb3Jtcy4nKSkge1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMucHVzaCh7IG5hbWU6IHZhcmlhYmxlLnN0cmlkZXMucmVwbGFjZSgndW5pZm9ybXMuJywgJycpLCB0eXBlOiAndTMyJywgbGVuZ3RoOiB2YXJpYWJsZS5yYW5rIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlY2xhcmVWYXJpYWJsZSh2YXJpYWJsZTogSW5kaWNlc0hlbHBlciwgYmluZGluZ0luZGV4OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgaWYgKHZhcmlhYmxlLnVzYWdlID09PSAnaW50ZXJuYWwnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSBpbnRlcm5hbCB2YXJpYWJsZSB3aXRoIGRlY2xhcmVWYXJpYWJsZSgpLiB1c2UgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcygpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcclxuICAgIHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh2YXJpYWJsZSk7XHJcbiAgICBjb25zdCBhY2Nlc3MgPSB2YXJpYWJsZS51c2FnZSA9PT0gJ2lucHV0JyA/ICdyZWFkJyA6ICdyZWFkX3dyaXRlJztcclxuICAgIGNvbnN0IHN0b3JhZ2VUeXBlID0gdmFyaWFibGUudXNhZ2UgPT09ICdhdG9taWNPdXRwdXQnID8gYGF0b21pYzxpMzI+YCA6IHZhcmlhYmxlLnR5cGUuc3RvcmFnZTtcclxuICAgIHJldHVybiBgQGdyb3VwKDApIEBiaW5kaW5nKCR7YmluZGluZ0luZGV4fSkgdmFyPHN0b3JhZ2UsICR7YWNjZXNzfT4gJHt2YXJpYWJsZS5uYW1lfTogYXJyYXk8JHtzdG9yYWdlVHlwZX0+O2A7XHJcbiAgfVxyXG5cclxuICBkZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB2YXJpYWJsZXMubWFwKCh2KSA9PiB0aGlzLmRlY2xhcmVWYXJpYWJsZSh2LCB0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oJ1xcbicpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWdpc3RlckludGVybmFsVmFyaWFibGUodmFyaWFibGU6IEluZGljZXNIZWxwZXIpOiB2b2lkIHtcclxuICAgIGlmICh2YXJpYWJsZS51c2FnZSAhPT0gJ2ludGVybmFsJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgJ2Nhbm5vdCB1c2UgaW5wdXQgb3Igb3V0cHV0IHZhcmlhYmxlIHdpdGggcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKCkuIHVzZSBkZWNsYXJlVmFyaWFibGVzKCkgaW5zdGVhZC4nLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XHJcbiAgICB0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGUpO1xyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IFNoYWRlckhlbHBlciB7XHJcbiAgICB2YXJpYWJsZXMuZm9yRWFjaCgodikgPT4gdGhpcy5yZWdpc3RlckludGVybmFsVmFyaWFibGUodikpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICByZWdpc3RlclVuaWZvcm0obmFtZTogc3RyaW5nLCB0eXBlOiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLCBsZW5ndGggPSAxKTogU2hhZGVySGVscGVyIHtcclxuICAgIHRoaXMudW5pZm9ybXMucHVzaCh7IG5hbWUsIHR5cGUsIGxlbmd0aCB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJVbmlmb3JtcyhhZGRpdGlvbmFsVW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlKTogU2hhZGVySGVscGVyIHtcclxuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zLmNvbmNhdChhZGRpdGlvbmFsVW5pZm9ybXMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGludGVybmFsVmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10gPSBbXTtcclxuICBwcml2YXRlIHZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdID0gW107XHJcbiAgcHJpdmF0ZSB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXTtcclxuICBwcml2YXRlIHVuaWZvcm1EZWNsYXJhdGlvbigpOiBzdHJpbmcge1xyXG4gICAgaWYgKHRoaXMudW5pZm9ybXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1bmlmb3JtU25pcHBldHM6IHN0cmluZ1tdID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHsgbmFtZSwgdHlwZSwgbGVuZ3RoIH0gb2YgdGhpcy51bmlmb3Jtcykge1xyXG4gICAgICBpZiAobGVuZ3RoICYmIGxlbmd0aCA+IDQpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2YxNicpIHtcclxuICAgICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGBAYWxpZ24oMTYpICR7bmFtZX06YXJyYXk8bWF0Mng0PCR7dHlwZX0+LCAke01hdGguY2VpbChsZW5ndGggLyA4KX0+YCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGAke25hbWV9OmFycmF5PHZlYzQ8JHt0eXBlfT4sICR7TWF0aC5jZWlsKGxlbmd0aCAvIDQpfT5gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgdHlwZVRlbXAgPSBsZW5ndGggPT0gbnVsbCB8fCBsZW5ndGggPT09IDEgPyB0eXBlIDogYHZlYyR7bGVuZ3RofTwke3R5cGV9PmA7XHJcbiAgICAgICAgdW5pZm9ybVNuaXBwZXRzLnB1c2goYCR7bmFtZX06JHt0eXBlVGVtcH1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBgXHJcbiAgICAgIHN0cnVjdCBVbmlmb3JtcyB7ICR7dW5pZm9ybVNuaXBwZXRzLmpvaW4oJywgJyl9IH07XHJcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YDtcclxuICB9XHJcbiAgcHJpdmF0ZSB2YXJpYWJsZUluZGV4ID0gMDtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFkZGl0aW9uYWwgaW1wbGVtZW50YXRpb24gdGhhdCBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgc2hhZGVyIHNvdXJjZS5cclxuICAgKi9cclxuICBnZXQgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucygpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSArXHJcbiAgICAgIHRoaXMudmFyaWFibGVzLm1hcCgoaSkgPT4gaS5pbXBsKCkpLmpvaW4oJ1xcbicpICtcclxuICAgICAgdGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5tYXAoKGkpID0+IGkuaW1wbCgpKS5qb2luKCdcXG4nKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdmFyaWFibGUgaW5mbyBvZiB0aGUgc2hhZGVyIHByb2dyYW0uXHJcbiAgICovXHJcbiAgZ2V0IHZhcmlhYmxlc0luZm8oKTogUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm9bXSB8IHVuZGVmaW5lZCB7XHJcbiAgICBpZiAodGhpcy51bmlmb3Jtcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1bmlmb3JtV2dzbFR5cGVUb0RhdGFUeXBlID0gKHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUpID0+XHJcbiAgICAgIFtEYXRhVHlwZS51aW50MzIsIERhdGFUeXBlLmZsb2F0MTYsIERhdGFUeXBlLmZsb2F0LCBEYXRhVHlwZS5pbnQzMl1bWyd1MzInLCAnZjE2JywgJ2YzMicsICdpMzInXS5pbmRleE9mKHR5cGUpXTtcclxuICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hcCgodSkgPT4gW3VuaWZvcm1XZ3NsVHlwZVRvRGF0YVR5cGUodS50eXBlKSwgdS5sZW5ndGggPz8gMV0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNoYWRlckhlbHBlciA9IChkaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGxpbWl0czogR1BVU3VwcG9ydGVkTGltaXRzKSA9PlxyXG4gIG5ldyBTaGFkZXJIZWxwZXJJbXBsKGRpc3BhdGNoR3JvdXAsIGxpbWl0cyk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc3Bvc2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBwZXJtOiBudW1iZXJbXTtcclxufVxyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIHBlcm06IHJlYWRvbmx5IG51bWJlcltdKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC4nKTtcclxuICB9XHJcblxyXG4gIGlmIChwZXJtLmxlbmd0aCAhPT0gMCAmJiBwZXJtLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBlcm0gc2l6ZSAke3Blcm0ubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCBpbnB1dCByYW5rICR7aW5wdXRzWzBdLmRpbXMubGVuZ3RofWApO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGdldEFkanVzdGVkUGVybSA9IChpbnB1dFJhbms6IG51bWJlciwgcGVybTogbnVtYmVyW10pOiBudW1iZXJbXSA9PlxyXG4gIHBlcm0ubGVuZ3RoICE9PSAwID8gcGVybSA6IFsuLi5uZXcgQXJyYXkoaW5wdXRSYW5rKS5rZXlzKCldLnJldmVyc2UoKTtcclxuXHJcbmNvbnN0IGdldE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtOiBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdID0+XHJcbiAgU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybShpbnB1dFNoYXBlLCBnZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZS5sZW5ndGgsIHBlcm0pKTtcclxuXHJcbmNvbnN0IHBlcm1GdW5jdGlvbkJvZHkgPSAocGVybTogbnVtYmVyW10sIHJhbms6IG51bWJlciwgaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlcik6IHN0cmluZyA9PiB7XHJcbiAgbGV0IHJldmVyc2VGdW5jID0gYGZuIHBlcm0oaTogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcclxuICAgIHZhciBhOiAke2lucHV0LnR5cGUuaW5kaWNlc307YDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xyXG4gICAgLy8gaW5wdXQgaW5kaWNlcyBhbmQgb3V0cHV0IGluZGljZXMgc2hvdWxkIGFsd2F5cyBiZSBsYXJnZXIgb3IgZXF1YWwgdG8gMixcclxuICAgIC8vIHNvIGluZGV4ZXIgaXMgYWx3YXlzIHZhbGlkIHRvIGJlIHVzZWQgb24gYGFgIGFuZCBgaWAuXHJcbiAgICByZXZlcnNlRnVuYyArPSBgYVske3Blcm1baV19XT1pWyR7aX1dO2A7XHJcbiAgfVxyXG4gIHJldHVybiAocmV2ZXJzZUZ1bmMgKz0gJ3JldHVybiBhO30nKTtcclxufTtcclxuXHJcbmNvbnN0IHNxdWVlemVTaGFwZSA9IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGFkanVzdGVkUGVybTogbnVtYmVyW10pOiB7IG5ld1NoYXBlOiBudW1iZXJbXTsgbmV3UGVybTogbnVtYmVyW10gfSA9PiB7XHJcbiAgY29uc3QgbmV3U2hhcGU6IG51bWJlcltdID0gW107XHJcbiAgY29uc3QgbmV3UGVybTogbnVtYmVyW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoc2hhcGVbaV0gIT09IDEpIHtcclxuICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcGVbYWRqdXN0ZWRQZXJtW2ldXSAhPT0gMSkge1xyXG4gICAgICBuZXdQZXJtLnB1c2goYWRqdXN0ZWRQZXJtW2ldKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHsgbmV3U2hhcGUsIG5ld1Blcm0gfTtcclxufTtcclxuXHJcbmNvbnN0IGlzVHJhbnNwb3NlUmVzaGFwZSA9IChwZXJtOiBudW1iZXJbXSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiB7XHJcbiAgLy8gQXMgbG9uZyBhcyB0aGUgZGltcyB3aXRoIHZhbHVlcyA+IDEgc3RheSBpbiB0aGUgc2FtZSBvcmRlciwgaXQncyBhIHJlc2hhcGUuXHJcbiAgLy8gRXhhbXBsZTogU2hhcGU9KDEsMSwxMDI0LDQwOTYpIC0+IHBlcm09KDIsMCwzLDEpLlxyXG4gIGxldCBsYXN0UGVybXV0ZWRBeGlzID0gMDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBlcm0ubGVuZ3RoOyArK2kpIHtcclxuICAgIGlmIChzaGFwZVtwZXJtW2ldXSA9PT0gMSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChwZXJtW2ldIDwgbGFzdFBlcm11dGVkQXhpcykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsYXN0UGVybXV0ZWRBeGlzID0gcGVybVtpXTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gPSAoaW5wdXRUZW5zb3I6IFRlbnNvclZpZXcsIHBlcm1BdHRyOiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBpbnB1dERhdGFUeXBlID0gaW5wdXRUZW5zb3IuZGF0YVR5cGU7XHJcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRUZW5zb3IuZGltcy5sZW5ndGg7XHJcbiAgY29uc3QgcGVybSA9IGdldEFkanVzdGVkUGVybShpbnB1dFJhbmssIHBlcm1BdHRyKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGdldE91dHB1dFNoYXBlKGlucHV0VGVuc29yLmRpbXMsIHBlcm0pO1xyXG4gIGxldCBuZXdJbnB1dFNoYXBlID0gaW5wdXRUZW5zb3IuZGltcztcclxuICBsZXQgbmV3T3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcclxuICBjb25zdCB0cmFuc3Bvc2VBc1Jlc2hhcGUgPSBpbnB1dFJhbmsgPCAyIHx8IGlzVHJhbnNwb3NlUmVzaGFwZShwZXJtLCBpbnB1dFRlbnNvci5kaW1zKTtcclxuICBsZXQgZ2V0U2hhZGVyU291cmNlO1xyXG4gIGlmICh0cmFuc3Bvc2VBc1Jlc2hhcGUpIHtcclxuICAgIGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXREYXRhVHlwZSwgbmV3SW5wdXRTaGFwZSwgNCk7XHJcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dERhdGFUeXBlLCBuZXdPdXRwdXRTaGFwZSwgNCk7XHJcbiAgICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1xyXG4gIH1gO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiAnVHJhbnNwb3NlQ29weScsXHJcbiAgICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxyXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFRlbnNvci5kYXRhVHlwZSB9XSxcclxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogY29tcG9uZW50cyAqLykgfSxcclxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtczogW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDQpIH1dLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIH07XHJcbiAgfVxyXG4gIGNvbnN0IHsgbmV3U2hhcGUsIG5ld1Blcm0gfSA9IHNxdWVlemVTaGFwZShpbnB1dFRlbnNvci5kaW1zLCBwZXJtKTtcclxuICBjb25zdCBjaGFubmVsc0xhc3QgPSBTaGFwZVV0aWwuYXJlRXF1YWwobmV3UGVybSwgWzIsIDMsIDFdKTtcclxuICBjb25zdCBjaGFubmVsc0ZpcnN0ID0gU2hhcGVVdGlsLmFyZUVxdWFsKG5ld1Blcm0sIFszLCAxLCAyXSk7XHJcbiAgY29uc3QgdXNlU2hhcmVkID0gbmV3U2hhcGUubGVuZ3RoID09PSAyIHx8IGNoYW5uZWxzTGFzdCB8fCBjaGFubmVsc0ZpcnN0O1xyXG4gIGlmICh1c2VTaGFyZWQpIHtcclxuICAgIG5ld0lucHV0U2hhcGUgPSBjaGFubmVsc0xhc3RcclxuICAgICAgPyBbbmV3U2hhcGVbMF0sIG5ld1NoYXBlWzFdICogbmV3U2hhcGVbMl1dXHJcbiAgICAgIDogY2hhbm5lbHNGaXJzdFxyXG4gICAgICAgID8gW25ld1NoYXBlWzBdICogbmV3U2hhcGVbMV0sIG5ld1NoYXBlWzJdXVxyXG4gICAgICAgIDogbmV3U2hhcGU7XHJcbiAgICBuZXdPdXRwdXRTaGFwZSA9IFtuZXdJbnB1dFNoYXBlWzFdLCBuZXdJbnB1dFNoYXBlWzBdXTtcclxuICAgIGNvbnN0IHRpbGVTaXplID0gMTY7XHJcbiAgICBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXREYXRhVHlwZSwgbmV3SW5wdXRTaGFwZS5sZW5ndGgpO1xyXG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgbmV3T3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuICAgICAgcmV0dXJuIGBcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XHJcbiAgdmFyPHdvcmtncm91cD4gdGlsZSA6IGFycmF5PGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke3RpbGVTaXplICsgMX0+LCAke3RpbGVTaXplfT47XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFt0aWxlU2l6ZSwgdGlsZVNpemUsIDFdKX1cclxuICAgIGxldCBzdHJpZGUgPSAodW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdIC0gMSkgLyAke3RpbGVTaXplfSArIDE7XHJcbiAgICBsZXQgd29ya2dyb3VwX2lkX3ggPSB3b3JrZ3JvdXBfaW5kZXggJSBzdHJpZGU7XHJcbiAgICBsZXQgd29ya2dyb3VwX2lkX3kgPSB3b3JrZ3JvdXBfaW5kZXggLyBzdHJpZGU7XHJcbiAgICBsZXQgaW5wdXRfY29sID0gd29ya2dyb3VwX2lkX3kgKiAke3RpbGVTaXplfXUgKyBsb2NhbF9pZC54O1xyXG4gICAgbGV0IGlucHV0X3JvdyA9IHdvcmtncm91cF9pZF94ICogJHt0aWxlU2l6ZX11ICsgbG9jYWxfaWQueTtcclxuICAgIGlmIChpbnB1dF9yb3cgPCB1bmlmb3Jtcy5hX3NoYXBlWzBdICYmIGlucHV0X2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMV0pIHtcclxuICAgICAgdGlsZVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKGAke2lucHV0LnR5cGUuaW5kaWNlc30oaW5wdXRfcm93LCBpbnB1dF9jb2wpYCl9O1xyXG4gICAgfVxyXG4gICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgIGxldCBvdXRwdXRfY29sID0gd29ya2dyb3VwX2lkX3ggKiAke3RpbGVTaXplfXUgKyBsb2NhbF9pZC54O1xyXG4gICAgbGV0IG91dHB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeSAqICR7dGlsZVNpemV9dSArIGxvY2FsX2lkLnk7XHJcbiAgICBpZiAob3V0cHV0X3JvdyA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVswXSAmJiBvdXRwdXRfY29sIDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdKSB7XHJcbiAgICAgICR7b3V0cHV0LnNldEJ5SW5kaWNlcyhgJHtvdXRwdXQudHlwZS5pbmRpY2VzfShvdXRwdXRfcm93LCBvdXRwdXRfY29sKWAsICd0aWxlW2xvY2FsX2lkLnhdW2xvY2FsX2lkLnldJyl9XHJcbiAgICB9XHJcbiAgfWA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZTogJ1RyYW5zcG9zZVNoYXJlZCcsXHJcbiAgICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxyXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFRlbnNvci5kYXRhVHlwZSB9XSxcclxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG5ld091dHB1dFNoYXBlWzFdIC8gdGlsZVNpemUpLCB5OiBNYXRoLmNlaWwobmV3T3V0cHV0U2hhcGVbMF0gLyB0aWxlU2l6ZSkgfSxcclxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhuZXdJbnB1dFNoYXBlLCBuZXdPdXRwdXRTaGFwZSksXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0RGF0YVR5cGUsIG5ld0lucHV0U2hhcGUubGVuZ3RoKTtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dERhdGFUeXBlLCBuZXdPdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIGBcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XHJcblxyXG4gICR7cGVybUZ1bmN0aW9uQm9keShwZXJtLCBpbnB1dFJhbmssIGlucHV0LCBvdXRwdXQpfVxyXG5cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcblxyXG4gICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xyXG5cclxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpKX1cclxuICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnVHJhbnNwb3NlJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke3Blcm1BdHRyfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xyXG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUZW5zb3IuZGF0YVR5cGUgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG5ld0lucHV0U2hhcGUsIG5ld091dHB1dFNoYXBlKSxcclxuICAgICAgICBdLFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHRyYW5zcG9zZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogVHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLnBlcm0pO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcy5wZXJtKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogVHJhbnNwb3NlQXR0cmlidXRlcyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHBlcm06IGF0dHJpYnV0ZXMucGVybSBhcyBudW1iZXJbXSB9KTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcbmltcG9ydCB7IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzLCBSZWR1Y2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9yZWR1Y2UnO1xyXG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHJhbnNwb3NlJztcclxuXHJcbmNvbnN0IHJlZHVjZU9wczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICBtYXg6ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSknLFxyXG4gIG1pbjogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKScsXHJcbiAgbWVhbjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXHJcbiAgc3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcclxuICBwcm9kOiAnYmVzdFZhbHVlICogY2FuZGlkYXRlJyxcclxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGUnLFxyXG4gIGxvZ1N1bUV4cDogJ2Jlc3RWYWx1ZSArIGV4cChjYW5kaWRhdGUpJyxcclxuICBsMTogJ2Jlc3RWYWx1ZSArIGFicyhjYW5kaWRhdGUpJyxcclxuICBsMjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZScsXHJcbiAgbG9nU3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcclxufTtcclxuXHJcbmNvbnN0IHJlZHVjZVNoYXJlZE9wczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICBtYXg6ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSknLFxyXG4gIG1pbjogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKScsXHJcbiAgbWVhbjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXHJcbiAgc3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcclxuICBwcm9kOiAnYmVzdFZhbHVlICogY2FuZGlkYXRlJyxcclxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxyXG4gIGxvZ1N1bUV4cDogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXHJcbiAgbDE6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxyXG4gIGwyOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcclxuICBsb2dTdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxyXG59O1xyXG5cclxuY29uc3QgcmVkdWNlSW5pdFZhbHVlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICBtYXg6ICdfQVtvZmZzZXRdJyxcclxuICBtaW46ICdfQVtvZmZzZXRdJyxcclxuICBtZWFuOiAnMCcsXHJcbiAgc3VtOiAnMCcsXHJcbiAgcHJvZDogJzEnLFxyXG4gIHN1bVNxdWFyZTogJzAnLFxyXG4gIGxvZ1N1bUV4cDogJzAnLFxyXG4gIGwxOiAnMCcsXHJcbiAgbDI6ICcwJyxcclxuICBsb2dTdW06ICcwJyxcclxufTtcclxuXHJcbmNvbnN0IHJlZHVjZU91dHB1dFZhbHVlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICBtYXg6ICdiZXN0VmFsdWUnLFxyXG4gIG1pbjogJ2Jlc3RWYWx1ZScsXHJcbiAgc3VtOiAnYmVzdFZhbHVlJyxcclxuICBwcm9kOiAnYmVzdFZhbHVlJyxcclxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUnLFxyXG4gIGxvZ1N1bUV4cDogJ2xvZyhiZXN0VmFsdWUpJyxcclxuICBsMTogJ2Jlc3RWYWx1ZScsXHJcbiAgbDI6ICdzcXJ0KGJlc3RWYWx1ZSknLFxyXG4gIGxvZ1N1bTogJ2xvZyhiZXN0VmFsdWUpJyxcclxufTtcclxuXHJcbmNvbnN0IGdldElubmVyTW9zdEF4ZXMgPSAobnVtSW5uZXJBeGVzOiBudW1iZXIsIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcclxuICBjb25zdCByZXMgPSBbXTtcclxuICBmb3IgKGxldCBpID0gcmFuayAtIG51bUlubmVyQXhlczsgaSA8IHJhbms7ICsraSkge1xyXG4gICAgcmVzLnB1c2goaSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXM7XHJcbn07XHJcblxyXG5jb25zdCBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzID0gKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10pOiBbbnVtYmVyW10sIG51bWJlcltdXSA9PiB7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbXTtcclxuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xyXG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XHJcbiAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XHJcbiAgICAgIG91dHB1dFNoYXBlLnB1c2goc2hhcGVbZGltXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHJlZHVjZVNoYXBlID0gYXhlcy5tYXAoKGRpbSkgPT4gc2hhcGVbZGltXSk7XHJcbiAgcmV0dXJuIFtvdXRwdXRTaGFwZSwgcmVkdWNlU2hhcGVdO1xyXG59O1xyXG5cclxuY29uc3QgZXhwYW5kU2hhcGVUb0tlZXBEaW0gPSAoc2hhcGU6IG51bWJlcltdLCBheGVzOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcclxuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoICsgYXhlcy5sZW5ndGg7XHJcbiAgY29uc3QgZXhwYW5kU2hhcGUgPSBbXTtcclxuICBsZXQgc2hhcGVJZHggPSAwO1xyXG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XHJcbiAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XHJcbiAgICAgIGV4cGFuZFNoYXBlLnB1c2goc2hhcGVbc2hhcGVJZHgrK10pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXhwYW5kU2hhcGUucHVzaCgxKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGV4cGFuZFNoYXBlO1xyXG59O1xyXG5cclxuY29uc3QgYXJlQXhlc0lubmVyTW9zdERpbXMgPSAoYXhlczogbnVtYmVyW10sIHJhbms6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKGF4ZXNbYXhlcy5sZW5ndGggLSBpIC0gMV0gIT09IHJhbmsgLSAxIC0gaSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuY29uc3QgZ2V0QXhlc1Blcm11dGF0aW9uID0gKGF4ZXM6IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XHJcbiAgY29uc3QgcmVzID0gW107XHJcbiAgaWYgKCFhcmVBeGVzSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcclxuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcclxuICAgICAgICByZXMucHVzaChpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXhlcy5mb3JFYWNoKChheGlzKSA9PiByZXMucHVzaChheGlzKSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXM7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlU2hhcmVkUHJvZ3JhbUluZm8gPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIGNhY2hlS2V5OiBzdHJpbmcsXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgcmVkdWNlVHlwZTogc3RyaW5nLFxyXG4gIG91dHB1dERhdGFUeXBlOiBEYXRhVHlwZSxcclxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXHJcbiAgcmVkdWNlU2hhcGU6IG51bWJlcltdLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG5cclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gIGNvbnN0IHJlZHVjZVNpemUgPSBTaGFwZVV0aWwuc2l6ZShyZWR1Y2VTaGFwZSk7XHJcblxyXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnX0EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0U2hhcGUpO1xyXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXREYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xyXG5cclxuICBsZXQgd29ya2dyb3VwU2l6ZSA9IDY0O1xyXG4gIC8vIElmIG9ubHkgb25lIHdvcmtncm91cCBpcyBkaXNwYXRjaGVkLCBpbmNyZWFzZSB3b3JrZ3JvdXBTaXplIHRvIGltcHJvdmUgcGFyYWxsZWxpc20uXHJcbiAgaWYgKG91dHB1dFNpemUgPT09IDEpIHtcclxuICAgIHdvcmtncm91cFNpemUgPSAyNTY7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzaGFyZWRNZW1vcnlTbmlwcGV0ID0gYFxyXG4gICAgICAgICAgdmFyPHdvcmtncm91cD4gYUJlc3RWYWx1ZXMgOiBhcnJheTxmMzIsICR7d29ya2dyb3VwU2l6ZX0+O1xyXG4gICAgICAgYDtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdyZWR1Y2VTaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XHJcbiAgICAgICAgJHtzaGFyZWRNZW1vcnlTbmlwcGV0fVxyXG4gICAgICAgIGZuIERJVl9DRUlMKGEgOiB1MzIsIGIgOiB1MzIpIC0+IHUzMiB7XHJcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcclxuICAgICAgICAgfVxyXG4gICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQod29ya2dyb3VwU2l6ZSl9XHJcblxyXG4gICAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gZ2xvYmFsX2lkeCAvICR7d29ya2dyb3VwU2l6ZX07XHJcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xyXG5cclxuICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSBmMzIoJHtyZWR1Y2VJbml0VmFsdWVzW3JlZHVjZVR5cGVdfSk7XHJcbiAgICAgICAgICBsZXQgTGVuZ3RoID0gdW5pZm9ybXMucmVkdWNlU2l6ZTtcclxuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHt3b3JrZ3JvdXBTaXplfSkge1xyXG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoJHtpbnB1dC5nZXRCeU9mZnNldCgnb2Zmc2V0ICsgaycpfSk7XHJcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHtyZWR1Y2VPcHNbcmVkdWNlVHlwZV19O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcclxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHt3b3JrZ3JvdXBTaXplfXUpO1xyXG4gICAgICAgICBmb3IgKHZhciBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydTsgcmVkdWNlU2l6ZSA+IDF1O1xyXG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcclxuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XHJcbiAgICAgICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJlbnRTaXplKSB7XHJcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XHJcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7cmVkdWNlU2hhcmVkT3BzW3JlZHVjZVR5cGVdfTtcclxuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmVkdWNlU2l6ZSA9IGludGVydmFsO1xyXG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xyXG4gICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoXHJcbiAgICAgICAgICAgICdvdXRwdXRJbmRleCcsXHJcbiAgICAgICAgICAgIGAke1xyXG4gICAgICAgICAgICAgIHJlZHVjZVR5cGUgPT09ICdtZWFuJ1xyXG4gICAgICAgICAgICAgICAgPyBgJHtvdXRwdXQudHlwZS5zdG9yYWdlfShiZXN0VmFsdWUgLyBmMzIodW5pZm9ybXMucmVkdWNlU2l6ZSkpYFxyXG4gICAgICAgICAgICAgICAgOiBgJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgke3JlZHVjZU91dHB1dFZhbHVlc1tyZWR1Y2VUeXBlXX0pYFxyXG4gICAgICAgICAgICB9YCxcclxuICAgICAgICAgICl9O1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgfWA7XHJcblxyXG4gIC8vIE9uZSB3b3JrIGdyb3VwIGlzIHJlc3BvbnNpYmxlIGZvciBvbmx5IG9uZSBlbGVtZW50IG9mIG91dHB1dC5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZSxcclxuICAgIC8vIE5vdGUgdGhhdCBpbiBKU0VQLCBXRyBzaXplIGlzIG5vdCBpbmNsdWRlZCBpbiBjYWNoZSBieSBkZWZhdWx0LCBidXQgV2ViR1BVIEVQIGl0IGlzLlxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y2FjaGVLZXl9OyR7d29ya2dyb3VwU2l6ZX1gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ10gfSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogb3V0cHV0U2l6ZSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcmVkdWNlU2l6ZSB9XSxcclxuICAgIH0pLFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VDb21tb24gPSAoXHJcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMsXHJcbiAgcmVkdWNlVHlwZTogJ3N1bScgfCAnc3VtU3F1YXJlJyB8ICdwcm9kJyB8ICdtaW4nIHwgJ21heCcgfCAnbWVhbicgfCAnbG9nU3VtRXhwJyB8ICdsMScgfCAnbDInIHwgJ2xvZ1N1bScsXHJcbik6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzID1cclxuICAgIGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcblxyXG4gIGxldCB1cGRhdGVkQXhlcyA9IHVwZGF0ZWRBdHRyaWJ1dGVzLmF4ZXM7XHJcbiAgaWYgKHVwZGF0ZWRBeGVzLmxlbmd0aCA9PT0gMCAmJiAhdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpIHtcclxuICAgIHVwZGF0ZWRBeGVzID0gY29udGV4dC5pbnB1dHNbMF0uZGltcy5tYXAoKF9kaW0sIGkpID0+IGkpO1xyXG4gIH1cclxuICBjb25zdCBub3JtYWxpemVBeGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXModXBkYXRlZEF4ZXMsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcclxuXHJcbiAgbGV0IGF4ZXMgPSBub3JtYWxpemVBeGVzO1xyXG4gIGxldCBpbnB1dCA9IGNvbnRleHQuaW5wdXRzWzBdO1xyXG4gIGNvbnN0IHBlcm11dGVkQXhlcyA9IGdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCBjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCk7XHJcbiAgaWYgKHBlcm11dGVkQXhlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBpbnB1dCA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgcGVybXV0ZWRBeGVzKSwge1xyXG4gICAgICBpbnB1dHM6IFswXSxcclxuICAgICAgb3V0cHV0czogWy0xXSxcclxuICAgIH0pWzBdO1xyXG4gICAgYXhlcyA9IGdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIGlucHV0LmRpbXMubGVuZ3RoKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IFtvdXRwdXRTaGFwZSwgcmVkdWNlU2hhcGVdID0gY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5kaW1zLCBheGVzKTtcclxuICBsZXQgZmluYWxPdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xyXG4gIGlmICh1cGRhdGVkQXR0cmlidXRlcy5rZWVwRGltcykge1xyXG4gICAgZmluYWxPdXRwdXRTaGFwZSA9IGV4cGFuZFNoYXBlVG9LZWVwRGltKG91dHB1dFNoYXBlLCBub3JtYWxpemVBeGVzKTtcclxuICB9XHJcblxyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZVJlZHVjZVNoYXJlZFByb2dyYW1JbmZvKFxyXG4gICAgICBuYW1lLFxyXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5jYWNoZUtleSxcclxuICAgICAgW2lucHV0XSxcclxuICAgICAgcmVkdWNlVHlwZSxcclxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXHJcbiAgICAgIGZpbmFsT3V0cHV0U2hhcGUsXHJcbiAgICAgIHJlZHVjZVNoYXBlLFxyXG4gICAgKSxcclxuICAgIHsgaW5wdXRzOiBbaW5wdXRdIH0sXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VNZWFuU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNZWFuU2hhcmVkJywgYXR0cmlidXRlcywgJ21lYW4nKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VMMVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTDFTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbDEnKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VMMlNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTDJTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbDInKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1FeHBTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bUV4cFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsb2dTdW1FeHAnKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VNYXhTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZU1heFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtYXgnKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VNaW5TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZU1pblNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtaW4nKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VQcm9kU2hhcmVkJywgYXR0cmlidXRlcywgJ3Byb2QnKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZVN1bVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdzdW0nKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TcXVhcmVTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZVN1bVNxdWFyZVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdzdW1TcXVhcmUnKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsb2dTdW0nKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcbmltcG9ydCB7XHJcbiAgcmVkdWNlTDFTaGFyZWQsXHJcbiAgcmVkdWNlTDJTaGFyZWQsXHJcbiAgcmVkdWNlTG9nU3VtRXhwU2hhcmVkLFxyXG4gIHJlZHVjZUxvZ1N1bVNoYXJlZCxcclxuICByZWR1Y2VNYXhTaGFyZWQsXHJcbiAgcmVkdWNlTWVhblNoYXJlZCxcclxuICByZWR1Y2VNaW5TaGFyZWQsXHJcbiAgcmVkdWNlUHJvZFNoYXJlZCxcclxuICByZWR1Y2VTdW1TaGFyZWQsXHJcbiAgcmVkdWNlU3VtU3F1YXJlU2hhcmVkLFxyXG59IGZyb20gJy4vcmVkdWNlLXNoYXJlZCc7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDAgfHwgaW5wdXRzLmxlbmd0aCA+IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMiAmJiBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBheGVzIGlucHV0IGRpbXMuJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSZWR1Y2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICBrZWVwRGltczogYm9vbGVhbjtcclxuICBub29wV2l0aEVtcHR5QXhlczogYm9vbGVhbjtcclxuICBheGVzOiBudW1iZXJbXTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUmVkdWNlT3AgPSAoXHJcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxyXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4pID0+IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIC4uLnN0cmluZ1tdXTtcclxuXHJcbmNvbnN0IG5vT3A6IFJlZHVjZU9wID0gKGlucHV0KSA9PiBbJycsICcnLCBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCwgJyddO1xyXG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8gPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIHNoYWRlckNhY2hlOiBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvLFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIHJlZHVjZU9wOiBSZWR1Y2VPcCxcclxuICBheGVzSW5wdXQ6IG51bWJlcltdLFxyXG4gIG91dHB1dERhdGFUeXBlOiBEYXRhVHlwZSxcclxuICBrZWVwRGltcyA9IGZhbHNlLFxyXG4gIG5vb3BXaXRoRW1wdHlBeGVzID0gZmFsc2UsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XHJcbiAgY29uc3QgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF4ZXNJbnB1dCwgaW5wdXRSYW5rKTtcclxuICBjb25zdCByZWR1Y2VPbkFsbEF4ZXMgPSAhbm9vcFdpdGhFbXB0eUF4ZXMgJiYgYXhlcy5sZW5ndGggPT09IDA7XHJcbiAgaW5wdXRTaGFwZS5mb3JFYWNoKChkLCBpKSA9PiB7XHJcbiAgICBpZiAocmVkdWNlT25BbGxBeGVzIHx8IGF4ZXMuaW5kZXhPZihpKSA+PSAwKSB7XHJcbiAgICAgIGlmIChrZWVwRGltcykge1xyXG4gICAgICAgIG91dHB1dFNoYXBlLnB1c2goMSk7XHJcbiAgICAgIH0gLy8gZWxzZSB7IC8vIHNraXAgdGhpcyBheGlzfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3V0cHV0U2hhcGUucHVzaChkKTtcclxuICAgIH1cclxuICB9KTtcclxuICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBpZHhDb3B5OiBzdHJpbmdbXSA9IFtdOyAvLyBjb3B5IG91dHB1dCBpbmRleGVzIHRvIGlucHV0IGluZGV4ZXNcclxuXHJcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ19BJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmspO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIG91dHB1dERhdGFUeXBlLCBvdXRwdXRSYW5rKTtcclxuICAgIGNvbnN0IG9wcyA9IHJlZHVjZU9wKGlucHV0LCBvdXRwdXQsIGF4ZXMpO1xyXG4gICAgbGV0IHJlZHVjZU9wcyA9IG9wc1syXTtcclxuXHJcbiAgICBmb3IgKGxldCBrID0gMCwgbCA9IDA7IGsgPCBpbnB1dFJhbms7IGsrKykge1xyXG4gICAgICAvLyBpZiB0aGlzIGF4aXMgaXMgcmVkdWNlZFxyXG4gICAgICBpZiAocmVkdWNlT25BbGxBeGVzIHx8IGF4ZXMuaW5kZXhPZihrKSA+PSAwKSB7XHJcbiAgICAgICAgaWYgKGtlZXBEaW1zKSB7XHJcbiAgICAgICAgICBsKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxvb3Agb3ZlciB0aGUgZC10aCBheGlzXHJcbiAgICAgICAgcmVkdWNlT3BzID0gYGZvcih2YXIgaiR7a306IHUzMiA9IDA7IGoke2t9IDwgJHtpbnB1dFNoYXBlW2tdfTsgaiR7a30rKykge1xyXG4gICAgICAgICAgICAgICAgICAke29wc1syXS5pbmNsdWRlcygnbGFzdF9pbmRleCcpID8gYGxldCBsYXN0X2luZGV4ID0gaiR7a307YCA6ICcnfVxyXG4gICAgICAgICAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBrLCBgaiR7a31gKX1cclxuICAgICAgICAgICAgICAgICAgJHtyZWR1Y2VPcHN9XHJcbiAgICAgICAgICAgICAgICB9YDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZHhDb3B5LnB1c2goYCR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGssIG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIGwpKX07YCk7XHJcbiAgICAgICAgbCsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYFxyXG5cclxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XHJcblxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XHJcbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcblxyXG4gICAgICAgICAgJHtpZHhDb3B5LmpvaW4oJ1xcbicpfVxyXG4gICAgICAgICAgJHtvcHNbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxyXG4gICAgICAgICAgJHtvcHNbMV19XHJcbiAgICAgICAgICAke3JlZHVjZU9wc31cclxuICAgICAgICAgICR7b3BzWzNdfVxyXG4gICAgICAgICAgJHtvcHMubGVuZ3RoID09PSA0ID8gb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJykgOiBvcHMuc2xpY2UoNCkuam9pbignXFxuJyl9XHJcbiAgICAgICAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWUsXHJcbiAgICBzaGFkZXJDYWNoZSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSksXHJcbiAgICAgIF0sXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMsXHJcbik6IFJlZHVjZUF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IGF4ZXM6IG51bWJlcltdID0gW107XHJcbiAgaWYgKGlucHV0c1sxXS5kaW1zWzBdID4gMCkge1xyXG4gICAgaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKCh2KSA9PiBheGVzLnB1c2goTnVtYmVyKHYpKSk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xyXG4gICAgYXhlcyxcclxuICAgIGtlZXBEaW1zOiBhdHRyaWJ1dGVzLmtlZXBEaW1zLFxyXG4gICAgbm9vcFdpdGhFbXB0eUF4ZXM6IGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMsXHJcbiAgfSk7XHJcbn07XHJcblxyXG5jb25zdCBydW5SZWR1Y2VQcm9ncmFtID0gKFxyXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxyXG4gIHJlZHVjZU9wOiBSZWR1Y2VPcCxcclxuKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XHJcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMgPVxyXG4gICAgaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xyXG5cclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcclxuICAgICAgbmFtZSxcclxuICAgICAgeyBoaW50OiB1cGRhdGVkQXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXHJcbiAgICAgIFtpbnB1dHNbMF1dLFxyXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcyAmJiB1cGRhdGVkQXR0cmlidXRlcy5heGVzLmxlbmd0aCA9PT0gMCA/IG5vT3AgOiByZWR1Y2VPcCxcclxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMuYXhlcyxcclxuICAgICAgaW5wdXRzWzBdLmRhdGFUeXBlLFxyXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5rZWVwRGltcyxcclxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMsXHJcbiAgICApLFxyXG4gICAgeyBpbnB1dHM6IFswXSB9LFxyXG4gICk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VMb2dTdW1OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xyXG4gICAgYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcclxuICAgICcnLFxyXG4gICAgYHZhbHVlICs9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXHJcbiAgICAndmFsdWUgPSBsb2codmFsdWUpOycsXHJcbiAgXTtcclxuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMb2dTdW0nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VMMU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PiBbXHJcbiAgICBgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxyXG4gICAgJycsXHJcbiAgICBgdmFsdWUgKz0gYWJzKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxyXG4gICAgJycsXHJcbiAgXTtcclxuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMMScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcclxufTtcclxuXHJcbmNvbnN0IHJlZHVjZUwyTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcclxuICAgIGB2YXIgdCA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtgLFxyXG4gICAgJycsXHJcbiAgICBgdCA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9OyB2YWx1ZSArPSAodCAqIHQpO2AsXHJcbiAgICAndmFsdWUgPSBzcXJ0KHZhbHVlKTsnLFxyXG4gIF07XHJcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTDInLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VMb2dTdW1FeHBOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xyXG4gICAgYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcclxuICAgICcnLFxyXG4gICAgYHZhbHVlICs9IGV4cCgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcclxuICAgICd2YWx1ZSA9IGxvZyh2YWx1ZSk7JyxcclxuICBdO1xyXG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bUV4cCcsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcclxufTtcclxuXHJcbmNvbnN0IHJlZHVjZU1heE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgX291dHB1dCwgYXhlcykgPT4ge1xyXG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xyXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcclxuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgaWR4WmVyby5wdXNoKGlucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBrLCAwKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsXHJcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxyXG4gICAgICBgdmFsdWUgPSBtYXgodmFsdWUsICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxyXG4gICAgICAnJyxcclxuICAgIF07XHJcbiAgfTtcclxuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNYXgnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VNZWFuTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQsIGF4ZXMpID0+IHtcclxuICAgIGxldCBzaXplID0gMS4wO1xyXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcclxuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgLy8gVE9ETzogdGhpcyBkZXBlbmRzIG9uIHRoZSBpbnB1dCBkaW1zLiBJZiB3ZSB3YW50IHRvIHVzZSB1bmlmb3JtLCB0aGlzIG5lZWQgdG8gYmUgdXBkYXRlZC5cclxuICAgICAgICBzaXplICo9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXNba107XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAndmFyIHN1bSA9IGYzMigwKTsnLFxyXG4gICAgICAnJyxcclxuICAgICAgYHN1bSArPSBmMzIoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXHJcbiAgICAgIGBsZXQgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfShzdW0gLyAke3NpemV9KTtgLFxyXG4gICAgXTtcclxuICB9O1xyXG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZU1lYW4nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VNaW5OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIF9vdXRwdXQsIGF4ZXMpID0+IHtcclxuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcclxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XHJcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcclxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXHJcbiAgICAgIGB2YWx1ZSA9IG1pbih2YWx1ZSwgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXHJcbiAgICAgICcnLFxyXG4gICAgXTtcclxuICB9O1xyXG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZU1pbicsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcclxufTtcclxuXHJcbmNvbnN0IHJlZHVjZVByb2ROYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xyXG4gICAgYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMSk7YCxcclxuICAgICcnLFxyXG4gICAgYHZhbHVlICo9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXHJcbiAgICAnJyxcclxuICBdO1xyXG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVByb2QnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VTdW1OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xyXG4gICAgYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcclxuICAgICcnLFxyXG4gICAgYHZhbHVlICs9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXHJcbiAgICAnJyxcclxuICBdO1xyXG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVN1bScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcclxufTtcclxuXHJcbmNvbnN0IHJlZHVjZVN1bVNxdWFyZU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PiBbXHJcbiAgICBgdmFyIHQgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7YCxcclxuICAgICcnLFxyXG4gICAgYHQgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTsgdmFsdWUgKz0gdCAqIHQ7YCxcclxuICAgICcnLFxyXG4gIF07XHJcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlU3VtU3F1YXJlJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xyXG59O1xyXG5cclxuY29uc3QgdXNlTmFpdmVSZWR1Y2VNZXRob2QgPSAoXHJcbiAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIG5vb3BXaXRoRW1wdHlBeGVzOiBib29sZWFuLFxyXG4pOiBib29sZWFuID0+IHtcclxuICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBub29wV2l0aEVtcHR5QXhlcztcclxuICB9XHJcblxyXG4gIGxldCBvdXRwdXRTaXplID0gMTtcclxuICBsZXQgcmVkdWNlU2l6ZSA9IDE7XHJcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgYXhlcy5sZW5ndGg7IGRpbSsrKSB7XHJcbiAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XHJcbiAgICAgIG91dHB1dFNpemUgKj0gc2hhcGVbZGltXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlZHVjZVNpemUgKj0gc2hhcGVbZGltXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFRoZSBjb25kaXRpb24gZGF0YSBpcyB2ZXJ5IHJvdWdoLCBhbHRob3VnaCBjb25zaWRlcmluZyB0aGUgY291bnQgb2YgRXhlY3V0aW9uIFVuaXQgKEVVKSwgdGhlIHBvdGVudGlhbFxyXG4gIC8vIHdvcmsgZ3JvdXBzIGluIGEgRVUgYW5kIHRoZSBjb3VudHMgb2YgbG9vcHMgaW4gdGhlIG5haXZlIGFuZCBzaGFyZWQgbWV0aG9kcywgYWxzbyBkb2luZyBleHBlcmltZW50c1xyXG4gIC8vIG9uIHNvbWUgbWFjaGluZXMuXHJcbiAgcmV0dXJuIHJlZHVjZVNpemUgPCAzMiAmJiBvdXRwdXRTaXplID4gMTAyNDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VNZWFuID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcclxuICAgIHJlZHVjZU1lYW5OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVkdWNlTWVhblNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTDEgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xyXG4gICAgcmVkdWNlTDFOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVkdWNlTDFTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlZHVjZUwyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcclxuICAgIHJlZHVjZUwyTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlZHVjZUwyU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1FeHAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xyXG4gICAgcmVkdWNlTG9nU3VtRXhwTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlZHVjZUxvZ1N1bUV4cFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTWF4ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcclxuICAgIHJlZHVjZU1heE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZWR1Y2VNYXhTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlZHVjZU1pbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XHJcbiAgICByZWR1Y2VNaW5OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVkdWNlTWluU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcclxuICAgIHJlZHVjZVByb2ROYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVkdWNlUHJvZFNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcclxuICAgIHJlZHVjZVN1bU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZWR1Y2VTdW1TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bVNxdWFyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XHJcbiAgICByZWR1Y2VTdW1TcXVhcmVOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVkdWNlU3VtU3F1YXJlU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xyXG4gICAgcmVkdWNlTG9nU3VtTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlZHVjZUxvZ1N1bVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuLy8gVE9ETzogdGhpcyBpcyB0aGUgc2FtZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB3ZSB1c2UgZm9yIHJlZHVjZSB0aGF0IGhhc1xyXG4vLyBwZXJmb3JtYW5jZSBsaW1pdGF0aW9ucyB3aGVuIHRoZSByZWR1Y2VkIGF4aXMgaXMgbG9uZy4gTmVlZCB0byBhZGRcclxuLy8gYSBvcHRpbWl6ZWQgY29kZXBhdGggZm9yIHRoaXMuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvLCBSZWR1Y2VPcCB9IGZyb20gJy4vcmVkdWNlJztcclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCB8fCBpbnB1dHMubGVuZ3RoID4gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcmdNaW5NYXhPcCBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLicpO1xyXG4gIH1cclxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBcmdNaW5NYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICBrZWVwRGltczogYm9vbGVhbjtcclxuICBheGlzOiBudW1iZXI7XHJcbiAgc2VsZWN0TGFzdEluZGV4OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhcmdNaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFyZ01pbk1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgYXJnTWluTWF4T3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQsIGF4ZXMpID0+IHtcclxuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcclxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XHJcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxyXG4gICAgICBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XFxudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsXHJcbiAgICAgIGBpZiAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0gJHthdHRyaWJ1dGVzLnNlbGVjdExhc3RJbmRleCA+IDAgPyAnPD0nIDogJzwnfSB2YWx1ZSkge1xyXG4gICAgICAgICB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xyXG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xyXG4gICAgICAgfWAsXHJcbiAgICAgICcnLFxyXG4gICAgICBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnYmVzdF9pbmRleCcpLFxyXG4gICAgXTtcclxuICB9O1xyXG5cclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcclxuICAgICAgJ0FyZ01pbicsXHJcbiAgICAgIHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXHJcbiAgICAgIFtjb250ZXh0LmlucHV0c1swXV0sXHJcbiAgICAgIGFyZ01pbk1heE9wLFxyXG4gICAgICBbYXR0cmlidXRlcy5heGlzXSxcclxuICAgICAgRGF0YVR5cGUuaW50NjQsXHJcbiAgICAgIGF0dHJpYnV0ZXMua2VlcERpbXMsXHJcbiAgICApLFxyXG4gICAgeyBpbnB1dHM6IFswXSB9LFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXJnTWF4ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBcmdNaW5NYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnN0IGFyZ01pbk1heE9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XHJcbiAgICBjb25zdCBpZHhaZXJvID0gW107XHJcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xyXG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0X2luZGljZXNbJHtrfV0gPSAwO2ApOyAvLyBmaXJzdCBlbGVtZW50XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbXHJcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcclxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLFxyXG4gICAgICBgaWYgKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9ICR7YXR0cmlidXRlcy5zZWxlY3RMYXN0SW5kZXggPiAwID8gJz49JyA6ICc+J30gdmFsdWUpIHtcclxuICAgICAgICAgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcclxuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcclxuICAgICAgIH1gLFxyXG4gICAgICAnJyxcclxuICAgICAgb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2Jlc3RfaW5kZXgnKSxcclxuICAgIF07XHJcbiAgfTtcclxuXHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXHJcbiAgICAgICdhcmdNYXgnLFxyXG4gICAgICB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxyXG4gICAgICBbY29udGV4dC5pbnB1dHNbMF1dLFxyXG4gICAgICBhcmdNaW5NYXhPcCxcclxuICAgICAgW2F0dHJpYnV0ZXMuYXhpc10sXHJcbiAgICAgIERhdGFUeXBlLmludDY0LFxyXG4gICAgICBhdHRyaWJ1dGVzLmtlZXBEaW1zLFxyXG4gICAgKSxcclxuICAgIHsgaW5wdXRzOiBbMF0gfSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQXJnTWluTWF4QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEFyZ01pbk1heEF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PEFyZ01pbk1heEF0dHJpYnV0ZXMsIGtleW9mIEF0dHJpYnV0ZVdpdGhDYWNoZUtleT4pO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIEdwdURhdGFUeXBlLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGdldE1heENvbXBvbmVudHMsXHJcbiAgSW5kaWNlc0hlbHBlcixcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcclxuICBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBjb25zdCBlbnVtIEF0dGVudGlvblFrdkZvcm1hdCB7XHJcbiAgdW5rbm93biwgLy8gZW51bSB2YWx1ZSBub3Qgc2V0LCBvciBkZXBlbmRzIG9uIHFrdiBwcm9qZWN0aW9uIGltcGxlbWVudGF0aW9uIGRldGFpbHNcclxuICBxa3ZCTlNILCAvLyBmb3Igbm9uLXBhY2tlZCBxa3YsIHBlcm11dGVkXHJcbiAgcWt2QlNOSCwgLy8gZm9yIG5vbi1wYWNrZWQgcWt2LCBub3QgcGVybXV0ZWQsIHVzZWQgYnkgbWVtb3J5IGVmZmljaWVudCBhdHRlbnRpb24gb3IgTXVsdGlIZWFkQXR0ZW50aW9uXHJcbiAgcWt2QlNOM0gsIC8vIGZvciBUUlQgZnVzZWQgYXR0ZW50aW9uLCBxa3YgYXJlIHBhY2tlZFxyXG4gIHFrdkJOU0hxa3ZCUzNOSCwgLy8gZm9yIFRSVCBmdXNlZCBjYXVzYWwgYXR0ZW50aW9uLCBkYXRhIGhhcyB0d28gZm9ybWF0cyAocWt2IGlzIDNCTlNILCBnZW1tX2J1ZmZlciBpcyBCUzNOSClcclxuICBxS3ZCU05IeEJTTjJILCAvLyBmb3IgVFJUIGZ1c2VkIGNyb3NzIGF0dGVudGlvbiwga3YgYXJlIHBhY2tlZFxyXG4gIHFrdlROSCwgLy8gZm9yIG1lbW9yeSBlZmZpY2llbnQgYXR0ZW50aW9uLCBxa3YgYXJlIG5vdCBwYWNrZWQsIGFuZCBwYWRkaW5ncyBhcmUgcmVtb3ZlZC5cclxuICBxa3ZUTjNILCAvLyBmb3IgVFJUIGZ1c2VkIGF0dGVudGlvbiwgcWt2IGFyZSBwYWNrZWQgYW5kIHBhZGRpbmdzIGFyZSByZW1vdmVkXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBlbnVtIEF0dGVudGlvbk1hc2tUeXBlIHtcclxuICBub25lLCAvLyBObyBtYXNrXHJcbiAgbWFzazFkS2V5U2VxTGVuLCAvLyBbYmF0Y2hfc2l6ZV0sIGtleSBzZXF1ZW5jZSBsZW5ndGhcclxuICBtYXNrMWRFbmRTdGFydCwgLy8gWzIgKiBiYXRjaF9zaXplXSB3aXRoIGVuZCBwb3NpdGlvbnMgYW5kIHN0YXJ0IHBvc2l0aW9uc1xyXG4gIG1hc2sxREtleVNlcUxlblN0YXJ0LCAvLyBbMyAqIGJhdGNoX3NpemUgKyAyXSB3aXRoIFtrZXlfbGVuWzBdLCAuLi4sIGtleV9sZW5bYmF0Y2hfc2l6ZSAtIDFdLCBxdWVyeV9zdGFydFswXSxcclxuICAvLyAuLi4sIHF1ZXJ5X3N0YXJ0W2JhdGNoX3NpemUgLSAxXSwgcXVlcnlfZW5kW2JhdGNoX3NpemUgLSAxXSwga2V5X3N0YXJ0WzBdLCAuLi4sXHJcbiAgLy8ga2V5X3N0YXJ0W2JhdGNoX3NpemUgLSAxXSwga2V5X2VuZFtiYXRjaF9zaXplIC0gMV1dXHJcbiAgbWFzazJkRHVtbXksIC8vIGR1bW15IG1hc2sgd2l0aCBzaGFwZSBbMSwgMV0gb3IgW2JhdGNoX3NpemUsIDFdLiBJdCBoYXMgc2FtZSBlZmZlY3QgYXMgbm8gbWFzay5cclxuICBtYXNrMmRLZXlQYWRkaW5nLCAvLyBbYmF0Y2hfc2l6ZSwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoXVxyXG4gIG1hc2szZEF0dGVudGlvbiwgLy8gW2JhdGNoX3NpemUsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoXVxyXG4gIG1hc2s0ZE1lZ2F0cm9uLCAvLyBNZWdhdHJvbiBjYXVzYWwgbWFzayB3aXRoIHNoYXBlIFtiYXRjaF9zaXplLCAxLCBtYXhfc2VxdWVuY2VfbGVuZ3RoLCBtYXhfc2VxdWVuY2VfbGVuZ3RoXVxyXG4gIG1hc2tVbmtub3duLFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVudGlvblBhcmFtZXRlcnMge1xyXG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xyXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XHJcbiAgcGFzdFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XHJcbiAga3ZTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xyXG4gIHRvdGFsU2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcclxuICBtYXhTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xyXG4gIGlucHV0SGlkZGVuU2l6ZTogbnVtYmVyO1xyXG4gIGhpZGRlblNpemU6IG51bWJlcjtcclxuICB2SGlkZGVuU2l6ZTogbnVtYmVyO1xyXG4gIGhlYWRTaXplOiBudW1iZXI7XHJcbiAgdkhlYWRTaXplOiBudW1iZXI7XHJcbiAgbnVtSGVhZHM6IG51bWJlcjtcclxuICBrdk51bUhlYWRzPzogbnVtYmVyO1xyXG4gIG5SZXBzPzogbnVtYmVyO1xyXG4gIGlzVW5pZGlyZWN0aW9uYWw/OiBib29sZWFuO1xyXG4gIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGJvb2xlYW47XHJcbiAgbWFza0ZpbHRlclZhbHVlPzogbnVtYmVyO1xyXG4gIG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZTtcclxuICBzY2FsZTogbnVtYmVyO1xyXG4gIGJyb2FkY2FzdFJlc1Bvc0JpYXM6IGJvb2xlYW47XHJcbiAgcGFzc1Bhc3RJbkt2OiBib29sZWFuO1xyXG4gIHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0O1xyXG4gIHNvZnRjYXA/OiBudW1iZXI7XHJcbiAgZG9Sb3Rhcnk/OiBudW1iZXI7XHJcbiAgcm90YXJ5SW50ZXJMZWF2ZWQ/OiBudW1iZXI7XHJcbiAgc29tbW9vdGhTb2Z0bWF4PzogbnVtYmVyO1xyXG4gIGxvY2FsV2luZG93c1NpemU/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXR0ZW50aW9uQXR0cnMge1xyXG4gIG51bUhlYWRzOiBudW1iZXI7XHJcbiAgaXNVbmlkaXJlY3Rpb25hbDogbnVtYmVyO1xyXG4gIG1hc2tGaWx0ZXJWYWx1ZTogbnVtYmVyO1xyXG4gIHNjYWxlOiBudW1iZXI7XHJcbiAgZG9Sb3Rhcnk6IG51bWJlcjtcclxuICBxa3ZIaWRkZW5TaXplczogbnVtYmVyW107XHJcbiAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogYm9vbGVhbjtcclxufVxyXG5cclxuY29uc3QgdmFsaWRhdGVBdHRlbnRpb25JbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uUGFyYW1ldGVycyA9PiB7XHJcbiAgLy8gQWJicmV2aWF0aW9uIGFuZCBNZWFuaW5nczpcclxuICAvLyAgIEI6ICAgIGJhdGNoX3NpemVcclxuICAvLyAgIFM6ICAgIHNlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIHF1ZXJ5KVxyXG4gIC8vICAgUDogICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggKHBhc3Qgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcclxuICAvLyAgIEw6ICAgIGt2X3NlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcclxuICAvLyAgIE06ICAgIG1heF9zZXF1ZW5jZV9sZW5ndGhcclxuICAvLyAgIFQ6ICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsga3Zfc2VxdWVuY2VfbGVuZ3RoXHJcbiAgLy8gICBOOiAgICBudW1faGVhZHNcclxuICAvLyAgIEg6ICAgIGhlYWQgc2l6ZSBmb3IgUSBhbmQgSywgYWthIHFfaGVhZF9zaXplIG9yIGtfaGVhZF9zaXplIG9yIHFrX2hlYWRfc2l6ZVxyXG4gIC8vICAgSF92OiAgdl9oZWFkX3NpemVcclxuICAvLyAgIERfaTogIGlucHV0IGhpZGRlbiBzaXplXHJcbiAgLy8gICBEOiAgICBoaWRkZW4gc2l6ZSBmb3IgUSBhbmQgSyAoRCA9IE4gKiBIKSwgYWthIHFfaGlkZGVuX3NpemUgb3Iga19oaWRkZW5fc2l6ZSBvciBxa19oaWRkZW5fc2l6ZVxyXG4gIC8vICAgRF92OiAgdl9oaWRkZW5fc2l6ZSA9IG51bV9oZWFkcyAqIHZfaGVhZF9zaXplXHJcblxyXG4gIC8vIFdoZW4gcGFzdCBzdGF0ZSBpcyB1c2VkLCBRLCBLIGFuZCBWIHNob3VsZCBoYXZlIHNhbWUgaGlkZGVuIHNpemUgKHVubGVzcyB3ZSBzcGxpdCBpdCBpbnRvIHBhc3Rfa2V5IGFuZCBwYXN0X3ZhbHVlKS5cclxuXHJcbiAgLy8gSW5wdXQgc2hhcGVzOlxyXG4gIC8vICAgaW5wdXQgICAgICAgIChRL0svVikgICAgOiAoQiwgUywgRF9pKVxyXG4gIC8vICAgd2VpZ2h0cyAgICAgIChRL0svVikgICAgOiAoRF9pLCBEICsgRCArIERfdilcclxuICAvLyAgIGJpYXMgICAgICAgICAoUS9LL1YpICAgIDogKEQgKyBEICsgRF92KVxyXG4gIC8vICAgbWFza19pbmRleCAgICAgICAgICAgICAgOiBzZWUgYmVsb3dcclxuICAvLyAgIHBhc3QgICAgICAgICAoSy9WKSAgICAgIDogKDIsIEIsIE4sIFAsIEgpIG9yIE5VTExcclxuICAvLyAgIGF0dGVudGlvbl9iaWFzICAgICAgICAgIDogKEIsIE4sIFMsIFQpIG9yIE5VTExcclxuXHJcbiAgLy8gRm9yIG1hc2tfaW5kZXgsIHRoZSBmb2xsb3dpbmcgc2hhcGVzIGFyZSBzdXBwb3J0ZWQ6XHJcbiAgLy8gICAgIE5VTEwsIChCLCAxKSwgKDEsIDEpXHJcbiAgLy8gICAgIChCKSwgKDIgKiBCKSwgKDMgKiBCICsgMilcclxuICAvLyAgICAgKEIsIFQpXHJcbiAgLy8gICAgIChCLCBTLCBUKVxyXG4gIC8vICAgICAoQiwgMSwgTSwgTSlcclxuICAvL1xyXG4gIC8vIFdoZW4gYSBtb2RlbCBpcyBwcnVuZWQgKGxpa2Ugc29tZSBhdHRlbnRpb24gaGVhZHMgYXJlIHJlbW92ZWQgaW4gUS9LL1YpLCBpbnB1dF9oaWRkZW5fc2l6ZSBjb3VsZCBiZSBsYXJnZXJcclxuICAvLyB0aGFuIGhpZGRlbiBkaW1lbnNpb24gb2YgUSwgSyBhbmQgVi5cclxuXHJcbiAgY29uc3QgaW5wdXQgPSBpbnB1dHNbMF07XHJcbiAgY29uc3Qgd2VpZ2h0cyA9IGlucHV0c1sxXTtcclxuICBjb25zdCBiaWFzID0gaW5wdXRzWzJdO1xyXG4gIGNvbnN0IG1hc2tJbmRleCA9IGlucHV0c1szXTtcclxuICBjb25zdCBwYXN0ID0gaW5wdXRzWzRdO1xyXG4gIGNvbnN0IGF0dGVudGlvbkJpYXMgPSBpbnB1dHNbNV07XHJcblxyXG4gIGlmIChwYXN0ICYmIGF0dGVudGlvbkJpYXMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW50aW9uIGNhbm5vdCBoYXZlIGJvdGggcGFzdCBhbmQgYXR0ZW50aW9uX2JpYXMnKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gMykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImlucHV0XCIgbXVzdCBoYXZlIDMgZGltZW5zaW9ucycpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXQuZGltc1swXTtcclxuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0LmRpbXNbMV07XHJcbiAgY29uc3QgaW5wdXRIaWRkZW5TaXplID0gaW5wdXQuZGltc1syXTtcclxuXHJcbiAgaWYgKGJpYXMuZGltcy5sZW5ndGggIT09IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcclxuICB9XHJcblxyXG4gIGlmICh3ZWlnaHRzLmRpbXMubGVuZ3RoICE9PSAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwid2VpZ2h0c1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zJyk7XHJcbiAgfVxyXG5cclxuICBpZiAod2VpZ2h0cy5kaW1zWzBdICE9PSBpbnB1dEhpZGRlblNpemUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgMSBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMiBvZiBpbnB1dCAwJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoYmlhcy5kaW1zWzBdICE9PSB3ZWlnaHRzLmRpbXNbMV0pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDEgb2YgaW5wdXQgXCJ3ZWlnaHRzXCInKTtcclxuICB9XHJcblxyXG4gIGxldCBxSGlkZGVuU2l6ZSA9IGJpYXMuZGltc1swXSAvIDM7XHJcbiAgbGV0IGtIaWRkZW5TaXplID0gcUhpZGRlblNpemU7XHJcbiAgbGV0IHZIaWRkZW5TaXplID0ga0hpZGRlblNpemU7XHJcbiAgaWYgKGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgaWYgKGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigncWt2X2hpZGRlbl9zaXplcyBhdHRyaWJ1dGUgc2hvdWxkIGhhdmUgMyBlbGVtZW50cycpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBzeiBvZiBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzKSB7XHJcbiAgICAgIGlmIChzeiAlIGF0dHJpYnV0ZXMubnVtSGVhZHMgIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSBudW1faGVhZHMnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHFIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1swXTtcclxuICAgIGtIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1sxXTtcclxuICAgIHZIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1syXTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGt2U2VxdWVuY2VMZW5ndGggPSBzZXF1ZW5jZUxlbmd0aDtcclxuXHJcbiAgaWYgKHFIaWRkZW5TaXplICE9PSBrSGlkZGVuU2l6ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdxa3ZfaGlkZGVuX3NpemVzIGZpcnN0IGVsZW1lbnQgc2hvdWxkIGJlIHNhbWUgYXMgdGhlIHNlY29uZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGJpYXMuZGltc1swXSAhPT0gcUhpZGRlblNpemUgKyBrSGlkZGVuU2l6ZSArIHZIaWRkZW5TaXplKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIHN1bSBvZiBRL0svViBoaWRkZW4gc2l6ZXMnKTtcclxuICB9XHJcblxyXG4gIGxldCBwYXN0U2VxdWVuY2VMZW5ndGggPSAwO1xyXG4gIGlmIChwYXN0KSB7XHJcbiAgICBpZiAoa0hpZGRlblNpemUgIT09IHZIaWRkZW5TaXplKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZXhwZWN0IGtfaGlkZGVuX3NpemUgPT0gdl9oaWRkZW5fc2l6ZScpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhc3QuZGltcy5sZW5ndGggIT09IDUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBtdXN0IGhhdmUgNSBkaW1lbnNpb25zJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFzdC5kaW1zWzBdICE9PSAyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhc3QuZGltc1sxXSAhPT0gYmF0Y2hTaXplKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgc2Vjb25kIGRpbWVuc2lvbiBtdXN0IGJlIGJhdGNoX3NpemUnKTtcclxuICAgIH1cclxuICAgIGlmIChwYXN0LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtcclxuICAgIH1cclxuICAgIGlmIChwYXN0LmRpbXNbNF0gIT09IGtIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpZnRoIGRpbWVuc2lvbiBtdXN0IGJlIGtfaGlkZGVuX3NpemUgLyBudW1faGVhZHMnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWF0dHJpYnV0ZXMucGFzdFByZXNlbnRTaGFyZUJ1ZmZlcikge1xyXG4gICAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0LmRpbXNbM107XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBoYW5kbGUgcGFzdF9zZXFfbGVuXHJcbiAgfVxyXG5cclxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0ga3ZTZXF1ZW5jZUxlbmd0aCArIHBhc3RTZXF1ZW5jZUxlbmd0aDtcclxuICBjb25zdCBtYXhTZXF1ZW5jZUxlbmd0aCA9IC0xO1xyXG5cclxuICBjb25zdCBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XHJcbiAgaWYgKG1hc2tJbmRleCkge1xyXG4gICAgLy8gbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5NQVNLX1VOS05PV047XHJcbiAgICAvLyBUT0RPOiBoYW5kbGUgbWFza1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXNrIG5vdCBzdXBwb3J0ZWQnKTtcclxuICB9XHJcblxyXG4gIGlmIChwYXN0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3QgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF0dGVudGlvbkJpYXMpIHtcclxuICAgIGlmIChhdHRlbnRpb25CaWFzLmRpbXMubGVuZ3RoICE9PSA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIG11c3QgaGF2ZSA0IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBzdXBwb3J0IGJyb2FkY2FzdGluZyB0aGUgZmlyc3QgYW5kIHNlY29uZCBkaW1lbnNpb25zIG9mIGF0dGVudGlvbl9iaWFzXHJcbiAgICBpZiAoXHJcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1swXSAhPT0gYmF0Y2hTaXplIHx8XHJcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fFxyXG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMl0gIT09IHNlcXVlbmNlTGVuZ3RoIHx8XHJcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1szXSAhPT0gdG90YWxTZXF1ZW5jZUxlbmd0aFxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBiYXRjaFNpemUsXHJcbiAgICBzZXF1ZW5jZUxlbmd0aCxcclxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcclxuICAgIGt2U2VxdWVuY2VMZW5ndGgsXHJcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgbWF4U2VxdWVuY2VMZW5ndGgsXHJcbiAgICBpbnB1dEhpZGRlblNpemUsXHJcbiAgICBoaWRkZW5TaXplOiBxSGlkZGVuU2l6ZSxcclxuICAgIHZIaWRkZW5TaXplLFxyXG4gICAgaGVhZFNpemU6IE1hdGguZmxvb3IocUhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcclxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxyXG4gICAgbnVtSGVhZHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMsXHJcbiAgICBpc1VuaWRpcmVjdGlvbmFsOiBmYWxzZSxcclxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxyXG4gICAgbWFza0ZpbHRlclZhbHVlOiBhdHRyaWJ1dGVzLm1hc2tGaWx0ZXJWYWx1ZSxcclxuICAgIG1hc2tUeXBlLFxyXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXHJcbiAgICBicm9hZGNhc3RSZXNQb3NCaWFzOiBmYWxzZSxcclxuICAgIHBhc3NQYXN0SW5LdjogZmFsc2UsXHJcbiAgICBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCTlNILFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCBpbml0VmFyU3R1YiA9IChcclxuICBzZXFMZW5zSW5wdXQ6IEluZGljZXNIZWxwZXIgfCB1bmRlZmluZWQsXHJcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0OiBJbmRpY2VzSGVscGVyIHwgdW5kZWZpbmVkLFxyXG4gIGluaXRQYXN0U2VxdWVuY2VMZW5ndGg6IGJvb2xlYW4sXHJcbikgPT4ge1xyXG4gIC8vIEluIHRoZSBjYXNlIG9mIEdRQSwgcmVkZWZpbmUgdG90YWxfc2VxdWVuY2VfbGVuZ3RoLCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCBhbmQgcGFzdF9zZXF1ZW5jZV9sZW5ndGggYmFzZWQgb24gc2VxbGVuX2sgaW5wdXRcclxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0ICYmIHNlcUxlbnNJbnB1dCkge1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgbGV0IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCA9IHUzMigke3RvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dC5nZXRCeU9mZnNldCgnMCcpfSk7XHJcbiAgICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IG1heCh0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQsIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKTtcclxuICAgICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0OiBib29sID0gc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiBzZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xyXG4gICAgICBsZXQgaXNfZmlyc3RfcHJvbXB0OiBib29sID0gaXNfc3Vic2VxdWVudF9wcm9tcHQgPT0gZmFsc2UgJiYgc2VxdWVuY2VfbGVuZ3RoID09IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dDtcclxuICAgICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdTMyKCR7c2VxTGVuc0lucHV0Py5nZXRCeU9mZnNldCgnYmF0Y2hJZHgnKX0pICsgMTtcclxuICAgICAgdmFyIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoOiB1MzIgPSAwO1xyXG4gICAgICBpZiAoaXNfZmlyc3RfcHJvbXB0ID09IGZhbHNlKSB7XHJcbiAgICAgICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggLSBzZXF1ZW5jZV9sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgIGA7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgXHJcbiAgICAke2luaXRQYXN0U2VxdWVuY2VMZW5ndGggPyAnbGV0IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgnIDogJyd9O1xyXG4gICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xyXG4gICAgYDtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVJblBsYWNlU29mdG1heFByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxyXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxyXG4gIG51bUhlYWRzOiBudW1iZXIsXHJcbiAgcGFzdFNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXHJcbiAgc2VxdWVuY2VMZW5ndGg6IG51bWJlcixcclxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXHJcbiAgc2VxTGVuczogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcclxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbikgPT4ge1xyXG4gIC8vIFNldCBjb21wb25lbnRzIHRvIDEgaWYgc2VxTGVucyBpcyBzcGVjaWZpZWQsIGkuZS4gR3JvdXBRdWVyeUF0dGVudGlvbi5cclxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhzZXFMZW5zID8gMSA6IHRvdGFsU2VxdWVuY2VMZW5ndGgpO1xyXG4gIGxldCBXRyA9IDY0O1xyXG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGhDb21wID0gdG90YWxTZXF1ZW5jZUxlbmd0aCAvIGNvbXBvbmVudHM7XHJcbiAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhDb21wIDwgV0cpIHtcclxuICAgIFdHID0gMzI7XHJcbiAgfVxyXG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gTWF0aC5jZWlsKHRvdGFsU2VxdWVuY2VMZW5ndGggLyBjb21wb25lbnRzIC8gV0cpO1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBiYXRjaFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBudW1IZWFkcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhc3RTZXF1ZW5jZUxlbmd0aCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNlcXVlbmNlTGVuZ3RoIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aENvbXAgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlbGVtZW50c1BlclRocmVhZCB9LFxyXG4gIF07XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXQuZGF0YVR5cGUsIGNvbXBvbmVudHMpO1xyXG4gIGNvbnN0IGYzMlR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKERhdGFUeXBlLmZsb2F0LCBjb21wb25lbnRzKTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZSddO1xyXG4gIGlmIChzZXFMZW5zKSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcclxuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcclxuICB9XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBpbnB1dEhlbHBlciA9IG91dHB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgaW5wdXRIZWxwZXJzID0gW2lucHV0SGVscGVyXTtcclxuICAgIGNvbnN0IHNlcUxlbnNJbnB1dEhlbHBlciA9IHNlcUxlbnMgPyBpbnB1dFZhcmlhYmxlKCdzZXFfbGVucycsIHNlcUxlbnMuZGF0YVR5cGUsIHNlcUxlbnMuZGltcykgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoc2VxTGVuc0lucHV0SGVscGVyKSB7XHJcbiAgICAgIGlucHV0SGVscGVycy5wdXNoKHNlcUxlbnNJbnB1dEhlbHBlcik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0SGVscGVyID0gdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0XHJcbiAgICAgID8gaW5wdXRWYXJpYWJsZSgndG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0JywgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRhdGFUeXBlLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGltcylcclxuICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0SGVscGVyKSB7XHJcbiAgICAgIGlucHV0SGVscGVycy5wdXNoKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dEhlbHBlcik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbGVtVmFsdWVUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShpbnB1dC5kYXRhVHlwZSk7XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ2JhdGNoX3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdwYXN0X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2VsZW1lbnRzX3Blcl90aHJlYWQnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgXTtcclxuXHJcbiAgICByZXR1cm4gYFxyXG4gIHZhcjx3b3JrZ3JvdXA+IHRocmVhZF9tYXg6IGFycmF5PGYzMiwgJHtXR30+O1xyXG4gIHZhcjx3b3JrZ3JvdXA+IHRocmVhZF9zdW06IGFycmF5PGYzMiwgJHtXR30+O1xyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRIZWxwZXJzKX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1dHLCAxLCAxXSl9XHJcbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcclxuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XHJcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoO1xyXG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcclxuICAgICR7aW5pdFZhclN0dWIoc2VxTGVuc0lucHV0SGVscGVyLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRIZWxwZXIsIGZhbHNlKX1cclxuICAgIGxldCBsb2NhbF9vZmZzZXQgPSBsb2NhbF9pZHggKiB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkO1xyXG4gICAgbGV0IG9mZnNldCA9IChnbG9iYWxfaWR4IC8gJHtXR30pICogdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoICsgbG9jYWxfb2Zmc2V0O1xyXG4gICAgbGV0IHNlcV9jYXVzYWxfbGVuZ3RoID0gJHtzZXFMZW5zID8gJ3UzMihwYXN0X3NlcXVlbmNlX2xlbmd0aCArIHdvcmtncm91cF9pZC55ICsgMSknIDogJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aCd9O1xyXG4gICAgdmFyIHRocmVhZF9tYXhfdmVjdG9yID0gJHtmMzJUeXBlfSgtMy40MDI4MjNlKzM4Zik7XHJcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xyXG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XHJcbiAgICB9XHJcbiAgICB0aHJlYWRfbWF4W2xvY2FsX2lkeF0gPSAkeygoKSA9PiB7XHJcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHJldHVybiAndGhyZWFkX21heF92ZWN0b3InO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHJldHVybiAnbWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpJztcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICByZXR1cm4gJ21heChtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSksIG1heCh0aHJlYWRfbWF4X3ZlY3Rvci56LCB0aHJlYWRfbWF4X3ZlY3Rvci53KSknO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7Y29tcG9uZW50c31gKTtcclxuICAgICAgfVxyXG4gICAgfSkoKX07XHJcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgdmFyIG1heF92YWx1ZSA9ICBmMzIoLTMuNDAyODIzZSszOGYpO1xyXG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtXR307IGkrKykge1xyXG4gICAgICBtYXhfdmFsdWUgPSBtYXgodGhyZWFkX21heFtpXSwgbWF4X3ZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3VtX3ZlY3RvciA9ICR7ZjMyVHlwZX0oMCk7XHJcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xyXG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcclxuICAgIH1cclxuICAgIHRocmVhZF9zdW1bbG9jYWxfaWR4XSA9ICR7KCgpID0+IHtcclxuICAgICAgc3dpdGNoIChjb21wb25lbnRzKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yJztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICByZXR1cm4gJ3N1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSc7XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnkgKyBzdW1fdmVjdG9yLnogKyBzdW1fdmVjdG9yLncnO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7Y29tcG9uZW50c31gKTtcclxuICAgICAgfVxyXG4gICAgfSkoKX07XHJcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgdmFyIHN1bTogZjMyID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7V0d9OyBpKyspIHtcclxuICAgICAgc3VtICs9IHRocmVhZF9zdW1baV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN1bSA9PSAwKSB7XHJcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0oJHtlbGVtVmFsdWVUeXBlfSgxLjApIC8gJHtlbGVtVmFsdWVUeXBlfShzZXFfY2F1c2FsX2xlbmd0aCkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBmMzJpbnB1dCA9ICR7ZjMyVHlwZX0oeFtvZmZzZXQgKyBpXSk7XHJcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgICAgJHtcclxuICAgICAgICBzZXFMZW5zXHJcbiAgICAgICAgICA/IGBcclxuICAgICAgICBmb3IgKHZhciB0b3RhbF9zZXFfaWQ6IHUzMiA9IHNlcV9jYXVzYWxfbGVuZ3RoOyB0b3RhbF9zZXFfaWQgKyBsb2NhbF9vZmZzZXQgPCB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGg7IHRvdGFsX3NlcV9pZCsrKSB7XHJcbiAgICAgICAgICB4W29mZnNldCArIHRvdGFsX3NlcV9pZF0gPSAke2lucHV0SGVscGVyLnR5cGUudmFsdWV9KCR7ZWxlbVZhbHVlVHlwZX0oMCkpO1xyXG4gICAgICAgIH1gXHJcbiAgICAgICAgICA6ICcnXHJcbiAgICAgIH07XHJcbiAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdBdHRlbnRpb25Qcm9ic1NvZnRtYXgnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7V0d9OyR7ZGF0YVR5cGV9OyR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW10sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogMSwgeTogc2VxdWVuY2VMZW5ndGgsIHo6IGJhdGNoU2l6ZSAqIG51bUhlYWRzIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVBdHRlbnRpb25Qcm9ic1Byb2dyYW1JbmZvID0gKFxyXG4gIG91dHB1dENvdW50OiBudW1iZXIsXHJcbiAgcTogVGVuc29yVmlldyxcclxuICBrZXk6IFRlbnNvclZpZXcsXHJcbiAgcGFzdEtleTogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcclxuICBhdHRlbnRpb25CaWFzOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxyXG4gIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsXHJcbiAgcGFzdFNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXHJcbiAgc2VxTGVuczogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcclxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbikgPT4ge1xyXG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBwYXJhbWV0ZXJzLmt2U2VxdWVuY2VMZW5ndGg7XHJcbiAgY29uc3QgcHJvYnNTaGFwZSA9IFtwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwgcGFyYW1ldGVycy5udW1IZWFkcywgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCwgdG90YWxTZXF1ZW5jZUxlbmd0aF07XHJcbiAgY29uc3QgcHJlc2VudEtleSA9IG91dHB1dENvdW50ID4gMSAmJiBwYXN0S2V5O1xyXG4gIGNvbnN0IGt2TnVtSGVhZHMgPSBwYXJhbWV0ZXJzLmt2TnVtSGVhZHMgPyBwYXJhbWV0ZXJzLmt2TnVtSGVhZHMgOiBwYXJhbWV0ZXJzLm51bUhlYWRzO1xyXG4gIGNvbnN0IHByZXNlbnRLZXlTaGFwZSA9IHByZXNlbnRLZXlcclxuICAgID8gW3BhcmFtZXRlcnMuYmF0Y2hTaXplLCBrdk51bUhlYWRzLCB0b3RhbFNlcXVlbmNlTGVuZ3RoLCBwYXJhbWV0ZXJzLmhlYWRTaXplXVxyXG4gICAgOiB1bmRlZmluZWQ7XHJcbiAgY29uc3QgblJlcHMgPSBwYXJhbWV0ZXJzLm5SZXBzID8gcGFyYW1ldGVycy5uUmVwcyA6IDE7XHJcbiAgLy8gVE9ETzogaGFuZGxlIG1hc2tcclxuXHJcbiAgY29uc3QgYWxwaGEgPSBwYXJhbWV0ZXJzLnNjYWxlID09PSAwID8gMS4wIC8gTWF0aC5zcXJ0KHBhcmFtZXRlcnMuaGVhZFNpemUpIDogcGFyYW1ldGVycy5zY2FsZTtcclxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhwYXJhbWV0ZXJzLmhlYWRTaXplKTtcclxuICBjb25zdCB2ZWN0b3JpemVkSGVhZFNpemUgPSBwYXJhbWV0ZXJzLmhlYWRTaXplIC8gY29tcG9uZW50cztcclxuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcclxuICBjb25zdCBkaXNwYXRjaCA9IHtcclxuICAgIHg6IE1hdGguY2VpbCh0b3RhbFNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcclxuICAgIHk6IE1hdGguY2VpbChwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcclxuICAgIHo6IHBhcmFtZXRlcnMuYmF0Y2hTaXplICogcGFyYW1ldGVycy5udW1IZWFkcyxcclxuICB9O1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdmVjdG9yaXplZEhlYWRTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMubnVtSGVhZHMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhlYWRTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhbHBoYSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhc3RTZXF1ZW5jZUxlbmd0aCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMua3ZTZXF1ZW5jZUxlbmd0aCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG5SZXBzIH0sXHJcbiAgXTtcclxuICAvLyBGZWVkIHBhc3RLZXkgdG8gdGhlIHNoYWRlci1jb2RlIG9ubHkgaWYgaXQgaXMgbm9uLXplcm8gYW5kIHByZXNlbnRLZXkgaXMgYmVpbmcgcHJvZHVjZWRcclxuICBjb25zdCBmZWVkUGFzdEtleSA9IHByZXNlbnRLZXkgJiYgcGFzdEtleSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpID4gMDtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XHJcbiAgaWYgKGZlZWRQYXN0S2V5KSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGlmIChhdHRlbnRpb25CaWFzKSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGlmIChzZXFMZW5zKSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcclxuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcclxuICB9XHJcbiAgY29uc3Qgb3V0cHV0cyA9IFt7IGRpbXM6IHByb2JzU2hhcGUsIGRhdGFUeXBlOiBxLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9XTtcclxuICBpZiAocHJlc2VudEtleSkge1xyXG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogcHJlc2VudEtleVNoYXBlISwgZGF0YVR5cGU6IHEuZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH0pO1xyXG4gIH1cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IHFJbnB1dCA9IGlucHV0VmFyaWFibGUoJ3EnLCBxLmRhdGFUeXBlLCBxLmRpbXMsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3Qga0lucHV0ID0gaW5wdXRWYXJpYWJsZSgna2V5Jywga2V5LmRhdGFUeXBlLCBrZXkuZGltcywgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBpbnB1dFZhcnMgPSBbcUlucHV0LCBrSW5wdXRdO1xyXG4gICAgaWYgKGZlZWRQYXN0S2V5KSB7XHJcbiAgICAgIGNvbnN0IHBhc3RLZXlJbnB1dCA9IGlucHV0VmFyaWFibGUoJ3Bhc3Rfa2V5JywgcGFzdEtleS5kYXRhVHlwZSwgcGFzdEtleS5kaW1zLCBjb21wb25lbnRzKTtcclxuICAgICAgaW5wdXRWYXJzLnB1c2gocGFzdEtleUlucHV0KTtcclxuICAgIH1cclxuICAgIGlmIChhdHRlbnRpb25CaWFzKSB7XHJcbiAgICAgIGlucHV0VmFycy5wdXNoKGlucHV0VmFyaWFibGUoJ2F0dGVudGlvbl9iaWFzJywgYXR0ZW50aW9uQmlhcy5kYXRhVHlwZSwgYXR0ZW50aW9uQmlhcy5kaW1zKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXFMZW5zSW5wdXRWYXJpYWJsZSA9IHNlcUxlbnMgPyBpbnB1dFZhcmlhYmxlKCdzZXFfbGVucycsIHNlcUxlbnMuZGF0YVR5cGUsIHNlcUxlbnMuZGltcykgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoc2VxTGVuc0lucHV0VmFyaWFibGUpIHtcclxuICAgICAgaW5wdXRWYXJzLnB1c2goc2VxTGVuc0lucHV0VmFyaWFibGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUgPSB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRcclxuICAgICAgPyBpbnB1dFZhcmlhYmxlKCd0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQnLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGF0YVR5cGUsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dC5kaW1zKVxyXG4gICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRWYXJpYWJsZSkge1xyXG4gICAgICBpbnB1dFZhcnMucHVzaCh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRWYXJpYWJsZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcS5kYXRhVHlwZSwgcHJvYnNTaGFwZSk7XHJcbiAgICBjb25zdCBvdXRwdXRWYXJzID0gW291dHB1dF07XHJcbiAgICBpZiAocHJlc2VudEtleSkge1xyXG4gICAgICBvdXRwdXRWYXJzLnB1c2gob3V0cHV0VmFyaWFibGUoJ3ByZXNlbnRfa2V5JywgcS5kYXRhVHlwZSwgcHJlc2VudEtleVNoYXBlISwgY29tcG9uZW50cykpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZjMyVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoRGF0YVR5cGUuZmxvYXQsIGNvbXBvbmVudHMpO1xyXG5cclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnTScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdOJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnbnVtX2hlYWRzJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnaGVhZF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJyBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlIH0sXHJcbiAgICAgIHsgbmFtZTogJ3Bhc3Rfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAna3Zfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnbl9yZXBzJywgdHlwZTogJ3UzMicgfSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gYFxyXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7VElMRV9TSVpFfXU7XHJcblxyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke3FJbnB1dC50eXBlLnN0b3JhZ2V9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke3FJbnB1dC50eXBlLnN0b3JhZ2V9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCAuLi5vdXRwdXRWYXJzKX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1RJTEVfU0laRSwgVElMRV9TSVpFLCAxXSl9XHJcbiAgICAvLyB4IGhvbGRzIHRoZSBOIGFuZCB5IGhvbGRzIHRoZSBNXHJcbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xyXG4gICAgbGV0IGt2SGVhZElkeCA9ICR7blJlcHMgPT09IDEgPyAnaGVhZElkeCcgOiAnaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwcyd9O1xyXG4gICAgbGV0IGt2X251bV9oZWFkcyA9ICR7blJlcHMgPT09IDEgPyAndW5pZm9ybXMubnVtX2hlYWRzJyA6ICd1bmlmb3Jtcy5udW1faGVhZHMgLyB1bmlmb3Jtcy5uX3JlcHMnfTtcclxuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xyXG4gICAgbGV0IG0gPSB3b3JrZ3JvdXBfaWQueSAqIFRJTEVfU0laRTtcclxuICAgIGxldCBuID0gd29ya2dyb3VwX2lkLnggKiBUSUxFX1NJWkU7XHJcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcclxuICAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5OO1xyXG4gICAgJHtpbml0VmFyU3R1YihzZXFMZW5zSW5wdXRWYXJpYWJsZSwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUsIHRydWUpfVxyXG4gICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4O1xyXG4gICAgbGV0IHFPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XHJcbiAgICAke2ZlZWRQYXN0S2V5ICYmIHByZXNlbnRLZXkgPyAnbGV0IHBhc3RLZXlPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLks7JyA6ICcnfTtcclxuICAgIGxldCBrT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcclxuICAgICR7cHJlc2VudEtleSA/ICdsZXQgcHJlc2VudEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LOycgOiAnJ31cclxuICAgIHZhciB2YWx1ZSA9ICR7ZjMyVHlwZX0oMCk7XHJcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XHJcbiAgICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XHJcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcVtxT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcclxuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XHJcbiAgICAgICR7KCgpID0+IHtcclxuICAgICAgICBpZiAoZmVlZFBhc3RLZXkgJiYgcHJlc2VudEtleSkge1xyXG4gICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCBwYXN0X3NlcXVlbmNlX2xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XHJcbiAgICAgICAgICAgICAgfWA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XHJcbiAgICAgICAgICB9YDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pKCl9XHJcbiAgICAgICR7XHJcbiAgICAgICAgcHJlc2VudEtleVxyXG4gICAgICAgICAgPyBgaWYgKG4gKyBsb2NhbF9pZC55IDwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGgpIHtcclxuICAgICAgICBwcmVzZW50X2tleVtwcmVzZW50S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF0gPSB0aWxlS1tpZHhdO1xyXG4gICAgICB9YFxyXG4gICAgICAgICAgOiAnJ1xyXG4gICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XHJcbiAgICAgICAgICB2YWx1ZSArPSAke2YzMlR5cGV9KHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnggKyBrXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIGdsb2JhbF9pZC54IDwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKSB7XHJcbiAgICAgIGxldCBoZWFkT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcclxuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcclxuICAgICAgdmFyIHN1bTogZjMyID0gJHsoKCkgPT4ge1xyXG4gICAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xyXG4gICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3ZhbHVlJztcclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgcmV0dXJuICd2YWx1ZS54ICsgdmFsdWUueSc7XHJcbiAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHJldHVybiAndmFsdWUueCArIHZhbHVlLnkgKyB2YWx1ZS56ICsgdmFsdWUudyc7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7Y29tcG9uZW50c31gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pKCl9O1xyXG4gICAgICAgIG91dHB1dFtvdXRwdXRJZHhdID0gJHtvdXRwdXQudHlwZS52YWx1ZX0gKHN1bSAqIHVuaWZvcm1zLmFscGhhKSArICR7XHJcbiAgICAgICAgICBhdHRlbnRpb25CaWFzID8gJ2F0dGVudGlvbl9iaWFzW291dHB1dElkeF0nIDogJzAuMCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gIH1gO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdBdHRlbnRpb25Qcm9icycsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHtjb21wb25lbnRzfTske2F0dGVudGlvbkJpYXMgIT09IHVuZGVmaW5lZH07JHtwYXN0S2V5ICE9PSB1bmRlZmluZWR9OyR7b3V0cHV0Q291bnR9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXMsXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHsgb3V0cHV0cywgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsIHByb2dyYW1Vbmlmb3JtcyB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlVnhBdHRlbnRpb25TY29yZVByb2dyYW1JbmZvID0gKFxyXG4gIG91dHB1dENvdW50OiBudW1iZXIsXHJcbiAgcHJvYnM6IFRlbnNvclZpZXcsXHJcbiAgdjogVGVuc29yVmlldyxcclxuICBwYXN0VmFsdWU6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbiAgcGFyYW1zOiBBdHRlbnRpb25QYXJhbWV0ZXJzLFxyXG4gIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxyXG4gIHNlcUxlbnM6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXHJcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxyXG4pID0+IHtcclxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGg7XHJcbiAgY29uc3QgblJlcHMgPSBwYXJhbXMublJlcHMgPyBwYXJhbXMublJlcHMgOiAxO1xyXG4gIGNvbnN0IHJlcGVhdGVkVkhpZGRlblNpemUgPSBwYXJhbXMudkhpZGRlblNpemUgKiBuUmVwcztcclxuICBjb25zdCBwcmVzZW50VmFsdWUgPSBvdXRwdXRDb3VudCA+IDEgJiYgcGFzdFZhbHVlO1xyXG4gIGNvbnN0IGt2TnVtSGVhZHMgPSBwYXJhbXMua3ZOdW1IZWFkcyA/IHBhcmFtcy5rdk51bUhlYWRzIDogcGFyYW1zLm51bUhlYWRzO1xyXG4gIGNvbnN0IHByZXNlbnRWYWx1ZVNoYXBlID0gcHJlc2VudFZhbHVlXHJcbiAgICA/IFtwYXJhbXMuYmF0Y2hTaXplLCBrdk51bUhlYWRzLCB0b3RhbFNlcXVlbmNlTGVuZ3RoLCBwYXJhbXMuaGVhZFNpemVdXHJcbiAgICA6IHVuZGVmaW5lZDtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsIHJlcGVhdGVkVkhpZGRlblNpemVdO1xyXG4gIGNvbnN0IFRJTEVfU0laRSA9IDEyO1xyXG4gIGNvbnN0IGRpc3BhdGNoID0ge1xyXG4gICAgeDogTWF0aC5jZWlsKHBhcmFtcy52SGVhZFNpemUgLyBUSUxFX1NJWkUpLFxyXG4gICAgeTogTWF0aC5jZWlsKHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXHJcbiAgICB6OiBwYXJhbXMuYmF0Y2hTaXplICogcGFyYW1zLm51bUhlYWRzLFxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMuc2VxdWVuY2VMZW5ndGggfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB0b3RhbFNlcXVlbmNlTGVuZ3RoIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLnZIZWFkU2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy5udW1IZWFkcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy5oZWFkU2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHJlcGVhdGVkVkhpZGRlblNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG5SZXBzIH0sXHJcbiAgXTtcclxuICAvLyBGZWVkIHBhc3RWYWx1ZSB0byB0aGUgc2hhZGVyLWNvZGUgb25seSBpZiBpdCBpcyBub24tZW1wdHkgYW5kIHByZXNlbnRWYWx1ZSBpcyBiZWluZyBwcm9kdWNlZFxyXG4gIGNvbnN0IGZlZWRQYXN0VmFsdWUgPSBwcmVzZW50VmFsdWUgJiYgcGFzdFZhbHVlICYmIFNoYXBlVXRpbC5zaXplKHBhc3RWYWx1ZS5kaW1zKSA+IDA7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xyXG4gIGlmIChmZWVkUGFzdFZhbHVlKSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGlmIChzZXFMZW5zKSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcclxuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcclxuICB9XHJcbiAgY29uc3Qgb3V0cHV0cyA9IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogcHJvYnMuZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH1dO1xyXG4gIGlmIChwcmVzZW50VmFsdWUpIHtcclxuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IHByZXNlbnRWYWx1ZVNoYXBlISwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9KTtcclxuICB9XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBwcm9ic0hlbHBlciA9IGlucHV0VmFyaWFibGUoJ3Byb2JzJywgcHJvYnMuZGF0YVR5cGUsIHByb2JzLmRpbXMpO1xyXG4gICAgY29uc3QgdkhlbHBlciA9IGlucHV0VmFyaWFibGUoJ3YnLCB2LmRhdGFUeXBlLCB2LmRpbXMpO1xyXG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3Byb2JzSGVscGVyLCB2SGVscGVyXTtcclxuICAgIGlmIChmZWVkUGFzdFZhbHVlKSB7XHJcbiAgICAgIGlucHV0VmFycy5wdXNoKGlucHV0VmFyaWFibGUoJ3Bhc3RfdmFsdWUnLCBwYXN0VmFsdWUuZGF0YVR5cGUsIHBhc3RWYWx1ZS5kaW1zKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXFMZW5zSW5wdXRWYXJpYWJsZSA9IHNlcUxlbnMgPyBpbnB1dFZhcmlhYmxlKCdzZXFfbGVucycsIHNlcUxlbnMuZGF0YVR5cGUsIHNlcUxlbnMuZGltcykgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoc2VxTGVucykge1xyXG4gICAgICBpbnB1dFZhcnMucHVzaChzZXFMZW5zSW5wdXRWYXJpYWJsZSEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUgPSB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRcclxuICAgICAgPyBpbnB1dFZhcmlhYmxlKCd0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQnLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGF0YVR5cGUsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dC5kaW1zKVxyXG4gICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcclxuICAgICAgaW5wdXRWYXJzLnB1c2godG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUhKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBwcm9icy5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xyXG4gICAgY29uc3Qgb3V0cHV0VmFycyA9IFtvdXRwdXRdO1xyXG4gICAgaWYgKHByZXNlbnRWYWx1ZSkge1xyXG4gICAgICBvdXRwdXRWYXJzLnB1c2gob3V0cHV0VmFyaWFibGUoJ3ByZXNlbnRfdmFsdWUnLCBwcm9icy5kYXRhVHlwZSwgcHJlc2VudFZhbHVlU2hhcGUhKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ00nLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdLJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ251bV9oZWFkcycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2hlYWRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ3ZfaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdwYXN0X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2t2X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ25fcmVwcycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGBcclxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke3Byb2JzSGVscGVyLnR5cGUudmFsdWV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVWOiBhcnJheTwke3Byb2JzSGVscGVyLnR5cGUudmFsdWV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCAuLi5vdXRwdXRWYXJzKX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1RJTEVfU0laRSwgVElMRV9TSVpFLCAxXSl9XHJcbiAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XHJcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xyXG4gICBsZXQga3ZIZWFkSWR4ID0gJHtuUmVwcyA9PT0gMSA/ICdoZWFkSWR4JyA6ICdoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzJ307XHJcbiAgIGxldCBrdl9udW1faGVhZHMgPSAke25SZXBzID09PSAxID8gJ3VuaWZvcm1zLm51bV9oZWFkcycgOiAndW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzJ307XHJcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XHJcbiAgIGxldCBuID0gZ2xvYmFsX2lkLng7XHJcbiAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5NO1xyXG4gICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuSztcclxuICAgJHtpbml0VmFyU3R1YihzZXFMZW5zSW5wdXRWYXJpYWJsZSwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUsIHRydWUpfVxyXG4gICBsZXQgb2Zmc2V0QSA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLksgKyBtICogdW5pZm9ybXMuSztcclxuICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4OyAvLyBrdkhlYWRJZHggaXMgcmVsYXRpdmUgdG8gdGhlIGJhdGNoXHJcbiAgICR7ZmVlZFBhc3RWYWx1ZSAmJiBwcmVzZW50VmFsdWUgPyAnbGV0IHBhc3RWYWx1ZU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCArIG47JyA6ICcnfTtcclxuICAgbGV0IHZPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICsgbjtcclxuICAgJHtwcmVzZW50VmFsdWUgPyAnbGV0IHByZXNlbnRWYWx1ZU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LICsgbjsnIDogJyd9XHJcbiAgIHZhciB2YWx1ZSA9ICR7cHJvYnNIZWxwZXIudHlwZS5zdG9yYWdlfSgwKTtcclxuICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xyXG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XHJcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcHJvYnNbb2Zmc2V0QSArIHcgKyBsb2NhbF9pZC54XTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobiA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5LKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xyXG4gICAgICAgICR7KCgpID0+IHtcclxuICAgICAgICAgIGlmIChmZWVkUGFzdFZhbHVlICYmIHByZXNlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aWxlVltpZHhdID0gcGFzdF92YWx1ZVtwYXN0VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XHJcbiAgICAgICAgfSBlbHNlIGlmICh3ICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuTl07XHJcbiAgICAgICAgfVxyXG4gICAgICBgO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgdGlsZVZbaWR4XSA9IHZbdk9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXTtcclxuICAgICAgICAgICAgfWA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKX1cclxuICAgICAgICAke1xyXG4gICAgICAgICAgcHJlc2VudFZhbHVlXHJcbiAgICAgICAgICAgID8gYFxyXG4gICAgICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCkge1xyXG4gICAgICAgICAgcHJlc2VudF92YWx1ZVtwcmVzZW50VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl0gPSB0aWxlVltpZHhdO1xyXG4gICAgICAgIH1gXHJcbiAgICAgICAgICAgIDogJydcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoOyBrKyspIHtcclxuICAgICAgIHZhbHVlICs9IHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVWW1RJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54XTtcclxuICAgICB9XHJcbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG4gICB9XHJcblxyXG4gICAvLyB3ZSBuZWVkIHRvIHRyYW5zcG9zZSBvdXRwdXQgZnJvbSBCTlNIX3YgdG8gQlNORF92XHJcbiAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xyXG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcclxuICAgICAgICsgaGVhZElkeCAqIHVuaWZvcm1zLk4gKyBuO1xyXG4gICAgIG91dHB1dFtvdXRwdXRJZHhdID0gdmFsdWU7XHJcbiAgIH1cclxuICB9YDtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0F0dGVudGlvblNjb3JlJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke3Bhc3RWYWx1ZSAhPT0gdW5kZWZpbmVkfTske291dHB1dENvdW50fWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoeyBvdXRwdXRzLCBkaXNwYXRjaEdyb3VwOiBkaXNwYXRjaCwgcHJvZ3JhbVVuaWZvcm1zIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXBwbHlBdHRlbnRpb24gPSAoXHJcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXHJcbiAgcTogVGVuc29yVmlldyxcclxuICBrOiBUZW5zb3JWaWV3LFxyXG4gIHY6IFRlbnNvclZpZXcsXHJcbiAgX21hc2tJbmRleDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcclxuICBfcGFzdDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcclxuICBwYXN0S2V5OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxyXG4gIHBhc3RWYWx1ZTogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcclxuICBhdHRlbnRpb25CaWFzSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbiAgcGFyYW1ldGVyczogQXR0ZW50aW9uUGFyYW1ldGVycyxcclxuICBzZXFMZW5zOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxyXG4gIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcclxuKSA9PiB7XHJcbiAgLy8gQXNzdW1wdGlvbiBpcyB0aGF0IHByZXNlbnRLZXkvcHJlc2VudFZhbHVlIGV4aXN0cyBvbmx5IGlmIHBhc3RLZXkvcGFzdFZhbHVlIGV4aXN0cy5cclxuICBjb25zdCBvdXRwdXRDb3VudCA9IE1hdGgubWluKGNvbnRleHQub3V0cHV0Q291bnQsIDEgKyAocGFzdEtleSA/IDEgOiAwKSArIChwYXN0VmFsdWUgPyAxIDogMCkpO1xyXG4gIGNvbnN0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IG91dHB1dENvdW50ID4gMSA/IHBhcmFtZXRlcnMucGFzdFNlcXVlbmNlTGVuZ3RoIDogMDtcclxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsgcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RoO1xyXG4gIGNvbnN0IGF0dGVudGlvbkJpYXMgPVxyXG4gICAgYXR0ZW50aW9uQmlhc0lucHV0ICYmIFNoYXBlVXRpbC5zaXplKGF0dGVudGlvbkJpYXNJbnB1dC5kaW1zKSA+IDAgPyBhdHRlbnRpb25CaWFzSW5wdXQgOiB1bmRlZmluZWQ7XHJcblxyXG4gIGNvbnN0IGlucHV0c0sgPSBbcSwga107XHJcbiAgaWYgKG91dHB1dENvdW50ID4gMSAmJiBwYXN0S2V5ICYmIFNoYXBlVXRpbC5zaXplKHBhc3RLZXkuZGltcykgPiAwKSB7XHJcbiAgICBpbnB1dHNLLnB1c2gocGFzdEtleSk7XHJcbiAgfVxyXG4gIGlmIChhdHRlbnRpb25CaWFzKSB7XHJcbiAgICBpbnB1dHNLLnB1c2goYXR0ZW50aW9uQmlhcyk7XHJcbiAgfVxyXG4gIGlmIChzZXFMZW5zKSB7XHJcbiAgICBpbnB1dHNLLnB1c2goc2VxTGVucyk7XHJcbiAgfVxyXG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcclxuICAgIGlucHV0c0sucHVzaCh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpO1xyXG4gIH1cclxuICAvLyBSdW4gQXR0ZW50aW9uUHJvYnNcclxuICBjb25zdCBwcm9icyA9IGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZUF0dGVudGlvblByb2JzUHJvZ3JhbUluZm8oXHJcbiAgICAgIG91dHB1dENvdW50LFxyXG4gICAgICBxLFxyXG4gICAgICBrLFxyXG4gICAgICBwYXN0S2V5LFxyXG4gICAgICBhdHRlbnRpb25CaWFzLFxyXG4gICAgICBwYXJhbWV0ZXJzLFxyXG4gICAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXHJcbiAgICAgIHNlcUxlbnMsXHJcbiAgICAgIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCxcclxuICAgICksXHJcbiAgICB7IGlucHV0czogaW5wdXRzSywgb3V0cHV0czogb3V0cHV0Q291bnQgPiAxID8gWy0xLCAxXSA6IFstMV0gfSxcclxuICApWzBdO1xyXG5cclxuICAvLyBSdW4gU29mdG1heFxyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZUluUGxhY2VTb2Z0bWF4UHJvZ3JhbUluZm8oXHJcbiAgICAgIHByb2JzLFxyXG4gICAgICBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSxcclxuICAgICAgcGFyYW1ldGVycy5udW1IZWFkcyxcclxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgICBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgICBzZXFMZW5zLFxyXG4gICAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQsXHJcbiAgICApLFxyXG4gICAgeyBpbnB1dHM6IHNlcUxlbnMgJiYgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0ID8gW3Byb2JzLCBzZXFMZW5zLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRdIDogW3Byb2JzXSwgb3V0cHV0czogW10gfSxcclxuICApO1xyXG5cclxuICAvLyBSdW4gQXR0ZW50aW9uU2NvcmVcclxuICBjb25zdCBpbnB1dHNWID0gW3Byb2JzLCB2XTtcclxuICBpZiAob3V0cHV0Q291bnQgPiAxICYmIHBhc3RWYWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0VmFsdWUuZGltcykgPiAwKSB7XHJcbiAgICBpbnB1dHNWLnB1c2gocGFzdFZhbHVlKTtcclxuICB9XHJcbiAgaWYgKHNlcUxlbnMpIHtcclxuICAgIGlucHV0c1YucHVzaChzZXFMZW5zKTtcclxuICB9XHJcbiAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCkge1xyXG4gICAgaW5wdXRzVi5wdXNoKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCk7XHJcbiAgfVxyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZVZ4QXR0ZW50aW9uU2NvcmVQcm9ncmFtSW5mbyhcclxuICAgICAgb3V0cHV0Q291bnQsXHJcbiAgICAgIHByb2JzLFxyXG4gICAgICB2LFxyXG4gICAgICBwYXN0VmFsdWUsXHJcbiAgICAgIHBhcmFtZXRlcnMsXHJcbiAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcclxuICAgICAgc2VxTGVucyxcclxuICAgICAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LFxyXG4gICAgKSxcclxuICAgIHtcclxuICAgICAgaW5wdXRzOiBpbnB1dHNWLFxyXG4gICAgICBvdXRwdXRzOiBvdXRwdXRDb3VudCA+IDEgPyBbMCwgMl0gOiBbMF0sXHJcbiAgICB9LFxyXG4gICk7XHJcbn07XHJcblxyXG5jb25zdCBwcmVwYXJlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBwYXJhbWV0ZXJzOiBBdHRlbnRpb25QYXJhbWV0ZXJzKSA9PiB7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbcGFyYW1ldGVycy5iYXRjaFNpemUsIHBhcmFtZXRlcnMubnVtSGVhZHMsIHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGgsIHBhcmFtZXRlcnMuaGVhZFNpemVdO1xyXG4gIGNvbnN0IE0gPSBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoO1xyXG4gIGNvbnN0IEsgPSBwYXJhbWV0ZXJzLmlucHV0SGlkZGVuU2l6ZTtcclxuICBjb25zdCBOID0gcGFyYW1ldGVycy5oZWFkU2l6ZTtcclxuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcclxuICBjb25zdCBkaXNwYXRjaCA9IHtcclxuICAgIHg6IE1hdGguY2VpbChwYXJhbWV0ZXJzLmhlYWRTaXplIC8gVElMRV9TSVpFKSxcclxuICAgIHk6IE1hdGguY2VpbChwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcclxuICAgIHo6IHBhcmFtZXRlcnMuYmF0Y2hTaXplICogcGFyYW1ldGVycy5udW1IZWFkcyxcclxuICB9O1xyXG4gIGNvbnN0IGlucHV0cyA9IFtjb250ZXh0LmlucHV0c1swXSwgY29udGV4dC5pbnB1dHNbMV0sIGNvbnRleHQuaW5wdXRzWzJdXTtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEsgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBOIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5udW1IZWFkcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGVhZFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhpZGRlblNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLnZIaWRkZW5TaXplIH0sXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBvdXRwdXRRID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9xJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XHJcbiAgICBjb25zdCBvdXRwdXRLID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9rJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XHJcbiAgICBjb25zdCBvdXRwdXRWID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF92JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XHJcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcyk7XHJcbiAgICBjb25zdCB3ZWlnaHQgPSBpbnB1dFZhcmlhYmxlKCd3ZWlnaHQnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zKTtcclxuICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcyk7XHJcbiAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0LnR5cGUuc3RvcmFnZTtcclxuXHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ00nLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdLJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ251bV9oZWFkcycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2hlYWRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnbGRiJywgdHlwZTogJ3UzMicgfSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gYFxyXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7VElMRV9TSVpFfXU7XHJcbiAgdmFyPHdvcmtncm91cD4gdGlsZUlucHV0OiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcclxuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XHJcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRWOiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCB3ZWlnaHQsIGJpYXMsIG91dHB1dFEsIG91dHB1dEssIG91dHB1dFYpfVxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbVElMRV9TSVpFLCBUSUxFX1NJWkUsIDFdKX1cclxuICAgIGxldCBiYXRjaEluZGV4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XHJcbiAgICBsZXQgaGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xyXG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcclxuICAgIGxldCBuID0gZ2xvYmFsX2lkLng7XHJcblxyXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcclxuICAgIGxldCBiaWFzT2Zmc2V0USA9IGhlYWROdW1iZXIgKiB1bmlmb3Jtcy5oZWFkX3NpemU7XHJcbiAgICBsZXQgYmlhc09mZnNldEsgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRRO1xyXG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcclxuXHJcbiAgICB2YXIgdmFsdWVRID0gJHtkYXRhVHlwZX0oMCk7XHJcbiAgICB2YXIgdmFsdWVLID0gJHtkYXRhVHlwZX0oMCk7XHJcbiAgICB2YXIgdmFsdWVWID0gJHtkYXRhVHlwZX0oMCk7XHJcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XHJcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcclxuICAgICAgICB0aWxlSW5wdXRbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gaW5wdXRbaW5wdXRPZmZzZXQgKyB3ICsgbG9jYWxfaWQueF07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSBuICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLmxkYjtcclxuICAgICAgICB0aWxlV2VpZ2h0UVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFEgKyBvZmZzZXRdO1xyXG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XHJcbiAgICAgICAgdGlsZVdlaWdodFZbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRWICsgb2Zmc2V0XTtcclxuICAgICAgfVxyXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcclxuICAgICAgICBsZXQgaW5wdXRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGs7XHJcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcclxuICAgICAgICB2YWx1ZVEgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0UVt3ZWlnaHRUaWxlT2Zmc2V0XTtcclxuICAgICAgICB2YWx1ZUsgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0S1t3ZWlnaHRUaWxlT2Zmc2V0XTtcclxuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XHJcbiAgICB2YWx1ZVEgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFFdO1xyXG4gICAgdmFsdWVLICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRLXTtcclxuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XHJcblxyXG4gICAgbGV0IG9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XHJcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcclxuICAgICAgbGV0IG91dHB1dElkeCA9IG9mZnNldCArIG0gKiB1bmlmb3Jtcy5OICsgbjtcclxuICAgICAgb3V0cHV0X3Fbb3V0cHV0SWR4XSA9IHZhbHVlUTtcclxuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcclxuICAgICAgb3V0cHV0X3Zbb3V0cHV0SWR4XSA9IHZhbHVlVjtcclxuICAgIH1cclxuICB9YDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnQXR0ZW50aW9uUHJlcGFyZScsXHJcbiAgICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnLCAndHlwZScsICd0eXBlJ10gfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAgICB7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH0sXHJcbiAgICAgICAgICB7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH0sXHJcbiAgICAgICAgICB7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkaXNwYXRjaEdyb3VwOiBkaXNwYXRjaCxcclxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICAgIH0pLFxyXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICB9LFxyXG4gICAgeyBpbnB1dHMsIG91dHB1dHM6IFstMSwgLTEsIC0xXSB9LFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXR0ZW50aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IHBhcmFtcyA9IHZhbGlkYXRlQXR0ZW50aW9uSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuXHJcbiAgY29uc3QgW3EsIGssIHZdID0gcHJlcGFyZShjb250ZXh0LCBwYXJhbXMpO1xyXG5cclxuICByZXR1cm4gYXBwbHlBdHRlbnRpb24oXHJcbiAgICBjb250ZXh0LFxyXG4gICAgcSxcclxuICAgIGssXHJcbiAgICB2LFxyXG4gICAgY29udGV4dC5pbnB1dHNbNF0sXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICBjb250ZXh0LmlucHV0c1s1XSxcclxuICAgIHBhcmFtcyxcclxuICApO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoTm9ybUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IGVwc2lsb246IG51bWJlcjtcclxuICByZWFkb25seSBtb21lbnR1bTogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IHNwYXRpYWw6IGJvb2xlYW47XHJcbiAgcmVhZG9ubHkgdHJhaW5pbmdNb2RlOiBib29sZWFuO1xyXG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnIHwgJ05DSFcnO1xyXG4gIHJlYWRvbmx5IG91dHB1dENvdW50OiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gNSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHMnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGNoZWNrU2hhcGVFcXVhbCA9IChhY3R1YWw6IHJlYWRvbmx5IG51bWJlcltdLCBleHBlY3RlZDogcmVhZG9ubHkgbnVtYmVyW10sIG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgciA9IGV4cGVjdGVkLmxlbmd0aDtcclxuICAgIGlmIChyICE9PSBhY3R1YWwubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHttZXNzYWdlfTogbnVtIGRpbWVuc2lvbnMgIT0gJHtyfWApO1xyXG4gICAgfVxyXG4gICAgZXhwZWN0ZWQuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG4gICAgICBpZiAodiAhPT0gYWN0dWFsW2ldKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21lc3NhZ2V9OiBkaW1bJHtpfV0gZG8gbm90IG1hdGNoYCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggPiAxKSB7XHJcbiAgICBjb25zdCBzaGFwZSA9XHJcbiAgICAgIGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQydcclxuICAgICAgICA/IGF0dHJpYnV0ZXMuc3BhdGlhbFxyXG4gICAgICAgICAgPyBpbnB1dHNbMF0uZGltcy5zbGljZSgtMSlcclxuICAgICAgICAgIDogaW5wdXRzWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxKSlcclxuICAgICAgICA6IGlucHV0c1swXS5kaW1zLnNsaWNlKDEsIGF0dHJpYnV0ZXMuc3BhdGlhbCA/IDIgOiB1bmRlZmluZWQpO1xyXG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1sxXS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgc2NhbGUnKTtcclxuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMl0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IEInKTtcclxuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbM10uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IG1lYW4nKTtcclxuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbNF0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IHZhcicpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzFdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgc2NhbGUnKTtcclxuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMl0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCBCJyk7XHJcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzNdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgbWVhbicpO1xyXG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1s0XS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IHZhcicpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IEJhdGNoTm9ybUF0dHJpYnV0ZXMsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCB7IGVwc2lsb24sIHNwYXRpYWwsIGZvcm1hdCB9ID0gYXR0cmlidXRlcztcclxuICBjb25zdCB5U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBjb21wb25lbnRzID0gc3BhdGlhbCA/IGdldE1heENvbXBvbmVudHMoeVNoYXBlW3lTaGFwZS5sZW5ndGggLSAxXSkgOiAxO1xyXG4gIGNvbnN0IGNDb21wb25lbnRzID0gZm9ybWF0ID09PSAnTkhXQycgJiYgeVNoYXBlLmxlbmd0aCA+IDEgPyBjb21wb25lbnRzIDogMTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoeVNoYXBlKSAvIGNvbXBvbmVudHM7XHJcbiAgLy8gT25seSBzdXBwb3J0IHVuaWZvcm1zIGZvciBvcHNldCB2ZXJzaW9uID49IDkgKHNwYXRpYWwgPSB0cnVlKS5cclxuICBjb25zdCB1c2VTaGFwZXNVbmlmb3JtcyA9IHNwYXRpYWw7XHJcbiAgY29uc3Qgc2hhcGVPclJhbmsgPSB1c2VTaGFwZXNVbmlmb3JtcyA/IHlTaGFwZS5sZW5ndGggOiB5U2hhcGU7XHJcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKTtcclxuICBjb25zdCBzY2FsZSA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcywgY0NvbXBvbmVudHMpO1xyXG4gIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY0NvbXBvbmVudHMpO1xyXG4gIGNvbnN0IGlucHV0TWVhbiA9IGlucHV0VmFyaWFibGUoJ2lucHV0TWVhbicsIGlucHV0c1szXS5kYXRhVHlwZSwgaW5wdXRzWzNdLmRpbXMsIGNDb21wb25lbnRzKTtcclxuICBjb25zdCBpbnB1dFZhciA9IGlucHV0VmFyaWFibGUoJ2lucHV0VmFyJywgaW5wdXRzWzRdLmRhdGFUeXBlLCBpbnB1dHNbNF0uZGltcywgY0NvbXBvbmVudHMpO1xyXG4gIGNvbnN0IHkgPSBvdXRwdXRWYXJpYWJsZSgneScsIGlucHV0c1swXS5kYXRhVHlwZSwgc2hhcGVPclJhbmssIGNvbXBvbmVudHMpO1xyXG4gIC8vIFRPRE86IHN1cHBvcnQgaW5wdXRzIHdpdGggZGlmZmVyZW50IGRhdGEgdHlwZS4gQ3VycmVudCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBhbGwgaW5wdXRzIGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlxyXG4gIC8vIE90aGVyd2lzZSwgdGhlIHNoYWRlciBjb21waWxhdGlvbiB3aWxsIGZhaWwuXHJcbiAgY29uc3QgY2FsY0NPZmZzZXQgPSAoKTogc3RyaW5nID0+IHtcclxuICAgIGxldCBjT2Zmc2V0ID0gJyc7XHJcbiAgICBpZiAoc3BhdGlhbCkge1xyXG4gICAgICBjT2Zmc2V0ID0gYGxldCBjT2Zmc2V0ID0gJHtcclxuICAgICAgICB5U2hhcGUubGVuZ3RoID09PSAxXHJcbiAgICAgICAgICA/ICcwdSdcclxuICAgICAgICAgIDogZm9ybWF0ID09PSAnTkhXQydcclxuICAgICAgICAgICAgPyBgb3V0cHV0SW5kaWNlc1ske3lTaGFwZS5sZW5ndGggLSAxfV0gLyAke2NvbXBvbmVudHN9YFxyXG4gICAgICAgICAgICA6ICdvdXRwdXRJbmRpY2VzWzFdJ1xyXG4gICAgICB9O2A7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoZm9ybWF0ID09PSAnTkNIVycpIHtcclxuICAgICAgICBjT2Zmc2V0ID0gYFxyXG4gICAgICAgICAgICAke3kuaW5kaWNlc1NldCgnb3V0cHV0SW5kaWNlcycsICcwJywgJzAnKX1cclxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke3kuaW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJyl9O2A7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gdXBkYXRlIEMgY2hhbm5lbC5cclxuICAgICAgICBjT2Zmc2V0ID0gYHZhciBjSW5kaWNlcyA9ICR7c2NhbGUudHlwZS5pbmRpY2VzfSgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICBjSW5kaWNlc1swXSA9IG91dHB1dEluZGljZXNbJHt5U2hhcGUubGVuZ3RoIC0gMX1dO2A7XHJcbiAgICAgICAgLy8gdXBkYXRlIEQxIHggLi4uIHggRG4gY2hhbm5lbHMuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzY2FsZS5yYW5rOyBpKyspIHtcclxuICAgICAgICAgIGNPZmZzZXQgKz0gYGNJbmRpY2VzWyR7aX1dID0gb3V0cHV0SW5kaWNlc1ske2l9XTtgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjT2Zmc2V0ICs9IGBsZXQgY09mZnNldCA9ICR7c2NhbGUuaW5kaWNlc1RvT2Zmc2V0KCdjSW5kaWNlcycpfTtgO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY09mZnNldDtcclxuICB9O1xyXG4gIGNvbnN0IGdldEluZmVyZW5jZU1vZGVTaGFkZXJTb3VyY2UgPSAoaGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICBjb25zdCBlcHNpbG9uID0gJHtlcHNpbG9ufTtcclxuICAke2hlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBzY2FsZSwgYmlhcywgaW5wdXRNZWFuLCBpbnB1dFZhciwgeSl9XHJcbiAgJHtoZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgJHtoZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxyXG4gICAgdmFyIG91dHB1dEluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfWApfTtcclxuICAgICR7Y2FsY0NPZmZzZXQoKX1cclxuICAgIGxldCBzY2FsZSA9ICR7c2NhbGUuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XHJcbiAgICBsZXQgYmlhcyA9ICR7Ymlhcy5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtcclxuICAgIGxldCBpbnB1dE1lYW4gPSAke2lucHV0TWVhbi5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtcclxuICAgIGxldCBpbnB1dFZhciA9ICR7aW5wdXRWYXIuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XHJcbiAgICBsZXQgeCA9ICR7eC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcclxuICAgIGxldCB2YWx1ZSA9ICh4IC0gaW5wdXRNZWFuKSAqIGludmVyc2VTcXJ0KGlucHV0VmFyICsgZXBzaWxvbikgKiBzY2FsZSArIGJpYXM7XHJcbiAgICAke3kuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cclxuICB9YDtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmVwc2lsb259XyR7YXR0cmlidXRlcy5mb3JtYXR9XyR7c3BhdGlhbH1fJHtjb21wb25lbnRzfWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiB1c2VTaGFwZXNVbmlmb3JtcyA/IFsncmFuaycsICd0eXBlJywgJ3R5cGUnLCAndHlwZScsICd0eXBlJ10gOiB1bmRlZmluZWQsXHJcbiAgICB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlOiBnZXRJbmZlcmVuY2VNb2RlU2hhZGVyU291cmNlLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXRzWzBdLmRpbXMsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiB1c2VTaGFwZXNVbmlmb3Jtc1xyXG4gICAgICAgID8gW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHlTaGFwZSldXHJcbiAgICAgICAgOiBbeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfV0sXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQmF0Y2hOb3JtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEJhdGNoTm9ybUF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PEJhdGNoTm9ybUF0dHJpYnV0ZXMsIGtleW9mIEF0dHJpYnV0ZVdpdGhDYWNoZUtleT4pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGJhdGNoTm9ybSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB2b2lkID0+IHtcclxuICBjb25zdCB7IGlucHV0cywgb3V0cHV0Q291bnQgfSA9IGNvbnRleHQ7XHJcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBwYXJzZUJhdGNoTm9ybUF0dHJpYnV0ZXMoeyAuLi5hdHRyaWJ1dGVzLCBvdXRwdXRDb3VudCB9KTtcclxuICBpZiAoZW52LndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCkge1xyXG4gICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcyk7XHJcbiAgfVxyXG4gIGlmIChhdHRyaWJ1dGVzLnRyYWluaW5nTW9kZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYXRjaE5vcm1hbGl6YXRpb24gdHJhaW5pbmdNb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmF0Y2hOb3JtSW5mZXJlbmNlUHJvZ3JhbUluZm8oaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcykpO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcclxuICB9XHJcblxyXG4gIGlmICghWzMyMCwgNjQwLCAxMjgwXS5pbmNsdWRlcyhpbnB1dHNbMF0uZGltc1syXSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIG9mIGNoYW5uZWxzIHNob3VsZCBiZSAzMjAsIDY0MCBvciAxMjgwJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dHNbMF0uZGltc1syXSAhPT0gaW5wdXRzWzFdLmRpbXNbMF0pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignbGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZScpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUJpYXNBZGRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG5cclxuICBjb25zdCBjaGFubmVscyA9IGlucHV0c1swXS5kaW1zWzJdO1xyXG4gIC8vIHNpbmNlIGNoYW5uZWwgbnVtYmVyIGNhbiBiZSBvbmx5IDMyMC82NDAvMTI4MCwgaXQncyBhbHdheXMgZGl2aXNpYmxlIGJ5IDRcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNDtcclxuXHJcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XHJcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XHJcbiAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBkYXRhVHlwZSwgW2NoYW5uZWxzXSwgNCk7XHJcbiAgY29uc3QgcmVzaWR1YWwgPSBpbnB1dFZhcmlhYmxlKCdyZXNpZHVhbCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxyXG4gIGNvbnN0IGNoYW5uZWxzID0gJHtjaGFubmVsc311IC8gNDtcclxuICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBiaWFzLCByZXNpZHVhbCwgb3V0cHV0KX1cclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG91dHB1dFNpemUpfVxyXG4gICAgbGV0IHZhbHVlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfVxyXG4gICAgICArICR7Ymlhcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAlIGNoYW5uZWxzJyl9ICsgJHtyZXNpZHVhbC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcclxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9XHJcbiAgfWA7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnQmlhc0FkZCcsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBiaWFzQWRkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVCaWFzQWRkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcclxuICBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuXHJcbnR5cGUgQnVpbHRpbkZ1bmN0aW9uTmFtZSA9IHN0cmluZztcclxudHlwZSBFbGVtZW50d2lzZUN1c3RvbUV4cHJlc3Npb24gPSAoZXhwcmVzc2lvbjogc3RyaW5nKSA9PiBzdHJpbmc7XHJcbnR5cGUgRWxlbWVudHdpc2VGdW5jdGlvbkNhbGwgPSBCdWlsdGluRnVuY3Rpb25OYW1lIHwgRWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uO1xyXG5cclxuY29uc3QgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtU2hhZGVyID0gKFxyXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxyXG4gIGRhdGFzaXplOiBudW1iZXIsXHJcbiAgaW5wdXREYXRhVHlwZTogbnVtYmVyLFxyXG4gIG91dHB1dERhdGFUeXBlOiBudW1iZXIsXHJcbiAgZnVuY0NhbGw6IEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsLFxyXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcclxuICBhZGRpdGlvbmFsVW5pZm9ybXNUeXBlPzogVW5pZm9ybXNBcnJheVR5cGUsXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3QgdmVjU2l6ZSA9IE1hdGguY2VpbChkYXRhc2l6ZSAvIDQpO1xyXG5cclxuICBsZXQgZXhwcmVzc2lvbiA9ICcnO1xyXG4gIGlmICh0eXBlb2YgZnVuY0NhbGwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBleHByZXNzaW9uID0gYCR7ZnVuY0NhbGx9KGEpYDtcclxuICB9IGVsc2Uge1xyXG4gICAgZXhwcmVzc2lvbiA9IGZ1bmNDYWxsKCdhJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0RGF0YScsIGlucHV0RGF0YVR5cGUsIFt2ZWNTaXplXSwgNCk7XHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dERhdGEnLCBvdXRwdXREYXRhVHlwZSwgW3ZlY1NpemVdLCA0KTtcclxuICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbeyBuYW1lOiAndmVjX3NpemUnLCB0eXBlOiAndTMyJyB9XTtcclxuICBpZiAoYWRkaXRpb25hbFVuaWZvcm1zVHlwZSkge1xyXG4gICAgdW5pZm9ybXMucHVzaCguLi5hZGRpdGlvbmFsVW5pZm9ybXNUeXBlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBgXHJcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XHJcblxyXG4gICR7YWRkaXRpb25hbEltcGxlbWVudGF0aW9uID8/ICcnfVxyXG5cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnZlY19zaXplJyl9XHJcblxyXG4gICAgbGV0IGEgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBleHByZXNzaW9uKX1cclxuICB9YDtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIGZ1bmNDYWxsOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCxcclxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXHJcbiAgY2FjaGVLZXk/OiBzdHJpbmcsXHJcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGlucHV0LmRhdGFUeXBlLFxyXG4gIGFkZGl0aW9uYWxVbmlmb3Jtcz86IFByb2dyYW1Vbmlmb3JtW10sXHJcbiAgYWRkaXRpb25hbFVuaWZvcm1zVHlwZT86IFVuaWZvcm1zQXJyYXlUeXBlLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSAvIDQpIH0sXHJcbiAgXTtcclxuICBpZiAoYWRkaXRpb25hbFVuaWZvcm1zKSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5hZGRpdGlvbmFsVW5pZm9ybXMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWUsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBjYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZSddIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XHJcbiAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbVNoYWRlcihcclxuICAgICAgICBzaGFkZXJIZWxwZXIsXHJcbiAgICAgICAgU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcyksXHJcbiAgICAgICAgaW5wdXQuZGF0YVR5cGUsXHJcbiAgICAgICAgb3V0cHV0RGF0YVR5cGUsXHJcbiAgICAgICAgZnVuY0NhbGwsXHJcbiAgICAgICAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxyXG4gICAgICAgIGFkZGl0aW9uYWxVbmlmb3Jtc1R5cGUsXHJcbiAgICAgICksXHJcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRUZW5zb3JzKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBpbnB1dC5kaW1zLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHtcclxuICAgICAgICB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzBdLmRpbXMpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIHZlYyBzaXplICovKSxcclxuICAgICAgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhYnMgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FicycsICdhYnMnKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYWNvcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvcycsICdhY29zJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFjb3NoID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBY29zaCcsICdhY29zaCcpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhc2luID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBc2luJywgJ2FzaW4nKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXNpbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW5oJywgJ2FzaW5oJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGF0YW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0F0YW4nLCAnYXRhbicpKTtcclxufTtcclxuZXhwb3J0IGNvbnN0IGF0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBdGFuaCcsICdhdGFuaCcpKTtcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2FzdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IHRvOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgc2F0dXJhdGU/OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IENhc3RBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMgeyB0bzogbnVtYmVyIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNhc3QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENhc3RBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgbGV0IGZ1bmM6IEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsO1xyXG4gIHN3aXRjaCAoYXR0cmlidXRlcy50bykge1xyXG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxyXG4gICAgICBmdW5jID0gJ3ZlYzQ8ZjE2Pic7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcclxuICAgICAgZnVuYyA9ICd2ZWM0PGYzMj4nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxyXG4gICAgICBmdW5jID0gJ3ZlYzQ8dTMyPic7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcclxuICAgICAgZnVuYyA9ICd2ZWM0PGkzMj4nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcclxuICAgICAgZnVuYyA9ICd2ZWM0PGJvb2w+JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbm90IHN1cHBvcnRlZCB0eXBlIChzcGVjaWZpZWQgaW4gYXR0cmlidXRlICd0bycgZnJvbSAnQ2FzdCcgb3BlcmF0b3IpOiAke2F0dHJpYnV0ZXMudG99YCk7XHJcbiAgfVxyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdDYXN0JywgZnVuYywgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBhdHRyaWJ1dGVzLnRvKSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDbGlwQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgbWluOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgbWF4OiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogQ2xpcEF0dHJpYnV0ZXMgPT4ge1xyXG4gIGxldCBtaW46IG51bWJlcjtcclxuICBsZXQgbWF4OiBudW1iZXI7XHJcbiAgY29uc3QgaGFzTWluID0gaW5wdXRzLmxlbmd0aCA+PSAyICYmIGlucHV0c1sxXS5kYXRhICE9PSAwO1xyXG4gIGNvbnN0IGhhc01heCA9IGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0uZGF0YSAhPT0gMDtcclxuXHJcbiAgc3dpdGNoIChpbnB1dHNbMF0uZGF0YVR5cGUpIHtcclxuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XHJcbiAgICAgIG1pbiA9IGhhc01pbiA/IGlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSA6IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XHJcbiAgICAgIG1heCA9IGhhc01heCA/IGlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXSA6IDMuNDAyODIzNDY2Mzg1Mjg4NmUzODtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XHJcbiAgICAgIG1pbiA9IGhhc01pbiA/IGlucHV0c1sxXS5nZXRVaW50MTZBcnJheSgpWzBdIDogNjQ1MTE7IC8vIHVpbnQxNig2NDUxMSkgPC0+IGZsb2F0MTYoLTY1NTA0LjApXHJcbiAgICAgIG1heCA9IGhhc01heCA/IGlucHV0c1syXS5nZXRVaW50MTZBcnJheSgpWzBdIDogMzE3NDM7IC8vIHVpbnQxNigzMTc0MykgPC0+IGZsb2F0MTYoNjU1MDQuMClcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydCBkYXRhIHR5cGUnKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBtaW4sIG1heCB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjbGlwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBjbGlwQXR0cmlidXRlczogQ2xpcEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBjb25zdCBhdHRyaWJ1dGVzID0gY2xpcEF0dHJpYnV0ZXMgPyBjbGlwQXR0cmlidXRlcyA6IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXHJcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxyXG4gICAgICAnQ2xpcCcsXHJcbiAgICAgIChhKSA9PiBgY2xhbXAoJHthfSwgdmVjNDwke2RhdGFUeXBlfT4odW5pZm9ybXMubWluKSwgdmVjNDwke2RhdGFUeXBlfT4odW5pZm9ybXMubWF4KSlgLFxyXG4gICAgICB1bmRlZmluZWQsXHJcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXHJcbiAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgW1xyXG4gICAgICAgIHsgdHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGRhdGE6IGF0dHJpYnV0ZXMubWluIH0sXHJcbiAgICAgICAgeyB0eXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZGF0YTogYXR0cmlidXRlcy5tYXggfSxcclxuICAgICAgXSxcclxuICAgICAgW1xyXG4gICAgICAgIHsgbmFtZTogJ21pbicsIHR5cGU6IGRhdGFUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcclxuICAgICAgICB7IG5hbWU6ICdtYXgnLCB0eXBlOiBkYXRhVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlIH0sXHJcbiAgICAgIF0sXHJcbiAgICApLFxyXG4gICAgeyBpbnB1dHM6IFswXSB9LFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY2VpbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2VpbCcsICdjZWlsJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ29zJywgJ2NvcycpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb3NoID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdDb3NoJywgJ2Nvc2gnKSk7XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFscGhhQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgYWxwaGE6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQWxwaGFBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQWxwaGFBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMgeyBhbHBoYTogbnVtYmVyIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcclxuICAgICAgJ0VsdScsXHJcbiAgICAgIChhKSA9PiBgZWx1X3ZmMzIoJHthfSlgLFxyXG4gICAgICBgXHJcbiAgY29uc3QgZWx1X2FscGhhXyA9ICR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5hbHBoYX0pO1xyXG5cclxuICBmbiBlbHVfZjMyKGE6ICR7ZGF0YVR5cGV9KSAtPiAke2RhdGFUeXBlfSB7XHJcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcclxuICB9XHJcblxyXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8JHtkYXRhVHlwZX0+KSAtPiB2ZWM0PCR7ZGF0YVR5cGV9PiB7XHJcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcclxuICB9YCxcclxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcclxuICAgICksXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBlcmZJbXBsID0gKHZhclR5cGUgPSAnZjMyJykgPT4gYFxyXG5jb25zdCByMDogJHt2YXJUeXBlfSA9IDAuMzI3NTkxMTtcclxuY29uc3QgcjE6ICR7dmFyVHlwZX0gPSAwLjI1NDgyOTU5MjtcclxuY29uc3QgcjI6ICR7dmFyVHlwZX0gPSAtMC4yODQ0OTY3MzY7XHJcbmNvbnN0IHIzOiAke3ZhclR5cGV9ID0gMS40MjE0MTM3NDE7XHJcbmNvbnN0IHI0OiAke3ZhclR5cGV9ID0gLTEuNDUzMTUyMDI3O1xyXG5jb25zdCByNTogJHt2YXJUeXBlfSA9IDEuMDYxNDA1NDI5O1xyXG5cclxuZm4gZXJmX3ZmMzIodjogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XHJcbiAgbGV0IGFic3YgPSBhYnModik7XHJcbiAgbGV0IHggPSAxLjAgLyAoMS4wICsgcjAgKiBhYnN2KTtcclxuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcclxufWA7XHJcblxyXG5leHBvcnQgY29uc3QgZXJmID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0VyZicsIChhKSA9PiBgZXJmX3ZmMzIoJHthfSlgLCBlcmZJbXBsKGRhdGFUeXBlKSkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGV4cCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRXhwJywgJ2V4cCcpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmbG9vciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRmxvb3InLCAnZmxvb3InKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcclxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXHJcbiAgICAgICdHZWx1JyxcclxuICAgICAgKGEpID0+IGAwLjUgKiAke2F9ICogKDEuMCArIGVyZl92ZjMyKCR7YX0gKiAwLjcwNzEwNjc4MTE4NjU0NzUpKWAsXHJcbiAgICAgIGVyZkltcGwoZGF0YVR5cGUpLFxyXG4gICAgKSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxlYWt5UmVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcclxuICAgICAgJ0xlYWt5UmVsdScsXHJcbiAgICAgIChhKSA9PiBgc2VsZWN0KGxlYWt5X3JlbHVfYWxwaGFfICogJHthfSwgJHthfSwgJHthfSA+PSB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApKWAsXHJcbiAgICAgIGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5hbHBoYX0pO2AsXHJcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXHJcbiAgICApLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgbm90ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdOb3QnLCAoYSkgPT4gYCEke2F9YCkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG5lZyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTmVnJywgKGEpID0+IGAtJHthfWApKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWNpcHJvY2FsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdSZWNpcHJvY2FsJywgKGEpID0+IGAxLjAvJHthfWApKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcclxuICAgICAgJ1JlbHUnLFxyXG4gICAgICAoYSkgPT4gYHNlbGVjdCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCAke2F9LCAke2F9ID4gdmVjNDwke2RhdGFUeXBlfT4oMC4wKSlgLFxyXG4gICAgKSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNpZ21vaWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpZ21vaWQnLCAoYSkgPT4gYCgxLjAgLyAoMS4wICsgZXhwKC0ke2F9KSkpYCkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBIYXJkU2lnbW9pZEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgYmV0YTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VIYXJkU2lnbW9pZEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBIYXJkU2lnbW9pZEF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoXHJcbiAgICBhdHRyaWJ1dGVzIGFzIHtcclxuICAgICAgYWxwaGE6IG51bWJlcjtcclxuICAgICAgYmV0YTogbnVtYmVyO1xyXG4gICAgfSxcclxuICApO1xyXG5cclxuZXhwb3J0IGNvbnN0IGhhcmRTaWdtb2lkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBIYXJkU2lnbW9pZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXHJcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxyXG4gICAgICAnSGFyZFNpZ21vaWQnLFxyXG4gICAgICAoYSkgPT5cclxuICAgICAgICBgbWF4KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksIG1pbih2ZWM0PCR7ZGF0YVR5cGV9PigxLjApLCAke2F0dHJpYnV0ZXMuYWxwaGF9ICogJHthfSArIHZlYzQ8JHtkYXRhVHlwZX0+KCR7YXR0cmlidXRlcy5iZXRhfSkpKWAsXHJcbiAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcclxuICAgICksXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbicsICdzaW4nKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU2luaCcsICdzaW5oJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNxcnQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NxcnQnLCAnc3FydCcpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0YW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbicsICd0YW4nKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdGFuaEV4cHJlc3Npb24gPSAoYTogc3RyaW5nKSA9PiBgc2lnbigke2F9KSAqICgxIC0gZXhwKC0yICogYWJzKCR7YX0pKSkgLyAoMSArIGV4cCgtMiAqIGFicygke2F9KSkpYDtcclxuXHJcbmV4cG9ydCBjb25zdCB0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgLy8gVE9ETzogcmV2aXNpdCBhZnRlciBodHRwczovL2dpdGh1Yi5jb20vZ3B1d2ViL2dwdXdlYi9pc3N1ZXMvNDQ1OCBpcyByZXNvbHZlZFxyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnVGFuaCcsIHRhbmhFeHByZXNzaW9uKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZmFzdEdlbHVJbXBsID0gKHZhclR5cGUgPSAnZjMyJykgPT4gYFxyXG5jb25zdCBmYXN0X2dlbHVfYTogJHt2YXJUeXBlfSA9IDAuNTtcclxuY29uc3QgZmFzdF9nZWx1X2I6ICR7dmFyVHlwZX0gPSAwLjc5Nzg4NDU2MDgwMjg2NTQ7XHJcbmNvbnN0IGZhc3RfZ2VsdV9jOiAke3ZhclR5cGV9ID0gMC4wMzU2Nzc0MDgxMzYzMDAxMjU7XHJcblxyXG5mbiB0YW5oX3YodjogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XHJcbiAgcmV0dXJuICR7dGFuaEV4cHJlc3Npb24oJ3YnKX07XHJcbn1cclxuYDtcclxuXHJcbmV4cG9ydCBjb25zdCBmYXN0R2VsdUV4cHJlc3Npb24gPSAoeDogc3RyaW5nKSA9PlxyXG4gIGAoZmFzdF9nZWx1X2EgKyBmYXN0X2dlbHVfYSAqIHRhbmhfdigke3h9ICogKGZhc3RfZ2VsdV9jICogJHt4fSAqICR7eH0gKyBmYXN0X2dlbHVfYikpKSAqICR7eH1gO1xyXG5cclxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcclxuICAgICAgJ0Zhc3RHZWx1JyxcclxuICAgICAgZmFzdEdlbHVFeHByZXNzaW9uLFxyXG4gICAgICBmYXN0R2VsdUltcGwoZGF0YVR5cGUpLFxyXG4gICAgICB1bmRlZmluZWQsXHJcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLFxyXG4gICAgKSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHRocmVzaG9sZGVkUmVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogbnVtYmVyID0+IHtcclxuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXHJcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxyXG4gICAgICAnVGhyZXNob2xkZWRSZWx1JyxcclxuICAgICAgKGEpID0+IGBzZWxlY3QodmVjNDwke2RhdGFUeXBlfT4oMC4wKSwgJHthfSwgJHthfSA+IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfKWAsXHJcbiAgICAgIGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtkYXRhVHlwZX0+KCR7YXR0cmlidXRlcy5hbHBoYX0pO2AsXHJcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXHJcbiAgICApLFxyXG4gICk7XHJcbiAgcmV0dXJuIDA7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbG9nID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdMb2cnLCAnbG9nJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHF1aWNrR2VsdUltcGwgPSAodmFyVHlwZTogc3RyaW5nLCBhbHBoYTogbnVtYmVyKSA9PiBgXHJcbmNvbnN0IGFscGhhID0gdmVjNDwke3ZhclR5cGV9Pigke2FscGhhfSk7XHJcbmNvbnN0IG9uZSA9ICR7dmFyVHlwZX0oMS4wKTtcclxuY29uc3QgemVybyA9ICR7dmFyVHlwZX0oMC4wKTtcclxuXHJcbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7dmFyVHlwZX0+KSAtPiB2ZWM0PCR7dmFyVHlwZX0+IHtcclxuICBsZXQgdiA9IHggKmFscGhhO1xyXG4gIHZhciB4MSA6IHZlYzQ8JHt2YXJUeXBlfT47XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcclxuICAgIGlmICh2W2ldID49IHplcm8pIHtcclxuICAgICAgeDFbaV0gPSBvbmUgLyAob25lICsgZXhwKC12W2ldKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4MVtpXSA9IG9uZSAtIG9uZSAvIChvbmUgKyBleHAodltpXSkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4geCAqIHgxO1xyXG59XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgcXVpY2tHZWx1RXhwcmVzc2lvbiA9ICh4OiBzdHJpbmcpID0+IGBxdWlja19nZWx1X2ltcGwoJHt4fSlgO1xyXG5cclxuZXhwb3J0IGNvbnN0IHF1aWNrZ2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgZFR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcclxuICAgICAgJ1F1aWNrR2VsdScsXHJcbiAgICAgIHF1aWNrR2VsdUV4cHJlc3Npb24sXHJcbiAgICAgIHF1aWNrR2VsdUltcGwoZFR5cGUsIGF0dHJpYnV0ZXMuYWxwaGEpLFxyXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICksXHJcbiAgKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xyXG5pbXBvcnQgeyBlcmZJbXBsIH0gZnJvbSAnLi91bmFyeS1vcCc7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoIVsyNTYwLCA1MTIwLCAxMDI0MF0uaW5jbHVkZXMoaW5wdXRzWzBdLmRpbXNbMl0pKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRpbXNbMl0gIT09IGlucHV0c1sxXS5kaW1zWzBdKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWUnKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVCaWFzU3BsaXRHZWx1UHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xyXG4gIG91dHB1dFNoYXBlWzJdID0gb3V0cHV0U2hhcGVbMl0gLyAyO1xyXG5cclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcywgNCk7XHJcbiAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIFtpbnB1dHNbMF0uZGltc1syXV0sIDQpO1xyXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCA0KTtcclxuXHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQ7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgY29uc3QgTV9TUVJUMiA9IHNxcnQoMi4wKTtcclxuICBjb25zdCBoYWxmQ2hhbm5lbHMgPSAke2lucHV0c1swXS5kaW1zWzJdIC8gNCAvIDJ9dTtcclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgYmlhcywgb3V0cHV0KX1cclxuXHJcbiAgJHtlcmZJbXBsKGRhdGFUeXBlKX1cclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG91dHB1dFNpemUpfVxyXG4gICAgbGV0IGJpYXNJZHggPSBnbG9iYWxfaWR4ICUgaGFsZkNoYW5uZWxzO1xyXG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xyXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmlhc0lkeCArIGJhdGNoSW5kZXggKiBoYWxmQ2hhbm5lbHMgKiAyO1xyXG4gICAgbGV0IHZhbHVlTGVmdCA9IGlucHV0W2lucHV0T2Zmc2V0XSArIGJpYXNbYmlhc0lkeF07XHJcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XHJcbiAgICBsZXQgZ2VsdVJpZ2h0ID0gdmFsdWVSaWdodCAqIDAuNSAqIChlcmZfdmYzMih2YWx1ZVJpZ2h0IC8gTV9TUVJUMikgKyAxKTtcclxuXHJcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZUxlZnQgKiBnZWx1UmlnaHQnKX1cclxuICB9YDtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdCaWFzU3BsaXRHZWx1JyxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGJpYXNTcGxpdEdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJpYXNTcGxpdEdlbHVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG50eXBlIEJ1aWx0aW5GdW5jdGlvbk5hbWUgPSBzdHJpbmc7XHJcbnR5cGUgQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbiA9IChleHByZXNzaW9uQTogc3RyaW5nLCBleHByZXNzaW9uQjogc3RyaW5nKSA9PiBzdHJpbmc7XHJcbnR5cGUgQmluYXJ5RnVuY3Rpb25DYWxsID1cclxuICB8IEJ1aWx0aW5GdW5jdGlvbk5hbWVcclxuICB8IEJpbmFyeUN1c3RvbUV4cHJlc3Npb25cclxuICB8IHtcclxuICAgICAgc2NhbGFyOiBCaW5hcnlDdXN0b21FeHByZXNzaW9uO1xyXG4gICAgICB2ZWN0b3I6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XHJcbiAgICB9O1xyXG5cclxuY29uc3QgY3JlYXRlQmluYXJ5T3BQcm9ncmFtU2hhZGVyID0gKFxyXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxyXG4gIGRpbXNBOiByZWFkb25seSBudW1iZXJbXSxcclxuICBkaW1zQjogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgZGltc091dHB1dDogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgdmVjdG9yaXplOiBib29sZWFuLFxyXG4gIGRvQnJvYWRjYXN0OiBib29sZWFuLFxyXG4gIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NDogYm9vbGVhbixcclxuICBmdW5jQ2FsbDogQmluYXJ5RnVuY3Rpb25DYWxsLFxyXG4gIHR5cGVBOiBudW1iZXIsXHJcbiAgdHlwZUI6IG51bWJlcixcclxuICB0eXBlT3V0cHV0OiBudW1iZXIsXHJcbiAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxyXG4pID0+IHtcclxuICBsZXQgZXhwcmVzc2lvblNjYWxhcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcclxuICBsZXQgZXhwcmVzc2lvblZlY3RvcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcclxuICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xyXG4gICAgZXhwcmVzc2lvblNjYWxhciA9IGV4cHJlc3Npb25WZWN0b3IgPSAoYSwgYikgPT4gYCR7ZnVuY0NhbGx9KCgke2F9KSwoJHtifSkpYDtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jQ2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgZXhwcmVzc2lvblNjYWxhciA9IGV4cHJlc3Npb25WZWN0b3IgPSBmdW5jQ2FsbDtcclxuICB9IGVsc2Uge1xyXG4gICAgZXhwcmVzc2lvblNjYWxhciA9IGZ1bmNDYWxsLnNjYWxhcjtcclxuICAgIGV4cHJlc3Npb25WZWN0b3IgPSBmdW5jQ2FsbC52ZWN0b3I7XHJcbiAgfVxyXG5cclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0RGF0YScsIHR5cGVPdXRwdXQsIGRpbXNPdXRwdXQubGVuZ3RoLCA0KTtcclxuICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYURhdGEnLCB0eXBlQSwgZGltc0EubGVuZ3RoLCA0KTtcclxuICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYkRhdGEnLCB0eXBlQiwgZGltc0IubGVuZ3RoLCA0KTtcclxuXHJcbiAgbGV0IGFzc2lnbm1lbnQ6IHN0cmluZztcclxuICBpZiAodmVjdG9yaXplKSB7XHJcbiAgICBpZiAoZG9Ccm9hZGNhc3QpIHtcclxuICAgICAgY29uc3QgaXNBT25lRWxlbWVudCA9IFNoYXBlVXRpbC5zaXplKGRpbXNBKSA9PT0gMTtcclxuICAgICAgY29uc3QgaXNCT25lRWxlbWVudCA9IFNoYXBlVXRpbC5zaXplKGRpbXNCKSA9PT0gMTtcclxuICAgICAgY29uc3QgYUxhc3REaW1EaXZpc2libGVCeTQgPSBkaW1zQS5sZW5ndGggPiAwICYmIGRpbXNBW2RpbXNBLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcclxuICAgICAgY29uc3QgYkxhc3REaW1EaXZpc2libGVCeTQgPSBkaW1zQi5sZW5ndGggPiAwICYmIGRpbXNCW2RpbXNCLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcclxuICAgICAgaWYgKGlzQU9uZUVsZW1lbnQgfHwgaXNCT25lRWxlbWVudCkge1xyXG4gICAgICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXHJcbiAgICAgICAgICAnZ2xvYmFsX2lkeCcsXHJcbiAgICAgICAgICBleHByZXNzaW9uVmVjdG9yKFxyXG4gICAgICAgICAgICBpc0FPbmVFbGVtZW50ID8gYCR7YS50eXBlLnZhbHVlfSgke2EuZ2V0QnlPZmZzZXQoJzAnKX0ueClgIDogYS5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLFxyXG4gICAgICAgICAgICBpc0JPbmVFbGVtZW50ID8gYCR7Yi50eXBlLnZhbHVlfSgke2IuZ2V0QnlPZmZzZXQoJzAnKX0ueClgIDogYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFzc2lnbm1lbnQgPSBgXHJcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4ICogNHUnKX07XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXRBID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJywgb3V0cHV0KX07XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXRCID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJywgb3V0cHV0KX07XHJcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KFxyXG4gICAgICAgICAgICAgICdnbG9iYWxfaWR4JyxcclxuICAgICAgICAgICAgICBleHByZXNzaW9uVmVjdG9yKFxyXG4gICAgICAgICAgICAgICAgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0IHx8IGFMYXN0RGltRGl2aXNpYmxlQnk0XHJcbiAgICAgICAgICAgICAgICAgID8gYS5nZXRCeU9mZnNldCgnb2Zmc2V0QSAvIDR1JylcclxuICAgICAgICAgICAgICAgICAgOiBgJHthLnR5cGUudmFsdWV9KCR7YS5nZXRCeU9mZnNldCgnb2Zmc2V0QSAvIDR1Jyl9W29mZnNldEEgJSA0dV0pYCxcclxuICAgICAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCB8fCBiTGFzdERpbURpdmlzaWJsZUJ5NFxyXG4gICAgICAgICAgICAgICAgICA/IGIuZ2V0QnlPZmZzZXQoJ29mZnNldEIgLyA0dScpXHJcbiAgICAgICAgICAgICAgICAgIDogYCR7Yi50eXBlLnZhbHVlfSgke2IuZ2V0QnlPZmZzZXQoJ29mZnNldEIgLyA0dScpfVtvZmZzZXRCICUgNHVdKWAsXHJcbiAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgKX1cclxuICAgICAgICAgIGA7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXHJcbiAgICAgICAgJ2dsb2JhbF9pZHgnLFxyXG4gICAgICAgIGV4cHJlc3Npb25WZWN0b3IoYS5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLCBiLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JykpLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWRvQnJvYWRjYXN0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiB7XHJcbiAgICAgIGNvbnN0IGV4cHJlc3Npb25BID0gYGFEYXRhW2luZGV4QSR7eH1dW2NvbXBvbmVudEEke3h9XWA7XHJcbiAgICAgIGNvbnN0IGV4cHJlc3Npb25CID0gYGJEYXRhW2luZGV4QiR7eH1dW2NvbXBvbmVudEIke3h9XWA7XHJcbiAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt4fSA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHt4fXVgKX07XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHt4fSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldEIke3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xyXG4gICAgICAgICAgICBsZXQgaW5kZXhBJHt4fSA9IG9mZnNldEEke3h9IC8gNHU7XHJcbiAgICAgICAgICAgIGxldCBpbmRleEIke3h9ID0gb2Zmc2V0QiR7eH0gLyA0dTtcclxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke3h9ID0gb2Zmc2V0QSR7eH0gJSA0dTtcclxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke3h9ID0gb2Zmc2V0QiR7eH0gJSA0dTtcclxuICAgICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtleHByZXNzaW9uU2NhbGFyKGV4cHJlc3Npb25BLCBleHByZXNzaW9uQil9KTtcclxuICAgICAgICAgIGA7XHJcbiAgICB9O1xyXG4gICAgaWYgKHR5cGVPdXRwdXQgPT09IERhdGFUeXBlLmJvb2wpIHtcclxuICAgICAgYXNzaWdubWVudCA9IGBcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDAsICd1MzInKX1cclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAyLCAndTMyJyl9XHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDMsICd1MzInKX1cclxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXNzaWdubWVudCA9IGBcclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMCl9XHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDEpfVxyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAyKX1cclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMyl9XHJcbiAgICAgICAgICBgO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGBcclxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoYSwgYiwgb3V0cHV0KX1cclxuXHJcbiAgICAgICAgJHthZGRpdGlvbmFsSW1wbGVtZW50YXRpb24gPz8gJyd9XHJcblxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnZlY19zaXplJyl9XHJcbiAgICAgICAgJHthc3NpZ25tZW50fVxyXG4gICAgICB9YDtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbUluZm8gPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIGNhY2hlS2V5OiBzdHJpbmcsXHJcbiAgYTogVGVuc29yVmlldyxcclxuICBiOiBUZW5zb3JWaWV3LFxyXG4gIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXHJcbiAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxyXG4gIG91dHB1dERhdGFUeXBlOiBudW1iZXIgPSBhLmRhdGFUeXBlLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgYURpbXMgPSBhLmRpbXMubWFwKCh4KSA9PiBOdW1iZXIoeCkgPz8gMSk7XHJcbiAgY29uc3QgYkRpbXMgPSBiLmRpbXMubWFwKCh4KSA9PiBOdW1iZXIoeCkgPz8gMSk7XHJcbiAgY29uc3QgaXNCcm9hZGNhc3QgPSAhU2hhcGVVdGlsLmFyZUVxdWFsKGFEaW1zLCBiRGltcyk7XHJcbiAgbGV0IG91dHB1dFNoYXBlID0gYURpbXM7XHJcbiAgbGV0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhRGltcyk7XHJcblxyXG4gIGxldCB2ZWN0b3JpemUgPSBmYWxzZTtcclxuICBsZXQgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0ID0gZmFsc2U7XHJcblxyXG4gIC8vIFRPRE86IGRlYWwgd2l0aCB6ZXJvLXNpemVkIHRlbnNvcnMgKGVnLiBkaW1zPVsxLDBdKVxyXG4gIGNvbnN0IGNhY2hlS2V5QXV4ID0gW2lzQnJvYWRjYXN0XTtcclxuICBpZiAoaXNCcm9hZGNhc3QpIHtcclxuICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGFEaW1zLCBiRGltcywgZmFsc2UpO1xyXG4gICAgaWYgKCFjYWxjdWxhdGVkU2hhcGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XHJcbiAgICB9XHJcbiAgICBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZWRTaGFwZS5zbGljZSgpO1xyXG4gICAgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICAgIGNvbnN0IGlzQU9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShhRGltcykgPT09IDE7XHJcbiAgICBjb25zdCBpc0JPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoYkRpbXMpID09PSAxO1xyXG4gICAgY29uc3QgYUxhc3REaW1EaXZpc2libGVCeTQgPSBhRGltcy5sZW5ndGggPiAwICYmIGFEaW1zW2FEaW1zLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcclxuICAgIGNvbnN0IGJMYXN0RGltRGl2aXNpYmxlQnk0ID0gYkRpbXMubGVuZ3RoID4gMCAmJiBiRGltc1tiRGltcy5sZW5ndGggLSAxXSAlIDQgPT09IDA7XHJcbiAgICBjYWNoZUtleUF1eC5wdXNoKGlzQU9uZUVsZW1lbnQpO1xyXG4gICAgY2FjaGVLZXlBdXgucHVzaChpc0JPbmVFbGVtZW50KTtcclxuICAgIGNhY2hlS2V5QXV4LnB1c2goYUxhc3REaW1EaXZpc2libGVCeTQpO1xyXG4gICAgY2FjaGVLZXlBdXgucHVzaChiTGFzdERpbURpdmlzaWJsZUJ5NCk7XHJcbiAgICAvLyBjaGVjayB3aGV0aGVyIHZlY3Rvcml6ZSBjYW4gYmUgZW5hYmxlZFxyXG4gICAgbGV0IHNoYXJlZERpbWVuc2lvbiA9IDE7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGRpbUEgPSBhRGltc1thRGltcy5sZW5ndGggLSBpXTtcclxuICAgICAgY29uc3QgZGltQiA9IGJEaW1zW2JEaW1zLmxlbmd0aCAtIGldO1xyXG4gICAgICBpZiAoZGltQSA9PT0gZGltQikge1xyXG4gICAgICAgIHNoYXJlZERpbWVuc2lvbiAqPSBkaW1BO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2hhcmVkRGltZW5zaW9uICUgNCA9PT0gMCkge1xyXG4gICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgPSB0cnVlO1xyXG4gICAgICB2ZWN0b3JpemUgPSB0cnVlO1xyXG4gICAgfSBlbHNlIGlmIChpc0FPbmVFbGVtZW50IHx8IGlzQk9uZUVsZW1lbnQgfHwgYUxhc3REaW1EaXZpc2libGVCeTQgfHwgYkxhc3REaW1EaXZpc2libGVCeTQpIHtcclxuICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gZWxlbWVudC13aXNlXHJcbiAgICB2ZWN0b3JpemUgPSB0cnVlO1xyXG4gIH1cclxuICBjYWNoZUtleUF1eC5wdXNoKHZlY3Rvcml6ZSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogY2FjaGVLZXkgKyBjYWNoZUtleUF1eC5tYXAoKHgpID0+IHgudG9TdHJpbmcoKSkuam9pbignXycpLFxyXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnXSxcclxuICAgIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XHJcbiAgICAgIGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbVNoYWRlcihcclxuICAgICAgICBzaGFkZXJIZWxwZXIsXHJcbiAgICAgICAgYURpbXMsXHJcbiAgICAgICAgYkRpbXMsXHJcbiAgICAgICAgb3V0cHV0U2hhcGUsXHJcbiAgICAgICAgdmVjdG9yaXplLFxyXG4gICAgICAgIGlzQnJvYWRjYXN0LFxyXG4gICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCxcclxuICAgICAgICBmdW5jQ2FsbCxcclxuICAgICAgICBhLmRhdGFUeXBlLFxyXG4gICAgICAgIGIuZGF0YVR5cGUsXHJcbiAgICAgICAgb3V0cHV0RGF0YVR5cGUsXHJcbiAgICAgICAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxyXG4gICAgICApLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovIC8gNCAvKiBjb21wb25lbnQgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA0KSB9LFxyXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGFEaW1zLCBiRGltcywgb3V0cHV0U2hhcGUpLFxyXG4gICAgICBdLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IHJ1bkJpbmFyeU9wID0gKFxyXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICBmdW5jQ2FsbDogQmluYXJ5RnVuY3Rpb25DYWxsLFxyXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcclxuICBjYWNoZUtleT86IHN0cmluZyxcclxuICBvdXRwdXREYXRhVHlwZT86IG51bWJlcixcclxuKTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlQmluYXJ5T3BQcm9ncmFtSW5mbyhcclxuICAgICAgbmFtZSxcclxuICAgICAgY2FjaGVLZXkgPz8gJycsXHJcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxyXG4gICAgICBjb250ZXh0LmlucHV0c1sxXSxcclxuICAgICAgZnVuY0NhbGwsXHJcbiAgICAgIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbixcclxuICAgICAgb3V0cHV0RGF0YVR5cGUsXHJcbiAgICApLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYWRkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ0FkZCcsIChhLCBiKSA9PiBgJHthfSske2J9YCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGl2ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ0RpdicsIChhLCBiKSA9PiBgJHthfS8ke2J9YCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBydW5CaW5hcnlPcChcclxuICAgIGNvbnRleHQsXHJcbiAgICAnRXF1YWwnLFxyXG4gICAgeyBzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX09PSR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9PT0ke2J9KWAgfSxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIERhdGFUeXBlLmJvb2wsXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBtdWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBydW5CaW5hcnlPcChjb250ZXh0LCAnTXVsJywgKGEsIGIpID0+IGAke2F9KiR7Yn1gKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwb3cgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb25zdCB0eXBlID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgY29udGV4dC5pbnB1dHNbMF0uZGltcykudHlwZS52YWx1ZTtcclxuICBjb25zdCByb3VuZFN0ciA9IHR5cGUgPT09ICdpMzInID8gJ3JvdW5kJyA6ICcnO1xyXG4gIHJ1bkJpbmFyeU9wKFxyXG4gICAgY29udGV4dCxcclxuICAgICdQb3cnLFxyXG4gICAgeyBzY2FsYXI6IChhLCBiKSA9PiBgcG93X2N1c3RvbSgke2F9LCR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHBvd192ZWN0b3JfY3VzdG9tKCR7YX0sJHtifSlgIH0sXHJcbiAgICBgXHJcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R5cGV9LCBiIDogJHt0eXBlfSkgLT4gJHt0eXBlfSB7XHJcbiAgICAgIGlmIChiID09ICR7dHlwZX0oMC4wKSkge1xyXG4gICAgICAgIHJldHVybiAke3R5cGV9KDEuMCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dHlwZX0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xyXG4gICAgICAgIHJldHVybiAke3R5cGV9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dHlwZX0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dHlwZX0oMi4wKSkpICE9IDEuMCkgKiAke3R5cGV9KCR7cm91bmRTdHJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xyXG4gICAgfVxyXG4gICAgZm4gcG93X3ZlY3Rvcl9jdXN0b20oYSA6IHZlYzQ8JHt0eXBlfT4sIGIgOiB2ZWM0PCR7dHlwZX0+KSAtPiB2ZWM0PCR7dHlwZX0+IHtcclxuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XHJcbiAgICAgIHJldHVybiB2ZWM0PCR7dHlwZX0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcclxuICAgIH1cclxuICAgICAgYCxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHN1YiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIHJ1bkJpbmFyeU9wKGNvbnRleHQsICdTdWInLCAoYSwgYikgPT4gYCR7YX0tJHtifWApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdyZWF0ZXIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBydW5CaW5hcnlPcChcclxuICAgIGNvbnRleHQsXHJcbiAgICAnR3JlYXRlcicsXHJcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT4ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT4ke2J9KWAgfSxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIERhdGFUeXBlLmJvb2wsXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsZXNzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgcnVuQmluYXJ5T3AoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgJ0xlc3MnLFxyXG4gICAgeyBzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX08JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX08JHtifSlgIH0sXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICBEYXRhVHlwZS5ib29sLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ3JlYXRlck9yRXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBydW5CaW5hcnlPcChcclxuICAgIGNvbnRleHQsXHJcbiAgICAnR3JlYXRlck9yRXF1YWwnLFxyXG4gICAgeyBzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX0+PSR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9Pj0ke2J9KWAgfSxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIERhdGFUeXBlLmJvb2wsXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsZXNzT3JFcXVhbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIHJ1bkJpbmFyeU9wKFxyXG4gICAgY29udGV4dCxcclxuICAgICdMZXNzT3JFcXVhbCcsXHJcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfTw9JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX08PSR7Yn0pYCB9LFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgRGF0YVR5cGUuYm9vbCxcclxuICApO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb25jYXRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBheGlzOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBheGlzOiBudW1iZXIpOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b28gZmV3IGlucHV0cycpO1xyXG4gIH1cclxuICBjb25zdCByZWZlcmVuY2VJbmRleCA9IDA7XHJcbiAgY29uc3QgcmVmZXJlbmNlSW5wdXQgPSBpbnB1dHNbcmVmZXJlbmNlSW5kZXhdO1xyXG4gIGNvbnN0IGlucHV0VHlwZSA9IHJlZmVyZW5jZUlucHV0LmRhdGFUeXBlO1xyXG4gIGNvbnN0IGlucHV0UmFuayA9IHJlZmVyZW5jZUlucHV0LmRpbXMubGVuZ3RoO1xyXG4gIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xyXG4gICAgaWYgKGkgPT09IHJlZmVyZW5jZUluZGV4KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIG1ha2Ugc3VyZSB0eXBlcyBvZiBhbGwgaW5wdXRzIG1hdGNoXHJcbiAgICBpZiAoaW5wdXQuZGF0YVR5cGUgIT09IGlucHV0VHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGJlIG9uZSB0eXBlJyk7XHJcbiAgICB9XHJcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIGFsbCBpbnB1dHMgYXJlIHRoZSBzYW1lXHJcbiAgICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IGlucHV0UmFuaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcclxuICAgIH1cclxuICAgIGlucHV0LmRpbXMuZm9yRWFjaCgoZGltLCBpKSA9PiB7XHJcbiAgICAgIGlmIChpICE9PSBheGlzICYmIGRpbSAhPT0gcmVmZXJlbmNlSW5wdXQuZGltc1tpXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5jb25zdCBjYWxjdWxhdGVJbnB1dEluZGV4SW1wbCA9IChudW1iZXJPZlRlbnNvcnM6IG51bWJlciwgc2l6ZUluQ29uY2F0QXhpc1N0cjogc3RyaW5nKTogc3RyaW5nID0+IGBcclxuICBmbiBjYWxjdWxhdGVJbnB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XHJcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtudW1iZXJPZlRlbnNvcnN9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XHJcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7bnVtYmVyT2ZUZW5zb3JzfTsgaSArPSAxdSApIHtcclxuICAgICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJHtudW1iZXJPZlRlbnNvcnN9dTtcclxuICB9YDtcclxuXHJcbmNvbnN0IGFzc2lnbk91dHB1dERhdGEgPSAoaW5wdXRzOiByZWFkb25seSBJbmRpY2VzSGVscGVyW10sIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xyXG4gIGNvbnN0IG51bWJlck9mVGVuc29ycyA9IGlucHV0cy5sZW5ndGg7XHJcblxyXG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVGVuc29yczsgKytpKSB7XHJcbiAgICBjb25zdCByZXR1cm5TbmlwcGV0ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXRzW2ldLmdldEJ5SW5kaWNlcygnaW5kaWNlcycpKTtcclxuICAgIGlmIChudW1iZXJPZlRlbnNvcnMgPT09IDEpIHtcclxuICAgICAgY29kZUxpbmVzLnB1c2gocmV0dXJuU25pcHBldCk7XHJcbiAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcclxuICAgICAgY29kZUxpbmVzLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7aX11KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xyXG4gICAgfSBlbHNlIGlmIChpID09PSBudW1iZXJPZlRlbnNvcnMgLSAxKSB7XHJcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2RlTGluZXMucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke2l9KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY29kZUxpbmVzLmpvaW4oJ1xcbicpO1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlQ29uY2F0UHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYWRqdXN0ZWRBeGlzOiBudW1iZXIsXHJcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxyXG4gIGRhdGFUeXBlOiBEYXRhVHlwZSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcblxyXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcclxuICBjb25zdCBpbnB1dFZhcnMgPSBuZXcgQXJyYXk8SW5kaWNlc0hlbHBlcj4oaW5wdXRzLmxlbmd0aCk7XHJcblxyXG4gIGxldCBwcmV2aW91c1N1bSA9IDA7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbXTtcclxuICBjb25zdCBpbnB1dFJhbmtzID0gW107XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH1dO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBwcmV2aW91c1N1bSArPSBpbnB1dHNbaV0uZGltc1thZGp1c3RlZEF4aXNdO1xyXG4gICAgc2l6ZUluQ29uY2F0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xyXG4gICAgaW5wdXRSYW5rcy5wdXNoKGlucHV0c1tpXS5kaW1zLmxlbmd0aCk7XHJcbiAgICBpbnB1dFZhcnNbaV0gPSBpbnB1dFZhcmlhYmxlKGBpbnB1dCR7aX1gLCBkYXRhVHlwZSwgaW5wdXRSYW5rc1tpXSk7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCh7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2l6ZUluQ29uY2F0QXhpc1tpXSB9KTtcclxuICB9XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1tpXS5kaW1zKSk7XHJcbiAgfVxyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XHJcblxyXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCBpbmRpY2VzQXhpcyA9IG91dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgYWRqdXN0ZWRBeGlzKTtcclxuICBjb25zdCBzaXplSW5Db25jYXRBeGlzU3RyID0gQXJyYXkuZnJvbShBcnJheShzaXplSW5Db25jYXRBeGlzLmxlbmd0aCkua2V5cygpKVxyXG4gICAgLm1hcCgoaSkgPT4gYHVuaWZvcm1zLnNpemVJbkNvbmNhdEF4aXMke2l9YClcclxuICAgIC5qb2luKCcsJyk7XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcblxyXG4gICR7KCgpID0+IHtcclxuICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHtpfWAsICd1MzInKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCk7XHJcbiAgfSkoKX1cclxuXHJcbiAgJHtjYWxjdWxhdGVJbnB1dEluZGV4SW1wbChzaXplSW5Db25jYXRBeGlzLmxlbmd0aCwgc2l6ZUluQ29uY2F0QXhpc1N0cil9XHJcblxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxyXG5cclxuICAgIHZhciBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG5cclxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke2luZGljZXNBeGlzfSk7XHJcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xyXG4gICAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtzaXplSW5Db25jYXRBeGlzLmxlbmd0aH11Pigke3NpemVJbkNvbmNhdEF4aXNTdHJ9KTtcclxuICAgICAgJHtpbmRpY2VzQXhpc30gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xyXG4gICAgfVxyXG5cclxuICAgICR7YXNzaWduT3V0cHV0RGF0YShpbnB1dFZhcnMsIG91dHB1dCl9XHJcbiAgfWA7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnQ29uY2F0JyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2FkanVzdGVkQXhpc31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29uY2F0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb25jYXRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGFkanVzdGVkQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xyXG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgYWRqdXN0ZWRBeGlzKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcclxuICBvdXRwdXRTaGFwZVthZGp1c3RlZEF4aXNdID0gaW5wdXRzLnJlZHVjZShcclxuICAgIChzdW0sIGlucHV0KSA9PiBzdW0gKyAoaW5wdXQuZGltcy5sZW5ndGggPiBhZGp1c3RlZEF4aXMgPyBpbnB1dC5kaW1zW2FkanVzdGVkQXhpc10gOiAwKSxcclxuICAgIDAsXHJcbiAgKTtcclxuICAvLyAwIGxlbmd0aCB0ZW5zb3JzIGFyZSB2YWxpZCBmb3IgY29uY2F0LCByZW1vdmUgdGhlbVxyXG4gIGNvbnN0IG5vbkVtcHR5SW5wdXRzID0gaW5wdXRzLmZpbHRlcigoaW5wdXQpID0+IFNoYXBlVXRpbC5zaXplKGlucHV0LmRpbXMpID4gMCk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvKG5vbkVtcHR5SW5wdXRzLCBhZGp1c3RlZEF4aXMsIG91dHB1dFNoYXBlLCBpbnB1dHNbMF0uZGF0YVR5cGUpLCB7XHJcbiAgICBpbnB1dHM6IG5vbkVtcHR5SW5wdXRzLFxyXG4gIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQ29uY2F0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IENvbmNhdEF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBNQVhfQ0xJUCwgTUlOX0NMSVAgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBVbmlmb3Jtc0FycmF5VHlwZSB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyB7XHJcbiAgcmVhZG9ubHkgYWN0aXZhdGlvbjogc3RyaW5nO1xyXG4gIHJlYWRvbmx5IGNsaXBNaW4/OiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgY2xpcE1heD86IG51bWJlcjtcclxuICByZWFkb25seSBhbHBoYT86IG51bWJlcjtcclxuICByZWFkb25seSBiZXRhPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZhdGlvblNuaXBwZXQgPSAoXHJcbiAgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcclxuICB2YWx1ZVR5cGU6IHN0cmluZyxcclxuICBiYXNlVHlwZSA9ICdmMzInLFxyXG4pOiBzdHJpbmcgPT4ge1xyXG4gIHN3aXRjaCAoYXR0cmlidXRlcy5hY3RpdmF0aW9uKSB7XHJcbiAgICBjYXNlICdSZWx1JzpcclxuICAgICAgcmV0dXJuIGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHt2YWx1ZVR5cGV9KDAuMCkpO2A7XHJcbiAgICBjYXNlICdTaWdtb2lkJzpcclxuICAgICAgcmV0dXJuIGB2YWx1ZSA9ICgke3ZhbHVlVHlwZX0oMS4wKSAvICgke3ZhbHVlVHlwZX0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtcclxuICAgIGNhc2UgJ0NsaXAnOlxyXG4gICAgICByZXR1cm4gYHZhbHVlID0gY2xhbXAodmFsdWUsICR7dmFsdWVUeXBlfSgke2Jhc2VUeXBlfSh1bmlmb3Jtcy5jbGlwX21pbikpLCAke3ZhbHVlVHlwZX0oJHtcclxuICAgICAgICBiYXNlVHlwZVxyXG4gICAgICB9KHVuaWZvcm1zLmNsaXBfbWF4KSkpO2A7XHJcbiAgICBjYXNlICdIYXJkU2lnbW9pZCc6XHJcbiAgICAgIHJldHVybiBgdmFsdWUgPSBtYXgoJHt2YWx1ZVR5cGV9KDAuMCksIG1pbigke3ZhbHVlVHlwZX0oMS4wKSwgJHtiYXNlVHlwZX0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUgKyAke1xyXG4gICAgICAgIGJhc2VUeXBlXHJcbiAgICAgIH0odW5pZm9ybXMuYmV0YSkpKTtgO1xyXG4gICAgY2FzZSAnTGVha3lSZWx1JzpcclxuICAgICAgcmV0dXJuIGB2YWx1ZSA9IHNlbGVjdCgke2Jhc2VUeXBlfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSwgdmFsdWUsIHZhbHVlID49ICR7dmFsdWVUeXBlfSgwLjApKTtgO1xyXG4gICAgY2FzZSAnVGFuaCc6XHJcbiAgICAgIHJldHVybiBgbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSBzaWduKHZhbHVlKSAqICgxLjAgLSBlMngpIC8gKDEuMCArIGUyeCk7XHJcbiAgICAgICAgYDtcclxuICAgIGNhc2UgJyc6XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIC8vIFRPRE86IGFkZGluZyBvdGhlciBhY3RpdmF0aW9ucyB0aGF0IGNhbiBiZSBmdXNlZC5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWN0aXZhdGlvbiAke2F0dHJpYnV0ZXMuYWN0aXZhdGlvbn1gKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSA9IChcclxuICBhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxyXG4gIHByb2dyYW1Vbmlmb3JtOiBQcm9ncmFtVW5pZm9ybVtdLFxyXG4pID0+IHtcclxuICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcclxuICAgIHByb2dyYW1Vbmlmb3JtLnB1c2goXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuY2xpcE1heCEgfSxcclxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWluISB9LFxyXG4gICAgKTtcclxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0hhcmRTaWdtb2lkJykge1xyXG4gICAgcHJvZ3JhbVVuaWZvcm0ucHVzaChcclxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYSEgfSxcclxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5iZXRhISB9LFxyXG4gICAgKTtcclxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0xlYWt5UmVsdScpIHtcclxuICAgIHByb2dyYW1Vbmlmb3JtLnB1c2goeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYSEgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyA9IChhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUpID0+IHtcclxuICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcclxuICAgIHVuaWZvcm1zLnB1c2goeyBuYW1lOiAnY2xpcF9tYXgnLCB0eXBlOiAnZjMyJyB9LCB7IG5hbWU6ICdjbGlwX21pbicsIHR5cGU6ICdmMzInIH0pO1xyXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnSGFyZFNpZ21vaWQnKSB7XHJcbiAgICB1bmlmb3Jtcy5wdXNoKHsgbmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMicgfSwgeyBuYW1lOiAnYmV0YScsIHR5cGU6ICdmMzInIH0pO1xyXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnTGVha3lSZWx1Jykge1xyXG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSAoXHJcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQsXHJcbik6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IGFjdGl2YXRpb24gPSAoYXR0cmlidXRlcz8uYWN0aXZhdGlvbiBhcyBzdHJpbmcpIHx8ICcnO1xyXG4gIGlmIChhY3RpdmF0aW9uID09PSAnSGFyZFNpZ21vaWQnKSB7XHJcbiAgICBjb25zdCBbYWxwaGEsIGJldGFdID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb25fcGFyYW1zIGFzIFtudW1iZXIsIG51bWJlcl0pIHx8IFswLjIsIDAuNV07XHJcbiAgICByZXR1cm4geyBhY3RpdmF0aW9uLCBhbHBoYSwgYmV0YSB9O1xyXG4gIH0gZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XHJcbiAgICBjb25zdCBbY2xpcE1pbiwgY2xpcE1heF0gPSAoYXR0cmlidXRlcz8uYWN0aXZhdGlvbl9wYXJhbXMgYXMgW251bWJlciwgbnVtYmVyXSkgfHwgW01JTl9DTElQLCBNQVhfQ0xJUF07XHJcbiAgICByZXR1cm4geyBhY3RpdmF0aW9uLCBjbGlwTWF4LCBjbGlwTWluIH07XHJcbiAgfSBlbHNlIGlmIChhY3RpdmF0aW9uID09PSAnTGVha3lSZWx1Jykge1xyXG4gICAgY29uc3QgW2FscGhhXSA9IChhdHRyaWJ1dGVzPy5hY3RpdmF0aW9uX3BhcmFtcyBhcyBbbnVtYmVyXSkgfHwgWzAuMDFdO1xyXG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgYWxwaGEgfTtcclxuICB9XHJcbiAgcmV0dXJuIHsgYWN0aXZhdGlvbiB9O1xyXG59O1xyXG4iLCAiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqL1xyXG5cclxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9hY3RpdmF0aW9uX3V0aWwudHNcclxuLy9cclxuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxyXG5cclxuZXhwb3J0IGNvbnN0IHR5cGVTbmlwcGV0ID0gKGNvbXBvbmVudDogbnVtYmVyLCBkYXRhVHlwZTogc3RyaW5nKSA9PiB7XHJcbiAgc3dpdGNoIChjb21wb25lbnQpIHtcclxuICAgIGNhc2UgMTpcclxuICAgICAgcmV0dXJuIGRhdGFUeXBlO1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICByZXR1cm4gYHZlYzI8JHtkYXRhVHlwZX0+YDtcclxuICAgIGNhc2UgMzpcclxuICAgICAgcmV0dXJuIGB2ZWMzPCR7ZGF0YVR5cGV9PmA7XHJcbiAgICBjYXNlIDQ6XHJcbiAgICAgIHJldHVybiBgdmVjNDwke2RhdGFUeXBlfT5gO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbXBvbmVudH0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGJpYXNTbmlwcGV0ID0gKGhhc0JpYXM6IGJvb2xlYW4pOiBzdHJpbmcgPT4gYFxyXG4gICAgICAke2hhc0JpYXMgPyAndmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpOycgOiAnJ31cclxuICAgICAgYDtcclxuIiwgIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKi9cclxuXHJcbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1jb3JlL3NyYy9vcHMvY29udl91dGlsLnRzXHJcbi8vXHJcbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcclxuXHJcbmV4cG9ydCBjb25zdCB1dGlsRnVuY3Rpb25zID0gKHN0cmlkZVN0cjogc3RyaW5nKSA9PiBgXHJcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XHJcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcclxuICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xyXG59XHJcbmZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XHJcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcclxuICAgIGkzMigke3N0cmlkZVN0cn0ueCksIGkzMigke3N0cmlkZVN0cn0ueSksIGkzMigke3N0cmlkZVN0cn0ueiksIDEpKTtcclxufVxyXG5gO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBnZXRFbGVtZW50QXQsXHJcbiAgZ2V0TWF4Q29tcG9uZW50cyxcclxuICBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgaW50ZXJuYWxWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuaW1wb3J0IHtcclxuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsXHJcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSxcclxuICBnZXRBY3RpdmF0aW9uU25pcHBldCxcclxuICBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxyXG59IGZyb20gJy4vZnVzZS11dGlscyc7XHJcblxyXG4vLyBIZWxwZXIgdGhhdCBjb252ZXJ0IG91dHB1dCBiYXRjaCBpbmRpY2VzIHRvIGlucHV0IGJhdGNoIGluZGljZXMgdXNpbmcgb25seSB0aGUgcmFuayBhbmRcclxuLy8gdGhlIHNoYXBlIGluZm9ybWF0aW9uIGluIHVuaWZvcm1cclxuZXhwb3J0IGNvbnN0IGNvbnZlcnRPdXRwdXRCYXRjaEluZGljZXNUb0lucHV0QmF0Y2hJbmRpY2VzID0gKFxyXG4gIHRhcmdldEluZGljZXNOYW1lOiBzdHJpbmcsXHJcbiAgaW5wdXRWYXJpYWJsZTogSW5kaWNlc0hlbHBlcixcclxuICBpbnB1dEJhdGNoUmFuazogbnVtYmVyLFxyXG4gIG91dHB1dEJhdGNoUmFuazogbnVtYmVyLFxyXG4gIGJhdGNoSW5kaWNlc05hbWU6IHN0cmluZyxcclxuKSA9PiB7XHJcbiAgLy8gQXNzdW1lIG91dHB1dEJhdGNoUmFuayA+PSBpbnB1dEJhdGNoUmFuaywgdGhlIGZpcnN0IG91dHB1dEJhdGNoUmFuayAtIGlucHV0QmF0Y2hSYW5rIG9mXHJcbiAgLy8gb3V0cHV0QmF0Y2hSYW5rIHNob3VsZCBiZSBpZ25vcmVkLlxyXG4gIGNvbnN0IGV4dGVuZGluZ0lucHV0UmFuayA9IG91dHB1dEJhdGNoUmFuayAtIGlucHV0QmF0Y2hSYW5rO1xyXG4gIHJldHVybiBgXHJcbiAgICAgICR7QXJyYXkuZnJvbSh7IGxlbmd0aDogaW5wdXRCYXRjaFJhbmsgfSlcclxuICAgICAgICAubWFwKFxyXG4gICAgICAgICAgKF8sIGkpID0+IGBcclxuICAgICAgaWYgKCR7Z2V0RWxlbWVudEF0KGlucHV0VmFyaWFibGUuc2hhcGUsIGksIGlucHV0VmFyaWFibGUucmFuayl9ICE9IDEpIHtcclxuICAgICAgICAke2lucHV0VmFyaWFibGUuaW5kaWNlc1NldCh0YXJnZXRJbmRpY2VzTmFtZSwgaSwgZ2V0RWxlbWVudEF0KGJhdGNoSW5kaWNlc05hbWUsIGkgKyBleHRlbmRpbmdJbnB1dFJhbmssIG91dHB1dEJhdGNoUmFuaykpfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICR7aW5wdXRWYXJpYWJsZS5pbmRpY2VzU2V0KHRhcmdldEluZGljZXNOYW1lLCBpLCAwKX1cclxuICAgICAgfWAsXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5qb2luKCcnKX1cclxuYDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxyXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICByZXNoYXBlZE91dHB1dFNoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSAvKiBvbmx5IHVzZWQgZm9yIGNvbnYyZEJ5TWF0TXVsKi8sXHJcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xyXG5cclxuICBjb25zdCBNID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAyXTtcclxuICBjb25zdCBOID0gYlNoYXBlW2JTaGFwZS5sZW5ndGggLSAxXTtcclxuICBjb25zdCBLID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcclxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhOKTtcclxuICBjb25zdCBhQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoSyk7XHJcbiAgY29uc3Qgb3V0cHV0TnVtYmVyID0gZ2V0TWF4Q29tcG9uZW50cyhNKTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcclxuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XHJcbiAgY29uc3Qgb3V0ZXJEaW1zID0gcmVzaGFwZWRPdXRwdXRTaGFwZSA/IHJlc2hhcGVkT3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpIDogb3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpO1xyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dGVyRGltcyk7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGVJblNoYWRlciA9IFtiYXRjaFNpemUsIE0sIE5dO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE0gfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBOIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogSyB9LFxyXG4gIF07XHJcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhY3RpdmF0aW9uQXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRlckRpbXMsIGFTaGFwZSwgYlNoYXBlKSk7XHJcbiAgaWYgKGhhc0JpYXMpIHtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XHJcbiAgfVxyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlSW5TaGFkZXIpKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBiYXRjaERpbXMgPSBpbnRlcm5hbFZhcmlhYmxlKCdiYXRjaF9kaW1zJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRlckRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBhU2hhcGUubGVuZ3RoLCBhQ29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgYlNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBiYXNlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShvdXRwdXQudHlwZS50ZW5zb3IpO1xyXG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlLCBiYXNlVHlwZSk7XHJcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFthLCBiXTtcclxuICAgIGxldCBwcm9jZXNzQmlhcyA9ICcnO1xyXG4gICAgaWYgKGhhc0JpYXMpIHtcclxuICAgICAgY29uc3QgYmlhc0NvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGNvbXBvbmVudHMgOiAxO1xyXG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgYmlhc0NvbXBvbmVudHMpKTtcclxuICAgICAgcHJvY2Vzc0JpYXMgPSBgJHtcclxuICAgICAgICBpc0NoYW5uZWxzTGFzdCA/IGB2YWx1ZSArPSBiaWFzW2NvbCAvICR7Ymlhc0NvbXBvbmVudHN9XTtgIDogYHZhbHVlICs9ICR7b3V0cHV0LnR5cGUudmFsdWV9KGJpYXNbcm93ICsgaV0pO2BcclxuICAgICAgfWA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ00nLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdOJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICBdO1xyXG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XHJcblxyXG4gICAgY29uc3QgY2FsY1Jlc3VsdCA9ICgpOiBzdHJpbmcgPT4ge1xyXG4gICAgICBsZXQgY2FsY1N0ciA9IGB2YXIgYV9kYXRhOiAke2EudHlwZS52YWx1ZX07YDtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhQ29tcG9uZW50czsgaSsrKSB7XHJcbiAgICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgICAgICAgbGV0IGJfZGF0YSR7aX0gPSBiWyhiX29mZnNldCArIChrICsgJHtpfSkgKiB1bmlmb3Jtcy5OICsgY29sKSAvICR7Y29tcG9uZW50c31dO2A7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXROdW1iZXI7IGkrKykge1xyXG4gICAgICAgIGNhbGNTdHIgKz0gYGFfZGF0YSA9IGFbKGFfb2Zmc2V0ICsgKHJvdyArICR7aX0pICogdW5pZm9ybXMuSyArIGspIC8gJHthQ29tcG9uZW50c31dO2A7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYUNvbXBvbmVudHM7IGorKykge1xyXG4gICAgICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgICAgIHZhbHVlc1ske2l9XSA9IGZtYSgke2IudHlwZS52YWx1ZX0oYV9kYXRhJHthQ29tcG9uZW50cyA9PT0gMSA/ICcnIDogYFske2p9XWB9KSwgYl9kYXRhJHtqfSwgdmFsdWVzWyR7aX1dKTtcXG5gO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2FsY1N0cjtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAke3NoYWRlckhlbHBlclxyXG4gICAgLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpXHJcbiAgICAucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyhiYXRjaERpbXMpXHJcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcbiAgICBsZXQgY29sID0gKGdsb2JhbF9pZHggJSAodW5pZm9ybXMuTiAvICR7Y29tcG9uZW50c30pKSAqICR7Y29tcG9uZW50c307XHJcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5OIC8gJHtjb21wb25lbnRzfSk7XHJcbiAgICBsZXQgc3RyaWRlMSA9IHVuaWZvcm1zLk0gLyAke291dHB1dE51bWJlcn07XHJcbiAgICBsZXQgcm93ID0gKGluZGV4MSAlIHN0cmlkZTEpICogJHtvdXRwdXROdW1iZXJ9O1xyXG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gc3RyaWRlMTtcclxuXHJcbiAgICAke291dHB1dFNoYXBlLmxlbmd0aCA9PT0gMiA/ICcnIDogYGxldCBiYXRjaF9pbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCdiYXRjaCcpfTtgfVxyXG5cclxuICAgIHZhciBhX2luZGljZXM6ICR7YS50eXBlLmluZGljZXN9O1xyXG4gICAgJHtjb252ZXJ0T3V0cHV0QmF0Y2hJbmRpY2VzVG9JbnB1dEJhdGNoSW5kaWNlcygnYV9pbmRpY2VzJywgYSwgYS5yYW5rIC0gMiwgYmF0Y2hEaW1zLnJhbmssICdiYXRjaF9pbmRpY2VzJyl9XHJcbiAgICAke2EuaW5kaWNlc1NldCgnYV9pbmRpY2VzJywgYS5yYW5rIC0gMiwgMCl9XHJcbiAgICAke2EuaW5kaWNlc1NldCgnYV9pbmRpY2VzJywgYS5yYW5rIC0gMSwgMCl9XHJcbiAgICBsZXQgYV9vZmZzZXQgPSAke2EuaW5kaWNlc1RvT2Zmc2V0KCdhX2luZGljZXMnKX07XHJcblxyXG4gICAgdmFyIGJfaW5kaWNlczogJHtiLnR5cGUuaW5kaWNlc307XHJcbiAgICAke2NvbnZlcnRPdXRwdXRCYXRjaEluZGljZXNUb0lucHV0QmF0Y2hJbmRpY2VzKCdiX2luZGljZXMnLCBiLCBiLnJhbmsgLSAyLCBiYXRjaERpbXMucmFuaywgJ2JhdGNoX2luZGljZXMnKX1cclxuICAgICR7Yi5pbmRpY2VzU2V0KCdiX2luZGljZXMnLCBiLnJhbmsgLSAyLCAwKX1cclxuICAgICR7Yi5pbmRpY2VzU2V0KCdiX2luZGljZXMnLCBiLnJhbmsgLSAxLCAwKX1cclxuICAgIGxldCBiX29mZnNldCA9ICR7Yi5pbmRpY2VzVG9PZmZzZXQoJ2JfaW5kaWNlcycpfTtcclxuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dE51bWJlcn0+O1xyXG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrID0gayArICR7YUNvbXBvbmVudHN9KSB7XHJcbiAgICAgICR7Y2FsY1Jlc3VsdCgpfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtvdXRwdXROdW1iZXJ9dTsgaSsrKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcclxuICAgICAgJHtwcm9jZXNzQmlhc31cclxuICAgICAgJHthcHBseUFjdGl2YXRpb259XHJcbiAgICAgIGxldCBjdXJfaW5kaWNlcyA9ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdyArIGksIGNvbCk7XHJcbiAgICAgIGxldCBvZmZzZXQgPSAke291dHB1dC5pbmRpY2VzVG9PZmZzZXQoJ2N1cl9pbmRpY2VzJyl9O1xyXG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHtjb21wb25lbnRzfWAsICd2YWx1ZScpfTtcclxuICAgIH1cclxuICB9XHJcbiAgYDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnTWF0TXVsTmFpdmUnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07JHtjb21wb25lbnRzfTske2FDb21wb25lbnRzfTske291dHB1dE51bWJlcn07JHtpc0NoYW5uZWxzTGFzdH1gLFxyXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogaGFzQmlhcyA/IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXSA6IFsncmFuaycsICdyYW5rJ10sXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuIiwgIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKi9cclxuXHJcbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvbWF0bXVsX3BhY2tlZF93ZWJncHUudHNcclxuLy9cclxuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBpbnRlcm5hbFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHtcclxuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsXHJcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSxcclxuICBnZXRBY3RpdmF0aW9uU25pcHBldCxcclxuICBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxyXG59IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xyXG5pbXBvcnQgeyBjb252ZXJ0T3V0cHV0QmF0Y2hJbmRpY2VzVG9JbnB1dEJhdGNoSW5kaWNlcyB9IGZyb20gJy4uL21hdG11bC1zaGFkZXJzJztcclxuXHJcbmltcG9ydCB7IHR5cGVTbmlwcGV0IH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xyXG5cclxuY29uc3Qgd3JpdGVEYXRhVG9TdWJBVmVjNFNuaXBwZXQgPSAodHJhbnNwb3NlOiBib29sZWFuLCBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyKSA9PiB7XHJcbiAgaWYgKHRyYW5zcG9zZSkge1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcclxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxyXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xyXG4gICAgICAgIGA7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXHJcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcclxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XHJcbiAgICAgICAgYDtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjYWxjdWxhdGVSZXN1bHRTbmlwcGV0ID0gKHRyYW5zcG9zZUE6IGJvb2xlYW4sIGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xyXG4gIGlmICh0cmFuc3Bvc2VBKSB7XHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgIGxldCBBQ2FjaGVkMCA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW2xvY2FsUm93XTtcclxuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xyXG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XHJcbiAgICAgICAgJHtpbm5lckVsZW1lbnRTaXplID09PSAzID8gJycgOiAnbGV0IEFDYWNoZWQzID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW2xvY2FsUm93XTsnfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcclxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XHJcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQxW2ldICsgYWNjW2ldO1xyXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcclxuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2FjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07J31cclxuICAgICAgICB9YDtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XHJcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xyXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XHJcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcclxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xyXG4gICAgICAgICAgJHtpbm5lckVsZW1lbnRTaXplID09PSAzID8gJycgOiAnYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07J31cclxuICAgICAgICB9YDtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UgPSAoXHJcbiAgd29ya1BlclRocmVhZDogbnVtYmVyW10sXHJcbiAgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gIHR5cGUgPSAnZjMyJyxcclxuICBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyLFxyXG4gIHRyYW5zcG9zZUEgPSBmYWxzZSxcclxuICB0aWxlSW5uZXIgPSAzMixcclxuICBzcGxpdEsgPSBmYWxzZSxcclxuICBzcGxpdGVkRGltSW5uZXIgPSAzMixcclxuKTogc3RyaW5nID0+IHtcclxuICBjb25zdCB0aWxlQU91dGVyID0gd29ya2dyb3VwU2l6ZVsxXSAqIHdvcmtQZXJUaHJlYWRbMV07XHJcbiAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtncm91cFNpemVbMF0gKiB3b3JrUGVyVGhyZWFkWzBdO1xyXG4gIGNvbnN0IHRpbGVBV2lkdGggPSB0cmFuc3Bvc2VBID8gdGlsZUFPdXRlciA6IHRpbGVJbm5lcjtcclxuICBjb25zdCB0aWxlQUhpZ2h0ID0gdHJhbnNwb3NlQSA/IHRpbGVJbm5lciA6IHRpbGVBT3V0ZXI7XHJcbiAgY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9IHRpbGVBV2lkdGggLyB3b3JrZ3JvdXBTaXplWzBdO1xyXG4gIGNvbnN0IHJvd1BlclRocmVhZEIgPSB0aWxlSW5uZXIgLyB3b3JrZ3JvdXBTaXplWzFdO1xyXG5cclxuICBpZiAoXHJcbiAgICAhKFxyXG4gICAgICAoKHRyYW5zcG9zZUEgJiYgaW5uZXJFbGVtZW50U2l6ZSA9PT0gNCAmJiB3b3JrUGVyVGhyZWFkWzFdID09PSA0KSB8fFxyXG4gICAgICAgICghdHJhbnNwb3NlQSAmJiAoaW5uZXJFbGVtZW50U2l6ZSA9PT0gMyB8fCBpbm5lckVsZW1lbnRTaXplID09PSA0KSkpICYmXHJcbiAgICAgIHRpbGVBV2lkdGggJSB3b3JrZ3JvdXBTaXplWzBdID09PSAwICYmXHJcbiAgICAgIHRpbGVJbm5lciAlIHdvcmtncm91cFNpemVbMV0gPT09IDAgJiZcclxuICAgICAgd29ya1BlclRocmVhZFswXSA9PT0gNFxyXG4gICAgKVxyXG4gICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7dHJhbnNwb3NlQX0gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7d29ya1BlclRocmVhZFsxXX0gbXVzdCBiZSA0LlxyXG4gICAgICBPdGhlcndpc2UsIGlubmVyRWxlbWVudFNpemUgJHtpbm5lckVsZW1lbnRTaXplfSBtdXN0IGJlIDMgb3IgNC5cclxuICB0aWxlQVdpZHRoICR7dGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7d29ya2dyb3VwU2l6ZVswXX0uIHRpbGVJbm5lciAke3RpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSAke3dvcmtncm91cFNpemVbMV19LiBjb2xQZXJUaHJlYWQgJHt3b3JrUGVyVGhyZWFkWzBdfSBtdXN0IGJlIDQuYCk7XHJcbiAgfVxyXG4gIHJldHVybiBgXHJcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7aW5uZXJFbGVtZW50U2l6ZX08JHt0eXBlfT4sICR7dGlsZUFXaWR0aCAvIGlubmVyRWxlbWVudFNpemV9PiwgJHt0aWxlQUhpZ2h0fT47XHJcbnZhcjx3b3JrZ3JvdXA+IG1tX0JzdWI6IGFycmF5PGFycmF5PHZlYzQ8JHt0eXBlfT4sICR7dGlsZUJPdXRlciAvIHdvcmtQZXJUaHJlYWRbMF19PiwgJHt0aWxlSW5uZXJ9PjtcclxuXHJcbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XHJcbmNvbnN0IGNvbFBlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFswXX07XHJcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke2lubmVyRWxlbWVudFNpemV9O1xyXG5jb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XHJcblxyXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt3b3JrZ3JvdXBTaXplWzBdfSwgJHt3b3JrZ3JvdXBTaXplWzFdfSwgJHt3b3JrZ3JvdXBTaXplWzJdfSlcclxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxyXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcclxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XHJcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XHJcbiAgbGV0IHRpbGVSb3cgPSBsb2NhbFJvdyAqIHJvd1BlclRocmVhZDtcclxuICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xyXG5cclxuICBsZXQgZ2xvYmFsUm93ID1pMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XHJcbiAgbGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KTtcclxuICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcclxuICAke2JhdGNoRGltcyA/IGBsZXQgYmF0Y2hJbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCd1MzIoYmF0Y2gpJyl9O2AgOiAnJ31cclxuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xyXG5cclxuICBsZXQgbnVtX3RpbGVzID0gJHtzcGxpdEsgPyBgJHtNYXRoLmNlaWwoc3BsaXRlZERpbUlubmVyIC8gdGlsZUlubmVyKX1gIDogJyh1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDEnfTtcclxuICB2YXIga1N0YXJ0ID0gJHtzcGxpdEsgPyBgaTMyKGdsb2JhbElkLnopICogJHtzcGxpdGVkRGltSW5uZXJ9YCA6ICcwJ307XHJcblxyXG4gIHZhciBhY2M6IGFycmF5PHZlYzQ8JHt0eXBlfT4sIHJvd1BlclRocmVhZD47XHJcblxyXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxyXG4gIGxldCB0aWxlUm93QiA9IGxvY2FsUm93ICogJHtyb3dQZXJUaHJlYWRCfTtcclxuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XHJcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cclxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcclxuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3cgKyBpbm5lclJvdztcclxuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XHJcbiAgICAgICAgICAke3dyaXRlRGF0YVRvU3ViQVZlYzRTbmlwcGV0KHRyYW5zcG9zZUEsIGJhdGNoRGltcyl9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cclxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7cm93UGVyVGhyZWFkQn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XHJcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xyXG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcclxuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sJHtcclxuICAgICAgICAgICAgYmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxyXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lciAvIGlubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xyXG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XHJcbiAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XHJcbiAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XHJcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07J31cclxuXHJcbiAgICAgICAgICAke2NhbGN1bGF0ZVJlc3VsdFNuaXBwZXQodHJhbnNwb3NlQSwgaW5uZXJFbGVtZW50U2l6ZSl9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XHJcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcclxuICB9XHJcbn1gO1xyXG59O1xyXG5cclxuY29uc3Qgd3JpdGVEYXRhVG9TdWJBU25pcHBldCA9ICh0cmFuc3Bvc2U6IGJvb2xlYW4sIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIpID0+IHtcclxuICBpZiAodHJhbnNwb3NlKSB7XHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcclxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcclxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcclxuICAgICAgICAgICAgYDtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXHJcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcclxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XHJcbiAgICAgICAgICAgIGA7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgcmVhZERhdGFGcm9tU3ViQVNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbikgPT5cclxuICB0cmFuc3Bvc2VBID8gJ2xldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddOycgOiAnbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107JztcclxuXHJcbi8vIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgbWVhbnMgc2VxdWVudGlhbCBkYXRhIGluIG1lbW9yeSBpcyBhY2Nlc3NlZCBieVxyXG4vLyB0aHJlYWRzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHRocmVhZCAoZGVmYXVsdCBiZWhhdmlvcikuXHJcbmV4cG9ydCBjb25zdCBtYWtlTWF0TXVsUGFja2VkU291cmNlID0gKFxyXG4gIHdvcmtQZXJUaHJlYWQ6IG51bWJlcltdLFxyXG4gIHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICB0eXBlID0gJ2YzMicsXHJcbiAgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcixcclxuICB0cmFuc3Bvc2VBID0gZmFsc2UsXHJcbiAgdGlsZUlubmVyID0gMzIsXHJcbiAgc3BsaXRLID0gZmFsc2UsXHJcbiAgc3BsaXRlZERpbUlubmVyID0gMzIsXHJcbiAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IGZhbHNlLFxyXG4pOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IHRpbGVBT3V0ZXIgPSB3b3JrUGVyVGhyZWFkWzFdICogd29ya2dyb3VwU2l6ZVsxXTtcclxuICBjb25zdCB0aWxlQk91dGVyID0gd29ya1BlclRocmVhZFswXSAqIHdvcmtncm91cFNpemVbMF07XHJcbiAgY29uc3QgdGlsZUFXaWR0aCA9IHRyYW5zcG9zZUEgPyB0aWxlQU91dGVyIDogdGlsZUlubmVyO1xyXG4gIGNvbnN0IHRpbGVBSGlnaHQgPSB0cmFuc3Bvc2VBID8gdGlsZUlubmVyIDogdGlsZUFPdXRlcjtcclxuXHJcbiAgaWYgKFxyXG4gICAgISh0aWxlQUhpZ2h0ICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJiB0aWxlQVdpZHRoICUgd29ya2dyb3VwU2l6ZVswXSA9PT0gMCAmJiB0aWxlSW5uZXIgJSB3b3JrZ3JvdXBTaXplWzFdID09PSAwKVxyXG4gICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgdGlsZUFIaWdodCAke3RpbGVBSGlnaHR9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3dvcmtncm91cFNpemVbMV19LCB0aWxlQVdpZHRoICR7dGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7d29ya2dyb3VwU2l6ZVswXX0sIHRpbGVJbm5lciAke3RpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7d29ya2dyb3VwU2l6ZVsxXX1gLFxyXG4gICAgKTtcclxuICB9XHJcbiAgY29uc3Qgcm93UGVyVGhyZWFkQSA9IHRpbGVBSGlnaHQgLyB3b3JrZ3JvdXBTaXplWzFdO1xyXG4gIGNvbnN0IGNvbFBlclRocmVhZEEgPSB0aWxlQVdpZHRoIC8gd29ya2dyb3VwU2l6ZVswXTtcclxuICBjb25zdCByb3dQZXJUaHJlYWRCID0gdGlsZUlubmVyIC8gd29ya2dyb3VwU2l6ZVsxXTtcclxuICBjb25zdCBtYXRtdWxTbmlwcGV0ID0gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkc1xyXG4gICAgPyBgXHJcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcclxuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xyXG4gICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHt0aWxlQU91dGVyfTtcclxuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7dGlsZUJPdXRlcn07XHJcblxyXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXHJcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XHJcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cclxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3RpbGVBSGlnaHR9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt3b3JrZ3JvdXBTaXplWzFdfSkge1xyXG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt0aWxlQVdpZHRofTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7d29ya2dyb3VwU2l6ZVswXX0pIHtcclxuICAgICAgICAgICR7d3JpdGVEYXRhVG9TdWJBU25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXHJcbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHt0aWxlSW5uZXJ9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt3b3JrZ3JvdXBTaXplWzFdfSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7dGlsZUJPdXRlcn07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3dvcmtncm91cFNpemVbMF19KSB7XHJcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcclxuICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXHJcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxyXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD47XHJcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcclxuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xyXG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3dvcmtncm91cFNpemVbMF19XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcclxuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtcclxuICAgICAgICAgICAgdHJhbnNwb3NlQVxyXG4gICAgICAgICAgICAgID8gYG1tX0FzdWJba11bbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7d29ya2dyb3VwU2l6ZVsxXX1dO2BcclxuICAgICAgICAgICAgICA6IGBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19XVtrXTtgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xyXG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcclxuICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcclxuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19O1xyXG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xyXG4gICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt3b3JrZ3JvdXBTaXplWzBdfTtcclxuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBgXHJcbiAgICA6IGBcclxubGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIHJvd1BlclRocmVhZDtcclxubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcclxuXHJcbmxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XHJcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XHJcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XHJcblxyXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7cm93UGVyVGhyZWFkQX07XHJcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHtjb2xQZXJUaHJlYWRBfTtcclxubGV0IHRpbGVSb3dCID0gaTMyKGxvY2FsSWQueSkgKiAke3Jvd1BlclRocmVhZEJ9O1xyXG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cclxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xyXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cclxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRBfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcclxuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke2NvbFBlclRocmVhZEF9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xyXG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xyXG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xyXG4gICAgICAke3dyaXRlRGF0YVRvU3ViQVNuaXBwZXQodHJhbnNwb3NlQSwgYmF0Y2hEaW1zKX1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cclxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcclxuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XHJcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XHJcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcclxuICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXHJcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXHJcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xyXG4gICAgfVxyXG4gIH1cclxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XHJcbiAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cclxuICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD47XHJcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xyXG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcclxuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcclxuICAgICAgJHtyZWFkRGF0YUZyb21TdWJBU25pcHBldCh0cmFuc3Bvc2VBKX1cclxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcclxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbn1cclxuXHJcbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XHJcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcclxuICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXHJcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xyXG4gIH1cclxufVxyXG5gO1xyXG5cclxuICByZXR1cm4gYFxyXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTwke3R5cGV9LCAke3RpbGVBV2lkdGh9PiwgJHt0aWxlQUhpZ2h0fT47XHJcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7dHlwZX0sICR7dGlsZUJPdXRlcn0+LCAke3RpbGVJbm5lcn0+O1xyXG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XHJcbiAgY29uc3QgY29sUGVyVGhyZWFkID0gJHt3b3JrUGVyVGhyZWFkWzBdfTtcclxuICBjb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XHJcblxyXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt3b3JrZ3JvdXBTaXplWzBdfSwgJHt3b3JrZ3JvdXBTaXplWzFdfSwgJHt3b3JrZ3JvdXBTaXplWzJdfSlcclxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxyXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcclxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XHJcbiAgICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcclxuICAgICR7YmF0Y2hEaW1zID8gYGxldCBiYXRjaEluZGljZXMgPSAke2JhdGNoRGltcy5vZmZzZXRUb0luZGljZXMoJ3UzMihiYXRjaCknKX07YCA6ICcnfVxyXG4gICAgbGV0IG51bV90aWxlcyA9ICR7XHJcbiAgICAgIHNwbGl0SyA/IGAke01hdGguY2VpbChzcGxpdGVkRGltSW5uZXIgLyB0aWxlSW5uZXIpfWAgOiAnKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMSdcclxuICAgIH07XHJcbiAgICB2YXIga1N0YXJ0ID0gJHtzcGxpdEsgPyBgaTMyKGdsb2JhbElkLnopICogJHtzcGxpdGVkRGltSW5uZXJ9YCA6ICcwJ307XHJcblxyXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XHJcbiAgICAke21hdG11bFNuaXBwZXR9XHJcbiAgfVxyXG5gO1xyXG59O1xyXG5cclxuY29uc3QgbWF0TXVsUmVhZFdyaXRlRm5Tb3VyY2UgPSAoXHJcbiAgY29tcG9uZW50OiBudW1iZXIsXHJcbiAgaGFzQmlhczogYm9vbGVhbixcclxuICBhcHBseUFjdGl2YXRpb246IHN0cmluZyxcclxuICB2YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSxcclxuICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlLFxyXG4pOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IFtiYXRjaFZhcmlhYmxlLCBhVmFyaWFibGUsIGJWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGVdID0gdmFyaWFibGVzO1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKHZhcmlhYmxlc1swXS50eXBlLnRlbnNvcik7XHJcblxyXG4gIGNvbnN0IHNvdXJjZSA9IGBcclxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7YmF0Y2hWYXJpYWJsZS50eXBlLmluZGljZXN9KSAtPiAke3R5cGVTbmlwcGV0KFxyXG4gICAgICBjb21wb25lbnQsXHJcbiAgICAgIGRhdGFUeXBlLFxyXG4gICAgKX0ge1xyXG4gICAgICB2YXIgdmFsdWUgPSAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSgwLjApO1xyXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XHJcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcilcclxuICAgICAge1xyXG4gICAgICAgIHZhciBhSW5kaWNlczogJHthVmFyaWFibGUudHlwZS5pbmRpY2VzfTtcclxuICAgICAgICAke2NvbnZlcnRPdXRwdXRCYXRjaEluZGljZXNUb0lucHV0QmF0Y2hJbmRpY2VzKFxyXG4gICAgICAgICAgJ2FJbmRpY2VzJyxcclxuICAgICAgICAgIGFWYXJpYWJsZSxcclxuICAgICAgICAgIGFWYXJpYWJsZS5yYW5rIC0gMixcclxuICAgICAgICAgIGJhdGNoVmFyaWFibGUucmFuayxcclxuICAgICAgICAgICdiYXRjaEluZGljZXMnLFxyXG4gICAgICAgICl9XHJcbiAgICAgICAgJHthVmFyaWFibGUuaW5kaWNlc1NldCgnYUluZGljZXMnLCBhVmFyaWFibGUucmFuayAtIDIsICd1MzIocm93KScpfVxyXG4gICAgICAgICR7YVZhcmlhYmxlLmluZGljZXNTZXQoJ2FJbmRpY2VzJywgYVZhcmlhYmxlLnJhbmsgLSAxLCAndTMyKGNvbEluKScpfVxyXG4gICAgICAgIHZhbHVlID0gJHthVmFyaWFibGUuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtiYXRjaFZhcmlhYmxlLnR5cGUuaW5kaWNlc30pIC0+ICR7dHlwZVNuaXBwZXQoXHJcbiAgICAgIGNvbXBvbmVudCxcclxuICAgICAgZGF0YVR5cGUsXHJcbiAgICApfSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KDAuMCk7XHJcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcclxuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxyXG4gICAgICB7XHJcbiAgICAgICAgdmFyIGJJbmRpY2VzOiAke2JWYXJpYWJsZS50eXBlLmluZGljZXN9O1xyXG4gICAgICAgICR7Y29udmVydE91dHB1dEJhdGNoSW5kaWNlc1RvSW5wdXRCYXRjaEluZGljZXMoXHJcbiAgICAgICAgICAnYkluZGljZXMnLFxyXG4gICAgICAgICAgYlZhcmlhYmxlLFxyXG4gICAgICAgICAgYlZhcmlhYmxlLnJhbmsgLSAyLFxyXG4gICAgICAgICAgYmF0Y2hWYXJpYWJsZS5yYW5rLFxyXG4gICAgICAgICAgJ2JhdGNoSW5kaWNlcycsXHJcbiAgICAgICAgKX1cclxuICAgICAgICAke2JWYXJpYWJsZS5pbmRpY2VzU2V0KCdiSW5kaWNlcycsIGJWYXJpYWJsZS5yYW5rIC0gMiwgJ3UzMihyb3cpJyl9XHJcbiAgICAgICAgJHtiVmFyaWFibGUuaW5kaWNlc1NldCgnYkluZGljZXMnLCBiVmFyaWFibGUucmFuayAtIDEsICd1MzIoY29sSW4pJyl9XHJcbiAgICAgICAgdmFsdWUgPSAke2JWYXJpYWJsZS5nZXRCeUluZGljZXMoJ2JJbmRpY2VzJyl9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgdmFsdWVJbjogJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0pIHtcclxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjb21wb25lbnR9O1xyXG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xyXG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xyXG4gICAgICAgICR7XHJcbiAgICAgICAgICBoYXNCaWFzXHJcbiAgICAgICAgICAgID8gYHZhbHVlID0gdmFsdWUgKyAke2lzQ2hhbm5lbHNMYXN0ID8gJ2JpYXNbY29sSW5dJyA6IGAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfShiaWFzW3Jvd10pYH07YFxyXG4gICAgICAgICAgICA6ICcnXHJcbiAgICAgICAgfVxyXG4gICAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxyXG4gICAgICAgICR7b3V0cHV0VmFyaWFibGUuc2V0QnlJbmRpY2VzKCd2ZWMzPHUzMj4oY29vcmRzKScsICd2YWx1ZScpfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBgO1xyXG4gIHJldHVybiBzb3VyY2U7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXHJcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHJlc2hhcGVkT3V0cHV0U2hhcGU/OiByZWFkb25seSBudW1iZXJbXSxcclxuICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlIC8qIG9ubHkgdXNlZCBmb3IgY29udjJkQnlNYXRNdWwqLyxcclxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XHJcbiAgY29uc3Qgb3V0ZXJEaW1zQSA9IGFTaGFwZS5zbGljZSgwLCAtMik7XHJcbiAgY29uc3Qgb3V0ZXJEaW1zQiA9IGJTaGFwZS5zbGljZSgwLCAtMik7XHJcbiAgY29uc3Qgb3V0ZXJEaW1zID0gcmVzaGFwZWRPdXRwdXRTaGFwZSA/IHJlc2hhcGVkT3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpIDogb3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpO1xyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dGVyRGltcyk7XHJcbiAgY29uc3QgZGltQU91dGVyID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAyXTtcclxuICBjb25zdCBkaW1Jbm5lciA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XHJcbiAgY29uc3QgZGltQk91dGVyID0gYlNoYXBlW2JTaGFwZS5sZW5ndGggLSAxXTtcclxuICBjb25zdCBpc1ZlYzQgPSBkaW1Jbm5lciAlIDQgPT09IDAgJiYgZGltQk91dGVyICUgNCA9PT0gMDtcclxuXHJcbiAgLy8gVE9ETzogZmluZSB0dW5lIHNpemVcclxuICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9IGRpbUFPdXRlciA8PSA4ID8gWzQsIDEsIDFdIDogWzQsIDQsIDFdO1xyXG4gIGNvbnN0IHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs4LCA4LCAxXTtcclxuICBjb25zdCBkaXNwYXRjaCA9IFtcclxuICAgIE1hdGguY2VpbChkaW1CT3V0ZXIgLyB3b3JrZ3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxyXG4gICAgTWF0aC5jZWlsKGRpbUFPdXRlciAvIHdvcmtncm91cFNpemVbMV0gLyBlbGVtZW50c1BlclRocmVhZFsxXSksXHJcbiAgICBNYXRoLmNlaWwoYmF0Y2hTaXplIC8gd29ya2dyb3VwU2l6ZVsyXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzJdKSxcclxuICBdO1xyXG5cclxuICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XHJcbiAgY29uc3QgYVNoYXBlVGVtcCA9IFsuLi5vdXRlckRpbXNBLCBkaW1BT3V0ZXIsIGRpbUlubmVyIC8gY29tcG9uZW50c107XHJcbiAgY29uc3QgYVJhbmsgPSBhU2hhcGVUZW1wLmxlbmd0aDtcclxuICBjb25zdCBiU2hhcGVUZW1wID0gWy4uLm91dGVyRGltc0IsIGRpbUlubmVyLCBkaW1CT3V0ZXIgLyBjb21wb25lbnRzXTtcclxuICBjb25zdCBiUmFuayA9IGJTaGFwZVRlbXAubGVuZ3RoO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltQk91dGVyIC8gY29tcG9uZW50c107XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQU91dGVyIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1CT3V0ZXIgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUlubmVyIH0sXHJcbiAgXTtcclxuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dGVyRGltcywgYVNoYXBlVGVtcCwgYlNoYXBlVGVtcCkpO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcclxuXHJcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xyXG4gIGlmIChoYXNCaWFzKSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xyXG4gIH1cclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZVRlbXApKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBiYXRjaFJhbmsgPSBvdXRlckRpbXMubGVuZ3RoO1xyXG4gICAgY29uc3QgYmF0Y2hEaW1zID0gaW50ZXJuYWxWYXJpYWJsZSgnYmF0Y2hEaW1zJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBiYXRjaFJhbmssIDEpO1xyXG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuXHJcbiAgICBjb25zdCBBID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgYVJhbmssIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgQiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGJSYW5rLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlVGVtcC5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbQSwgQl07XHJcbiAgICBpZiAoaGFzQmlhcykge1xyXG4gICAgICBjb25zdCBiaWFzQ29tcG9uZW50cyA9IGlzQ2hhbm5lbHNMYXN0ID8gY29tcG9uZW50cyA6IDE7XHJcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBiaWFzQ29tcG9uZW50cykpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdkaW1fYV9vdXRlcicsIHR5cGU6ICdpMzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2RpbV9iX291dGVyJywgdHlwZTogJ2kzMicgfSxcclxuICAgICAgeyBuYW1lOiAnZGltX2lubmVyJywgdHlwZTogJ2kzMicgfSxcclxuICAgIF07XHJcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcclxuICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XHJcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUsIGJhc2VUeXBlKTtcclxuICAgIGNvbnN0IGRlY2xhcmVGdW5jdGlvbnMgPSBtYXRNdWxSZWFkV3JpdGVGblNvdXJjZShcclxuICAgICAgY29tcG9uZW50cyxcclxuICAgICAgaGFzQmlhcyxcclxuICAgICAgYXBwbHlBY3RpdmF0aW9uLFxyXG4gICAgICBbYmF0Y2hEaW1zLCBBLCBCLCBvdXRwdXRdLFxyXG4gICAgICBpc0NoYW5uZWxzTGFzdCxcclxuICAgICk7XHJcbiAgICByZXR1cm4gYFxyXG4gICR7c2hhZGVySGVscGVyXHJcbiAgICAucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcylcclxuICAgIC5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGJhdGNoRGltcylcclxuICAgIC5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxyXG4gICR7ZGVjbGFyZUZ1bmN0aW9uc31cclxuICAke1xyXG4gICAgaXNWZWM0XHJcbiAgICAgID8gbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UoZWxlbWVudHNQZXJUaHJlYWQsIHdvcmtncm91cFNpemUsIGRhdGFUeXBlLCBiYXRjaERpbXMpXHJcbiAgICAgIDogbWFrZU1hdE11bFBhY2tlZFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcylcclxuICB9XHJcbiAgICAgICAgICAgICAgICAgICBgO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdNYXRNdWwnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7ZWxlbWVudHNQZXJUaHJlYWR9OyR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07JHtpc1ZlYzR9OyR7aXNDaGFubmVsc0xhc3R9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXMsXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG4iLCAiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqL1xyXG5cclxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252MmRfbW1fd2ViZ3B1LnRzXHJcbi8vXHJcbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4uL2NvbnYnO1xyXG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi4vZnVzZS11dGlscyc7XHJcblxyXG5pbXBvcnQgeyBiaWFzU25pcHBldCwgdHlwZVNuaXBwZXQgfSBmcm9tICcuL2FjdGl2YXRpb25fdXRpbCc7XHJcbmltcG9ydCB7IHV0aWxGdW5jdGlvbnMgfSBmcm9tICcuL2NvbnZfdXRpbCc7XHJcbmltcG9ydCB7IG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UsIG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlIH0gZnJvbSAnLi9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XHJcblxyXG5jb25zdCBjb252MmRDb21tb25TbmlwcGV0ID0gKFxyXG4gIGlzQ2hhbm5lbHNMYXN0OiBib29sZWFuLFxyXG4gIGZpdEFPdXRlcjogYm9vbGVhbixcclxuICBmaXRCT3V0ZXI6IGJvb2xlYW4sXHJcbiAgZml0SW5uZXI6IGJvb2xlYW4sXHJcbiAgYWRkQmlhcyA9IGZhbHNlLFxyXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxyXG4gIGlubmVyRWxlbWVudFNpemVYID0gNCxcclxuICBpbm5lckVsZW1lbnRTaXplVyA9IDQsXHJcbiAgaW5uZXJFbGVtZW50U2l6ZSA9IDQsXHJcbiAgZGF0YVR5cGUgPSAnZjMyJyxcclxuKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBnZXRYU25pcHBldCA9IChpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcclxuICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXhdOyc7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICByZXR1cm4gYHJlc0RhdGEgPSB2ZWMzPCR7ZGF0YVR5cGV9Pih4W3hJbmRleF0sIHhbeEluZGV4ICsgMV0sIHhbeEluZGV4ICsgMl0pO2A7XHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICByZXR1cm4gJ3Jlc0RhdGEgPSB4W3hJbmRleCAvIDRdOyc7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGdldFdTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xyXG4gICAgc3dpdGNoIChpbm5lckVsZW1lbnRTaXplKSB7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICByZXR1cm4gJ3JldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSArIGNvbEluXTsnO1xyXG4gICAgICBjYXNlIDQ6XHJcbiAgICAgICAgcmV0dXJuICdyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgLyA0ICsgY29sSW5dOyc7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGNvb3JkQVNuaXBwZXQgPSBpc0NoYW5uZWxzTGFzdFxyXG4gICAgPyBgXHJcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XHJcbiAgICBgXHJcbiAgICA6IGBcclxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcclxuICAgIGA7XHJcblxyXG4gIGNvbnN0IGNvb3JkUmVzU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0XHJcbiAgICA/IGBcclxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXHJcbiAgICAgIGJhdGNoLFxyXG4gICAgICByb3cgLyBvdXRXaWR0aCxcclxuICAgICAgcm93ICUgb3V0V2lkdGgsXHJcbiAgICAgIGNvbCk7XHJcbiAgICBgXHJcbiAgICA6IGBcclxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXHJcbiAgICAgIGJhdGNoLFxyXG4gICAgICByb3csXHJcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxyXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XHJcbiAgICBgO1xyXG5cclxuICBjb25zdCB4SGVpZ2h0ID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVsyXSknO1xyXG4gIGNvbnN0IHhXaWR0aCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pJztcclxuICBjb25zdCByb3cgPSBpc0NoYW5uZWxzTGFzdCA/ICdyb3cnIDogJ2NvbCc7XHJcbiAgY29uc3QgY29sID0gaXNDaGFubmVsc0xhc3QgPyAnY29sJyA6ICdyb3cnO1xyXG4gIGNvbnN0IHJlYWRYU25pcHBldCA9IGBcclxuICAgIGxldCBpbkNoYW5uZWxzID0gaTMyKHVuaWZvcm1zLndfc2hhcGVbMl0pO1xyXG4gICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcclxuICAgIGxldCBvdXRSb3cgPSAke3Jvd30gLyBvdXRXaWR0aDtcclxuICAgIGxldCBvdXRDb2wgPSAke3Jvd30gJSBvdXRXaWR0aDtcclxuXHJcbiAgICBsZXQgV1JvdyA9ICR7Y29sfSAvIChpMzIodW5pZm9ybXMud19zaGFwZVsxXSkgKiBpbkNoYW5uZWxzKTtcclxuICAgIGxldCBXQ29sID0gJHtjb2x9IC8gaW5DaGFubmVscyAlIGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKTtcclxuICAgIGxldCB4Um93ID0gb3V0Um93ICogdW5pZm9ybXMuc3RyaWRlWzBdICsgdW5pZm9ybXMuZGlsYXRpb25bMF0gKiBXUm93IC0gdW5pZm9ybXMucGFkWzBdO1xyXG4gICAgbGV0IHhDb2wgPSBvdXRDb2wgKiB1bmlmb3Jtcy5zdHJpZGVbMV0gKyB1bmlmb3Jtcy5kaWxhdGlvblsxXSAqIFdDb2wgLSB1bmlmb3Jtcy5wYWRbMV07XHJcbiAgICBsZXQgeENoID0gJHtjb2x9ICUgaW5DaGFubmVscztcclxuICAgIHZhciByZXNEYXRhID0gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO1xyXG4gICAgLy8gVGhlIGJvdW5kcyBjaGVja2luZyBpcyBhbHdheXMgbmVlZGVkIHNpbmNlIHdlIHVzZSBpdCB0byBwYWQgemVybyBmb3JcclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxyXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHt4SGVpZ2h0fSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7eFdpZHRofSkge1xyXG4gICAgICAke2Nvb3JkQVNuaXBwZXR9XHJcbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcclxuICAgICAgJHtnZXRYU25pcHBldChpbm5lckVsZW1lbnRTaXplWCl9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzRGF0YTtgO1xyXG5cclxuICBjb25zdCBzYW1wbGVYID0gaXNDaGFubmVsc0xhc3RcclxuICAgID8gZml0QU91dGVyICYmIGZpdElubmVyXHJcbiAgICAgID8gYFxyXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XHJcbiAgICAke3JlYWRYU25pcHBldH1gXHJcbiAgICAgIDogYFxyXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XHJcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XHJcbiAgICAgICR7cmVhZFhTbmlwcGV0fVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKX0oMC4wKTtgXHJcbiAgICA6IGZpdElubmVyICYmIGZpdEJPdXRlclxyXG4gICAgICA/IGBcclxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xyXG4gICAgJHtyZWFkWFNuaXBwZXR9YFxyXG4gICAgICA6IGBcclxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xyXG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xyXG4gICAgICAke3JlYWRYU25pcHBldH1cclxuICAgIH1cclxuICAgIHJldHVybiAke3R5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSl9KDAuMCk7YDtcclxuXHJcbiAgY29uc3Qgc2FtcGxlVyA9IGlzQ2hhbm5lbHNMYXN0XHJcbiAgICA/IGZpdElubmVyICYmIGZpdEJPdXRlclxyXG4gICAgICA/IGdldFdTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXKVxyXG4gICAgICA6IGBcclxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVd9O1xyXG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xyXG4gICAgICAke2dldFdTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXKX1cclxuICAgIH1cclxuICAgIHJldHVybiAke3R5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXLCBkYXRhVHlwZSl9KDAuMCk7YFxyXG4gICAgOiBgXHJcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVXfTtcclxuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIpIHtcclxuICAgICAgJHtnZXRXU25pcHBldChpbm5lckVsZW1lbnRTaXplVyl9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplVywgZGF0YVR5cGUpfSgwLjApO2A7XHJcblxyXG4gIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCBkYXRhVHlwZSk7XHJcbiAgY29uc3QgYVR5cGUgPSBpc0NoYW5uZWxzTGFzdCA/IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSkgOiB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplVywgZGF0YVR5cGUpO1xyXG4gIGNvbnN0IGJUeXBlID0gaXNDaGFubmVsc0xhc3QgPyB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplVywgZGF0YVR5cGUpIDogdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKTtcclxuICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCByZXNUeXBlLCBkYXRhVHlwZSk7XHJcbiAgY29uc3QgdXNlckNvZGUgPSBgXHJcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke2FUeXBlfSB7XHJcbiAgICAgICR7aXNDaGFubmVsc0xhc3QgPyBzYW1wbGVYIDogc2FtcGxlV31cclxuICAgIH1cclxuXHJcbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke2JUeXBlfSB7XHJcbiAgICAgICR7aXNDaGFubmVsc0xhc3QgPyBzYW1wbGVXIDogc2FtcGxlWH1cclxuICAgIH1cclxuXHJcbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHtyZXNUeXBlfSkge1xyXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemV9O1xyXG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXHJcbiAgICAgIHtcclxuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcclxuICAgICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcclxuICAgICAgJHtjb29yZFJlc1NuaXBwZXR9XHJcbiAgICAgICR7Ymlhc1NuaXBwZXQoYWRkQmlhcyl9XHJcbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxyXG4gICAgICBzZXRPdXRwdXRBdENvb3Jkcyhjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10sIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfWA7XHJcbiAgcmV0dXJuIHVzZXJDb2RlO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbnYyRE1hdE11bFByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxyXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBkaW1BT3V0ZXI6IG51bWJlcixcclxuICBkaW1CT3V0ZXI6IG51bWJlcixcclxuICBkaW1Jbm5lcjogbnVtYmVyLFxyXG4gIGhhc0JpYXM6IGJvb2xlYW4sXHJcbiAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkczogYm9vbGVhbixcclxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xyXG4gIGNvbnN0IGluQ2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IGlucHV0c1swXS5kaW1zWzNdIDogaW5wdXRzWzBdLmRpbXNbMV07XHJcbiAgY29uc3QgYmF0Y2hTaXplID0gb3V0cHV0U2hhcGVbMF07XHJcbiAgY29uc3Qgb3V0V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzJdIDogb3V0cHV0U2hhcGVbM107XHJcbiAgY29uc3Qgb3V0SGVpZ2h0ID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVsxXSA6IG91dHB1dFNoYXBlWzJdO1xyXG4gIGNvbnN0IG91dENoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVszXSA6IG91dHB1dFNoYXBlWzFdO1xyXG4gIC8vIFRPRE86IGVuYWJsZSB2ZWM0IGZvciBOQ0hXXHJcbiAgY29uc3QgaXNWZWM0ID0gaXNDaGFubmVsc0xhc3QgJiYgKGluQ2hhbm5lbHMgJSA0ID09PSAwIHx8IGluQ2hhbm5lbHMgJSAzID09PSAwKSAmJiBvdXRDaGFubmVscyAlIDQgPT09IDA7XHJcblxyXG4gIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXHJcbiAgY29uc3QgZGlzcGF0Y2hYID0gaXNDaGFubmVsc0xhc3QgPyBvdXRDaGFubmVscyA6IG91dFdpZHRoICogb3V0SGVpZ2h0O1xyXG4gIGNvbnN0IGRpc3BhdGNoWSA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0V2lkdGggKiBvdXRIZWlnaHQgOiBvdXRDaGFubmVscztcclxuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XHJcbiAgY29uc3QgZWxlbWVudHNQZXJUaHJlYWQgPSBkaW1BT3V0ZXIgPD0gOCA/IFs0LCAxLCAxXSA6IFs0LCA0LCAxXTtcclxuICBjb25zdCBkaXNwYXRjaCA9IFtcclxuICAgIE1hdGguY2VpbChkaXNwYXRjaFggLyB3b3JrR3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxyXG4gICAgTWF0aC5jZWlsKGRpc3BhdGNoWSAvIHdvcmtHcm91cFNpemVbMV0gLyBlbGVtZW50c1BlclRocmVhZFsxXSksXHJcbiAgICBNYXRoLmNlaWwoYmF0Y2hTaXplIC8gd29ya0dyb3VwU2l6ZVsyXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzJdKSxcclxuICBdO1xyXG5cclxuICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW2NvbnYyZF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcclxuXHJcbiAgY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9IGlzVmVjNCA/IChpc0NoYW5uZWxzTGFzdCAmJiBpbkNoYW5uZWxzICUgNCAhPT0gMCA/IDMgOiA0KSA6IDE7XHJcbiAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtHcm91cFNpemVbMV0gKiBlbGVtZW50c1BlclRocmVhZFsxXTtcclxuICBjb25zdCB0aWxlQk91dGVyID0gd29ya0dyb3VwU2l6ZVswXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzBdO1xyXG4gIGNvbnN0IHRpbGVJbm5lciA9IE1hdGgubWF4KHdvcmtHcm91cFNpemVbMF0gKiBpbm5lckVsZW1lbnRTaXplLCB3b3JrR3JvdXBTaXplWzFdKTtcclxuICBjb25zdCBmaXRBT3V0ZXIgPSBkaW1BT3V0ZXIgJSB0aWxlQU91dGVyID09PSAwO1xyXG4gIGNvbnN0IGZpdEJPdXRlciA9IGRpbUJPdXRlciAlIHRpbGVCT3V0ZXIgPT09IDA7XHJcbiAgY29uc3QgZml0SW5uZXIgPSBkaW1Jbm5lciAlIHRpbGVJbm5lciA9PT0gMDtcclxuICBjb25zdCBlbGVtZW50c1NpemUgPSBpc1ZlYzQgPyBbaW5uZXJFbGVtZW50U2l6ZSwgNCwgNF0gOiBbMSwgMSwgMV07XHJcblxyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUFPdXRlciB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQk91dGVyIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1Jbm5lciB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMucGFkc1swXSwgYXR0cmlidXRlcy5wYWRzWzFdXSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucyB9LFxyXG4gIF07XHJcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcykpO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcclxuICBpZiAoaGFzQmlhcykge1xyXG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcclxuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcclxuICB9XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ2RpbV9hX291dGVyJywgdHlwZTogJ2kzMicgfSxcclxuICAgICAgeyBuYW1lOiAnZGltX2Jfb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdkaW1faW5uZXInLCB0eXBlOiAnaTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdwYWQnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXHJcbiAgICAgIHsgbmFtZTogJ3N0cmlkZScsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcclxuICAgICAgeyBuYW1lOiAnZGlsYXRpb24nLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXHJcbiAgICBdO1xyXG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcclxuXHJcbiAgICAvLyBUT0RPOiBzdXBwb3J0IGNvbXBvbmVudCAyLCAzLlxyXG4gICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xyXG4gICAgY29uc3QgdCA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG4gICAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSBgXHJcbiAgICAgIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0pIHtcclxuICAgICAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0odmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0pIHtcclxuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xyXG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7aXNWZWM0ID8gJy8gNCcgOiAnJ30sIHZhbHVlKTtcclxuICAgICAgfWA7XHJcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZShcclxuICAgICAgJ3gnLFxyXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXHJcbiAgICAgIGlucHV0c1swXS5kaW1zLmxlbmd0aCxcclxuICAgICAgaW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/IDEgOiBpbm5lckVsZW1lbnRTaXplLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHcgPSBpbnB1dFZhcmlhYmxlKCd3JywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbeCwgd107XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgaWYgKGhhc0JpYXMpIHtcclxuICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goYmlhcyk7XHJcbiAgICAgIGRlY2xhcmVGdW5jdGlvbnMgKz0gYFxyXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0ge1xyXG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7aXNDaGFubmVsc0xhc3QgPyAndycgOiAneSd9JHtpc1ZlYzQgPyAnLyA0JyA6ICcnfV07XHJcbiAgICAgICAgfWA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICAke3V0aWxGdW5jdGlvbnMoJ3VuaWZvcm1zLnJlc3VsdF9zdHJpZGVzJyl9XHJcbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXHJcbiAgICAgICAgLy8gIG91dFNoYXBlU3RyaWRlczogdmVjMzxpMzI+LCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIHN0cmlkZSA6IHZlYzI8aTMyPixcclxuICAgICAgICAvLyAgZGlsYXRpb24gOiB2ZWMyPGkzMj4sIGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMiB9O1xyXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XHJcbiAgICAgICAgJHtkZWNsYXJlRnVuY3Rpb25zfVxyXG4gICAgICAgICR7Y29udjJkQ29tbW9uU25pcHBldChcclxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LFxyXG4gICAgICAgICAgZml0QU91dGVyLFxyXG4gICAgICAgICAgZml0Qk91dGVyLFxyXG4gICAgICAgICAgZml0SW5uZXIsXHJcbiAgICAgICAgICBoYXNCaWFzLFxyXG4gICAgICAgICAgYXR0cmlidXRlcyxcclxuICAgICAgICAgIGVsZW1lbnRzU2l6ZVswXSxcclxuICAgICAgICAgIGVsZW1lbnRzU2l6ZVsxXSxcclxuICAgICAgICAgIGVsZW1lbnRzU2l6ZVsyXSxcclxuICAgICAgICAgIHQsXHJcbiAgICAgICAgKX1cclxuICAgICAgICAke1xyXG4gICAgICAgICAgaXNWZWM0XHJcbiAgICAgICAgICAgID8gbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UoZWxlbWVudHNQZXJUaHJlYWQsIHdvcmtHcm91cFNpemUsIHQsIHVuZGVmaW5lZCwgIWlzQ2hhbm5lbHNMYXN0LCB0aWxlSW5uZXIpXHJcbiAgICAgICAgICAgIDogbWFrZU1hdE11bFBhY2tlZFNvdXJjZShcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLFxyXG4gICAgICAgICAgICAgICAgd29ya0dyb3VwU2l6ZSxcclxuICAgICAgICAgICAgICAgIHQsXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAhaXNDaGFubmVsc0xhc3QsXHJcbiAgICAgICAgICAgICAgICB0aWxlSW5uZXIsXHJcbiAgICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMsXHJcbiAgICAgICAgICAgICAgKVxyXG4gICAgICAgIH1gO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdDb252MkRNYXRNdWwnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpbm5lckVsZW1lbnRTaXplfTske2lzVmVjNH07JHtmaXRBT3V0ZXJ9OyR7Zml0Qk91dGVyfTske2ZpdElubmVyfTske3RpbGVBT3V0ZXJ9OyR7dGlsZUJPdXRlcn07JHt0aWxlSW5uZXJ9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXMsXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG4iLCAiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqL1xyXG5cclxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252M2RfbmFpdmVfd2ViZ3B1LnRzXHJcbi8vXHJcbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcclxuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uLy4uL3R5cGVzJztcclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBnZXRFbGVtZW50QXQsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udic7XHJcbmltcG9ydCB7IGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcywgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSwgZ2V0QWN0aXZhdGlvblNuaXBwZXQgfSBmcm9tICcuLi9mdXNlLXV0aWxzJztcclxuXHJcbmltcG9ydCB7IHR5cGVTbmlwcGV0IH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xyXG5cclxuY29uc3QgYXJyYXlQcm9kdWN0ID0gKGFycjogbnVtYmVyW10pID0+IHtcclxuICBsZXQgcHJvZHVjdCA9IDE7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgIHByb2R1Y3QgKj0gYXJyW2ldO1xyXG4gIH1cclxuICByZXR1cm4gcHJvZHVjdDtcclxufTtcclxuXHJcbmNvbnN0IHBhcnNlM1R1cGxlUGFyYW0gPSAocGFyYW06IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9PlxyXG4gIHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgPyBbcGFyYW0sIHBhcmFtLCBwYXJhbV0gOiBwYXJhbTtcclxuXHJcbmNvbnN0IGdldEVmZmVjdGl2ZUZpbHRlclNpemUgPSAoZmlsdGVyU2l6ZTogbnVtYmVyLCBkaWxhdGlvbjogbnVtYmVyKTogbnVtYmVyID0+IHtcclxuICBpZiAoZGlsYXRpb24gPD0gMSkge1xyXG4gICAgcmV0dXJuIGZpbHRlclNpemU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmlsdGVyU2l6ZSArIChmaWx0ZXJTaXplIC0gMSkgKiAoZGlsYXRpb24gLSAxKTtcclxufTtcclxuXHJcbmNvbnN0IGNvbXB1dGVEZWZhdWx0UGFkID0gKFxyXG4gIGlucHV0U2hhcGU6IFtudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICBmaWVsZFNpemU6IG51bWJlcixcclxuICBzdHJpZGU6IG51bWJlcixcclxuICBkaWxhdGlvbiA9IDEsXHJcbik6IG51bWJlciA9PiB7XHJcbiAgY29uc3QgZWZmZWN0aXZlRmllbGRTaXplID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWVsZFNpemUsIGRpbGF0aW9uKTtcclxuICByZXR1cm4gTWF0aC5mbG9vcigoaW5wdXRTaGFwZVswXSAqIChzdHJpZGUgLSAxKSAtIHN0cmlkZSArIGVmZmVjdGl2ZUZpZWxkU2l6ZSkgLyAyKTtcclxufTtcclxuXHJcbmNvbnN0IGNvbXB1dGVPdXRwdXRTaGFwZTREID0gKFxyXG4gIGluU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gIGZpbHRlclNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgb3V0Q2hhbm5lbHM6IG51bWJlcixcclxuICBzdHJpZGVzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgemVyb1BhZD86IG51bWJlcixcclxuKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPT4ge1xyXG4gIGlmICh6ZXJvUGFkID09IG51bGwpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgemVyb1BhZCA9IGNvbXB1dGVEZWZhdWx0UGFkKGluU2hhcGUsIGZpbHRlclNoYXBlWzBdLCBzdHJpZGVzWzBdKTtcclxuICB9XHJcbiAgY29uc3Qgb3V0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIDAsIG91dENoYW5uZWxzXTtcclxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgMzsgaW5kZXgrKykge1xyXG4gICAgaWYgKGluU2hhcGVbaW5kZXhdICsgMiAqIHplcm9QYWQgPj0gZmlsdGVyU2hhcGVbaW5kZXhdKSB7XHJcbiAgICAgIG91dFNoYXBlW2luZGV4XSA9IE1hdGgudHJ1bmMoKGluU2hhcGVbaW5kZXhdIC0gZmlsdGVyU2hhcGVbaW5kZXhdICsgMiAqIHplcm9QYWQpIC8gc3RyaWRlc1tpbmRleF0gKyAxKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG91dFNoYXBlO1xyXG59O1xyXG5cclxuY29uc3QgZ2V0M0RQYWRBbmRPdXRJbmZvID0gKFxyXG4gIHBhZDogbnVtYmVyIHwgc3RyaW5nIHwgbnVtYmVyW10sXHJcbiAgaW5EZXB0aDogbnVtYmVyLFxyXG4gIGluSGVpZ2h0OiBudW1iZXIsXHJcbiAgaW5XaWR0aDogbnVtYmVyLFxyXG4gIHN0cmlkZURlcHRoOiBudW1iZXIsXHJcbiAgc3RyaWRlSGVpZ2h0OiBudW1iZXIsXHJcbiAgc3RyaWRlV2lkdGg6IG51bWJlcixcclxuICBmaWx0ZXJEZXB0aDogbnVtYmVyLFxyXG4gIGZpbHRlckhlaWdodDogbnVtYmVyLFxyXG4gIGZpbHRlcldpZHRoOiBudW1iZXIsXHJcbik6IHsgcGFkSW5mbzogUGFkSW5mbzNEOyBvdXREZXB0aDogbnVtYmVyOyBvdXRIZWlnaHQ6IG51bWJlcjsgb3V0V2lkdGg6IG51bWJlciB9ID0+IHtcclxuICBsZXQgcGFkSW5mbzogUGFkSW5mbzNEO1xyXG4gIGxldCBvdXREZXB0aDogbnVtYmVyO1xyXG4gIGxldCBvdXRIZWlnaHQ6IG51bWJlcjtcclxuICBsZXQgb3V0V2lkdGg6IG51bWJlcjtcclxuXHJcbiAgaWYgKHBhZCA9PT0gJ1ZBTElEJykge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXHJcbiAgICBwYWQgPSAwO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBwYWQgPT09ICdudW1iZXInKSB7XHJcbiAgICBwYWRJbmZvID0geyB0b3A6IHBhZCwgYm90dG9tOiBwYWQsIGxlZnQ6IHBhZCwgcmlnaHQ6IHBhZCwgZnJvbnQ6IHBhZCwgYmFjazogcGFkIH07XHJcbiAgICBjb25zdCBvdXRTaGFwZSA9IGNvbXB1dGVPdXRwdXRTaGFwZTREKFxyXG4gICAgICBbaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIDFdLFxyXG4gICAgICBbZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGhdLFxyXG4gICAgICAxLFxyXG4gICAgICBbc3RyaWRlRGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGhdLFxyXG4gICAgICBwYWQsXHJcbiAgICApO1xyXG4gICAgb3V0RGVwdGggPSBvdXRTaGFwZVswXTtcclxuICAgIG91dEhlaWdodCA9IG91dFNoYXBlWzFdO1xyXG4gICAgb3V0V2lkdGggPSBvdXRTaGFwZVsyXTtcclxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFkKSkge1xyXG4gICAgaWYgKCFwYWQuZXZlcnkoKHZhbCwgXywgYXJyKSA9PiB2YWwgPT09IGFyclswXSkpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHBhZGRpbmcgcGFyYW1ldGVyOiAke3BhZH1gKTtcclxuICAgIH1cclxuICAgIHBhZEluZm8gPSB7IHRvcDogcGFkWzBdLCBib3R0b206IHBhZFsxXSwgbGVmdDogcGFkWzJdLCByaWdodDogcGFkWzNdLCBmcm9udDogcGFkWzRdLCBiYWNrOiBwYWRbNV0gfTtcclxuICAgIGNvbnN0IG91dFNoYXBlID0gY29tcHV0ZU91dHB1dFNoYXBlNEQoXHJcbiAgICAgIFtpbkRlcHRoLCBpbkhlaWdodCwgaW5XaWR0aCwgMV0sXHJcbiAgICAgIFtmaWx0ZXJEZXB0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aF0sXHJcbiAgICAgIDEsXHJcbiAgICAgIFtzdHJpZGVEZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aF0sXHJcbiAgICAgIHBhZFswXSxcclxuICAgICk7XHJcbiAgICBvdXREZXB0aCA9IG91dFNoYXBlWzBdO1xyXG4gICAgb3V0SGVpZ2h0ID0gb3V0U2hhcGVbMV07XHJcbiAgICBvdXRXaWR0aCA9IG91dFNoYXBlWzJdO1xyXG4gIH0gZWxzZSBpZiAocGFkID09PSAnU0FNRV9VUFBFUicpIHtcclxuICAgIC8vIFRPRE86IHN1cHBvcnQgJ1NBTUVfTE9XRVInLlxyXG4gICAgb3V0RGVwdGggPSBNYXRoLmNlaWwoaW5EZXB0aCAvIHN0cmlkZURlcHRoKTtcclxuICAgIG91dEhlaWdodCA9IE1hdGguY2VpbChpbkhlaWdodCAvIHN0cmlkZUhlaWdodCk7XHJcbiAgICBvdXRXaWR0aCA9IE1hdGguY2VpbChpbldpZHRoIC8gc3RyaWRlV2lkdGgpO1xyXG4gICAgY29uc3QgcGFkQWxvbmdEZXB0aCA9IChvdXREZXB0aCAtIDEpICogc3RyaWRlRGVwdGggKyBmaWx0ZXJEZXB0aCAtIGluRGVwdGg7XHJcbiAgICBjb25zdCBwYWRBbG9uZ0hlaWdodCA9IChvdXRIZWlnaHQgLSAxKSAqIHN0cmlkZUhlaWdodCArIGZpbHRlckhlaWdodCAtIGluSGVpZ2h0O1xyXG4gICAgY29uc3QgcGFkQWxvbmdXaWR0aCA9IChvdXRXaWR0aCAtIDEpICogc3RyaWRlV2lkdGggKyBmaWx0ZXJXaWR0aCAtIGluV2lkdGg7XHJcbiAgICBjb25zdCBmcm9udCA9IE1hdGguZmxvb3IocGFkQWxvbmdEZXB0aCAvIDIpO1xyXG4gICAgY29uc3QgYmFjayA9IHBhZEFsb25nRGVwdGggLSBmcm9udDtcclxuICAgIGNvbnN0IHRvcCA9IE1hdGguZmxvb3IocGFkQWxvbmdIZWlnaHQgLyAyKTtcclxuICAgIGNvbnN0IGJvdHRvbSA9IHBhZEFsb25nSGVpZ2h0IC0gdG9wO1xyXG4gICAgY29uc3QgbGVmdCA9IE1hdGguZmxvb3IocGFkQWxvbmdXaWR0aCAvIDIpO1xyXG4gICAgY29uc3QgcmlnaHQgPSBwYWRBbG9uZ1dpZHRoIC0gbGVmdDtcclxuXHJcbiAgICBwYWRJbmZvID0geyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQsIGZyb250LCBiYWNrIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IEVycm9yKGBVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiAke3BhZH1gKTtcclxuICB9XHJcbiAgcmV0dXJuIHsgcGFkSW5mbywgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGggfTtcclxufTtcclxuXHJcbnR5cGUgUGFkSW5mbzNEID0ge1xyXG4gIHRvcDogbnVtYmVyO1xyXG4gIGxlZnQ6IG51bWJlcjtcclxuICByaWdodDogbnVtYmVyO1xyXG4gIGJvdHRvbTogbnVtYmVyO1xyXG4gIGZyb250OiBudW1iZXI7XHJcbiAgYmFjazogbnVtYmVyO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgQ29udjNESW5mbyA9IHtcclxuICBiYXRjaFNpemU6IG51bWJlcjtcclxuICBpbkRlcHRoOiBudW1iZXI7XHJcbiAgaW5IZWlnaHQ6IG51bWJlcjtcclxuICBpbldpZHRoOiBudW1iZXI7XHJcbiAgaW5DaGFubmVsczogbnVtYmVyO1xyXG4gIG91dERlcHRoOiBudW1iZXI7XHJcbiAgb3V0SGVpZ2h0OiBudW1iZXI7XHJcbiAgb3V0V2lkdGg6IG51bWJlcjtcclxuICBvdXRDaGFubmVsczogbnVtYmVyO1xyXG4gIGRhdGFGb3JtYXQ6ICdjaGFubmVsc0ZpcnN0JyB8ICdjaGFubmVsc0xhc3QnO1xyXG4gIHN0cmlkZURlcHRoOiBudW1iZXI7XHJcbiAgc3RyaWRlSGVpZ2h0OiBudW1iZXI7XHJcbiAgc3RyaWRlV2lkdGg6IG51bWJlcjtcclxuICBkaWxhdGlvbkRlcHRoOiBudW1iZXI7XHJcbiAgZGlsYXRpb25IZWlnaHQ6IG51bWJlcjtcclxuICBkaWxhdGlvbldpZHRoOiBudW1iZXI7XHJcbiAgZmlsdGVyRGVwdGg6IG51bWJlcjtcclxuICBmaWx0ZXJIZWlnaHQ6IG51bWJlcjtcclxuICBmaWx0ZXJXaWR0aDogbnVtYmVyO1xyXG4gIGVmZmVjdGl2ZUZpbHRlckRlcHRoOiBudW1iZXI7XHJcbiAgZWZmZWN0aXZlRmlsdGVySGVpZ2h0OiBudW1iZXI7XHJcbiAgZWZmZWN0aXZlRmlsdGVyV2lkdGg6IG51bWJlcjtcclxuICBwYWRJbmZvOiBQYWRJbmZvM0Q7XHJcbiAgaW5TaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuICBvdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuICBmaWx0ZXJTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb21wdXRlQ29udjNESW5mbyA9IChcclxuICBpblNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gIGZpbHRlclNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gIHN0cmlkZXM6IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICBkaWxhdGlvbnM6IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICBwYWQ6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdLFxyXG4gIGRlcHRod2lzZSA9IGZhbHNlLFxyXG4gIGRhdGFGb3JtYXQ6ICdjaGFubmVsc0ZpcnN0JyB8ICdjaGFubmVsc0xhc3QnID0gJ2NoYW5uZWxzTGFzdCcsXHJcbik6IENvbnYzREluZm8gPT4ge1xyXG4gIGxldCBiYXRjaFNpemUsIGluRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCBpbkNoYW5uZWxzO1xyXG4gIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xyXG4gICAgW2JhdGNoU2l6ZSwgaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIGluQ2hhbm5lbHNdID0gaW5TaGFwZTtcclxuICB9IGVsc2UgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xyXG4gICAgW2JhdGNoU2l6ZSwgaW5DaGFubmVscywgaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGhdID0gaW5TaGFwZTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGFGb3JtYXQgJHtkYXRhRm9ybWF0fWApO1xyXG4gIH1cclxuICBjb25zdCBbZmlsdGVyQ2hhbm5lbHMsICwgZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGhdID0gZmlsdGVyU2hhcGU7XHJcblxyXG4gIGNvbnN0IFtzdHJpZGVEZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aF0gPSBwYXJzZTNUdXBsZVBhcmFtKHN0cmlkZXMpO1xyXG4gIGNvbnN0IFtkaWxhdGlvbkRlcHRoLCBkaWxhdGlvbkhlaWdodCwgZGlsYXRpb25XaWR0aF0gPSBwYXJzZTNUdXBsZVBhcmFtKGRpbGF0aW9ucyk7XHJcblxyXG4gIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRlcHRoID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJEZXB0aCwgZGlsYXRpb25EZXB0aCk7XHJcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJIZWlnaHQsIGRpbGF0aW9uSGVpZ2h0KTtcclxuICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJXaWR0aCA9IGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmlsdGVyV2lkdGgsIGRpbGF0aW9uV2lkdGgpO1xyXG4gIGNvbnN0IHsgcGFkSW5mbywgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGggfSA9IGdldDNEUGFkQW5kT3V0SW5mbyhcclxuICAgIHBhZCxcclxuICAgIGluRGVwdGgsXHJcbiAgICBpbkhlaWdodCxcclxuICAgIGluV2lkdGgsXHJcbiAgICBzdHJpZGVEZXB0aCxcclxuICAgIHN0cmlkZUhlaWdodCxcclxuICAgIHN0cmlkZVdpZHRoLFxyXG4gICAgZWZmZWN0aXZlRmlsdGVyRGVwdGgsXHJcbiAgICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQsXHJcbiAgICBlZmZlY3RpdmVGaWx0ZXJXaWR0aCxcclxuICApO1xyXG5cclxuICBjb25zdCBvdXRDaGFubmVscyA9IGRlcHRod2lzZSA/IGZpbHRlckNoYW5uZWxzICogaW5DaGFubmVscyA6IGZpbHRlckNoYW5uZWxzO1xyXG5cclxuICBsZXQgb3V0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbMCwgMCwgMCwgMCwgMF07XHJcbiAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xyXG4gICAgb3V0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRDaGFubmVscywgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGhdO1xyXG4gIH0gZWxzZSBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcclxuICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBiYXRjaFNpemUsXHJcbiAgICBkYXRhRm9ybWF0LFxyXG4gICAgaW5EZXB0aCxcclxuICAgIGluSGVpZ2h0LFxyXG4gICAgaW5XaWR0aCxcclxuICAgIGluQ2hhbm5lbHMsXHJcbiAgICBvdXREZXB0aCxcclxuICAgIG91dEhlaWdodCxcclxuICAgIG91dFdpZHRoLFxyXG4gICAgb3V0Q2hhbm5lbHMsXHJcbiAgICBwYWRJbmZvLFxyXG4gICAgc3RyaWRlRGVwdGgsXHJcbiAgICBzdHJpZGVIZWlnaHQsXHJcbiAgICBzdHJpZGVXaWR0aCxcclxuICAgIGZpbHRlckRlcHRoLFxyXG4gICAgZmlsdGVySGVpZ2h0LFxyXG4gICAgZmlsdGVyV2lkdGgsXHJcbiAgICBlZmZlY3RpdmVGaWx0ZXJEZXB0aCxcclxuICAgIGVmZmVjdGl2ZUZpbHRlckhlaWdodCxcclxuICAgIGVmZmVjdGl2ZUZpbHRlcldpZHRoLFxyXG4gICAgZGlsYXRpb25EZXB0aCxcclxuICAgIGRpbGF0aW9uSGVpZ2h0LFxyXG4gICAgZGlsYXRpb25XaWR0aCxcclxuICAgIGluU2hhcGUsXHJcbiAgICBvdXRTaGFwZSxcclxuICAgIGZpbHRlclNoYXBlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcclxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgZmlsdGVyRGltczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgcGFkczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgZGF0YUZvcm1hdDogc3RyaW5nLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnO1xyXG4gIGNvbnN0IGluQ2hhbm5lbHMgPSBpc0NoYW5uZWxMYXN0ID8gaW5wdXRzWzBdLmRpbXNbM10gOiBpbnB1dHNbMF0uZGltc1sxXTtcclxuICAvLyBUT0RPOiBlbmFibGUgdmVjNC5cclxuICBjb25zdCBpc1ZlYzQgPSBmYWxzZTtcclxuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNjQsIDEsIDFdO1xyXG4gIGNvbnN0IGRpc3BhdGNoTGF5b3V0ID0geyB4OiBvdXRwdXRTaGFwZS5tYXAoKF8sIGkpID0+IGkpIH07XHJcbiAgY29uc3QgZGlzcGF0Y2ggPSBbTWF0aC5jZWlsKGFycmF5UHJvZHVjdChkaXNwYXRjaExheW91dC54Lm1hcCgoZCkgPT4gb3V0cHV0U2hhcGVbZF0pKSAvIHdvcmtHcm91cFNpemVbMF0pLCAxLCAxXTtcclxuXHJcbiAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252M2RfbmFpdmVfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7ZGlzcGF0Y2h9YCk7XHJcblxyXG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSBpc1ZlYzQgPyAoaXNDaGFubmVsTGFzdCAmJiBpbkNoYW5uZWxzICUgNCAhPT0gMCA/IDMgOiA0KSA6IDE7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGZpbHRlckRpbXMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYWRzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5kaWxhdGlvbnMgfSxcclxuICBdO1xyXG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpKTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XHJcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XHJcbiAgaWYgKGhhc0JpYXMpIHtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XHJcbiAgfVxyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2ZpbHRlcl9kaW1zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZmlsdGVyRGltcy5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHBhZHMubGVuZ3RoIH0sXHJcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIH0sXHJcbiAgICAgIHsgbmFtZTogJ2RpbGF0aW9ucycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCB9LFxyXG4gICAgXTtcclxuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XHJcbiAgICAvLyBUT0RPOiBzdXBwb3J0IGNvbXBvbmVudCAyLCAzLlxyXG4gICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xyXG4gICAgY29uc3QgdCA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG5cclxuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKFxyXG4gICAgICAneCcsXHJcbiAgICAgIGlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICAgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLFxyXG4gICAgICBpbm5lckVsZW1lbnRTaXplID09PSAzID8gMSA6IGlubmVyRWxlbWVudFNpemUsXHJcbiAgICApO1xyXG4gICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ1cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBsZXQgZGVjbGFyZUZ1bmN0aW9ucyA9ICcnO1xyXG4gICAgaWYgKGhhc0JpYXMpIHtcclxuICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goYmlhcyk7XHJcbiAgICAgIGRlY2xhcmVGdW5jdGlvbnMgKz0gYFxyXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiBhcnJheTx1MzIsIDU+KSAtPiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9IHtcclxuICAgICAgICAgIHJldHVybiBiaWFzWyR7aXNDaGFubmVsTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgNCwgNSkgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIDUpfSR7XHJcbiAgICAgICAgICAgIGlzVmVjNCA/ICcvIDQnIDogJydcclxuICAgICAgICAgIH1dO1xyXG4gICAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzVHlwZSA9IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemUsIHQpO1xyXG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgcmVzVHlwZSwgdCk7XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgJHtkZWNsYXJlRnVuY3Rpb25zfVxyXG4gICAgICAgICAgICBmbiBnZXRYKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcclxuICAgICAgICAgICAgICBsZXQgYUluZGljZXMgPSBhcnJheTx1MzIsIDU+KGQwLCBkMSwgZDIsIGQzLCBkNCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICR7eC5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZuIGdldFcoZDAgOiB1MzIsIGQxIDogdTMyLCBkMiA6IHUzMiwgZDMgOiB1MzIsIGQ0IDogdTMyKSAtPiBmMzIge1xyXG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcclxuICAgICAgICAgICAgICByZXR1cm4gJHt3LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XHJcbiAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcbiAgICAgICAgICAgICAgbGV0IGNvb3JkcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke2dldEVsZW1lbnRBdCgnY29vcmRzJywgMCwgeC5yYW5rKX07XHJcbiAgICAgICAgICAgICAgbGV0IGQyID0gJHtcclxuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3QgPyBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIHgucmFuayAtIDEsIHgucmFuaykgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIHgucmFuaylcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGxldCB4RlJDQ29ybmVyID0gdmVjMzx1MzI+KCR7XHJcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAxLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAyLCB4LnJhbmspXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAke2lzQ2hhbm5lbExhc3QgPyBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDIsIHgucmFuaykgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDMsIHgucmFuayl9LFxyXG4gICAgICAgICAgICAgICR7XHJcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCA0LCB4LnJhbmspXHJcbiAgICAgICAgICAgICAgfSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcclxuICAgICAgICAgICAgICBsZXQgeEZDb3JuZXIgPSB4RlJDQ29ybmVyLng7XHJcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xyXG4gICAgICAgICAgICAgIGxldCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcclxuICAgICAgICAgICAgICBsZXQgeFNoYXBlWSA9ICR7XHJcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XHJcbiAgICAgICAgICAgICAgICAgID8gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMSwgeC5yYW5rKVxyXG4gICAgICAgICAgICAgICAgICA6IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDIsIHgucmFuaylcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGxldCB4U2hhcGVaID0gJHtcclxuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcclxuICAgICAgICAgICAgICAgICAgPyBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAyLCB4LnJhbmspXHJcbiAgICAgICAgICAgICAgICAgIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMywgeC5yYW5rKVxyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVcgPSAke1xyXG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxyXG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDMsIHgucmFuaylcclxuICAgICAgICAgICAgICAgICAgOiBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCA0LCB4LnJhbmspXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICBsZXQgeFNoYXBlVSA9ICR7XHJcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XHJcbiAgICAgICAgICAgICAgICAgID8gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgNCwgeC5yYW5rKVxyXG4gICAgICAgICAgICAgICAgICA6IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDEsIHgucmFuaylcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgPSAoeFNoYXBlVSAvIDQpICogNDtcclxuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSB4U2hhcGVVICUgNDtcclxuXHJcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gMC4wO1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIHdGID0gMHU7IHdGIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdGKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB4RiA9IHhGQ29ybmVyICsgd0YgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoeEYgPCAwIHx8IHhGID49IHhTaGFwZVkpIHtcclxuICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwdTsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd1IrKykge1xyXG4gICAgICAgICAgICAgICAgICBsZXQgeFIgPSB4UkNvcm5lciArIHdSICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IHhTaGFwZVopIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwdTsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1syXTsgd0MrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB4QyA9IHhDQ29ybmVyICsgd0MgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSB4U2hhcGVXKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMHU7IGQxIDwgaW5wdXREZXB0aE5lYXJlc3RWZWM0OyBkMSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogYGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhGLCB4UiwgeEMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAxLCB4RiwgeFIsIHhDKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeEYsIHhSLCB4QyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhGLCB4UiwgeEMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjNDxmMzI+KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSwgd0YsIHdSLCB3QyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMSwgd0YsIHdSLCB3QyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMiwgd0YsIHdSLCB3QyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMywgd0YsIHdSLCB3QykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYHZhbHVlICs9IGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgdmFsdWUgKz0gZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICogZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKTtgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICR7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogYGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB4RiwgeFIsIHhDKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYFxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMjxmMzI+KFxyXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcclxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICR7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXQgeFZhbHVlcyA9IHZlYzM8ZjMyPihcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXQgeFZhbHVlcyA9IHZlYzM8ZjMyPihcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHhGLCB4UiwgeEMpKTtcclxuICAgICAgICAgICAgICAgICAgICBgXHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMzPGYzMj4oXHJcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QyksXHJcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB3Riwgd1IsIHdDKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICR7aGFzQmlhcyA/ICd2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyknIDogJyd9O1xyXG4gICAgICAgICAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxyXG4gICAgICAgICAgICAgIHJlc3VsdFtnbG9iYWxfaWR4XSA9IGYzMih2YWx1ZSk7XHJcbiAgICAgICAgICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnQ29udjNETmFpdmUnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpc0NoYW5uZWxMYXN0fTske2lubmVyRWxlbWVudFNpemV9OyR7aGFzQmlhc31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgZ2V0TWF4Q29tcG9uZW50cyxcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XHJcbmltcG9ydCB7IGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcywgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSwgZ2V0QWN0aXZhdGlvblNuaXBwZXQgfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIG5haXZlIGdyb3VwZWQgY29udiBpbXBsZW1lbnRhdGlvbiwgc3VwcG9ydHMgMWQvMmQgY29udlxyXG4gKiBAcGFyYW0gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gLSBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBzcXVlZXplIHRoZSBvdXRwdXQgc2hhcGUsIG9ubHkgdXNlZCBpbiBjb252MWRcclxuICovXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxyXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xyXG4gIGNvbnN0IHByb2Nlc3NCaWFzID0gaGFzQmlhcyA/ICd2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTsnIDogJyc7XHJcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3Qgd1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XHJcblxyXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xyXG4gIGNvbnN0IG91dHB1dENoYW5uZWxzID0gaXNDaGFubmVsTGFzdCA/IG91dHB1dFNoYXBlWzNdIDogb3V0cHV0U2hhcGVbMV07XHJcbiAgY29uc3Qgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9IG91dHB1dENoYW5uZWxzIC8gYXR0cmlidXRlcy5ncm91cDtcclxuICBjb25zdCBjb21wb25lbnRzID0gaXNDaGFubmVsTGFzdCAmJiBvdXRwdXRDaGFubmVsc1Blckdyb3VwID49IDQgPyBnZXRNYXhDb21wb25lbnRzKG91dHB1dENoYW5uZWxzKSA6IDE7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHM7XHJcblxyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5kaWxhdGlvbnMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5zdHJpZGVzWzBdLCBhdHRyaWJ1dGVzLnN0cmlkZXNbMV1dIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMucGFkc1swXSwgYXR0cmlidXRlcy5wYWRzWzFdXSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgfSxcclxuICBdO1xyXG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaChcclxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHhTaGFwZSwgW3dTaGFwZVswXSwgd1NoYXBlWzFdLCB3U2hhcGVbMl0sIHdTaGFwZVszXSAvIGNvbXBvbmVudHNdKSxcclxuICApO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gaGFzQmlhcyA/IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXSA6IFsncmFuaycsICdyYW5rJ107XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzFdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM10gLyBjb21wb25lbnRzXSksXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcclxuICAgIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlLCBiYXNlVHlwZSk7XHJcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgeFNoYXBlLmxlbmd0aCk7XHJcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgd1NoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBpbnB1dFZhcnMgPSBbeCwgd107XHJcbiAgICBpZiAoaGFzQmlhcykge1xyXG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cykpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IDIgfSxcclxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IDIgfSxcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICBdO1xyXG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcclxuXHJcbiAgICBjb25zdCBjYWxjdWxhdGVSZXN1bHQgPSBpc0NoYW5uZWxMYXN0XHJcbiAgICAgID8gYFxyXG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMF07IHdIZWlnaHQrKykge1xyXG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xyXG5cclxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsxXSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3V2lkdGgrKykge1xyXG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xyXG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0luQ2hhbm5lbCsrKSB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xyXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7eC5nZXQoJ2JhdGNoJywgJ3hIZWlnaHQnLCAneFdpZHRoJywgJ2lucHV0X2NoYW5uZWwnKX07XHJcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHt3LmdldCgnd0hlaWdodCcsICd3V2lkdGgnLCAnd0luQ2hhbm5lbCcsICdvdXRwdXRfY2hhbm5lbCcpfTtcclxuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGBcclxuICAgICAgOiBgXHJcbiAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd0luQ2hhbm5lbCsrKSB7XHJcbiAgICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBpbl9jaGFubmVsX29mZnNldCArIHdJbkNoYW5uZWw7XHJcbiAgICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcclxuICAgICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xyXG5cclxuICAgICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbM107IHdXaWR0aCsrKSB7XHJcbiAgICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcclxuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzNdKSB7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCB4VmFsID0gJHt4LmdldCgnYmF0Y2gnLCAnaW5wdXRfY2hhbm5lbCcsICd4SGVpZ2h0JywgJ3hXaWR0aCcpfTtcclxuICAgICAgICAgICAgbGV0IHdWYWwgPSAke3cuZ2V0KCdvdXRwdXRfY2hhbm5lbCcsICd3SW5DaGFubmVsJywgJ3dIZWlnaHQnLCAnd1dpZHRoJyl9O1xyXG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYDtcclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XHJcblxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuXHJcbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcclxuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske2lzQ2hhbm5lbExhc3QgPyAzIDogMX1dO1xyXG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHtpc0NoYW5uZWxMYXN0ID8gMSA6IDJ9XSwgb3V0cHV0SW5kaWNlc1ske1xyXG4gICAgICBpc0NoYW5uZWxMYXN0ID8gMiA6IDNcclxuICAgIH1dKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xyXG4gICAgbGV0IGdyb3VwX2lkOiB1MzIgPSBvdXRwdXRfY2hhbm5lbCAqICR7Y29tcG9uZW50c30gLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xyXG4gICAgdmFyIGluX2NoYW5uZWxfb2Zmc2V0ID0gZ3JvdXBfaWQgKiB1bmlmb3Jtcy53X3NoYXBlWyR7aXNDaGFubmVsTGFzdCA/IDIgOiAxfV07XHJcblxyXG4gICAgdmFyIHZhbHVlOiAke291dHB1dC50eXBlLnZhbHVlfSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xyXG4gICAgJHtjYWxjdWxhdGVSZXN1bHR9XHJcbiAgICAke3Byb2Nlc3NCaWFzfVxyXG4gICAgJHthcHBseUFjdGl2YXRpb259XHJcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxyXG4gIH1gO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdHcm91cGVkQ29udicsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fV8ke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcclxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcclxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaGFwZVszXSk7XHJcbiAgY29uc3Qgb3V0cHV0TnVtYmVyID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaGFwZVsyXSk7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMgLyBvdXRwdXROdW1iZXI7XHJcbiAgY29uc3QgeFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSwgaW5wdXRzWzBdLmRpbXNbMl0sIGlucHV0c1swXS5kaW1zWzNdIC8gY29tcG9uZW50c107XHJcbiAgY29uc3Qgd1NoYXBlID0gW2lucHV0c1sxXS5kaW1zWzBdLCBpbnB1dHNbMV0uZGltc1sxXSwgaW5wdXRzWzFdLmRpbXNbMl0sIGlucHV0c1sxXS5kaW1zWzNdIC8gY29tcG9uZW50c107XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGVJblNoYWRlciA9IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMV0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXSAvIGNvbXBvbmVudHNdO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMucGFkc1swXSwgYXR0cmlidXRlcy5wYWRzWzFdXSB9LFxyXG4gIF07XHJcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHhTaGFwZSwgd1NoYXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyKSk7XHJcbiAgY29uc3QgeE51bWJlciA9IChvdXRwdXROdW1iZXIgLSAxKSAqIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXSArIHdTaGFwZVsxXTtcclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlSW5TaGFkZXIubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XHJcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xyXG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIHhTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIHdTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3gsIHddO1xyXG4gICAgaWYgKGhhc0JpYXMpIHtcclxuICAgICAgaW5wdXRWYXJzLnB1c2goaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNvbXBvbmVudHMpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb2Nlc3NCaWFzID0gaGFzQmlhcyA/ICd2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTsnIDogJyc7XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcclxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcclxuICAgIF07XHJcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYXR0cmlidXRlcywgdW5pZm9ybXMpO1xyXG4gICAgcmV0dXJuIGBcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcbiAgICBsZXQgd2lkdGgwID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzNdO1xyXG4gICAgbGV0IG91dHB1dF9jaGFubmVsID0gZ2xvYmFsX2lkeCAlIHdpZHRoMDtcclxuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gd2lkdGgwO1xyXG4gICAgbGV0IHdpZHRoMSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsyXSAvICR7b3V0cHV0TnVtYmVyfXU7XHJcbiAgICBsZXQgY29sID0gKGluZGV4MSAlIHdpZHRoMSkgKiAke291dHB1dE51bWJlcn11O1xyXG4gICAgaW5kZXgxID0gaW5kZXgxIC8gd2lkdGgxO1xyXG4gICAgbGV0IHJvdyA9IGluZGV4MSAlIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcclxuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcclxuXHJcbiAgICBsZXQgeF9jb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHJvdyksIGkzMihjb2wpKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xyXG5cclxuICAgIHZhciB4X3ZhbHM6IGFycmF5PCR7eC50eXBlLnZhbHVlfSwgJHt4TnVtYmVyfT47XHJcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXJ9PjtcclxuICAgIGxldCBpbnB1dF9jaGFubmVsID0gb3V0cHV0X2NoYW5uZWw7XHJcbiAgICAvLyBVc2UgY29uc3RhbnQgaW5zdGVhZCBvZiB1bmlmb3JtIGNhbiBnaXZlIGJldHRlciBwZXJmb3JtYW5jZSBmb3IgdydzIGhlaWdodC93aWR0aC5cclxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3dTaGFwZVswXX07IHdfaGVpZ2h0KyspIHtcclxuICAgICAgbGV0IHhfaGVpZ2h0ID0geF9jb3JuZXIueCArIGkzMih3X2hlaWdodCk7XHJcbiAgICAgIGlmICh4X2hlaWdodCA+PSAwICYmIHUzMih4X2hlaWdodCkgPCB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3hOdW1iZXJ9OyBpKyspIHtcclxuICAgICAgICAgIGxldCB4X3dpZHRoID0geF9jb3JuZXIueSArIGk7XHJcbiAgICAgICAgICBpZiAoeF93aWR0aCA+PSAwICYmIHUzMih4X3dpZHRoKSA8IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcclxuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt4LmdldCgnYmF0Y2gnLCAndTMyKHhfaGVpZ2h0KScsICd1MzIoeF93aWR0aCknLCAnaW5wdXRfY2hhbm5lbCcpfTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7eC50eXBlLnZhbHVlfSgwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgd193aWR0aDogdTMyID0gMHU7IHdfd2lkdGggPCAke3dTaGFwZVsxXX07IHdfd2lkdGgrKykge1xyXG4gICAgICAgICAgbGV0IHdfdmFsID0gJHt3LmdldCgnd19oZWlnaHQnLCAnd193aWR0aCcsICcwJywgJ291dHB1dF9jaGFubmVsJyl9O1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtvdXRwdXROdW1iZXJ9dTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IGZtYSh4X3ZhbHNbaSAqIHUzMih1bmlmb3Jtcy5zdHJpZGVzWzFdKSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke291dHB1dE51bWJlcn11OyBpKyspIHtcclxuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xyXG4gICAgICAke3Byb2Nlc3NCaWFzfVxyXG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cclxuICAgICAgJHtvdXRwdXQuc2V0KCdiYXRjaCcsICdyb3cnLCAnY29sICsgaScsICdvdXRwdXRfY2hhbm5lbCcsICd2YWx1ZScpfTtcclxuICAgIH1cclxuICB9YDtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0dyb3VwZWRDb252LVZlY3Rvcml6ZScsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2NvbXBvbmVudHN9OyR7b3V0cHV0TnVtYmVyfTske3hOdW1iZXJ9OyR7d1NoYXBlWzBdfTske3dTaGFwZVsxXX1gLFxyXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogaGFzQmlhcyA/IFsncmFuaycsICdyYW5rJywgJ3R5cGUnXSA6IFsncmFuaycsICdyYW5rJ10sXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBQb29sQ29udlV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L2NvbnYyZF9tbV93ZWJncHUnO1xyXG5pbXBvcnQgeyBjb21wdXRlQ29udjNESW5mbywgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L2NvbnYzZF9uYWl2ZV93ZWJncHUnO1xyXG5pbXBvcnQgeyBjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L21hdG11bF9wYWNrZWRfd2ViZ3B1JztcclxuaW1wb3J0IHsgY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbywgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyB9IGZyb20gJy4vY29udi1ncm91cGVkJztcclxuaW1wb3J0IHsgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcclxuaW1wb3J0IHsgY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyB9IGZyb20gJy4vbWF0bXVsLXNoYWRlcnMnO1xyXG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHJhbnNwb3NlJztcclxuXHJcbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9IChcclxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcclxuICBhZGp1c3RQYWRzOiByZWFkb25seSBudW1iZXJbXSxcclxuICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcclxuICBpc0NoYW5uZWxMYXN0OiBib29sZWFuLFxyXG4pOiBudW1iZXJbXSA9PiB7XHJcbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXRTaGFwZVswXTtcclxuICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoaXNDaGFubmVsTGFzdCA/IDEgOiAyLCBpc0NoYW5uZWxMYXN0ID8gMyA6IDQpO1xyXG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRTcGF0aWFsU2hhcGUubGVuZ3RoO1xyXG4gIGNvbnN0IG91dENoYW5uZWxzID0ga2VybmVsU2hhcGVbMF07XHJcbiAgY29uc3Qga2VybmVsU3BhdGlhbFNoYXBlID0ga2VybmVsU2hhcGUuc2xpY2UoMik7XHJcbiAgY29uc3QgZGlsYXRlZEtlcm5lbFNoYXBlID0ga2VybmVsU3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArICh2IC0gMSkgKiAoZGlsYXRpb25zW2ldIC0gMSkpO1xyXG4gIGNvbnN0IGlucHV0U3BhdGlhbFNoYXBlV2l0aFBhZCA9IGlucHV0U3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArIGFkanVzdFBhZHNbaV0gKyBhZGp1c3RQYWRzW2kgKyBzcGF0aWFsUmFua10pO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTcGF0aWFsU2hhcGVXaXRoUGFkLm1hcCgodiwgaSkgPT5cclxuICAgIE1hdGguZmxvb3IoKHYgLSBkaWxhdGVkS2VybmVsU2hhcGVbaV0gKyBzdHJpZGVzW2ldKSAvIHN0cmlkZXNbaV0pLFxyXG4gICk7XHJcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKDAsIDAsIGJhdGNoU2l6ZSk7XHJcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGlzQ2hhbm5lbExhc3QgPyAzIDogMSwgMCwgb3V0Q2hhbm5lbHMpO1xyXG4gIHJldHVybiBvdXRwdXRTaGFwZTtcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29udkF0dHJpYnV0ZXMgZXh0ZW5kcyBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IGF1dG9QYWQ6IHN0cmluZztcclxuICByZWFkb25seSBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnIHwgJ05DSFcnO1xyXG4gIHJlYWRvbmx5IGdyb3VwOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gIHJlYWRvbmx5IHdJc0NvbnN0OiBib29sZWFuO1xyXG59XHJcblxyXG4vLyBmb3IgdHJhbnNwb3Npbmcgd2VpZ2h0IHRlbnNvciBmcm9tIFtNLCBDL2dyb3VwLCBLSCwgS1ddIHRvIFtLSCwgS1csIEMvZ3JvdXAsIE1dXHJcbmNvbnN0IHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSA9IFsyLCAzLCAxLCAwXTtcclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21hc3Rlci9kb2NzL09wZXJhdG9ycy5tZCNDb252XHJcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gNSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdncmVhdGVyIHRoYW4gNUQgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0Jyk7XHJcbiAgfVxyXG5cclxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXHJcbiAgY29uc3QgZGF0YUNoYW5uZWwgPSBpbnB1dHNbMF0uZGltc1thdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnID8gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMSA6IDFdO1xyXG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcclxuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMJyk7XHJcbiAgfVxyXG5cclxuICAvLyBpZiBiaWFzIGlzIHByb3ZpZGVkIGl0IHNob3VsZCBiZSAxRCBhbmQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBmZWF0dXJlIG1hcHNcclxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMl0uZGltc1swXSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XHJcbiAgLy8gd3JvbmcgZGlsYXRpb25zIGRpbWVuc2lvblxyXG4gIGlmIChhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XHJcbiAgfVxyXG5cclxuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxyXG4gIGlmIChhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcclxuICB9XHJcblxyXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXHJcbiAgaWYgKGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rICogMn1EYCk7XHJcbiAgfVxyXG5cclxuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBzcGVjaWZpZWQsIGl0J3MgZGF0YSBsZW5ndGggbXVzdCBiZSAyIGxlc3MgdGhhbiBkaW1zIGxlbmd0aCBvZiB0aGUgd2VpZ2h0cyB0ZW5zb3JcclxuICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXHJcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2VybmVsIHNoYXBlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyA9IDxUIGV4dGVuZHMgQ29udkF0dHJpYnV0ZXM+KGF0dHJpYnV0ZXM6IFQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogVCA9PiB7XHJcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XHJcbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgbm90IHdlbGwgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzLCBpbmZlciBpdCBmcm9tIHRoZSB3ZWlnaHQgdGVuc29yIGRpbXNcclxuICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xyXG4gICAga2VybmVsU2hhcGUucHVzaCguLi5BcnJheShpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyIC0ga2VybmVsU2hhcGUubGVuZ3RoKS5maWxsKDApKTtcclxuICB9XHJcbiAgZm9yIChsZXQgaSA9IDI7IGkgPCBpbnB1dHNbMV0uZGltcy5sZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKGtlcm5lbFNoYXBlW2kgLSAyXSA9PT0gMCkge1xyXG4gICAgICBrZXJuZWxTaGFwZVtpIC0gMl0gPSBpbnB1dHNbMV0uZGltc1tpXTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xyXG4gIFBvb2xDb252VXRpbC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXHJcbiAgICBpbnB1dHNbMF0uZGltcyxcclxuICAgIGF0dHJpYnV0ZXMuc3RyaWRlcyxcclxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zLFxyXG4gICAga2VybmVsU2hhcGUsXHJcbiAgICBwYWRzLFxyXG4gICAgYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyxcclxuICAgIGF0dHJpYnV0ZXMuYXV0b1BhZCxcclxuICApO1xyXG5cclxuICAvLyBhbHdheXMgcmV0dXJuIGEgbmV3IG9iamVjdCBzbyBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcclxuICBjb25zdCBuZXdBdHRyaWJ1dGVzOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XHJcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBwYWRzIH0pO1xyXG4gIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb252QXR0cmlidXRlcyA9PiB7XHJcbiAgY29uc3QgYWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XHJcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxyXG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJztcclxuICBjb25zdCBhdXRvUGFkID0gWydOT1RTRVQnLCAnVkFMSUQnLCAnU0FNRV9VUFBFUicsICdTQU1FX0xPV0VSJ11bYXR0cmlidXRlcy5hdXRvX3BhZCBhcyBudW1iZXJdO1xyXG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIG51bWJlcltdO1xyXG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5ncm91cCBhcyBudW1iZXI7XHJcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbF9zaGFwZSBhcyBudW1iZXJbXTtcclxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzIGFzIG51bWJlcltdO1xyXG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMgYXMgbnVtYmVyW107XHJcbiAgY29uc3Qgd0lzQ29uc3QgPSAoYXR0cmlidXRlcy53X2lzX2NvbnN0IGFzICgpID0+IGJvb2xlYW4pKCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBhdXRvUGFkLFxyXG4gICAgZm9ybWF0LFxyXG4gICAgZGlsYXRpb25zLFxyXG4gICAgZ3JvdXAsXHJcbiAgICBrZXJuZWxTaGFwZSxcclxuICAgIHBhZHMsXHJcbiAgICBzdHJpZGVzLFxyXG4gICAgd0lzQ29uc3QsXHJcbiAgICAuLi5hY3RpdmF0aW9uQXR0cmlidXRlcyxcclxuICAgIGNhY2hlS2V5OiBgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9ufTtgLFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCBjb252MmQgPSAoXHJcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXHJcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcclxuKTogdm9pZCA9PiB7XHJcbiAgLy8gY2hlY2sgYXR0cmlidXRlc1xyXG5cclxuICAvLyBjb25zdCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gZmFsc2U7IC8qIFRPRE86IGFkZCBzdXBwb3J0IGZvciBwcmVsdSBhY3RpdmF0aW9uIHdlaWdodHMgKi9cclxuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVPdXRwdXRTaGFwZShcclxuICAgIGlucHV0c1swXS5kaW1zLFxyXG4gICAgaW5wdXRzWzFdLmRpbXMsXHJcbiAgICBhdHRyaWJ1dGVzLmRpbGF0aW9ucyxcclxuICAgIGF0dHJpYnV0ZXMucGFkcyxcclxuICAgIGF0dHJpYnV0ZXMuc3RyaWRlcyxcclxuICAgIGlzQ2hhbm5lbHNMYXN0LFxyXG4gICk7XHJcbiAgaWYgKGF0dHJpYnV0ZXMuZ3JvdXAgIT09IDEpIHtcclxuICAgIGNvbnN0IGNvbnZJbnB1dHMgPSBbaW5wdXRzWzBdXTtcclxuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xyXG4gICAgICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cclxuICAgICAgICAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XHJcbiAgICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0c1sxXSwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlKSwge1xyXG4gICAgICAgICAgaW5wdXRzOiBbMV0sXHJcbiAgICAgICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxyXG4gICAgICAgIH0pWzBdO1xyXG4gICAgICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XHJcbiAgICAgICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcclxuICAgICAgfVxyXG4gICAgICBjb252SW5wdXRzLnB1c2godHJhbnNwb3NlZFdlaWdodCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb252SW5wdXRzLnB1c2goaW5wdXRzWzFdKTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xyXG4gICAgfVxyXG4gICAgLy8gTlZJRElBIEdQVSB3aXRoIGFtcGVyZSBhcmNoaXRlY3R1cmUgZmFpbHMgd2l0aCBiZWxvdyAyIGNhc2VzLCBidXQgd2UgY291bGRuJ3QgcmVwcm8gdGhlbSB3aXRoIGFueSBvdGhlclxyXG4gICAgLy8gR1BVcy4gU28ganVzdCBkaXNhYmxlIHZlY3Rvcml6ZSBvbiBOVklESUEgYW1wZXJlIHRvIGVuc3VyZSBhbHdheXMgY29ycmVjdCBvdXRwdXRzLlxyXG4gICAgLy8gW3dlYmdwdV1Db252IC0gY29udiAtIHZlY3Rvcml6ZSBncm91cCAtIEJcclxuICAgIC8vIFt3ZWJncHVdQ29udiAtIGNvbnYgLSB2ZWN0b3JpemUgZ3JvdXAgLSBEXHJcbiAgICBjb25zdCBlbmFibGVHcm91cGVkQ29udlZlY3Rvcml6ZSA9ICFjb250ZXh0LmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKCdhbXBlcmUnKTtcclxuICAgIGlmIChcclxuICAgICAgZW5hYmxlR3JvdXBlZENvbnZWZWN0b3JpemUgJiZcclxuICAgICAgaXNDaGFubmVsc0xhc3QgJiZcclxuICAgICAgaW5wdXRzWzFdLmRpbXNbMF0gPT09IGF0dHJpYnV0ZXMuZ3JvdXAgJiZcclxuICAgICAgaW5wdXRzWzFdLmRpbXNbMV0gPT09IDEgJiZcclxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPT09IDEgJiZcclxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDFcclxuICAgICkge1xyXG4gICAgICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICAgICAgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyhjb252SW5wdXRzLCBhdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSwgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24pLFxyXG4gICAgICAgIHsgaW5wdXRzOiBjb252SW5wdXRzIH0sXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbyhjb252SW5wdXRzLCBhdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSwgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24pLCB7XHJcbiAgICAgICAgaW5wdXRzOiBjb252SW5wdXRzLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID09PSAzO1xyXG4gIGNvbnN0IGlucHV0SGVpZ2h0ID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XHJcbiAgY29uc3QgaW5wdXRXaWR0aCA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdO1xyXG4gIGNvbnN0IGlucHV0Q2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcclxuICBjb25zdCB3ZWlnaHRIZWlnaHQgPSBpbnB1dHNbMV0uZGltc1syXTtcclxuICBjb25zdCB3ZWlnaHRXaWR0aCA9IGlucHV0c1sxXS5kaW1zWzNdO1xyXG5cclxuICBjb25zdCBvdXRIZWlnaHQgPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXTtcclxuICBjb25zdCBvdXRXaWR0aCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdO1xyXG4gIGNvbnN0IG91dENoYW5uZWxzID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XHJcblxyXG4gIGNvbnN0IHNhbWVTaXplID1cclxuICAgIGlzQ2hhbm5lbHNMYXN0ICYmXHJcbiAgICB3ZWlnaHRIZWlnaHQgPT09IGlucHV0SGVpZ2h0ICYmXHJcbiAgICB3ZWlnaHRXaWR0aCA9PT0gaW5wdXRXaWR0aCAmJlxyXG4gICAgYXR0cmlidXRlcy5wYWRzWzBdID09PSAwICYmXHJcbiAgICBhdHRyaWJ1dGVzLnBhZHNbMV0gPT09IDA7XHJcbiAgaWYgKFxyXG4gICAgc2FtZVNpemUgfHxcclxuICAgICh3ZWlnaHRIZWlnaHQgPT09IDEgJiZcclxuICAgICAgd2VpZ2h0V2lkdGggPT09IDEgJiZcclxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPT09IDEgJiZcclxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDEgJiZcclxuICAgICAgYXR0cmlidXRlcy5zdHJpZGVzWzBdID09PSAxICYmXHJcbiAgICAgIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXSA9PT0gMSAmJlxyXG4gICAgICBhdHRyaWJ1dGVzLnBhZHNbMF0gPT09IDAgJiZcclxuICAgICAgYXR0cmlidXRlcy5wYWRzWzFdID09PSAwKVxyXG4gICkge1xyXG4gICAgLy8gY29udjJkQnlNYXRNdWxcclxuICAgIGNvbnN0IGJhdGNoID0gb3V0cHV0U2hhcGVbMF07XHJcbiAgICBsZXQgeFJlc2hhcGVkLCB3UmVzaGFwZWQsIG1hdG11bE91dHB1dFNoYXBlO1xyXG4gICAgY29uc3QgbWF0bXVsSW5wdXRzID0gW107XHJcbiAgICBpZiAoaXNDaGFubmVsc0xhc3QpIHtcclxuICAgICAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9XHJcbiAgICAgICAgKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xyXG4gICAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSksIHtcclxuICAgICAgICAgIGlucHV0czogWzFdLFxyXG4gICAgICAgICAgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXSxcclxuICAgICAgICB9KVswXTtcclxuICAgICAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xyXG4gICAgICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNhbWVTaXplKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhcmVkRGltID0gaW5wdXRIZWlnaHQgKiBpbnB1dFdpZHRoICogaW5wdXRDaGFubmVscztcclxuICAgICAgICB4UmVzaGFwZWQgPSBpbnB1dHNbMF0ucmVzaGFwZShbMSwgYmF0Y2gsIHNoYXJlZERpbV0pO1xyXG4gICAgICAgIHdSZXNoYXBlZCA9IHRyYW5zcG9zZWRXZWlnaHQucmVzaGFwZShbMSwgc2hhcmVkRGltLCBvdXRDaGFubmVsc10pO1xyXG4gICAgICAgIG1hdG11bE91dHB1dFNoYXBlID0gWzEsIGJhdGNoLCBvdXRDaGFubmVsc107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeFJlc2hhcGVkID0gaW5wdXRzWzBdLnJlc2hhcGUoW2JhdGNoLCBpbnB1dEhlaWdodCAqIGlucHV0V2lkdGgsIGlucHV0Q2hhbm5lbHNdKTtcclxuICAgICAgICB3UmVzaGFwZWQgPSB0cmFuc3Bvc2VkV2VpZ2h0LnJlc2hhcGUoWzEsIGlucHV0Q2hhbm5lbHMsIG91dENoYW5uZWxzXSk7XHJcbiAgICAgICAgbWF0bXVsT3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG91dEhlaWdodCAqIG91dFdpZHRoLCBvdXRDaGFubmVsc107XHJcbiAgICAgIH1cclxuICAgICAgbWF0bXVsSW5wdXRzLnB1c2goeFJlc2hhcGVkKTtcclxuICAgICAgbWF0bXVsSW5wdXRzLnB1c2god1Jlc2hhcGVkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHhSZXNoYXBlZCA9IGlucHV0c1swXS5yZXNoYXBlKFtiYXRjaCwgaW5wdXRDaGFubmVscywgaW5wdXRIZWlnaHQgKiBpbnB1dFdpZHRoXSk7XHJcbiAgICAgIHdSZXNoYXBlZCA9IGlucHV0c1sxXS5yZXNoYXBlKFsxLCBvdXRDaGFubmVscywgaW5wdXRDaGFubmVsc10pO1xyXG4gICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFtiYXRjaCwgb3V0Q2hhbm5lbHMsIG91dEhlaWdodCAqIG91dFdpZHRoXTtcclxuICAgICAgbWF0bXVsSW5wdXRzLnB1c2god1Jlc2hhcGVkKTtcclxuICAgICAgbWF0bXVsSW5wdXRzLnB1c2goeFJlc2hhcGVkKTtcclxuICAgIH1cclxuICAgIGlmIChoYXNCaWFzKSB7XHJcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKGlucHV0c1syXSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBOID0gbWF0bXVsT3V0cHV0U2hhcGVbMl07XHJcbiAgICBjb25zdCBLID0gbWF0bXVsSW5wdXRzWzBdLmRpbXNbbWF0bXVsSW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV07XHJcbiAgICAvLyBUdW5lIHRoZSB0aHJlc2hvbGQuXHJcbiAgICBpZiAoTiA8IDggJiYgSyA8IDgpIHtcclxuICAgICAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgICAgIGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8oXHJcbiAgICAgICAgICBtYXRtdWxJbnB1dHMsXHJcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgb3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSxcclxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LFxyXG4gICAgICAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24sXHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IGlucHV0czogbWF0bXVsSW5wdXRzIH0sXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICAgICAgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8oXHJcbiAgICAgICAgICBtYXRtdWxJbnB1dHMsXHJcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgb3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSxcclxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LFxyXG4gICAgICAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24sXHJcbiAgICAgICAgKSxcclxuICAgICAgICB7IGlucHV0czogbWF0bXVsSW5wdXRzIH0sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBpbXBsZW1lbnQgY29udjJkV2l0aEltMkNvbCgpXHJcblxyXG4gIGNvbnN0IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgPSAvKiBiYWNrZW5kLmFkYXB0ZXJJbmZvLmlzSW50ZWwoKSAqLyB0cnVlO1xyXG5cclxuICAvLyBTVEVQLjE6IHRyYW5zcG9zZSB3ZWlnaHRcclxuICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cclxuICAgIChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cclxuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSksIHtcclxuICAgICAgaW5wdXRzOiBbMV0sXHJcbiAgICAgIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV0sXHJcbiAgICB9KVswXTtcclxuICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XHJcbiAgICBjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgPSB0cmFuc3Bvc2VkV2VpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLy8gU1RFUC4yOiBwcmVwYXJlIHJlc2hhcGVkIGlucHV0c1xyXG4gIGNvbnN0IGNvbnZJbnB1dHMgPSBbaW5wdXRzWzBdLCB0cmFuc3Bvc2VkV2VpZ2h0XTtcclxuICBpZiAoaGFzQmlhcykge1xyXG4gICAgY29udklucHV0cy5wdXNoKGlucHV0c1syXSk7XHJcbiAgfVxyXG5cclxuICAvLyBTVEVQLjM6IGNvbXB1dGUgbWF0bXVsXHJcbiAgY29uc3QgZGltQU91dGVyID0gaXNDaGFubmVsc0xhc3QgPyBvdXRIZWlnaHQgKiBvdXRXaWR0aCA6IG91dENoYW5uZWxzO1xyXG4gIGNvbnN0IGRpbUJPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRIZWlnaHQgKiBvdXRXaWR0aDtcclxuICBjb25zdCBkaW1Jbm5lciA9IHdlaWdodEhlaWdodCAqIHdlaWdodFdpZHRoICogaW5wdXRDaGFubmVscztcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyhcclxuICAgICAgY29udklucHV0cyxcclxuICAgICAgYXR0cmlidXRlcyxcclxuICAgICAgb3V0cHV0U2hhcGUsXHJcbiAgICAgIGRpbUFPdXRlcixcclxuICAgICAgZGltQk91dGVyLFxyXG4gICAgICBkaW1Jbm5lcixcclxuICAgICAgaGFzQmlhcyxcclxuICAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyxcclxuICAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24sXHJcbiAgICApLFxyXG4gICAgeyBpbnB1dHM6IGNvbnZJbnB1dHMgfSxcclxuICApO1xyXG59O1xyXG5cclxuY29uc3QgY29udjFkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIC8vIGV4dGVuZCB0aGUgaW5wdXQgdG8gMkQgYnkgYWRkaW5nIEggZGltZW5zaW9uXHJcbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XHJcbiAgY29uc3QgaW5wdXRzID0gW1xyXG4gICAgY29udGV4dC5pbnB1dHNbMF0ucmVzaGFwZShcclxuICAgICAgaXNDaGFubmVsTGFzdFxyXG4gICAgICAgID8gLy8gW04sIFcsIENdIC0+IFtOLCBIPTEsIFcsIENdXHJcbiAgICAgICAgICBbY29udGV4dC5pbnB1dHNbMF0uZGltc1swXSwgMSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1sxXSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1syXV1cclxuICAgICAgICA6IC8vIFtOLCBDLCBXXSAtPiBbTiwgQywgSD0xLCBXXVxyXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dLFxyXG4gICAgKSxcclxuICAgIC8vW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtXXSAtPiBbRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga0g9MSwga1ddXHJcbiAgICBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXSksXHJcbiAgXTtcclxuICBpZiAoY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICBpbnB1dHMucHVzaChjb250ZXh0LmlucHV0c1syXSk7XHJcbiAgfVxyXG4gIGNvbnN0IHBhZHMgPSBbMCwgYXR0cmlidXRlcy5wYWRzWzBdLCAwLCBhdHRyaWJ1dGVzLnBhZHNbMV1dO1xyXG4gIGNvbnN0IHN0cmlkZXMgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMuc3RyaWRlcyk7XHJcbiAgY29uc3QgZGlsYXRpb25zID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLmRpbGF0aW9ucyk7XHJcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xyXG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMoXHJcbiAgICB7IC4uLmF0dHJpYnV0ZXMsIHBhZHMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUgfSxcclxuICAgIGlucHV0cyxcclxuICApO1xyXG4gIGNvbnYyZChjb250ZXh0LCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcywgKG91dHB1dFNoYXBlKSA9PlxyXG4gICAgaXNDaGFubmVsTGFzdCA/IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdXSA6IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMV0sIG91dHB1dFNoYXBlWzNdXSxcclxuICApO1xyXG59O1xyXG5cclxuY29uc3QgY29udjNkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnID8gJ2NoYW5uZWxzTGFzdCcgOiAnY2hhbm5lbHNGaXJzdCc7XHJcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBpbnB1dHMpO1xyXG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLmF1dG9QYWQgPT09ICdOT1RTRVQnID8gYXR0cmlidXRlcy5wYWRzIDogYXR0cmlidXRlcy5hdXRvUGFkO1xyXG4gIGNvbnN0IGNvbnZJbmZvID0gY29tcHV0ZUNvbnYzREluZm8oXHJcbiAgICBpbnB1dHNbMF0uZGltcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gICAgaW5wdXRzWzFdLmRpbXMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICAgIGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgICBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgICBwYWRzIGFzIHN0cmluZyB8IG51bWJlcltdLFxyXG4gICAgZmFsc2UsXHJcbiAgICBmb3JtYXQsXHJcbiAgKTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVDb252M0ROYWl2ZVByb2dyYW1JbmZvKFxyXG4gICAgICBpbnB1dHMsXHJcbiAgICAgIGFkanVzdGVkQXR0cmlidXRlcyxcclxuICAgICAgY29udkluZm8ub3V0U2hhcGUsXHJcbiAgICAgIFtjb252SW5mby5maWx0ZXJEZXB0aCwgY29udkluZm8uZmlsdGVySGVpZ2h0LCBjb252SW5mby5maWx0ZXJXaWR0aF0sXHJcbiAgICAgIFtjb252SW5mby5wYWRJbmZvLmZyb250LCBjb252SW5mby5wYWRJbmZvLnRvcCwgY29udkluZm8ucGFkSW5mby5sZWZ0XSxcclxuICAgICAgZm9ybWF0LFxyXG4gICAgKSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbnYgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xyXG4gIGlmIChjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gMykge1xyXG4gICAgY29udjFkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH0gZWxzZSBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDUpIHtcclxuICAgIGNvbnYzZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMoYXR0cmlidXRlcywgY29udGV4dC5pbnB1dHMpO1xyXG4gICAgY29udjJkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpO1xyXG4gIH1cclxufTtcclxuIiwgIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKi9cclxuXHJcbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udl9iYWNrcHJvcF93ZWJncHUudHNcclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcclxuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uLy4uL3R5cGVzJztcclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbiAgZ2V0TWF4Q29tcG9uZW50cyxcclxufSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBDb252VHJhbnNwb3NlQXR0cmlidXRlcyB9IGZyb20gJy4uL2NvbnYtdHJhbnNwb3NlJztcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcclxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZTtcclxuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XHJcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwO1xyXG4gIGNvbnN0IHdTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xyXG4gIGNvbnN0IGlucHV0Q2hhbm5lbHNQZXJHcm91cCA9IHdTaGFwZVsyXSAvIGdyb3VwO1xyXG4gIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbM107XHJcbiAgY29uc3QgYUNvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGdldE1heENvbXBvbmVudHMoaW5wdXRDaGFubmVsc1Blckdyb3VwKSA6IDE7XHJcbiAgY29uc3QgcGFja0lucHV0QXM0ID0gaXNDaGFubmVsc0xhc3QgJiYgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9PT0gMSAmJiBpbnB1dENoYW5uZWxzUGVyR3JvdXAgPj0gNDtcclxuICBjb25zdCBpbnB1dENoYW5uZWxzUGVyR3JvdXBJbnQgPSBwYWNrSW5wdXRBczRcclxuICAgID8gTWF0aC5mbG9vcihpbnB1dENoYW5uZWxzUGVyR3JvdXAgLyA0KSAqIDRcclxuICAgIDogTWF0aC5mbG9vcihpbnB1dENoYW5uZWxzUGVyR3JvdXAgLyBhQ29tcG9uZW50cykgKiBhQ29tcG9uZW50cztcclxuICBjb25zdCBpbnB1dENoYW5uZWxzUmVtYWluZGVyID0gaW5wdXRDaGFubmVsc1Blckdyb3VwIC0gaW5wdXRDaGFubmVsc1Blckdyb3VwSW50O1xyXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGdldE1heENvbXBvbmVudHMob3V0cHV0Q2hhbm5lbHNQZXJHcm91cCkgOiAxO1xyXG4gIGNvbnN0IGJDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyAob3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9PT0gMSA/IGFDb21wb25lbnRzIDogY29tcG9uZW50cykgOiAxO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xyXG4gIGNvbnN0IGRpc3BhdGNoID0gW01hdGguY2VpbChvdXRwdXRTaXplIC8gNjQpLCAxLCAxXTtcclxuICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW2NvbnYyZF9iYWNrcHJvcF93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcclxuXHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xyXG4gIGNvbnN0IHN0cmlkZXMgPSBbYXR0cmlidXRlcy5zdHJpZGVzWzBdLCBhdHRyaWJ1dGVzLnN0cmlkZXNbMV1dO1xyXG4gIGNvbnN0IGZpbHRlckRpbXMgPSBbYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXSwgYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXV07XHJcbiAgY29uc3QgZGlsYXRpb25zID0gW2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdLCBhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXV07XHJcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGltcyA9IFtcclxuICAgIGZpbHRlckRpbXNbMF0gK1xyXG4gICAgICAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPD0gMVxyXG4gICAgICAgID8gMFxyXG4gICAgICAgIDogKGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSAtIDEpKSxcclxuICAgIGZpbHRlckRpbXNbMV0gK1xyXG4gICAgICAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPD0gMVxyXG4gICAgICAgID8gMFxyXG4gICAgICAgIDogKGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM10gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXSAtIDEpKSxcclxuICBdO1xyXG4gIGNvbnN0IHBhZHMgPSBbXHJcbiAgICBlZmZlY3RpdmVGaWx0ZXJEaW1zWzBdIC0gMSAtIE1hdGguZmxvb3IoKGF0dHJpYnV0ZXMucGFkc1swXSArIGF0dHJpYnV0ZXMucGFkc1syXSkgLyAyKSxcclxuICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0gLSAxIC0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5wYWRzWzFdICsgYXR0cmlidXRlcy5wYWRzWzNdKSAvIDIpLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc3RyaWRlcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGZpbHRlckRpbXMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkaWxhdGlvbnMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlZmZlY3RpdmVGaWx0ZXJEaW1zIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBwYWRzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRDaGFubmVsc1Blckdyb3VwSW50IH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRDaGFubmVsc1Blckdyb3VwIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCB9LFxyXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKSxcclxuICBdO1xyXG4gIGlmIChoYXNCaWFzKSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xyXG4gIH1cclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogc3RyaWRlcy5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAnZmlsdGVyX2RpbXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdlZmZlY3RpdmVfZmlsdGVyX2RpbXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBlZmZlY3RpdmVGaWx0ZXJEaW1zLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogcGFkcy5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAnaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwX2ludCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2lucHV0X2NoYW5uZWxzX3Blcl9ncm91cCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9jaGFubmVsc19wZXJfZ3JvdXAnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgXTtcclxuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgICBjb25zdCByb3dEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDEgOiAyO1xyXG4gICAgY29uc3QgY29sRGltID0gaXNDaGFubmVsc0xhc3QgPyAyIDogMztcclxuICAgIGNvbnN0IGNoYW5uZWxEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDMgOiAxO1xyXG5cclxuICAgIGNvbnN0IHcgPSBpbnB1dFZhcmlhYmxlKCdXJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIGJDb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGR5ID0gaW5wdXRWYXJpYWJsZSgnRHknLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgYUNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbZHksIHddO1xyXG4gICAgaWYgKGhhc0JpYXMpIHtcclxuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBbb3V0cHV0U2hhcGVbY2hhbm5lbERpbV1dLmxlbmd0aCwgY29tcG9uZW50cykpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuXHJcbiAgICBjb25zdCBjYWxjdWxhdGVSZXN1bHQgPSAoKTogc3RyaW5nID0+IHtcclxuICAgICAgbGV0IGNhbGNTdHIgPSAnJztcclxuICAgICAgaWYgKHBhY2tJbnB1dEFzNCkge1xyXG4gICAgICAgIGlmIChhQ29tcG9uZW50cyA9PT0gNCkge1xyXG4gICAgICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgbGV0IHhWYWx1ZSA9ICR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0Jyl9O1xyXG4gICAgICAgIGxldCB3VmFsdWUgPSAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0Jyl9O1xyXG4gICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHhWYWx1ZSwgd1ZhbHVlKTtcclxuICAgICAgICB4X29mZnNldCArPSAxdTtcclxuICAgICAgICB3X29mZnNldCArPSAxdTtgO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYUNvbXBvbmVudHMgPT09IDIpIHtcclxuICAgICAgICAgIGNhbGNTdHIgKz0gYFxyXG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyBkb3QodmVjNDwke2RhdGFUeXBlfT4oJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQnKX0sICR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0ICsgMXUnKX0pLCB2ZWM0PCR7ZGF0YVR5cGV9Pigke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0Jyl9LCAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0ICsgMXUnKX0pKTtcclxuICAgICAgICAgIHhfb2Zmc2V0ICs9IDJ1O1xyXG4gICAgICAgICAgd19vZmZzZXQgKz0gMnU7YDtcclxuICAgICAgICB9IGVsc2UgaWYgKGFDb21wb25lbnRzID09PSAxKSB7XHJcbiAgICAgICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHZlYzQ8JHtkYXRhVHlwZX0+KCR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0Jyl9LCAke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCArIDF1Jyl9LCAke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCArIDJ1Jyl9LCAke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCArIDN1Jyl9KSwgdmVjNDwke2RhdGFUeXBlfT4oJHt3LmdldEJ5T2Zmc2V0KCd3X29mZnNldCcpfSwgJHt3LmdldEJ5T2Zmc2V0KCd3X29mZnNldCArIDF1Jyl9LCAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0ICsgMnUnKX0sICR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQgKyAzdScpfSkpO1xyXG4gICAgICAgICAgeF9vZmZzZXQgKz0gNHU7XHJcbiAgICAgICAgICB3X29mZnNldCArPSA0dTtgO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDaGFubmVsc0xhc3RcclxuICAgICAgICAgICAgICAgICAgICAgID8gZHkuZ2V0QnlPZmZzZXQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZHkuaW5kaWNlc1RvT2Zmc2V0KGAke2R5LnR5cGUuaW5kaWNlc30oYmF0Y2gsIGlkeVIsIGlkeUMsIGlucHV0Q2hhbm5lbClgKX0gLyAke2FDb21wb25lbnRzfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgIDogZHkuZ2V0KCdiYXRjaCcsICdpbnB1dENoYW5uZWwnLCAnaWR5UicsICdpZHlDJylcclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICBgO1xyXG4gICAgICAgIGlmIChhQ29tcG9uZW50cyA9PT0gMSkge1xyXG4gICAgICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgICBsZXQgd19vZmZzZXQgPSAke3cuaW5kaWNlc1RvT2Zmc2V0KGAke3cudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9O1xyXG4gICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7dy5nZXRCeU9mZnNldChgd19vZmZzZXQgLyAke2JDb21wb25lbnRzfWApfTtcclxuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlICogd1ZhbHVlO2A7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYUNvbXBvbmVudHM7IGMrKykge1xyXG4gICAgICAgICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgICAgbGV0IHdWYWx1ZSR7Y30gPSAke3cuZ2V0QnlPZmZzZXQoYCR7dy5pbmRpY2VzVG9PZmZzZXQoYCR7dy50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsICsgJHtjfSwgd091dENoYW5uZWwpYCl9IC8gJHtiQ29tcG9uZW50c31gKX07XHJcbiAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlWyR7Y31dICogd1ZhbHVlJHtjfTtgO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2FsY1N0cjtcclxuICAgIH07XHJcbiAgICBjb25zdCBjYWxjdWxhdGVSZW1haW5kZXIgPSAoKTogc3RyaW5nID0+IHtcclxuICAgICAgaWYgKGlucHV0Q2hhbm5lbHNSZW1haW5kZXIgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFwYWNrSW5wdXRBczQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhY2tJbnB1dEFzNCAke3BhY2tJbnB1dEFzNH0gaXMgbm90IHRydWUuYCk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGNhbGNTdHIgPSAnJztcclxuICAgICAgaWYgKGFDb21wb25lbnRzID09PSAxKSB7XHJcbiAgICAgICAgY2FsY1N0ciArPSAnZG90UHJvZCA9IGRvdFByb2QnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDaGFubmVsc1JlbWFpbmRlcjsgaSsrKSB7XHJcbiAgICAgICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgICAgKyAke2R5LmdldEJ5T2Zmc2V0KGB4X29mZnNldCArICR7aX1gKX0gKiAke3cuZ2V0QnlPZmZzZXQoYHdfb2Zmc2V0ICsgJHtpfWApfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGNTdHIgKz0gJzsnO1xyXG4gICAgICB9IGVsc2UgaWYgKGFDb21wb25lbnRzID09PSAyKSB7XHJcbiAgICAgICAgaWYgKGlucHV0Q2hhbm5lbHNSZW1haW5kZXIgIT09IDIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnB1dENoYW5uZWxzUmVtYWluZGVyICR7aW5wdXRDaGFubmVsc1JlbWFpbmRlcn0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGNTdHIgKz0gYFxyXG4gICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0Jyl9O1xyXG4gICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQnKX07XHJcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh4VmFsdWUsIHdWYWx1ZSk7YDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2FsY1N0cjtcclxuICAgIH07XHJcbiAgICBjb25zdCBjb2RlU25pcHBldCA9IGBcclxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9YCl9O1xyXG4gICAgICAgICAgICBsZXQgYmF0Y2ggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgMCl9O1xyXG4gICAgICAgICAgICBsZXQgZDEgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgY2hhbm5lbERpbSl9O1xyXG4gICAgICAgICAgICBsZXQgciA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCByb3dEaW0pfTtcclxuICAgICAgICAgICAgbGV0IGMgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgY29sRGltKX07XHJcbiAgICAgICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB1bmlmb3Jtcy5wYWRzO1xyXG4gICAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcclxuICAgICAgICAgICAgbGV0IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XHJcbiAgICAgICAgICAgIGxldCBncm91cElkID0gZDEgLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xyXG4gICAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xyXG4gICAgICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cclxuICAgICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXHJcbiAgICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMC4wKTtcclxuICAgICAgICAgICAgdmFyIHdSOiB1MzIgPSAwO1xyXG4gICAgICAgICAgICBpZiAodW5pZm9ybXMuZGlsYXRpb25zLnggPT0gMSkge1xyXG4gICAgICAgICAgICAgIC8vIE1pbmltdW0gd1IgPj0gMCB0aGF0IHNhdGlzZmllcyAoZHlSQ29ybmVyICsgd1IpICUgKHVuaWZvcm1zLnN0cmlkZXMueCkgPT0gMFxyXG4gICAgICAgICAgICAgIHdSID0gdTMyKCgoZHlSQ29ybmVyICsgaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkgLSAxKSAvIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpKSAqIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpIC0gZHlSQ29ybmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKDsgd1IgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueDsgd1IgPSB3UiArIDEpIHtcclxuICAgICAgICAgICAgICBpZiAod1IgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbGV0IGR5UiA9ICgke2RhdGFUeXBlfShkeVJDb3JuZXIpICsgJHtkYXRhVHlwZX0od1IpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXNbMF0pO1xyXG4gICAgICAgICAgICAgIGxldCB3UlBlcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy54IC0gMSAtIHdSIC8gdW5pZm9ybXMuZGlsYXRpb25zLng7XHJcbiAgICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbJHtyb3dEaW19XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxyXG4gICAgICAgICAgICAgICAgICB3UlBlcm0gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xyXG4gICAgICAgICAgICAgIHZhciB3QzogdTMyID0gMDtcclxuICAgICAgICAgICAgICBpZiAodW5pZm9ybXMuZGlsYXRpb25zLnkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWluaW11bSB3QyA+PSAwIHRoYXQgc2F0aXNmaWVzIChkeUNDb3JuZXIgKyB3QykgJSAodW5pZm9ybXMuc3RyaWRlcy55KSA9PSAwXHJcbiAgICAgICAgICAgICAgICB3QyA9IHUzMigoKGR5Q0Nvcm5lciArIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpIC0gMSkgLyBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSkgKiBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSAtIGR5Q0Nvcm5lcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGZvciAoOyB3QyA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy55OyB3QyA9IHdDICsgMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdDICUgdW5pZm9ybXMuZGlsYXRpb25zLnkgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBkeUMgPSAoJHtkYXRhVHlwZX0oZHlDQ29ybmVyKSArICR7ZGF0YVR5cGV9KHdDKSkgLyAke2RhdGFUeXBlfSh1bmlmb3Jtcy5zdHJpZGVzLnkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnkgLSAxIC0gd0MgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueTtcclxuICAgICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLkR5X3NoYXBlWyR7Y29sRGltfV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAke1xyXG4gICAgICAgICAgICAgICAgICBwYWNrSW5wdXRBczRcclxuICAgICAgICAgICAgICAgICAgICA/IGBcclxuICAgICAgICAgICAgICAgIHZhciB4X29mZnNldCA9ICR7ZHkuaW5kaWNlc1RvT2Zmc2V0KGAke2R5LnR5cGUuaW5kaWNlc30oYmF0Y2gsIGlkeVIsIGlkeUMsIGlucHV0Q2hhbm5lbClgKX0gLyAke2FDb21wb25lbnRzfTtcclxuICAgICAgICAgICAgICAgIHZhciB3X29mZnNldCA9ICR7dy5pbmRpY2VzVG9PZmZzZXQoYCR7dy50eXBlLmluZGljZXN9KHdSUGVybSwgd0NQZXJtLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfSAvICR7YkNvbXBvbmVudHN9O1xyXG4gICAgICAgICAgICAgICAgICBgXHJcbiAgICAgICAgICAgICAgICAgICAgOiAnJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwX2ludDsgZDIgPSBkMiArICR7cGFja0lucHV0QXM0ID8gNCA6IGFDb21wb25lbnRzfSkge1xyXG4gICAgICAgICAgICAgICAgICAke2NhbGN1bGF0ZVJlc3VsdCgpfVxyXG4gICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAke3BhY2tJbnB1dEFzNCA/IDQgOiBhQ29tcG9uZW50c307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAke2NhbGN1bGF0ZVJlbWFpbmRlcigpfVxyXG4gICAgICAgICAgICAgICAgd0MgPSB3QyArIHVuaWZvcm1zLnN0cmlkZXMueSAtIDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHdSID0gd1IgKyB1bmlmb3Jtcy5zdHJpZGVzWzBdIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kJHtoYXNCaWFzID8gYCArIGJpYXNbZDEgLyAke2NvbXBvbmVudHN9XWAgOiAnJ307XHJcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xyXG4gICAgICAgICAgYDtcclxuXHJcbiAgICByZXR1cm4gYFxyXG4gICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cclxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9O1xyXG4gICAgJHtjb2RlU25pcHBldH19YDtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0NvbnZUcmFuc3Bvc2UyRCcsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2FDb21wb25lbnRzfSR7YkNvbXBvbmVudHN9JHtjb21wb25lbnRzfSR7cGFja0lucHV0QXM0fSR7aW5wdXRDaGFubmVsc1JlbWFpbmRlcn1gLFxyXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcclxuICAgIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcclxuICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L2NvbnZfYmFja3Byb3Bfd2ViZ3B1JztcclxuaW1wb3J0IHsgQ29udkF0dHJpYnV0ZXMgfSBmcm9tICcuL2NvbnYnO1xyXG5pbXBvcnQgeyBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xyXG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHJhbnNwb3NlJztcclxuXHJcbmNvbnN0IGNvbXB1dGVUb3RhbFBhZCA9IChcclxuICBpbkRpbTogbnVtYmVyLFxyXG4gIHN0cmlkZTogbnVtYmVyLFxyXG4gIGFkajogbnVtYmVyLFxyXG4gIGtlcm5lbDogbnVtYmVyLFxyXG4gIGRpbGF0aW9uOiBudW1iZXIsXHJcbiAgb3V0U2l6ZTogbnVtYmVyLFxyXG4pID0+IChpbkRpbSAtIDEpICogc3RyaWRlICsgYWRqICsgKGtlcm5lbCAtIDEpICogZGlsYXRpb24gKyAxIC0gb3V0U2l6ZTtcclxuXHJcbmNvbnN0IGRpc3RyaWJ1dGVQYWRkaW5nID0gKHRvdGFsUGFkOiBudW1iZXIsIGF1dG9QYWQ6IHN0cmluZywgcGFkczogbnVtYmVyW10sIGhlYWQ6IG51bWJlciwgdGFpbDogbnVtYmVyKSA9PiB7XHJcbiAgY29uc3Qgc21hbGxQYWQgPSBNYXRoLmZsb29yKHRvdGFsUGFkIC8gMik7XHJcbiAgaWYgKGF1dG9QYWQgPT09ICdTQU1FX1VQUEVSJykge1xyXG4gICAgcGFkc1toZWFkXSA9IHNtYWxsUGFkO1xyXG4gICAgcGFkc1t0YWlsXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XHJcbiAgfSBlbHNlIGlmIChhdXRvUGFkID09PSAnU0FNRV9MT1dFUicpIHtcclxuICAgIHBhZHNbaGVhZF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xyXG4gICAgcGFkc1t0YWlsXSA9IHNtYWxsUGFkO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNhbGN1bGF0ZU91dHB1dFNoYXBlQW5kUGFkcyA9IChcclxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcclxuICBhdXRvUGFkOiBzdHJpbmcsXHJcbiAgZ3JvdXA6IG51bWJlcixcclxuICBwYWRzOiBudW1iZXJbXSxcclxuICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcclxuICBpc0NoYW5uZWxMYXN0OiBib29sZWFuLFxyXG4gIG91dHB1dFBhZGRpbmc6IG51bWJlcltdLFxyXG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcclxuKSA9PiB7XHJcbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aCAtIDI7XHJcbiAgY29uc3QgdXBkYXRlT3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZS5sZW5ndGggPT09IDA7XHJcbiAgaWYgKG91dHB1dFBhZGRpbmcubGVuZ3RoIDwgc3BhdGlhbFJhbmspIHtcclxuICAgIG91dHB1dFBhZGRpbmcucHVzaCguLi5BcnJheShzcGF0aWFsUmFuayAtIG91dHB1dFBhZGRpbmcubGVuZ3RoKS5maWxsKDApKTtcclxuICB9XHJcbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXRTaGFwZVswXTtcclxuICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlW2lzQ2hhbm5lbExhc3QgPyAzIDogMV0gKiBncm91cDtcclxuICBmb3IgKGxldCBpID0gMCwgaiA9IGlucHV0U2hhcGUubGVuZ3RoIC0gc3BhdGlhbFJhbmsgLSAoaXNDaGFubmVsTGFzdCA/IDEgOiAwKTsgaSA8IHNwYXRpYWxSYW5rOyArK2ksICsraikge1xyXG4gICAgY29uc3QgaW5TaXplID0gaW5wdXRTaGFwZVtqXTtcclxuICAgIGNvbnN0IG91dFNpemUgPSB1cGRhdGVPdXRwdXRTaGFwZSA/IGluU2l6ZSAqIHN0cmlkZXNbaV0gOiBvdXRwdXRTaGFwZVtpXTtcclxuICAgIGNvbnN0IHRvdGFsUGFkID0gY29tcHV0ZVRvdGFsUGFkKGluU2l6ZSwgc3RyaWRlc1tpXSwgcGFkc1tpXSwga2VybmVsU2hhcGVbal0sIGRpbGF0aW9uc1tpXSwgb3V0U2l6ZSk7XHJcbiAgICBkaXN0cmlidXRlUGFkZGluZyh0b3RhbFBhZCwgYXV0b1BhZCwgcGFkcywgaSwgaSArIHNwYXRpYWxSYW5rKTtcclxuICAgIGlmICh1cGRhdGVPdXRwdXRTaGFwZSkge1xyXG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKFxyXG4gICAgICAgIHN0cmlkZXNbaV0gKiAoaW5TaXplIC0gMSkgK1xyXG4gICAgICAgICAgb3V0cHV0UGFkZGluZ1tpXSArXHJcbiAgICAgICAgICAoa2VybmVsU2hhcGVbal0gLSAxKSAqIGRpbGF0aW9uc1tpXSArXHJcbiAgICAgICAgICAxIC1cclxuICAgICAgICAgIHBhZHNbaV0gLVxyXG4gICAgICAgICAgcGFkc1tpICsgc3BhdGlhbFJhbmtdLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuICBvdXRwdXRTaGFwZS5zcGxpY2UoMCwgMCwgYmF0Y2hTaXplKTtcclxuICBvdXRwdXRTaGFwZS5zcGxpY2UoaXNDaGFubmVsTGFzdCA/IDMgOiAxLCAwLCBvdXRDaGFubmVscyk7XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIGV4dGVuZHMgQ29udkF0dHJpYnV0ZXMge1xyXG4gIHJlYWRvbmx5IG91dHB1dFBhZGRpbmc6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gIHJlYWRvbmx5IG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcclxufVxyXG5cclxuY29uc3QgZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyA9IDxUIGV4dGVuZHMgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM+KFxyXG4gIGF0dHJpYnV0ZXM6IFQsXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbik6IFQgPT4ge1xyXG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xyXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXHJcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAwIHx8IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSkgPT09IDApIHtcclxuICAgIGtlcm5lbFNoYXBlLmxlbmd0aCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGtlcm5lbFNoYXBlLnB1c2goaW5wdXRzWzFdLmRpbXNbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XHJcbiAga2VybmVsU2hhcGUuc3BsaWNlKDAsIDAsIGlucHV0c1sxXS5kaW1zWzBdKTtcclxuICBrZXJuZWxTaGFwZS5zcGxpY2UoaXNDaGFubmVsc0xhc3QgPyAzIDogMSwgMCwgaW5wdXRzWzFdLmRpbXNbMV0pO1xyXG5cclxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLnNsaWNlKCk7XHJcbiAgY29uc3Qgb3V0cHV0UGFkZGluZyA9IGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZy5zbGljZSgpO1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBsZXQgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMuc2xpY2UoKTtcclxuICBpZiAoZGlsYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID09PSAwKSB7XHJcbiAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XHJcbiAgICBkaWxhdGlvbnMgPSBuZXcgQXJyYXkoc3BhdGlhbFJhbmspLmZpbGwoMSk7XHJcbiAgfVxyXG4gIGxldCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzLnNsaWNlKCk7XHJcbiAgaWYgKHN0cmlkZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPT09IDApIHtcclxuICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcclxuICAgIHN0cmlkZXMgPSBuZXcgQXJyYXkoc3BhdGlhbFJhbmspLmZpbGwoMSk7XHJcbiAgfVxyXG4gIC8vIElmIG91dHB1dFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgcGFyYW1ldGVyc1xyXG4gIC8vIFNpbWlsYXJseSwgYXV0b21hdGljYWxseSBpbmZlciBwYWRzIGlmIG5vdCBzcGVjaWZpZWRcclxuICBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMoXHJcbiAgICBpbnB1dFNoYXBlLFxyXG4gICAga2VybmVsU2hhcGUsXHJcbiAgICBkaWxhdGlvbnMsXHJcbiAgICBhdHRyaWJ1dGVzLmF1dG9QYWQsXHJcbiAgICBhdHRyaWJ1dGVzLmdyb3VwLFxyXG4gICAgcGFkcyxcclxuICAgIHN0cmlkZXMsXHJcbiAgICBpc0NoYW5uZWxzTGFzdCxcclxuICAgIG91dHB1dFBhZGRpbmcsXHJcbiAgICBvdXRwdXRTaGFwZSxcclxuICApO1xyXG5cclxuICAvLyBhbHdheXMgcmV0dXJuIGEgbmV3IG9iamVjdCBzbyBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcclxuICBjb25zdCBuZXdBdHRyaWJ1dGVzOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XHJcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBwYWRzLCBvdXRwdXRQYWRkaW5nLCBvdXRwdXRTaGFwZSwgZGlsYXRpb25zLCBzdHJpZGVzIH0pO1xyXG4gIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyA9PiB7XHJcbiAgY29uc3QgYWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XHJcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxyXG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJztcclxuICBjb25zdCBhdXRvUGFkID0gWydOT1RTRVQnLCAnVkFMSUQnLCAnU0FNRV9VUFBFUicsICdTQU1FX0xPV0VSJ11bXHJcbiAgICB0eXBlb2YgYXR0cmlidXRlcy5hdXRvUGFkID09ICd1bmRlZmluZWQnID8gMCA6IChhdHRyaWJ1dGVzLmF1dG9QYWQgYXMgbnVtYmVyKVxyXG4gIF07XHJcbiAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgW251bWJlciwgbnVtYmVyXTtcclxuICBjb25zdCBncm91cCA9IGF0dHJpYnV0ZXMuZ3JvdXAgYXMgbnVtYmVyO1xyXG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xyXG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdO1xyXG4gIGNvbnN0IHdJc0NvbnN0ID0gKGF0dHJpYnV0ZXMud0lzQ29uc3QgYXMgKCkgPT4gYm9vbGVhbikoKTtcclxuICBjb25zdCBvdXRwdXRQYWRkaW5nID0gYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xyXG4gIHJldHVybiB7XHJcbiAgICBhdXRvUGFkLFxyXG4gICAgZm9ybWF0LFxyXG4gICAgZGlsYXRpb25zLFxyXG4gICAgZ3JvdXAsXHJcbiAgICBrZXJuZWxTaGFwZSxcclxuICAgIG91dHB1dFBhZGRpbmcsXHJcbiAgICBvdXRwdXRTaGFwZSxcclxuICAgIHBhZHMsXHJcbiAgICBzdHJpZGVzLFxyXG4gICAgd0lzQ29uc3QsXHJcbiAgICAuLi5hY3RpdmF0aW9uQXR0cmlidXRlcyxcclxuICAgIGNhY2hlS2V5OiBgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9ufTtgLFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICAvLyBSZWZlciB0byB0aGUgYmVsb3cgbGluayBmb3IgYWxsIGlucHV0IGNoZWNrc1xyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZUcmFuc3Bvc2VcclxuICBpZiAoIWlucHV0cyB8fCAoaW5wdXRzLmxlbmd0aCAhPT0gMiAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcclxuICB9XHJcblxyXG4gIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XHJcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnYnKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxyXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDEgOiAxXTtcclxuICBjb25zdCBmaWx0ZXJJbkNoYW5uZWwgPSBpbnB1dHNbMV0uZGltc1swXTtcclxuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmZWF0dXJlTWFwcyA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcclxuXHJcbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgKGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBpbnB1dHNbMl0uZGltc1swXSAhPT0gZmVhdHVyZU1hcHMpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xyXG4gIGNvbnN0IGRpbGF0aW9uc1NldCA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcclxuICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXHJcbiAgaWYgKGRpbGF0aW9uc1NldCAmJiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzdHJpZGVzU2V0ID0gYXR0cmlidXRlcy5zdHJpZGVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcclxuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxyXG4gIGlmIChzdHJpZGVzU2V0ICYmIGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xyXG4gIH1cclxuXHJcbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cclxuICBjb25zdCBwYWRzU2V0ID0gYXR0cmlidXRlcy5wYWRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcclxuICBpZiAocGFkc1NldCAmJiBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xyXG4gIH1cclxuXHJcbiAgLy8gV3Jvbmcgb3V0cHV0IHBhZGRpbmcgZGltZW5zaW9uXHJcbiAgaWYgKGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICYmIGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZy5sZW5ndGggIT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xyXG4gIH1cclxuXHJcbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXHJcbiAgLy8gKHRoZSBmaXJzdCAyIGRpbXMgYXJlIGJhdGNoX3NpemUgYW5kIGNoYW5uZWxzKVxyXG4gIGNvbnN0IGtlcm5lbFNoYXBlU2V0ID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XHJcbiAgaWYgKFxyXG4gICAga2VybmVsU2hhcGVTZXQgJiZcclxuICAgIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmXHJcbiAgICBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMlxyXG4gICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xyXG4gIH1cclxuXHJcbiAgLy8gYXMgd2l0aCBrZXJuZWxTaGFwZSwgbXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHNwYXRpYWwgZGltcyBhcyBpbnB1dFxyXG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG91dHB1dCBzaGFwZScpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNvbnZUcmFuc3Bvc2UyZCA9IChcclxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcclxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxyXG4pOiB2b2lkID0+IHtcclxuICAvLyBTVEVQLjE6IHRyYW5zcG9zZSB3ZWlnaHRcclxuICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cclxuICAgIChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cclxuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIFsyLCAzLCAwLCAxXSksIHtcclxuICAgICAgaW5wdXRzOiBbMV0sXHJcbiAgICAgIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV0sXHJcbiAgICB9KVswXTtcclxuICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XHJcbiAgICBjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgPSB0cmFuc3Bvc2VkV2VpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLy8gU1RFUC4yOiBwcmVwYXJlIHJlc2hhcGVkIGlucHV0c1xyXG4gIGNvbnN0IGNvbnZUcmFuc3Bvc2VJbnB1dHMgPSBbaW5wdXRzWzBdLCB0cmFuc3Bvc2VkV2VpZ2h0XTtcclxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgY29udlRyYW5zcG9zZUlucHV0cy5wdXNoKGlucHV0c1syXSk7XHJcbiAgfVxyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyhjb252VHJhbnNwb3NlSW5wdXRzLCBhdHRyaWJ1dGVzLCBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiksIHtcclxuICAgIGlucHV0czogY29udlRyYW5zcG9zZUlucHV0cyxcclxuICB9KTtcclxufTtcclxuXHJcbmNvbnN0IGNvbnZUcmFuc3Bvc2UxZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICAvLyBleHRlbmQgdGhlIGlucHV0IHRvIDJEIGJ5IGFkZGluZyBIIGRpbWVuc2lvblxyXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xyXG5cclxuICBjb25zdCBpbnB1dHMgPSBbXHJcbiAgICBjb250ZXh0LmlucHV0c1swXS5yZXNoYXBlKFxyXG4gICAgICBpc0NoYW5uZWxMYXN0XHJcbiAgICAgICAgPyAvLyBbTiwgVywgQ10gLT4gW04sIEg9MSwgVywgQ11cclxuICAgICAgICAgIFtjb250ZXh0LmlucHV0c1swXS5kaW1zWzBdLCAxLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzFdLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzJdXVxyXG4gICAgICAgIDogLy8gW04sIEMsIFddIC0+IFtOLCBDLCBIPTEsIFddXHJcbiAgICAgICAgICBbY29udGV4dC5pbnB1dHNbMF0uZGltc1swXSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1sxXSwgMSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1syXV0sXHJcbiAgICApLFxyXG4gICAgLy9bRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga1ddIC0+IFtGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrSD0xLCBrV11cclxuICAgIGNvbnRleHQuaW5wdXRzWzFdLnJlc2hhcGUoW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dKSxcclxuICBdO1xyXG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDMpIHtcclxuICAgIGlucHV0cy5wdXNoKGNvbnRleHQuaW5wdXRzWzJdKTtcclxuICB9XHJcbiAgbGV0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZTtcclxuICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoID09PSAwIHx8IGtlcm5lbFNoYXBlWzBdID09PSAwKSB7XHJcbiAgICBrZXJuZWxTaGFwZSA9IFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXTtcclxuICB9XHJcbiAgbGV0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zO1xyXG4gIGlmIChkaWxhdGlvbnMubGVuZ3RoID09PSAwIHx8IGRpbGF0aW9uc1swXSA9PT0gMCkge1xyXG4gICAgZGlsYXRpb25zID0gWzFdO1xyXG4gIH1cclxuICBsZXQgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcztcclxuICBpZiAoc3RyaWRlcy5sZW5ndGggPT09IDAgfHwgc3RyaWRlc1swXSA9PT0gMCkge1xyXG4gICAgc3RyaWRlcyA9IFsxXTtcclxuICB9XHJcbiAgbGV0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHM7XHJcbiAgaWYgKHBhZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICBwYWRzID0gWzAsIDBdO1xyXG4gIH1cclxuICBwYWRzID0gWzAsIHBhZHNbMF0sIDAsIHBhZHNbMV1dO1xyXG4gIHN0cmlkZXMgPSBbMV0uY29uY2F0KHN0cmlkZXMpO1xyXG4gIGRpbGF0aW9ucyA9IFsxXS5jb25jYXQoZGlsYXRpb25zKTtcclxuICBrZXJuZWxTaGFwZSA9IFsxXS5jb25jYXQoa2VybmVsU2hhcGUpO1xyXG4gIGxldCBvdXRwdXRQYWRkaW5nID0gYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nO1xyXG4gIG91dHB1dFBhZGRpbmcgPSBbMF0uY29uY2F0KG91dHB1dFBhZGRpbmcpO1xyXG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMoXHJcbiAgICB7IC4uLmF0dHJpYnV0ZXMsIHBhZHMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIG91dHB1dFBhZGRpbmcgfSxcclxuICAgIGlucHV0cyxcclxuICApO1xyXG5cclxuICBjb252VHJhbnNwb3NlMmQoY29udGV4dCwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIChvdXRwdXRTaGFwZSkgPT5cclxuICAgIGlzQ2hhbm5lbExhc3QgPyBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXV0gOiBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzFdLCBvdXRwdXRTaGFwZVszXV0sXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb252VHJhbnNwb3NlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMpIHtcclxuICAgIGNvbnZUcmFuc3Bvc2UxZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBjb250ZXh0LmlucHV0cyk7XHJcbiAgICBjb252VHJhbnNwb3NlMmQoY29udGV4dCwgY29udGV4dC5pbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyk7XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDdW1TdW1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBleGNsdXNpdmU6IGJvb2xlYW47XHJcbiAgcmVhZG9ubHkgcmV2ZXJzZTogYm9vbGVhbjtcclxufVxyXG5jb25zdCBjcmVhdGVDdW1zdW1Qcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dFR5cGU6IG51bWJlcixcclxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBheGlzSW5wdXQ6IFRlbnNvclZpZXcsXHJcbiAgYXR0cmlidXRlczogQ3VtU3VtQXR0cmlidXRlcyxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTsgLy8gb3V0cHV0U2hhcGUgaXMgc2FtZSBhcyBpbnB1dFNoYXBlLlxyXG4gIGNvbnN0IHJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDsgLy8gaW5wdXQvb3V0cHV0IHJhbmtcclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRUeXBlLCByYW5rKTtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRUeXBlLCByYW5rKTtcclxuICBjb25zdCBheGlzVmFsdWUgPVxyXG4gICAgYXhpc0lucHV0LmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMiA/IGF4aXNJbnB1dC5nZXRJbnQzMkFycmF5KClbMF0gOiBOdW1iZXIoYXhpc0lucHV0LmdldEJpZ0ludDY0QXJyYXkoKVswXSk7XHJcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF4aXNWYWx1ZSwgcmFuayk7XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBpbmRleCA9IGAgaTMyKCR7aW5wdXQuaW5kaWNlc0dldCgnaW5wdXRJbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX0pIGA7XHJcbiAgICBjb25zdCBtYXggPSBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ3VuaWZvcm1zLmF4aXMnLCByYW5rKTtcclxuICAgIGNvbnN0IGxvd2VyTGltaXQgPSBhdHRyaWJ1dGVzLnJldmVyc2UgPyBpbmRleCArIChhdHRyaWJ1dGVzLmV4Y2x1c2l2ZSA/ICcgKyAxJyA6ICcnKSA6ICcwJztcclxuICAgIGNvbnN0IHVwcGVyTGltaXQgPSBhdHRyaWJ1dGVzLnJldmVyc2UgPyBtYXggOiBpbmRleCArIChhdHRyaWJ1dGVzLmV4Y2x1c2l2ZSA/ICcnIDogJyArIDEnKTtcclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgICAgICAke3NoYWRlckhlbHBlclxyXG4gICAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXHJcbiAgICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcclxuICAgICAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XHJcbiAgICAgICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxyXG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgICAgICAgICAgICAgICB2YXIgc3VtID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7bG93ZXJMaW1pdH07XHJcbiAgICAgICAgICAgICAgICAgIGxldCBsYXN0IDogaTMyID0gJHt1cHBlckxpbWl0fTtcclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA6IGkzMiA9IGZpcnN0OyBpIDwgbGFzdDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICd1MzIoaSknKX07XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0SW5kaWNlcycpfTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdzdW0nKX07XHJcbiAgICAgICAgICAgICAgICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnQ3VtU3VtJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzIH0sXHJcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgaW5wdXRTaGFwZSksXHJcbiAgICAgIF0sXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGN1bXN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ3VtU3VtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBjb250ZXh0LmlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGlucHV0VHlwZSA9IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlO1xyXG4gIGNvbnN0IGF4aXMgPSBjb250ZXh0LmlucHV0c1sxXTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQ3Vtc3VtUHJvZ3JhbUluZm8oaW5wdXRUeXBlLCBpbnB1dFNoYXBlLCBheGlzLCBhdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUN1bVN1bUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDdW1TdW1BdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBleGNsdXNpdmUgPSAoYXR0cmlidXRlcy5leGNsdXNpdmUgYXMgbnVtYmVyKSA9PT0gMTtcclxuICBjb25zdCByZXZlcnNlID0gKGF0dHJpYnV0ZXMucmV2ZXJzZSBhcyBudW1iZXIpID09PSAxO1xyXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBleGNsdXNpdmUsIHJldmVyc2UgfSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRBdHRyaWJ1dGVzIHtcclxuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzIGV4dGVuZHMgRm9ybWF0QXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBibG9ja3NpemU6IG51bWJlcjtcclxuICByZWFkb25seSBtb2RlOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXB0aFRvU3BhY2UgcmVxdWlyZXMgMSBpbnB1dC4nKTtcclxuICB9XHJcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXB0aFRvU3BhY2UgcmVxdWlyZXMgNEQgaW5wdXQuJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgcGVybUZ1bmN0aW9uQm9keSA9IChwZXJtOiBudW1iZXJbXSwgcmFuazogbnVtYmVyLCBpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyKTogc3RyaW5nID0+IHtcclxuICBjb25zdCByZXZlcnNlRnVuYyA9IFtdO1xyXG4gIHJldmVyc2VGdW5jLnB1c2goYGZuIHBlcm0oaTogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcclxuICAgIHZhciBhOiAke2lucHV0LnR5cGUuaW5kaWNlc307YCk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcclxuICAgIHJldmVyc2VGdW5jLnB1c2goaW5wdXQuaW5kaWNlc1NldCgnYScsIHBlcm1baV0sIGBpWyR7aX1dYCkpO1xyXG4gIH1cclxuICByZXZlcnNlRnVuYy5wdXNoKCdyZXR1cm4gYTt9Jyk7XHJcbiAgcmV0dXJuIHJldmVyc2VGdW5jLmpvaW4oJ1xcbicpO1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlRGVwdGhUb1NwYWNlUHJvZ3JhbUluZm8gPSAoaW5wdXRUZW5zb3I6IFRlbnNvclZpZXcsIGF0dHJpYnV0ZXM6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgbGV0IG46IG51bWJlciwgaDogbnVtYmVyLCB3OiBudW1iZXIsIGM6IG51bWJlcjtcclxuICBsZXQgc2hhcGU6IG51bWJlcltdO1xyXG4gIGxldCBwZXJtOiBudW1iZXJbXTtcclxuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcclxuICBjb25zdCBibG9ja3NpemUgPSBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZTtcclxuICBjb25zdCBpc0RDUm1vZGUgPSBhdHRyaWJ1dGVzLm1vZGUgPT09ICdEQ1InO1xyXG4gIGlmIChpc0NoYW5uZWxMYXN0KSB7XHJcbiAgICBbbiwgaCwgdywgY10gPSBpbnB1dFRlbnNvci5kaW1zO1xyXG4gICAgc2hhcGUgPSBpc0RDUm1vZGVcclxuICAgICAgPyBbbiwgaCwgdywgYmxvY2tzaXplLCBibG9ja3NpemUsIGMgLyBibG9ja3NpemUgKiogMl1cclxuICAgICAgOiBbbiwgaCwgdywgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBibG9ja3NpemUsIGJsb2Nrc2l6ZV07XHJcbiAgICBwZXJtID0gaXNEQ1Jtb2RlID8gWzAsIDEsIDMsIDIsIDQsIDVdIDogWzAsIDEsIDQsIDIsIDUsIDNdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBbbiwgaCwgdywgY10gPSBbaW5wdXRUZW5zb3IuZGltc1swXSwgaW5wdXRUZW5zb3IuZGltc1syXSwgaW5wdXRUZW5zb3IuZGltc1szXSwgaW5wdXRUZW5zb3IuZGltc1sxXV07XHJcbiAgICBzaGFwZSA9IGlzRENSbW9kZVxyXG4gICAgICA/IFtuLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBoLCB3XVxyXG4gICAgICA6IFtuLCBjIC8gYmxvY2tzaXplICoqIDIsIGJsb2Nrc2l6ZSwgYmxvY2tzaXplLCBoLCB3XTtcclxuICAgIHBlcm0gPSBpc0RDUm1vZGUgPyBbMCwgMywgNCwgMSwgNSwgMl0gOiBbMCwgMSwgNCwgMiwgNSwgM107XHJcbiAgfVxyXG4gIGNvbnN0IHJlc2hhcGVkSW5wdXRUZW5zb3IgPSBpbnB1dFRlbnNvci5yZXNoYXBlKHNoYXBlKTtcclxuICBjb25zdCByZXNoYXBlZElucHV0UmFuayA9IHJlc2hhcGVkSW5wdXRUZW5zb3IuZGltcy5sZW5ndGg7XHJcbiAgY29uc3QgaW5wdXREYXRhVHlwZSA9IGlucHV0VGVuc29yLmRhdGFUeXBlO1xyXG5cclxuICBjb25zdCByZXNoYXBlZElucHV0ID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0RGF0YVR5cGUsIHJlc2hhcGVkSW5wdXRSYW5rKTtcclxuICBjb25zdCBwZXJtZWRPdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgcmVzaGFwZWRJbnB1dFJhbmspO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMocmVzaGFwZWRJbnB1dCwgcGVybWVkT3V0cHV0KX1cclxuXHJcbiAgJHtwZXJtRnVuY3Rpb25Cb2R5KHBlcm0sIHJlc2hhcGVkSW5wdXRSYW5rLCByZXNoYXBlZElucHV0LCBwZXJtZWRPdXRwdXQpfVxyXG5cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcblxyXG4gICAgbGV0IGluZGljZXMgPSAke3Blcm1lZE91dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xyXG5cclxuICAgICR7cGVybWVkT3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgcmVzaGFwZWRJbnB1dC5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJykpfVxyXG4gIH1gO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0RlcHRoVG9TcGFjZScsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHtpbnB1dFRlbnNvci5kaW1zfTske2F0dHJpYnV0ZXMuYmxvY2tzaXplfTske2F0dHJpYnV0ZXMubW9kZX1gLFxyXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10sXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKGlucHV0cykgPT4ge1xyXG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlzQ2hhbm5lbExhc3RcclxuICAgICAgICA/IFtuLCBoICogYmxvY2tzaXplLCB3ICogYmxvY2tzaXplLCBjIC8gYmxvY2tzaXplICoqIDJdXHJcbiAgICAgICAgOiBbbiwgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBoICogYmxvY2tzaXplLCB3ICogYmxvY2tzaXplXTtcclxuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICAgICAgY29uc3Qgc2hhcGVCZWZvcmVQZXJtID0gcmVzaGFwZWRJbnB1dFRlbnNvci5kaW1zO1xyXG4gICAgICBjb25zdCBzaGFwZUFmdGVyUGVybSA9IFNoYXBlVXRpbC5zb3J0QmFzZWRPblBlcm0oc2hhcGVCZWZvcmVQZXJtLCBwZXJtKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXHJcbiAgICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoc2hhcGVCZWZvcmVQZXJtLCBzaGFwZUFmdGVyUGVybSksXHJcbiAgICAgICAgXSxcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkZXB0aFRvU3BhY2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZURlcHRoVG9TcGFjZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XHJcbiAgICBibG9ja3NpemU6IGF0dHJpYnV0ZXMuYmxvY2tzaXplIGFzIG51bWJlcixcclxuICAgIG1vZGU6IGF0dHJpYnV0ZXMubW9kZSBhcyBzdHJpbmcsXHJcbiAgICBmb3JtYXQ6IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJyxcclxuICB9KTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFaW5zdW1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBlcXVhdGlvbjogc3RyaW5nO1xyXG59XHJcbi8vIFRoZSBlcXVhdGlvbiBhdHRyaWJ1dGUgdmFsdWUgaXMgYSBzdHJpbmcgd2hpY2ggY29uc2lzdHMgb2YgbGVmdCBoYW5kIHNpZGUgKExIUykgYW5kIG9wdGlvbmFsbHkgcmlnaHQgaGFuZCBzaWRlIChSSFMpXHJcbi8vIHNlcGFyYXRlZCBieSAnLT4nLiBFeC4gXCJpaixqayAtPiBpa1wiIGV4cHJlc3NlcyBtYXRyaXggbXVsdGlwbGljYXRpb25cclxuLy8gICAgIFwiaWotPmppXCIgZXhwcmVzc2VzIG1hdHJpeCB0cmFuc3Bvc2VcclxuLy8gICAgICBcImlpLT5pXCIgZGlhZ29uYWwgZWxlbWVudHMgb2YgYSBzcXVhcmUgbWF0cml4XHJcbi8vIExIUyBjb25zaXN0cyBvZiBhIHNlcXVlbmNlIG9mIHRlcm1zIHNlcGFyYXRlZCBieSBjb21tYXMuIEVhY2ggdGVybSBjb3JyZXNwb25kcyB0byBhbiBpbnB1dCB2YXJpYWJsZS5cclxuLy8gRWFjaCBzeW1ib2wgY29ycmVzcG9uZHMgdG8gYSBkaW1lbnNpb24gaW4gdGhlIGlucHV0IHZhcmlhYmxlLiBUaGUgc3ltYm9sIGNhbiBiZSBlaXRoZXIgYSBsZXR0ZXIsICdhJyB0byAneicgb3IgJ0EnIHRvXHJcbi8vICdaJyBvciAnLi4uJyB0byByZXByZXNlbnQgYXJiaXRyYXJ5IGRpbWVuc2lvbnMuXHJcblxyXG5jb25zdCBzeW1ib2xQYXR0ZXJuID0gJ1thLXpBLVpdfFxcXFwuXFxcXC5cXFxcLic7IC8vIFRoZSBwYXR0ZXJuIGVhY2ggc3ltYm9sIGluIGVhY2ggdGVybSBpbiB0aGUgc3ltYm9saWMgZXF1YXRpb24gc2hvdWxkIG1hdGNoXHJcbmNvbnN0IHRlcm1QYXR0ZXJuID0gJygnICsgc3ltYm9sUGF0dGVybiArICcpKyc7IC8vIFRoZSBwYXR0ZXJuIGVhY2ggdGVybSBpbiB0aGUgc3ltYm9saWMgZXF1YXRpb24gc2hvdWxkIG1hdGNoXHJcbmNvbnN0IHRlcm1QYXR0ZXJuT25seSA9ICdeJyArIHRlcm1QYXR0ZXJuICsgJyQnOyAvLyBUaGUgcGF0dGVybnMgb25seSBtYXRjaGVzIGEgdGVybSBiZWdpbiB0byBlbmQuXHJcbmNvbnN0IGxoc1BhdHRlcm4gPSAnKCcgKyB0ZXJtUGF0dGVybiArICcsKSonICsgdGVybVBhdHRlcm47IC8vIFRoZSBwYXR0ZXJuIHRoZSBMSFMgc2hvdWxkIG1hdGNoXHJcbmNvbnN0IGxoc1BhdHRlcm5Pbmx5ID0gJ14nICsgbGhzUGF0dGVybiArICckJzsgLy8gVGhlIHBhdHRlcm5zIG9ubHkgbWF0Y2hlcyBhIExIUyBiZWdpbiB0byBlbmQuXHJcblxyXG5pbnRlcmZhY2UgU3ltYm9sSW5mbyB7XHJcbiAgY291bnQ6IG51bWJlcjsgLy8gU3ltYm9sIGNvcnJlc3BvbmRpbmcgdG8gYSBkaW1lbnNpb24gb2YgYW4gaW5wdXRcclxuICBpbnB1dEluZGljZXM6IG51bWJlcltdOyAvLyBOdW1iZXIgb2YgaW5wdXQgdmFyaWFibGVzIHRoZSBzeW1ib2wgY29ycmVzcG9uZHMgdG9cclxuICBkaW1WYWx1ZTogbnVtYmVyOyAvLyBOdW1iZXIgb2YgZGltZW5zaW9ucyB0aGUgc3ltYm9sIGNvcnJlc3BvbmRzIHRvXHJcbn1cclxuXHJcbmNsYXNzIEVpbnN1bVRlcm0ge1xyXG4gIGNvbnN0cnVjdG9yKGlucHV0SW5kZXggPSAtMSkge1xyXG4gICAgdGhpcy5zeW1ib2xUb0luZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyW10+KCk7XHJcbiAgICB0aGlzLmlucHV0SW5kZXggPSBpbnB1dEluZGV4O1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIGEgc3ltYm9sIHRvIHRoZSB0ZXJtXHJcbiAgYWRkU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBpbmRleDogbnVtYmVyKSB7XHJcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhbHVlID0gW2luZGV4XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbHVlLnB1c2goaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHN5bWJvbCwgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgc3ltYm9sVG9JbmRpY2VzOiBNYXA8c3RyaW5nLCBudW1iZXJbXT47IC8vIE1hcCBmcm9tIHN5bWJvbCB0byBkaW1lbnNpb25zIG9mIHRoZSBpbnB1dCBjb3JyZXNwb25kaW5nIHRvIHRoZSB0ZXJtXHJcbiAgaW5wdXRJbmRleDogbnVtYmVyOyAvLyAtMSBmb3Igb3V0cHV0IGFuZCAwLCAxLCAyLCAuLi4gZm9yIGlucHV0c1xyXG59XHJcblxyXG5jbGFzcyBFaW5zdW1FcXVhdGlvbiB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICAgIHB1YmxpYyByZWFkb25seSBlcXVhdGlvbjogc3RyaW5nLFxyXG4gICkge1xyXG4gICAgdGhpcy5oYXNFbGxpcHNpcyA9IGZhbHNlO1xyXG4gICAgdGhpcy5zeW1ib2xUb0luZm8gPSBuZXcgTWFwPHN0cmluZywgU3ltYm9sSW5mbz4oKTtcclxuICAgIHRoaXMubGhzID0gbmV3IEFycmF5PEVpbnN1bVRlcm0+KCk7XHJcbiAgICB0aGlzLm91dHB1dERpbXMgPSBbXTtcclxuICAgIC8vIEFzIHJocyBuZWVkcyB0byBiZSB1cGRhdGVkIGFsbG93IHVzaW5nIGxldCBpbnN0ZWFkIG9mIGNvbnN0IGZvciBib3RoIGxocyBhbmQgcmhzLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxyXG4gICAgbGV0IFtsaHMsIHJoc10gPSBlcXVhdGlvbi5pbmNsdWRlcygnLT4nKSA/IGVxdWF0aW9uLnNwbGl0KCctPicsIDIpIDogW2VxdWF0aW9uLCAnJ107XHJcbiAgICBpZiAoIWxocy5tYXRjaChSZWdFeHAobGhzUGF0dGVybk9ubHkpKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTEhTIHRlcm0nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlucHV0VGVybXMgPSBsaHMuc3BsaXQoJywnKTtcclxuICAgIGlucHV0VGVybXMuZm9yRWFjaCgoaW5wdXRUZXJtLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBkaW1zID0gaW5wdXRzW2luZGV4XS5kaW1zLnNsaWNlKCk7XHJcbiAgICAgIGlmICghaW5wdXRUZXJtLm1hdGNoKFJlZ0V4cCh0ZXJtUGF0dGVybk9ubHkpKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGVpbnN1bVRlcm0gPSB0aGlzLnByb2Nlc3NUZXJtKGlucHV0VGVybSwgdHJ1ZSwgZGltcywgaW5kZXgpO1xyXG4gICAgICB0aGlzLmxocy5wdXNoKGVpbnN1bVRlcm0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgUkhTIGlmIG5vdCBzcGVjaWZpZWRcclxuICAgIGlmIChyaHMgPT09ICcnKSB7XHJcbiAgICAgIC8vIENvbnN0cnVjdCBSSFMgZnJvbSBMSFMgdGVybXMvc3ltYm9sc1xyXG4gICAgICByaHMgKz0gWy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV1cclxuICAgICAgICAuZmlsdGVyKChbc3ltLCBpbmZvXSkgPT4gaW5mby5jb3VudCA9PT0gMSB8fCBzeW0gPT09ICcuLi4nKVxyXG4gICAgICAgIC5tYXAoKFtzeW1dKSA9PiBzeW0pXHJcbiAgICAgICAgLmpvaW4oJycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCFyaHMubWF0Y2goUmVnRXhwKHRlcm1QYXR0ZXJuKSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21wdXRlIG91dHB1dCBkaW1zXHJcbiAgICBjb25zdCByaHNTeW1ib2xzID0gcmhzLm1hdGNoKFJlZ0V4cChzeW1ib2xQYXR0ZXJuLCAnZycpKTtcclxuICAgIHJoc1N5bWJvbHM/LmZvckVhY2goKHN5bWJvbCkgPT4ge1xyXG4gICAgICBpZiAoc3ltYm9sID09PSAnLi4uJykge1xyXG4gICAgICAgIHRoaXMub3V0cHV0RGltcyA9IHRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLnN5bWJvbFRvSW5mby5nZXQoc3ltYm9sKTtcclxuICAgICAgICBpZiAoaW5mbyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTIHN5bWJvbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm91dHB1dERpbXMucHVzaChpbmZvLmRpbVZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnJocyA9IHRoaXMucHJvY2Vzc1Rlcm0ocmhzLCBmYWxzZSwgdGhpcy5vdXRwdXREaW1zKTtcclxuICB9IC8vIEVuZCBvZiBFaW5zdW1FcWF0aW9uIGNvbnN0cnVjdG9yXHJcblxyXG4gIC8vIEFkZCBhIHN5bWJvbCB0byB0aGUgZXF1YXRpb25cclxuICBhZGRTeW1ib2woc3ltYm9sOiBzdHJpbmcsIGRpbVZhbHVlOiBudW1iZXIsIGlucHV0SW5kZXg6IG51bWJlcikge1xyXG4gICAgbGV0IGluZm8gPSB0aGlzLnN5bWJvbFRvSW5mby5nZXQoc3ltYm9sKTtcclxuICAgIGlmIChpbmZvICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKGluZm8uZGltVmFsdWUgIT09IGRpbVZhbHVlICYmIGluZm8uY291bnQgIT09IDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluZm8uY291bnQrKztcclxuICAgICAgICBpbmZvLmlucHV0SW5kaWNlcy5wdXNoKGlucHV0SW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbmZvID0geyBjb3VudDogMSwgZGltVmFsdWUsIGlucHV0SW5kaWNlczogW2lucHV0SW5kZXhdIH07XHJcbiAgICB9XHJcbiAgICB0aGlzLnN5bWJvbFRvSW5mby5zZXQoc3ltYm9sLCBpbmZvKTtcclxuICB9XHJcblxyXG4gIC8vIFByb2Nlc3Mgb25lIGlucHV0L291dHB1dCB0ZXJtXHJcbiAgcHJvY2Vzc1Rlcm0odGVybTogc3RyaW5nLCBpc0lucHV0OiBib29sZWFuLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSwgaW5kZXggPSAtMSk6IEVpbnN1bVRlcm0ge1xyXG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xyXG4gICAgbGV0IGVsbGlwc2lzID0gZmFsc2U7XHJcbiAgICBsZXQgZWxsaXBzaXNEaW1zID0gW107XHJcbiAgICBsZXQgbmV4dERpbSA9IDA7XHJcbiAgICAvLyBGb3Igb3V0cHV0IGVtcHR5IHN0cmluZyBpcyBhbGxvd2VkIGJlY2F1c2UgdGhlIG91dHB1dCBtYXkgYmUgcmVkdWNlZCB0byBhIHNjYWxhciB2YWx1ZVxyXG4gICAgaWYgKCF0ZXJtLm1hdGNoKFJlZ0V4cCh0ZXJtUGF0dGVybk9ubHkpKSAmJiAhaXNJbnB1dCAmJiB0ZXJtICE9PSAnJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTEhTIHRlcm0nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluZGV4U3ltYm9scyA9IHRlcm0ubWF0Y2goUmVnRXhwKHN5bWJvbFBhdHRlcm4sICdnJykpO1xyXG4gICAgY29uc3QgZWluc3VtVGVybSA9IG5ldyBFaW5zdW1UZXJtKGluZGV4KTtcclxuICAgIC8vIHN5bWJvbCBjYW4gYmUgZWl0aGVyIGEgbGV0dHJlLCAnYScgdG8gJ3onIG9yICdBJyB0byAnWicsIG9yICcuLi4nXHJcbiAgICBpbmRleFN5bWJvbHM/LmZvckVhY2goKHN5bWJvbDogc3RyaW5nLCBpOiBudW1iZXIpID0+IHtcclxuICAgICAgaWYgKHN5bWJvbCA9PT0gJy4uLicpIHtcclxuICAgICAgICBpZiAoZWxsaXBzaXMpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgZWxsaXBzaXMgaXMgYWxsb3dlZCBwZXIgaW5wdXQgdGVybScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbGxpcHNpcyA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgZWxsaXBzaXNEaW1MZW5ndGggPSByYW5rIC0gaW5kZXhTeW1ib2xzLmxlbmd0aCArIDE7XHJcbiAgICAgICAgaWYgKGVsbGlwc2lzRGltTGVuZ3RoIDwgMCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBvdXQgb2YgYm91bmRzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsbGlwc2lzRGltcyA9IGRpbXMuc2xpY2UobmV4dERpbSwgbmV4dERpbSArIGVsbGlwc2lzRGltTGVuZ3RoKTtcclxuICAgICAgICBpZiAodGhpcy5oYXNFbGxpcHNpcykge1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGggIT09IGVsbGlwc2lzRGltcy5sZW5ndGggfHxcclxuICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSAhPT0gZWxsaXBzaXNEaW1zLnRvU3RyaW5nKClcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsbGlwc2lzIGRpbWVuc2lvbnMgbWlzbWF0Y2gnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGlzSW5wdXQpIHtcclxuICAgICAgICAgIHRoaXMuaGFzRWxsaXBzaXMgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMgPSBlbGxpcHNpc0RpbXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxsaXBzaXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIExIUycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsIGV0YyB0byByZXByZXNlbnQgZWxsaXBzaXMgZGltZW5zaW9ucyB0byBhdm9pZCBzcGVjaWFsIGhhbmRsaW5nXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBlbGxpcHNpc0RpbXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJzAnLmNoYXJDb2RlQXQoMCkgKyBqKTtcclxuICAgICAgICAgIGVpbnN1bVRlcm0uYWRkU3ltYm9sKHN5bWJvbCwgaSArIGopO1xyXG4gICAgICAgICAgdGhpcy5hZGRTeW1ib2woc3ltYm9sLCBkaW1zW25leHREaW0rK10sIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWluc3VtVGVybS5hZGRTeW1ib2woc3ltYm9sLCBpICsgKHRoaXMuaGFzRWxsaXBzaXMgPyB0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGggLSAxIDogMCkpO1xyXG4gICAgICAgIHRoaXMuYWRkU3ltYm9sKHN5bWJvbCwgZGltc1tuZXh0RGltKytdLCBpbmRleCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGVpbnN1bVRlcm07XHJcbiAgfVxyXG5cclxuICBzeW1ib2xUb0luZm86IE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+OyAvLyBBbGwgc3ltYm9scyBpbiB0aGUgZXF1YXRpb25cclxuICBoYXNFbGxpcHNpczogYm9vbGVhbjsgLy8gVGhlIGVxdWF0aW9uIGhhcyBlbGxpcHNpcyBvciBub3RcclxuICBlbGxpcHNpc0RpbXM6IG51bWJlcltdOyAvLyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZXF1YXRpb24gZWxsaXBzaXMgY29ycmVzcG9uZHMgdG8uXHJcbiAgbGhzOiBFaW5zdW1UZXJtW107IC8vIFRlcm1zIG9uIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgZXF1YXRpb25cclxuICByaHM6IEVpbnN1bVRlcm07IC8vIFRlcm0gb24gdGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgZXF1YXRpb25cclxuICBvdXRwdXREaW1zOiBudW1iZXJbXTsgLy8gT3V0cHV0IGRpbWVuc2lvbnMgb2YgdGhlIGVxdWF0aW9uXHJcbn0gLy8gRW5kIG9mIGNsYXNzIEVpbnN1bUVxdWF0aW9uXHJcblxyXG5jb25zdCBhcHBlbmRNYXggPSAobmFtZTogc3RyaW5nKTogc3RyaW5nID0+IG5hbWUgKyAnX21heCc7XHJcblxyXG5jb25zdCBjcmVhdGVFaW5zdW1Qcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dFNoYXBlczogQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+LFxyXG4gIGRhdGFUeXBlOiBudW1iZXIsXHJcbiAgZWluc3VtRXF1YXRpb246IEVpbnN1bUVxdWF0aW9uLFxyXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IHJhbmtzID0gaW5wdXRTaGFwZXMubWFwKChkaW1zKSA9PiBkaW1zLmxlbmd0aCk7XHJcbiAgY29uc3QgaW5wdXRWYXJzID0gcmFua3MubWFwKChyYW5rLCBpbmRleCkgPT4gaW5wdXRWYXJpYWJsZShgaW5wdXQke2luZGV4fWAsIGRhdGFUeXBlLCByYW5rKSk7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgY29uc3QgdW5pZm9ybXNTeW1ib2xzID0gWy4uLmVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5rZXlzKCldLmZpbHRlcihcclxuICAgIChzeW1ib2wpID0+ICFlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhzeW1ib2wpLFxyXG4gICk7XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBpZHhDb3B5OiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgY29uc3QgaW5pdFByb2QgPSAndmFyIHByb2QgPSAxLjA7JztcclxuICAgIGNvbnN0IGluaXRTdW0gPSAndmFyIHN1bSA9IDAuMDsnO1xyXG4gICAgY29uc3QgdXBkYXRlU3VtID0gJ3N1bSArPSBwcm9kOyc7XHJcbiAgICBjb25zdCByZWR1Y2VPcHNTZXRJbmRpY2VzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgY29uc3QgcmVkdWNlT3BzTG9vcEhlYWRlcnM6IHN0cmluZ1tdID0gW107XHJcbiAgICBjb25zdCByZWR1Y2VPcHNMb29wRm9vdGVyczogc3RyaW5nW10gPSBbXTtcclxuICAgIGNvbnN0IHJlZHVjZU9wQ29tcHV0ZTogc3RyaW5nW10gPSBbXTtcclxuICAgIGNvbnN0IGlzUmVkdWNlT3BzV2l0aG91dExvb3AgPSBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uc2l6ZSA9PT0gZWluc3VtRXF1YXRpb24ucmhzLnN5bWJvbFRvSW5kaWNlcy5zaXplO1xyXG4gICAgZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmZvckVhY2goKGluZm8sIHN5bWJvbCkgPT4ge1xyXG4gICAgICBpZiAoZWluc3VtRXF1YXRpb24ucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoc3ltYm9sKSkge1xyXG4gICAgICAgIGNvbnN0IG91dHB1dEluZGV4ID0gZWluc3VtRXF1YXRpb24ucmhzLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKT8uWzBdO1xyXG4gICAgICAgIGlmIChvdXRwdXRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBlaW5zdW1FcXVhdGlvbi5saHMuZm9yRWFjaCgodGVybSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5mby5pbnB1dEluZGljZXMuaW5jbHVkZXMoaSkpIHtcclxuICAgICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gdGVybS5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgaWYgKGluZGljZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN5bWJvbCBlcnJvcicpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpbmRpY2VzLmZvckVhY2goKGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZHhDb3B5LnB1c2goXHJcbiAgICAgICAgICAgICAgICAgIGAke2lucHV0VmFyc1tpXS5pbmRpY2VzU2V0KFxyXG4gICAgICAgICAgICAgICAgICAgIGBpbnB1dCR7aX1JbmRpY2VzYCxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dEluZGV4KSxcclxuICAgICAgICAgICAgICAgICAgKX1gLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVpbnN1bUVxdWF0aW9uLmxocy5mb3JFYWNoKCh0ZXJtLCBpKSA9PiB7XHJcbiAgICAgICAgICBpZiAoaW5mby5pbnB1dEluZGljZXMuaW5jbHVkZXMoaSkpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRlcm0uc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpO1xyXG4gICAgICAgICAgICBpZiAoaW5kaWNlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN5bWJvbCBlcnJvcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluZGljZXMuZm9yRWFjaCgoaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICByZWR1Y2VPcHNTZXRJbmRpY2VzLnB1c2goYCR7aW5wdXRWYXJzW2ldLmluZGljZXNTZXQoYGlucHV0JHtpfUluZGljZXNgLCBpbmRleCwgYCR7c3ltYm9sfWApfWApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVkdWNlT3BDb21wdXRlLnB1c2goYHByb2QgKj0gJHtpbnB1dFZhcnNbaV0uZ2V0QnlJbmRpY2VzKGBpbnB1dCR7aX1JbmRpY2VzYCl9O2ApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlZHVjZU9wc0xvb3BIZWFkZXJzLnB1c2goXHJcbiAgICAgICAgICBgZm9yKHZhciAke3N5bWJvbH06IHUzMiA9IDA7ICR7c3ltYm9sfSA8IHVuaWZvcm1zLiR7YXBwZW5kTWF4KHN5bWJvbCl9OyAke3N5bWJvbH0rKykge2AsXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZWR1Y2VPcHNMb29wRm9vdGVycy5wdXNoKCd9Jyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVkdWNlT3BzID0gaXNSZWR1Y2VPcHNXaXRob3V0TG9vcFxyXG4gICAgICA/IFtcclxuICAgICAgICAgIC4uLmlkeENvcHksXHJcbiAgICAgICAgICBgbGV0IHN1bSA9ICR7aW5wdXRWYXJzLm1hcCgoaW5wdXRWYXIsIGkpID0+IGlucHV0VmFyLmdldEJ5SW5kaWNlcyhgaW5wdXQke2l9SW5kaWNlc2ApKS5qb2luKCcgKiAnKX07YCxcclxuICAgICAgICBdXHJcbiAgICAgIDogW1xyXG4gICAgICAgICAgLi4uaWR4Q29weSxcclxuICAgICAgICAgIGluaXRTdW0sXHJcbiAgICAgICAgICAuLi5yZWR1Y2VPcHNMb29wSGVhZGVycyxcclxuICAgICAgICAgIC4uLnJlZHVjZU9wc1NldEluZGljZXMsXHJcbiAgICAgICAgICBpbml0UHJvZCxcclxuICAgICAgICAgIC4uLnJlZHVjZU9wQ29tcHV0ZSxcclxuICAgICAgICAgIHVwZGF0ZVN1bSxcclxuICAgICAgICAgIC4uLnJlZHVjZU9wc0xvb3BGb290ZXJzLFxyXG4gICAgICAgIF07XHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlclxyXG4gICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zU3ltYm9scy5tYXAoKHN5bWJvbCkgPT4gKHsgbmFtZTogYCR7YXBwZW5kTWF4KHN5bWJvbCl9YCwgdHlwZTogJ3UzMicgfSkpKVxyXG4gICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcclxuICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XHJcblxyXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxyXG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgICAgICAgJHtpbnB1dFZhcnMubWFwKChfdmFyLCBpKSA9PiBgdmFyIGlucHV0JHtpfUluZGljZXM6ICR7aW5wdXRWYXJzW2ldLnR5cGUuaW5kaWNlc307YCkuam9pbignXFxuJyl9XHJcbiAgICAgICAgICAgICR7cmVkdWNlT3BzLmpvaW4oJ1xcbicpfTtcclxuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnc3VtJyl9O1xyXG4gICAgICAgICAgfWA7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0VpbnN1bScsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBlaW5zdW1FcXVhdGlvbi5lcXVhdGlvbiwgaW5wdXREZXBlbmRlbmNpZXM6IGlucHV0U2hhcGVzLm1hcCgoKSA9PiAncmFuaycpIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiB7XHJcbiAgICAgIC8vIFRoZSBzeW1ib2xzIGZyb20gdW5pZm9ybVN5bWJvbHMgYXJyYXkgYXJlIGd1YXJhbnRlZWQgdG8gZXhpc3QgaW4gZWluc3VtRXF1YXRpb25zLnN5bWJvbFRvSW5mbyBtYXAuIFRoZVxyXG4gICAgICAvLyBmaWx0ZXIgaXMgYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgZGltVmFsdWUgaXMgbmV2ZXIgMC5cclxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zSW5pdDogUHJvZ3JhbVVuaWZvcm1bXSA9IHVuaWZvcm1zU3ltYm9sc1xyXG4gICAgICAgIC5maWx0ZXIoKHN5bWJvbCkgPT4gZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmhhcyhzeW1ib2wpKVxyXG4gICAgICAgIC5tYXAoKHN5bWJvbCkgPT4gKHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk/LmRpbVZhbHVlIHx8IDAgfSkpO1xyXG4gICAgICBwcm9ncmFtVW5pZm9ybXNJbml0LnB1c2goeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSk7XHJcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IGlucHV0U2hhcGVzXHJcbiAgICAgICAgLm1hcCgoZGltcywgXykgPT4gWy4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGRpbXMpXSlcclxuICAgICAgICAucmVkdWNlKChhY2MsIGlucHV0UHJvZ3JhbVVuaWZvcm1zKSA9PiBhY2MuY29uY2F0KGlucHV0UHJvZ3JhbVVuaWZvcm1zKSwgcHJvZ3JhbVVuaWZvcm1zSW5pdCk7XHJcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxyXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZWluc3VtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBFaW5zdW1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgZWluc3VtRXF1YXRpb24gPSBuZXcgRWluc3VtRXF1YXRpb24oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMuZXF1YXRpb24pO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZWluc3VtRXF1YXRpb24ub3V0cHV0RGltcztcclxuICBjb25zdCBpbnB1dFNoYXBlcyA9IGNvbnRleHQuaW5wdXRzLm1hcCgoaW5wdXQsIF8pID0+IGlucHV0LmRpbXMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFaW5zdW1Qcm9ncmFtSW5mbyhpbnB1dFNoYXBlcywgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGVpbnN1bUVxdWF0aW9uLCBvdXRwdXRTaGFwZSkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlRWluc3VtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEVpbnN1bUF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IGVxdWF0aW9uID0gKGF0dHJpYnV0ZXMuZXF1YXRpb24gYXMgc3RyaW5nKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcclxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgZXF1YXRpb24gfSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuJyk7XHJcbiAgfVxyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcclxuXHJcbiAgbGV0IHNoYXBlSW5kZXggPSBzaGFwZS5sZW5ndGggPCBpbnB1dFNoYXBlLmxlbmd0aCA/IDAgOiBzaGFwZS5sZW5ndGggLSBpbnB1dFNoYXBlLmxlbmd0aDtcclxuICBsZXQgaW5wdXRTaGFwZUluZGV4ID0gaW5wdXRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGggPyAwIDogaW5wdXRTaGFwZS5sZW5ndGggLSBzaGFwZS5sZW5ndGg7XHJcbiAgZm9yICg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGggJiYgaW5wdXRTaGFwZUluZGV4IDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsrc2hhcGVJbmRleCwgKytpbnB1dFNoYXBlSW5kZXgpIHtcclxuICAgIGlmIChcclxuICAgICAgc2hhcGVbc2hhcGVJbmRleF0gIT09IGlucHV0U2hhcGVbaW5wdXRTaGFwZUluZGV4XSAmJlxyXG4gICAgICBzaGFwZVtzaGFwZUluZGV4XSAhPT0gMSAmJlxyXG4gICAgICBpbnB1dFNoYXBlW2lucHV0U2hhcGVJbmRleF0gIT09IDFcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZ2V0QWRqdXN0ZWRTaGFwZSA9IChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xyXG4gIGNvbnN0IGRpZmYgPSBzaGFwZTEubGVuZ3RoIC0gc2hhcGUyLmxlbmd0aDtcclxuICBjb25zdCBzaGFwZTogbnVtYmVyW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7ICsraSkge1xyXG4gICAgc2hhcGUucHVzaChzaGFwZTFbaV0pO1xyXG4gIH1cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlMi5sZW5ndGg7ICsraSkge1xyXG4gICAgc2hhcGUucHVzaChzaGFwZTJbaV0gPT09IDEgPyBzaGFwZTFbaSArIGRpZmZdIDogc2hhcGUyW2ldKTtcclxuICB9XHJcbiAgcmV0dXJuIHNoYXBlO1xyXG59O1xyXG5cclxuY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+XHJcbiAgaW5wdXRTaGFwZS5sZW5ndGggPiBzaGFwZS5sZW5ndGggPyBnZXRBZGp1c3RlZFNoYXBlKGlucHV0U2hhcGUsIHNoYXBlKSA6IGdldEFkanVzdGVkU2hhcGUoc2hhcGUsIGlucHV0U2hhcGUpO1xyXG5cclxuY29uc3QgY3JlYXRlRXhwYW5kUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IHNoYXBlID0gQXJyYXkuZnJvbShpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpLCBOdW1iZXIpO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNoYXBlKTtcclxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcclxuICBjb25zdCBpc0Jvb2xPclNjYWxhciA9IGRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sIHx8IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpID09PSAxO1xyXG4gIGNvbnN0IGlDb21wb25lbnRzID1cclxuICAgIGRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sID8gNCA6IGlucHV0U2hhcGUubGVuZ3RoID4gMCAmJiBpbnB1dFNoYXBlW2lucHV0U2hhcGUubGVuZ3RoIC0gMV0gJSA0ID09PSAwID8gNCA6IDE7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGlzQm9vbE9yU2NhbGFyXHJcbiAgICA/IDRcclxuICAgIDogb3V0cHV0U2hhcGUubGVuZ3RoID4gMCAmJiBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXSAlIDQgPT09IDBcclxuICAgICAgPyA0XHJcbiAgICAgIDogMTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMpO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGlDb21wb25lbnRzKTtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XHJcbiAgICBpZiAoZGF0YVR5cGUgPT09IERhdGFUeXBlLmJvb2wpIHtcclxuICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiBgXHJcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7eH11YCl9O1xyXG4gICAgICAgICAgbGV0IG9mZnNldCR7eH0gPSAke2lucHV0LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xyXG4gICAgICAgICAgbGV0IGluZGV4JHt4fSA9IG9mZnNldCR7eH0gLyA0dTtcclxuICAgICAgICAgIGxldCBjb21wb25lbnQke3h9ID0gb2Zmc2V0JHt4fSAlIDR1O1xyXG4gICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtpbnB1dC5nZXRCeU9mZnNldChgaW5kZXgke3h9YCl9W2NvbXBvbmVudCR7eH1dKTtcclxuICAgICAgICBgO1xyXG4gICAgICBhc3NpZ25tZW50ID0gYFxyXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfTtcclxuICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcclxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XHJcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxyXG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDIsICd1MzInKX1cclxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XHJcbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnZGF0YScpfVxyXG4gICAgICB9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFzc2lnbm1lbnQgPSBgXHJcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9YCl9O1xyXG4gICAgICAgIGxldCBpbnB1dE9mZnNldCA9ICR7aW5wdXQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcclxuICAgICAgICBsZXQgZGF0YSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KCR7aW5wdXQuZ2V0QnlPZmZzZXQoYGlucHV0T2Zmc2V0IC8gJHtpQ29tcG9uZW50c31gKX0pO1xyXG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2RhdGEnKX1cclxuICAgICAgfWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYFxyXG4gICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxyXG4gICAgJHthc3NpZ25tZW50fWA7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIG91dHB1dFNoYXBlKSxcclxuICBdO1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnRXhwYW5kJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke291dHB1dFNoYXBlLmxlbmd0aH07JHtpQ29tcG9uZW50c30ke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGV4cGFuZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRXhwYW5kUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpLCB7IGlucHV0czogWzBdIH0pO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG4gIFdPUktHUk9VUF9TSVpFLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuaW1wb3J0ICogYXMgdW5hcnkgZnJvbSAnLi91bmFyeS1vcCc7XHJcblxyXG4vLyBHRUxVIGlzIGRlZmluZWQgYXMgWT0wLjUqWCooMSt0YW5oKDAuNzk3ODg1KlgrMC4wMzU2NzcqWCpYKlgpKSwgd2hlcmUgWCBtYXkgcHJlLWFkZCBhIGJpYXMuXHJcblxyXG5jb25zdCBjcmVhdGVGYXN0R2VsdVByb2dyYW1JbmZvID0gKGlucHV0VGVuc29yczogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRUZW5zb3JzWzBdLmRhdGFUeXBlO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFRlbnNvcnNbMF0uZGltcyk7XHJcbiAgY29uc3QgYmlhc0xlbmd0aCA9IFNoYXBlVXRpbC5zaXplKGlucHV0VGVuc29yc1sxXS5kaW1zKTtcclxuICAvLyBjYW4gb25seSB1c2UgdmVjNCB3aGVuIGJpYXMgbGVuZ3RoIGlzIG11bHRpcGxlIG9mIDRcclxuICBjb25zdCB1c2VWZWM0ID0gYmlhc0xlbmd0aCAlIDQgPT09IDA7XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKTogc3RyaW5nID0+IHtcclxuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgZGF0YVR5cGUsIFsxXSwgNCk7XHJcbiAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGRhdGFUeXBlLCBbMV0sIDQpO1xyXG4gICAgY29uc3QgeSA9IG91dHB1dFZhcmlhYmxlKCd5JywgZGF0YVR5cGUsIFsxXSwgNCk7XHJcblxyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfdmVjX3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdiaWFzX3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgXTtcclxuXHJcbiAgICBjb25zdCBzaW5nbGVFbGVtZW50QmlhcyA9IChpOiAwIHwgMSB8IDIgfCAzKSA9PiBgXHJcbiAgICAgIGxldCBiaWFzJHtpfV9vZmZzZXQ6IHUzMiA9IChnbG9iYWxfaWR4ICogNCArICR7aX0pICUgdW5pZm9ybXMuYmlhc19zaXplO1xyXG4gICAgICBsZXQgYmlhcyR7aX0gPSAke2JpYXMuZ2V0QnlPZmZzZXQoYGJpYXMke2l9X29mZnNldCAvIDRgKX1bYmlhcyR7aX1fb2Zmc2V0ICUgNF07YDtcclxuICAgIGNvbnN0IGJpYXNHZXRFeHByZXNzaW9uID0gdXNlVmVjNFxyXG4gICAgICA/IGBcclxuICAgICAgbGV0IGJpYXMgPSAke2JpYXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHggJSAodW5pZm9ybXMuYmlhc19zaXplIC8gNCknKX07YFxyXG4gICAgICA6IGAke3NpbmdsZUVsZW1lbnRCaWFzKDApfSR7c2luZ2xlRWxlbWVudEJpYXMoMSl9JHtzaW5nbGVFbGVtZW50QmlhcygyKX0ke3NpbmdsZUVsZW1lbnRCaWFzKDMpfVxyXG4gICAgICBsZXQgYmlhcyA9ICR7eC50eXBlLnZhbHVlfShiaWFzMCwgYmlhczEsIGJpYXMyLCBiaWFzMyk7YDtcclxuXHJcbiAgICByZXR1cm4gYCR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgYmlhcywgeSl9XHJcblxyXG4gICAgJHt1bmFyeS5mYXN0R2VsdUltcGwodGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShkYXRhVHlwZSkpfVxyXG5cclxuICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChXT1JLR1JPVVBfU0laRSl9XHJcbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF92ZWNfc2l6ZScpfVxyXG5cclxuICAgICAgbGV0IHggPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICAgICR7Ymlhc0dldEV4cHJlc3Npb259XHJcbiAgICAgIGxldCB4X2luID0geCArIGJpYXM7XHJcbiAgICAgICR7eS5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIHVuYXJ5LmZhc3RHZWx1RXhwcmVzc2lvbigneF9pbicpKX1cclxuICAgIH1gO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnRmFzdEdlbHVXaXRoQmlhcycsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHt1c2VWZWM0fWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnLCAndHlwZSddIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRzKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBpbnB1dHNbMF0uZGltcywgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNCkgfSxcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmlhc0xlbmd0aCB9LFxyXG4gICAgICBdLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gV09SS0dST1VQX1NJWkUgLyA0KSB9LFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmYXN0R2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPCAyIHx8IFNoYXBlVXRpbC5zaXplKGNvbnRleHQuaW5wdXRzWzFdLmRpbXMpID09PSAwKSB7XHJcbiAgICB1bmFyeS5mYXN0R2VsdShjb250ZXh0KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUZhc3RHZWx1UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR2F0aGVyQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgYXhpczogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHYXRoZXJBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcclxuXHJcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XHJcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRSYW5rKTtcclxuXHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDApO1xyXG4gIG91dHB1dFNoYXBlLnNwbGljZShheGlzLCAxLCAuLi5pbmRpY2VzU2hhcGUpO1xyXG5cclxuICBjb25zdCBheGlzRGltTGltaXQgPSBpbnB1dFNoYXBlW2F4aXNdO1xyXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmJvb2wgPyA0IDogMTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMpO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXhpc0RpbUxpbWl0IH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXhpcyB9LFxyXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBvdXRwdXRTaGFwZSksXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gaW5wdXRWYXJpYWJsZSgnZGF0YScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGluZGljZXMgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dEluZGljZXMnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG5cclxuICAgIGNvbnN0IGNhbGNEYXRhSW5kaWNlcyA9ICh4OiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgICBjb25zdCBpbmRpY2VzUmFuayA9IGluZGljZXNTaGFwZS5sZW5ndGg7XHJcbiAgICAgIGxldCBjYWxjU3RyID0gYHZhciBpbmRpY2VzSW5kaWNlcyR7eH0gID0gJHtpbmRpY2VzLnR5cGUuaW5kaWNlc30oMCk7YDtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzUmFuazsgaSsrKSB7XHJcbiAgICAgICAgY2FsY1N0ciArPSBgJHtpbmRpY2VzUmFuayA+IDEgPyBgaW5kaWNlc0luZGljZXMke3h9WyR7aX1dYCA6IGBpbmRpY2VzSW5kaWNlcyR7eH1gfSA9ICR7XHJcbiAgICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGggPiAxID8gYG91dHB1dEluZGljZXMke3h9W3VuaWZvcm1zLmF4aXMgKyAke2l9XWAgOiBgb3V0cHV0SW5kaWNlcyR7eH1gXHJcbiAgICAgICAgfTtgO1xyXG4gICAgICB9XHJcbiAgICAgIGNhbGNTdHIgKz0gYFxyXG4gICAgICAgICAgdmFyIGlkeCR7eH0gPSAke2luZGljZXMuZ2V0QnlJbmRpY2VzKGBpbmRpY2VzSW5kaWNlcyR7eH1gKX07XHJcbiAgICAgICAgICBpZiAoaWR4JHt4fSA8IDApIHtcclxuICAgICAgICAgICAgaWR4JHt4fSA9IGlkeCR7eH0gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgZGF0YUluZGljZXMke3h9IDogJHtkYXRhLnR5cGUuaW5kaWNlc307XHJcbiAgICAgICAgYDtcclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgaW5wdXRSYW5rOyBpKyspIHtcclxuICAgICAgICBpZiAoaSA9PT0gYXhpcykge1xyXG4gICAgICAgICAgY2FsY1N0ciArPSBgJHtpbnB1dFJhbmsgPiAxID8gYGRhdGFJbmRpY2VzJHt4fVske2l9XWAgOiBgZGF0YUluZGljZXMke3h9YH0gPSB1MzIoaWR4JHt4fSk7YDtcclxuICAgICAgICAgIGogKz0gaW5kaWNlc1Jhbms7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNhbGNTdHIgKz0gYCR7aW5wdXRSYW5rID4gMSA/IGBkYXRhSW5kaWNlcyR7eH1bJHtpfV1gIDogYGRhdGFJbmRpY2VzJHt4fWB9ID0gJHtcclxuICAgICAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoID4gMSA/IGBvdXRwdXRJbmRpY2VzJHt4fVske2p9XWAgOiBgb3V0cHV0SW5kaWNlcyR7eH1gXHJcbiAgICAgICAgICB9O2A7XHJcbiAgICAgICAgICBqKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjYWxjU3RyO1xyXG4gICAgfTtcclxuICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XHJcbiAgICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sKSB7XHJcbiAgICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4gYFxyXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke3h9dWApfTtcclxuICAgICAgICAgICR7Y2FsY0RhdGFJbmRpY2VzKHgpfTtcclxuICAgICAgICAgIGxldCBvZmZzZXQke3h9ID0gJHtkYXRhLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke3h9YCl9O1xyXG4gICAgICAgICAgbGV0IGluZGV4JHt4fSA9IG9mZnNldCR7eH0gLyA0dTtcclxuICAgICAgICAgIGxldCBjb21wb25lbnQke3h9ID0gb2Zmc2V0JHt4fSAlIDR1O1xyXG4gICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtkYXRhLmdldEJ5T2Zmc2V0KGBpbmRleCR7eH1gKX1bY29tcG9uZW50JHt4fV0pO1xyXG4gICAgICAgIGA7XHJcbiAgICAgIGFzc2lnbm1lbnQgPSBgXHJcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9O1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcclxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMCwgJ3UzMicpfVxyXG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAxLCAndTMyJyl9XHJcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDIsICd1MzInKX1cclxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMywgJ3UzMicpfVxyXG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9XHJcbiAgICAgIGA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhc3NpZ25tZW50ID0gYFxyXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgJHtjYWxjRGF0YUluZGljZXMoJycpfTtcclxuICAgICAgbGV0IHZhbHVlID0gJHtkYXRhLmdldEJ5SW5kaWNlcygnZGF0YUluZGljZXMnKX07XHJcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xyXG4gICAgICBgO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBcclxuICAgICAgJHtzaGFkZXJIZWxwZXJcclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXHJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXHJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpcycsICd1MzInKVxyXG4gICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGRhdGEsIGluZGljZXMsIG91dHB1dCl9XHJcbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cclxuICAgICAgICAke2Fzc2lnbm1lbnR9XHJcbiAgICAgIH1gO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdHYXRoZXInLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJ10gfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyQXR0cmlidXRlcyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIgfSk7XHJcblxyXG5leHBvcnQgY29uc3QgZ2F0aGVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHYXRoZXJBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XHJcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZSB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR2F0aGVyTkRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBiYXRjaERpbXM6IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgY29tcHV0ZVNsaWNlT2Zmc2V0cyA9IChcclxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcclxuICBpbmRpY2VzRGF0YTogVGVuc29yVmlldyxcclxuICBzaXplc0Zyb21TbGljZURpbXNEYXRhOiBudW1iZXJbXSxcclxuICBiYXRjaERpbXM6IG51bWJlcixcclxuICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIG51bVNsaWNlczogbnVtYmVyLFxyXG4gIG51bVNsaWNlc1BlckJhdGNoOiBudW1iZXIsXHJcbiAgaW5wdXRCYXRjaFN0cmlkZTogbnVtYmVyLFxyXG4gIG51bVNsaWNlRGltczogbnVtYmVyLFxyXG4pID0+IHtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbnVtU2xpY2VzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmF0Y2hEaW1zIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXREaW1zIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2l6ZXNGcm9tU2xpY2VEaW1zRGF0YSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG51bVNsaWNlc1BlckJhdGNoIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRCYXRjaFN0cmlkZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG51bVNsaWNlRGltcyB9LFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW251bVNsaWNlc107XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5kaWNlc0RhdGEuZGltcywgb3V0cHV0U2hhcGUpKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5kaWNlc19kYXRhJywgaW5kaWNlc0RhdGEuZGF0YVR5cGUsIGluZGljZXNEYXRhLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGEnLCBEYXRhVHlwZS51aW50MzIsIDEsIDEpO1xyXG4gICAgY29uc3QgdmFyaWFibGVzID0gW2luZGljZXMsIG91dHB1dF07XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYmF0Y2hfZGltcycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2lucHV0X2RpbXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBpbnB1dERpbXMubGVuZ3RoIH0sXHJcbiAgICAgIHsgbmFtZTogJ3NpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhJywgdHlwZTogJ3UzMicsIGxlbmd0aDogc2l6ZXNGcm9tU2xpY2VEaW1zRGF0YS5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAnbnVtX3NsaWNlc19wZXJfYmF0Y2gnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdpbnB1dF9iYXRjaF9zdHJpZGUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdudW1fc2xpY2VfZGltcycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGBcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG4gICAgbGV0IGJhdGNoX2lkeCA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5udW1fc2xpY2VzX3Blcl9iYXRjaDtcclxuICAgIGxldCBiYXNlX29mZnNldCA9IGJhdGNoX2lkeCAqIHVuaWZvcm1zLmlucHV0X2JhdGNoX3N0cmlkZTtcclxuXHJcbiAgICBsZXQgc2xpY2VfaW5kaWNlc19iYXNlX29mZnNldCA9IGdsb2JhbF9pZHggKiB1bmlmb3Jtcy5udW1fc2xpY2VfZGltcztcclxuICAgIHZhciByZWxhdGl2ZV9zbGljZV9vZmZzZXQgPSAwO1xyXG4gICAgZm9yICh2YXIgZGltX2lkeCA9IDB1OyBkaW1faWR4IDwgdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7IGRpbV9pZHggKyspIHtcclxuICAgICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNfZGF0YVtkaW1faWR4ICsgc2xpY2VfaW5kaWNlc19iYXNlX29mZnNldF0ueCk7XHJcbiAgICAgIGxldCBpbnB1dF9kaW1faWR4ID0gdW5pZm9ybXMuYmF0Y2hfZGltcyArIGRpbV9pZHg7XHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAke1xyXG4gICAgICAgICAgaW5wdXREaW1zLmxlbmd0aCA9PT0gMVxyXG4gICAgICAgICAgICA/ICdpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltcyk7J1xyXG4gICAgICAgICAgICA6ICdpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltc1tpbnB1dF9kaW1faWR4XSk7J1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAke1xyXG4gICAgICAgIHNpemVzRnJvbVNsaWNlRGltc0RhdGEubGVuZ3RoID09PSAxXHJcbiAgICAgICAgICA/ICdyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGEpOydcclxuICAgICAgICAgIDogJ3JlbGF0aXZlX3NsaWNlX29mZnNldCArPSBpbmRleCAqIGkzMih1bmlmb3Jtcy5zaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YVtkaW1faWR4XSk7J1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhW2dsb2JhbF9pZHhdID0gIGJhc2Vfb2Zmc2V0ICsgdTMyKHJlbGF0aXZlX3NsaWNlX29mZnNldCk7XHJcbiAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ2NvbXB1dGVTbGljZU9mZnNldHMnLFxyXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtpbnB1dERpbXMubGVuZ3RofV8ke3NpemVzRnJvbVNsaWNlRGltc0RhdGEubGVuZ3RofWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxyXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMV0uZGF0YVR5cGUgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwobnVtU2xpY2VzIC8gNjQpIH0sXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgICB9KSxcclxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgfSxcclxuICAgIHsgaW5wdXRzOiBbaW5kaWNlc0RhdGFdLCBvdXRwdXRzOiBbLTFdIH0sXHJcbiAgKVswXTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnYXRoZXJORCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyTkRBdHRyaWJ1dGVzKSA9PiB7XHJcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcclxuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcclxuICBjb25zdCBudW1TbGljZURpbXMgPSBpbmRpY2VzU2hhcGVbaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDFdO1xyXG4gIGNvbnN0IG51bVNsaWNlcyA9IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oaW5kaWNlc1NoYXBlLCBpbmRpY2VzU2hhcGUubGVuZ3RoIC0gMSk7XHJcbiAgY29uc3Qgc2xpY2VTaXplID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGlucHV0U2hhcGUsIGF0dHJpYnV0ZXMuYmF0Y2hEaW1zICsgbnVtU2xpY2VEaW1zKTtcclxuICBjb25zdCBudW1CYXRjaGVzID0gU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihpbnB1dFNoYXBlLCBhdHRyaWJ1dGVzLmJhdGNoRGltcyk7XHJcbiAgY29uc3QgaW5wdXRCYXRjaFN0cmlkZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dFNoYXBlLCBhdHRyaWJ1dGVzLmJhdGNoRGltcyk7XHJcbiAgY29uc3QgbnVtU2xpY2VzUGVyQmF0Y2ggPSBudW1TbGljZXMgLyBudW1CYXRjaGVzO1xyXG4gIGNvbnN0IHNpemVzRnJvbVNsaWNlRGltcyA9IG5ldyBBcnJheShudW1TbGljZURpbXMpO1xyXG4gIGxldCBydW5uaW5nUHJvZHVjdCA9IHNsaWNlU2l6ZTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNsaWNlRGltczsgKytpKSB7XHJcbiAgICBzaXplc0Zyb21TbGljZURpbXNbbnVtU2xpY2VEaW1zIC0gMSAtIGldID0gcnVubmluZ1Byb2R1Y3Q7XHJcbiAgICBydW5uaW5nUHJvZHVjdCAqPSBpbnB1dFNoYXBlW2F0dHJpYnV0ZXMuYmF0Y2hEaW1zICsgbnVtU2xpY2VEaW1zIC0gMSAtIGldO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaW5wdXRTbGljZU9mZnNldHMgPSBjb21wdXRlU2xpY2VPZmZzZXRzKFxyXG4gICAgY29udGV4dCxcclxuICAgIGlucHV0c1sxXSxcclxuICAgIHNpemVzRnJvbVNsaWNlRGltcyxcclxuICAgIGF0dHJpYnV0ZXMuYmF0Y2hEaW1zLFxyXG4gICAgaW5wdXRTaGFwZSxcclxuICAgIG51bVNsaWNlcyxcclxuICAgIG51bVNsaWNlc1BlckJhdGNoLFxyXG4gICAgaW5wdXRCYXRjaFN0cmlkZSxcclxuICAgIG51bVNsaWNlRGltcyxcclxuICApO1xyXG5cclxuICBjb25zdCBsYXN0SW5kaWNlc0RpbWVuc2lvbiA9IGF0dHJpYnV0ZXMuYmF0Y2hEaW1zICsgbnVtU2xpY2VEaW1zO1xyXG4gIGlmIChsYXN0SW5kaWNlc0RpbWVuc2lvbiA+IGlucHV0U2hhcGUubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGluZGljZXMgbXVzdCBub3QgYmUgbGFyZ2VyIHRoYW4gcmFuayBvZiBpbnB1dCB0ZW5zb3InKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5kaWNlc1NoYXBlLnNsaWNlKDAsIC0xKS5jb25jYXQoaW5wdXRTaGFwZS5zbGljZShsYXN0SW5kaWNlc0RpbWVuc2lvbikpO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcblxyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2xpY2VTaXplIH0sXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRTbGljZU9mZnNldHMuZGltcywgb3V0cHV0U2hhcGUpLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdkYXRhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xyXG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ3NsaWNlX29mZnNldHMnLCBEYXRhVHlwZS51aW50MzIsIGlucHV0U2xpY2VPZmZzZXRzLmRpbXMubGVuZ3RoKTtcclxuXHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICAgICR7c2hhZGVySGVscGVyXHJcbiAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpXHJcbiAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NsaWNlX3NpemUnLCAndTMyJylcclxuICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGluZGljZXMsIG91dHB1dCl9XHJcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG4gICAgICAgICAgbGV0IHNsaWNlX29mZnNldCA9IHNsaWNlX29mZnNldHNbZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLnNsaWNlX3NpemVdO1xyXG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZGF0YVt1MzIoc2xpY2Vfb2Zmc2V0KSArIGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5zbGljZV9zaXplXTtcclxuICAgICAgICB9YDtcclxuICB9O1xyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ0dhdGhlck5EJyxcclxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJ10gfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VHlwZSB9XSxcclxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgICB9KSxcclxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgfSxcclxuICAgIHsgaW5wdXRzOiBbaW5wdXRzWzBdLCBpbnB1dFNsaWNlT2Zmc2V0c10gfSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyTkRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyTkRBdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBiYXRjaERpbXMgPSBhdHRyaWJ1dGVzLmJhdGNoX2RpbXMgYXMgbnVtYmVyO1xyXG4gIHJldHVybiB7XHJcbiAgICBiYXRjaERpbXMsXHJcbiAgICBjYWNoZUtleTogJycsXHJcbiAgfTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgZ2F0aGVyQXhpczogbnVtYmVyO1xyXG4gIHF1YW50aXplQXhpczogbnVtYmVyO1xyXG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgMyB8fCBpbnB1dHMubGVuZ3RoID4gNCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXJCbG9ja1F1YW50aXplZCByZXF1aXJlcyAzIG9yIDQgaW5wdXRzLicpO1xyXG4gIH1cclxuICBjb25zdCBxdWFudGl6ZUF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLnF1YW50aXplQXhpcywgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcclxuICBjb25zdCBibG9ja1NpemUgPSBhdHRyaWJ1dGVzLmJsb2NrU2l6ZTtcclxuICBjb25zdCBkYXRhID0gaW5wdXRzWzBdO1xyXG4gIGNvbnN0IHNjYWxlcyA9IGlucHV0c1syXTtcclxuICBjb25zdCB6ZXJvUG9pbnQgPSBpbnB1dHMubGVuZ3RoID09PSA0ID8gaW5wdXRzWzNdIDogdW5kZWZpbmVkO1xyXG4gIGlmIChcclxuICAgIHNjYWxlcy5kaW1zLmxlbmd0aCAhPT0gZGF0YS5kaW1zLmxlbmd0aCB8fFxyXG4gICAgIWRhdGEuZGltc1xyXG4gICAgICAubWFwKChkLCBpKSA9PiAoaSA9PT0gcXVhbnRpemVBeGlzID8gTWF0aC5jZWlsKGQgLyBibG9ja1NpemUpID09PSBzY2FsZXMuZGltc1tpXSA6IGQgPT09IHNjYWxlcy5kaW1zW2ldKSlcclxuICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKVxyXG4gICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAnU2NhbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gZ2F0aGVyQXhpcy4nLFxyXG4gICAgKTtcclxuICB9XHJcbiAgLy8gVE9ETyBVbmNvbW1lbnQgdGhlIGZvbGxvd2luZyBjaGVjayBvbmNlIHRoZSB0ZXN0IGNhc2UgY3JlYXRpb24gY29kZSBpcyBmaXhlZCB0byBjcmVhdGUgZGF0YSBjb3JyZWN0bHkgYWxpZ25lZC5cclxuICAvLyBjb25zdCBpbmRpY2VzID0gaW5wdXRzWzFdO1xyXG4gIC8vIGNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXg6IG51bWJlcikgPT4gaW5kZXggPj0gMCAmJiBpbmRleCA8IGRhdGEuZGltc1thdHRyaWJ1dGVzLmdhdGhlckF4aXNdO1xyXG4gIC8vIGlmIChpbmRpY2VzLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMiAmJiBpbmRpY2VzLmdldEludDMyQXJyYXkoKS5zb21lKCh2KSA9PiAhdmFsaWRJbmRleCh2KSkgfHxcclxuICAvLyAgICAgaW5kaWNlcy5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50NjQgJiYgaW5kaWNlcy5nZXRCaWdJbnQ2NEFycmF5KCkuc29tZSgodikgPT4gIXZhbGlkSW5kZXgoTnVtYmVyKHYpKSkpIHtcclxuICAvLyAgIHRocm93IG5ldyBFcnJvcignSW5kaWNlcyBtdXN0IGJlIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBnYXRoZXJBeGlzLicpO1xyXG4gIC8vIH1cclxuICBpZiAoemVyb1BvaW50KSB7XHJcbiAgICBpZiAoemVyb1BvaW50LmRhdGFUeXBlICE9PSBkYXRhLmRhdGFUeXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlIGFzIHRoZSBpbnB1dCB0ZW5zb3IuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoXHJcbiAgICAgIHplcm9Qb2ludC5kaW1zLmxlbmd0aCAhPT0gc2NhbGVzLmRpbXMubGVuZ3RoIHx8XHJcbiAgICAgICF6ZXJvUG9pbnQuZGltcy5tYXAoKGQsIGkpID0+IGQgPT09IHNjYWxlcy5kaW1zW2ldKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSlcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgJ1plcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBxdWFudGl6ZUF4aXMuJyxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVHYXRoZXJCbG9ja1F1YW50aXplZFByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IEdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcclxuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcclxuICBjb25zdCBnYXRoZXJBeGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5nYXRoZXJBeGlzLCBpbnB1dFJhbmspO1xyXG4gIGNvbnN0IHF1YW50aXplQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMucXVhbnRpemVBeGlzLCBpbnB1dFJhbmspO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcclxuICBvdXRwdXRTaGFwZS5zcGxpY2UoZ2F0aGVyQXhpcywgMSwgLi4uaW5kaWNlc1NoYXBlKTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gIGNvbnN0IG91dHB1dFR5cGUgPSBpbnB1dHNbMl0uZGF0YVR5cGU7XHJcbiAgY29uc3QgaW5wdXRUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xyXG4gIGNvbnN0IGlzU2lnbmVkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ0OyAvLyBpbnB1dCBkYXRhIHR5cGUgaXMgZWl0aGVyIGludDQgb3IgdWludDQuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBxdWFudGl6ZUF4aXMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnYXRoZXJBeGlzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5ibG9ja1NpemUgfSxcclxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKC4uLmlucHV0cy5tYXAoKGlucHV0LCBfKSA9PiBpbnB1dC5kaW1zKSwgb3V0cHV0U2hhcGUpLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgZGF0YSA9IGlucHV0VmFyaWFibGUoJ2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5wdXRJbmRpY2VzJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgpO1xyXG4gICAgY29uc3Qgc2NhbGVzID0gaW5wdXRWYXJpYWJsZSgnc2NhbGVzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xyXG4gICAgY29uc3QgemVyb1BvaW50ID1cclxuICAgICAgaW5wdXRzLmxlbmd0aCA+IDMgPyBpbnB1dFZhcmlhYmxlKCd6ZXJvUG9pbnQnLCBpbnB1dHNbM10uZGF0YVR5cGUsIGlucHV0c1szXS5kaW1zLmxlbmd0aCkgOiB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0Jywgb3V0cHV0VHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2RhdGEsIGluZGljZXMsIHNjYWxlc107XHJcbiAgICBpZiAoemVyb1BvaW50KSB7XHJcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goemVyb1BvaW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdxdWFudGl6ZV9heGlzJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnZ2F0aGVyX2F4aXMnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdibG9ja19zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgICAgIHZhciBpbmRpY2VzX2luZGljZXMgPSAke2luZGljZXMudHlwZS5pbmRpY2VzfSgwKTtcclxuICAgICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoaW5kaWNlc1NoYXBlLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2luZGljZXNTaGFwZS5sZW5ndGh9OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyBpJyl9O1xyXG4gICAgICAgICAgICAke2luZGljZXMuaW5kaWNlc1NldCgnaW5kaWNlc19pbmRpY2VzJywgJ2knLCAnaW5kZXgnKX07XHJcbiAgICAgICAgICB9YDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgaW5kaWNlc19pbmRpY2VzID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuZ2F0aGVyX2F4aXMnKX07YDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSgpfTtcclxuICAgICAgICB2YXIgZGF0YV9pbmRpY2VzID0gJHtkYXRhLnR5cGUuaW5kaWNlc30oMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmdhdGhlcl9heGlzOyBpKyspIHtcclxuICAgICAgICAgIGxldCBpbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX07XHJcbiAgICAgICAgICAke2RhdGEuaW5kaWNlc1NldCgnZGF0YV9pbmRpY2VzJywgJ2knLCAnaW5kZXgnKX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmRleF9mcm9tX2luZGljZXMgPSAke2luZGljZXMuZ2V0QnlJbmRpY2VzKCdpbmRpY2VzX2luZGljZXMnKX07XHJcbiAgICAgICAgaWYgKGluZGV4X2Zyb21faW5kaWNlcyA8IDApIHtcclxuICAgICAgICAgIGluZGV4X2Zyb21faW5kaWNlcyArPSAke2lucHV0U2hhcGVbZ2F0aGVyQXhpc119O1xyXG4gICAgICAgIH1cclxuICAgICAgICAke2RhdGEuaW5kaWNlc1NldCgnZGF0YV9pbmRpY2VzJywgJ3VuaWZvcm1zLmdhdGhlcl9heGlzJywgJ3UzMihpbmRleF9mcm9tX2luZGljZXMpJyl9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIDE7IGkgPCAke291dHB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xyXG4gICAgICAgICAgbGV0IGluZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCBgaSArICR7aW5kaWNlc1NoYXBlLmxlbmd0aH0gLSAxYCl9O1xyXG4gICAgICAgICAgJHtkYXRhLmluZGljZXNTZXQoJ2RhdGFfaW5kaWNlcycsICdpJywgJ2luZGV4Jyl9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGF0YV9vZmZzZXQgPSAke2RhdGEuaW5kaWNlc1RvT2Zmc2V0KCdkYXRhX2luZGljZXMnKX07XHJcbiAgICAgICAgbGV0IGRhdGFfaW5kZXggPSBkYXRhX29mZnNldCAlIDg7XHJcbiAgICAgICAgLy8gQ29udmVydCA0LWJpdCBwYWNrZWQgZGF0YSB0byA4LWJpdCBwYWNrZWQgZGF0YS5cclxuICAgICAgICBsZXQgcGFja2VkXzRiaXRfcXVhbnRpemVkX2RhdGEgPSAke2RhdGEuZ2V0QnlPZmZzZXQoJ2RhdGFfb2Zmc2V0IC8gOCcpfTtcclxuICAgICAgICBsZXQgcGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEgPSAocGFja2VkXzRiaXRfcXVhbnRpemVkX2RhdGEgPj4gKDQgKiAoZGF0YV9pbmRleCAlIDIpKSkgJiAweDBmMGYwZjBmO1xyXG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YV92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgnIDogJ3VucGFjazR4VTgnfSh1MzIocGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEpKTtcclxuICAgICAgICBsZXQgcXVhbnRpemVkX2RhdGEgPSBxdWFudGl6ZWRfZGF0YV92ZWNbZGF0YV9pbmRleCAvIDJdO1xyXG4gICAgICAgIHZhciBzY2FsZV9pbmRpY2VzID0gZGF0YV9pbmRpY2VzO1xyXG4gICAgICAgIGxldCBxdWFudGl6ZV9heGlzX2luZGV4ID0gJHtzY2FsZXMuaW5kaWNlc0dldCgnZGF0YV9pbmRpY2VzJywgJ3VuaWZvcm1zLnF1YW50aXplX2F4aXMnKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xyXG4gICAgICAgICR7c2NhbGVzLmluZGljZXNTZXQoJ3NjYWxlX2luZGljZXMnLCAndW5pZm9ybXMucXVhbnRpemVfYXhpcycsICdxdWFudGl6ZV9heGlzX2luZGV4Jyl9O1xyXG4gICAgICAgIHZhciBzY2FsZSA9ICR7c2NhbGVzLmdldEJ5SW5kaWNlcygnc2NhbGVfaW5kaWNlcycpfTtcclxuICAgICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIXplcm9Qb2ludCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3ZhciB6ZXJvX3BvaW50ID0gMCc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGljZXMgPSBzY2FsZV9pbmRpY2VzO1xyXG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7emVyb1BvaW50LmluZGljZXNUb09mZnNldCgnemVyb19wb2ludF9pbmRpY2VzJyl9O1xyXG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gemVyb19wb2ludF9vZmZzZXQgJSA4O1xyXG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X29mZnNldCAvIDgnKX07XHJcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF84Yml0X3plcm9fcG9pbnRzID0gKHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID4+ICg0ICogKHplcm9fcG9pbnRfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcclxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgnIDogJ3VucGFjazR4VTgnfSh1MzIocGFja2VkXzhiaXRfemVyb19wb2ludHMpKTtcclxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludCA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfaW5kZXggLyAyXTtgO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKCl9O1xyXG4gICAgICAgIGxldCBkZXF1YW50aXplZF9kYXRhID0gJHt0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKG91dHB1dFR5cGUpfShxdWFudGl6ZWRfZGF0YSAtIHplcm9fcG9pbnQpICogc2NhbGU7XHJcbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnZGVxdWFudGl6ZWRfZGF0YScpfTtcclxuICAgIH1gO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdHYXRoZXJCbG9ja1F1YW50aXplZCcsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2lucHV0c1xyXG4gICAgICAgIC5maWx0ZXIoKF8sIGkpID0+IGkgIT09IDEpXHJcbiAgICAgICAgLm1hcCgoaW5wdXQpID0+IGlucHV0LmRpbXMuam9pbignXycpKVxyXG4gICAgICAgIC5qb2luKCc7Jyl9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IEFycmF5LmZyb20oeyBsZW5ndGg6IGlucHV0cy5sZW5ndGggfSwgKF92LCBfaSkgPT4gJ3JhbmsnKSxcclxuICAgIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dFR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnYXRoZXJCbG9ja1F1YW50aXplZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XHJcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyQmxvY2tRdWFudGl6ZWRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzID0gKFxyXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxyXG4pOiBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xyXG4gICAgYmxvY2tTaXplOiBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSBhcyBudW1iZXIsXHJcbiAgICBnYXRoZXJBeGlzOiBhdHRyaWJ1dGVzLmdhdGhlckF4aXMgYXMgbnVtYmVyLFxyXG4gICAgcXVhbnRpemVBeGlzOiBhdHRyaWJ1dGVzLnF1YW50aXplQXhpcyBhcyBudW1iZXIsXHJcbiAgfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgYXhpczogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoIDwgMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGJlIHJhbmsgPj0gMS4nKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUdhdGhlckVsZW1lbnRzUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGlucHV0T3V0cHV0RGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XHJcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XHJcblxyXG4gIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xyXG4gIGNvbnN0IGluZGljZXNEYXRhVHlwZSA9IGlucHV0c1sxXS5kYXRhVHlwZTtcclxuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xyXG4gIGNvbnN0IGF4aXNEaW1MaW1pdCA9IGlucHV0U2hhcGVbYXhpc107XHJcblxyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5kaWNlc1NoYXBlLnNsaWNlKDApO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcblxyXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dE91dHB1dERhdGFUeXBlLCBpbnB1dFJhbmspO1xyXG4gIGNvbnN0IGluZGljZXMgPSBpbnB1dFZhcmlhYmxlKCdpbmRpY2VzSW5wdXQnLCBpbmRpY2VzRGF0YVR5cGUsIGluZGljZXNTaGFwZS5sZW5ndGgpO1xyXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dE91dHB1dERhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXhpc0RpbUxpbWl0IH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXhpcyB9LFxyXG4gIF07XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgaW5kaWNlc1NoYXBlLCBvdXRwdXRTaGFwZSkpO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcclxuXHJcbiAgLy8gaW50NjQgaW5kaWNlcyB3b3VsZCBiZSB0cmVhdGVkIGFzIGxpdHRsZSBlbmRpYW4gaTMyIHdpdGggYXNzdW1wdGlvbiB0aGV5IGZhbGwgaW4gaTMyIGxpbWl0c1xyXG4gIC8vIFRoYXQgYXNzdW1wdGlvbiBpcyBzYWZlIGFzIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGFsbG9jYXRlID4yZ2IgYnVmZmVyIGZvciBpbnB1dCB0ZW5zb3JcclxuICAvLyBJbnB1dCBkYXRhIHdpbGwgYmUgdHJlYXRlZCBhcyB1MzIgb3IgdHdvIHUzMiBmb3IgOC1ieXRlIHRlbnNvcnNcclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICAgICAgJHtzaGFkZXJIZWxwZXJcclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXHJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXHJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpcycsICd1MzInKVxyXG4gICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBpbmRpY2VzLCBvdXRwdXQpfVxyXG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxyXG5cclxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcblxyXG4gICAgICB2YXIgaWR4ID0gJHtpbmRpY2VzLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgICBpZiAoaWR4IDwgMCkge1xyXG4gICAgICAgIGlkeCA9IGlkeCArIHVuaWZvcm1zLmF4aXNEaW1MaW1pdDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtpbnB1dC50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xyXG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0SW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJywgJ3UzMihpZHgpJyl9O1xyXG4gICAgICBsZXQgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRJbmRpY2VzJyl9O1xyXG5cclxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX07XHJcbiAgfWA7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnR2F0aGVyRWxlbWVudHMnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdhdGhlckVsZW1lbnRzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcclxuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHYXRoZXJFbGVtZW50c1Byb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IEdlbW1VdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpcyBtaXNzaW5nJyk7XHJcbiAgfVxyXG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgMiB8fCBpbnB1dHMubGVuZ3RoID4gMykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhaWQgaW5wdXQgbnVtYmVyLicpO1xyXG4gIH1cclxuXHJcbiAgLy8gJ0MnIGNhbiBiZSBvZiBkaW1lbnNpb25hbGl0eSAwLCAxIG9yIDIgb25seVxyXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCA+IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMV0uZGF0YVR5cGUgfHwgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMl0uZGF0YVR5cGUpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHZW1tQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgdHJhbnNBOiBib29sZWFuO1xyXG4gIHRyYW5zQjogYm9vbGVhbjtcclxuICBhbHBoYTogbnVtYmVyO1xyXG4gIGJldGE6IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgY3JlYXRlR2VtbVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHZW1tQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xyXG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XHJcbiAgY29uc3QgW00sIE4sIEtdID0gR2VtbVV0aWwuZ2V0U2hhcGVPZkdlbW1SZXN1bHQoXHJcbiAgICBhU2hhcGUsXHJcbiAgICBhdHRyaWJ1dGVzLnRyYW5zQSxcclxuICAgIGJTaGFwZSxcclxuICAgIGF0dHJpYnV0ZXMudHJhbnNCLFxyXG4gICAgaW5wdXRzLmxlbmd0aCA9PT0gMyA/IGlucHV0c1syXS5kaW1zIDogdW5kZWZpbmVkLFxyXG4gICk7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbTSwgTl07XHJcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XHJcbiAgfVxyXG4gIGNvbnN0IHRpbGVTaXplID0gMTY7XHJcbiAgY29uc3QgbnVtVGlsZU4gPSBNYXRoLmNlaWwoTiAvIHRpbGVTaXplKTtcclxuICBjb25zdCBudW1UaWxlTSA9IE1hdGguY2VpbChNIC8gdGlsZVNpemUpO1xyXG4gIC8vIFRPRE86IEZpbmQgdGhlIGNvbmRpdGlvbiB3aGVuIHRvIHVzZSB0aGUgbmFpdmUgb25lLlxyXG4gIGNvbnN0IHVzZVNoYXJlZCA9IHRydWU7XHJcblxyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHVzZVNoYXJlZCA/IG51bVRpbGVOIDogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE0gfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBOIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogSyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5iZXRhIH0sXHJcbiAgXTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XHJcbiAgfVxyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgbGV0IGxpbmUgPSAnJztcclxuICAgIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiBhdHRyaWJ1dGVzLnRyYW5zQikge1xyXG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTsnO1xyXG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcclxuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07JztcclxuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XHJcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdOyc7XHJcbiAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcclxuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07JztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjYWxjdWxhdGVBbHBoYSA9IGF0dHJpYnV0ZXMuYWxwaGEgPT09IDEgPyAnJyA6ICd2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTsnO1xyXG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zKTtcclxuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcyk7XHJcbiAgICBjb25zdCBkYXRhVHlwZSA9IGEudHlwZS52YWx1ZTtcclxuICAgIGxldCBjOiBJbmRpY2VzSGVscGVyIHwgbnVsbCA9IG51bGw7XHJcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbYSwgYl07XHJcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICBjID0gaW5wdXRWYXJpYWJsZSgnYycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcclxuICAgICAgdmFyaWFibGVzLnB1c2goYyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG4gICAgdmFyaWFibGVzLnB1c2gob3V0cHV0KTtcclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2JldGEnLCB0eXBlOiAnZjMyJyB9LFxyXG4gICAgXTtcclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxyXG5cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcblxyXG4gICAgbGV0IG0gPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuTjtcclxuICAgIGxldCBuID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLk47XHJcblxyXG4gICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oMCk7XHJcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsrKykge1xyXG4gICAgICAke2xpbmV9XHJcbiAgICB9XHJcblxyXG4gICAgJHtjYWxjdWxhdGVBbHBoYX1cclxuICAgICR7KCgpID0+IHtcclxuICAgICAgaWYgKGMgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBgbGV0IGNPZmZzZXQgPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ3ZlYzIobSwgbiknLCBvdXRwdXQpfTsgdmFsdWUgKz0gJHtcclxuICAgICAgICAgIGRhdGFUeXBlXHJcbiAgICAgICAgfSh1bmlmb3Jtcy5iZXRhKSAqICR7Yy5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtgO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH0pKCl9XHJcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcclxuICB9YDtcclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2VTaGFyZWQgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcyk7XHJcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xyXG4gICAgbGV0IGM6IEluZGljZXNIZWxwZXIgfCBudWxsID0gbnVsbDtcclxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFthLCBiXTtcclxuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgIGMgPSBpbnB1dFZhcmlhYmxlKCdjJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xyXG4gICAgICB2YXJpYWJsZXMucHVzaChjKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgICB2YXJpYWJsZXMucHVzaChvdXRwdXQpO1xyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdudW1fdGlsZV9uJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnTScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdLJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdiZXRhJywgdHlwZTogJ2YzMicgfSxcclxuICAgIF07XHJcblxyXG4gICAgbGV0IGNhbGNSZXN1bHQgPSAnJztcclxuICAgIGxldCBmaWxsV29ya2dyb3VwTWVtb3J5ID0gJyc7XHJcbiAgICBpZiAoYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcclxuICAgICAgZmlsbFdvcmtncm91cE1lbW9yeSA9IGBcclxuICAgICAgdmFyIGNvbCA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueDtcclxuICAgICAgdmFyIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xyXG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XHJcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5NICsgY29sXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2EudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xyXG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XHJcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk4pIHtcclxuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Yi50eXBlLnZhbHVlfSgwKTtcclxuICAgICAgfVxyXG4gICAgICBgO1xyXG4gICAgICBjYWxjUmVzdWx0ID0gYHZhbHVlICs9IHRpbGVfYVtrXVtsb2NhbF9pZC55XSAqIHRpbGVfYltsb2NhbF9pZC54XVtrXTtgO1xyXG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcclxuICAgICAgZmlsbFdvcmtncm91cE1lbW9yeSA9IGBcclxuICAgICAgdmFyIGNvbCA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueDtcclxuICAgICAgdmFyIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xyXG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XHJcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5NICsgY29sXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2EudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcclxuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XHJcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5OICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcclxuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Yi50eXBlLnZhbHVlfSgwKTtcclxuICAgICAgfVxyXG4gICAgICBgO1xyXG4gICAgICBjYWxjUmVzdWx0ID0gYHZhbHVlICs9IHRpbGVfYVtrXVtsb2NhbF9pZC55XSAqIHRpbGVfYltrXVtsb2NhbF9pZC54XTtgO1xyXG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcclxuICAgICAgZmlsbFdvcmtncm91cE1lbW9yeSA9IGBcclxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xyXG4gICAgICB2YXIgcm93ID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xyXG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XHJcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2EudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xyXG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XHJcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk4pIHtcclxuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Yi50eXBlLnZhbHVlfSgwKTtcclxuICAgICAgfVxyXG4gICAgICBgO1xyXG4gICAgICBjYWxjUmVzdWx0ID0gYHZhbHVlICs9IHRpbGVfYVtsb2NhbF9pZC55XVtrXSAqIHRpbGVfYltsb2NhbF9pZC54XVtrXTtgO1xyXG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XHJcbiAgICAgIGZpbGxXb3JrZ3JvdXBNZW1vcnkgPSBgXHJcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcclxuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcclxuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTSkge1xyXG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHthLnR5cGUudmFsdWV9KDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb2wgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XHJcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xyXG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XHJcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5OICsgY29sXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2IudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgIH1cclxuICAgICAgYDtcclxuICAgICAgY2FsY1Jlc3VsdCA9IGB2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07YDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjYWxjdWxhdGVBbHBoYSA9IGF0dHJpYnV0ZXMuYWxwaGEgPT09IDEgPyAnJyA6ICd2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTsnO1xyXG5cclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYTogYXJyYXk8YXJyYXk8JHthLnR5cGUuc3RvcmFnZX0sICR7dGlsZVNpemV9PiwgJHt0aWxlU2l6ZX0+O1xyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYjogYXJyYXk8YXJyYXk8JHtiLnR5cGUuc3RvcmFnZX0sICR7dGlsZVNpemV9PiwgJHt0aWxlU2l6ZX0+O1xyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbdGlsZVNpemUsIHRpbGVTaXplLCAxXSl9XHJcbiAgICBsZXQgdGlsZV9jb2xfc3RhcnQgPSAod29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMubnVtX3RpbGVfbikgKiAke3RpbGVTaXplfTtcclxuICAgIGxldCB0aWxlX3Jvd19zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7dGlsZVNpemV9O1xyXG4gICAgbGV0IG51bV90aWxlcyA9ICh1bmlmb3Jtcy5LIC0gMSkgLyAke3RpbGVTaXplfSArIDE7XHJcbiAgICB2YXIga19zdGFydCA9IDB1O1xyXG4gICAgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XHJcbiAgICBmb3IgKHZhciB0OiB1MzIgPSAwdTsgdCA8IG51bV90aWxlczsgdCsrKSB7XHJcbiAgICAgICR7ZmlsbFdvcmtncm91cE1lbW9yeX1cclxuICAgICAga19zdGFydCA9IGtfc3RhcnQgKyAke3RpbGVTaXplfTtcclxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCAke3RpbGVTaXplfTsgaysrKSB7XHJcbiAgICAgICAgJHtjYWxjUmVzdWx0fVxyXG4gICAgICB9XHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAke2NhbGN1bGF0ZUFscGhhfVxyXG4gICAgbGV0IG0gPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XHJcbiAgICBsZXQgbiA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcclxuICAgICR7KCgpID0+IHtcclxuICAgICAgaWYgKGMgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBgbGV0IGNPZmZzZXQgPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ3ZlYzIobSwgbiknLCBvdXRwdXQpfTsgdmFsdWUgKz0gJHtcclxuICAgICAgICAgIG91dHB1dC50eXBlLnZhbHVlXHJcbiAgICAgICAgfSh1bmlmb3Jtcy5iZXRhKSAqICR7Yy5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtgO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH0pKCl9XHJcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcclxuICAgICAgb3V0cHV0W20gKiB1bmlmb3Jtcy5OICsgbl0gPSB2YWx1ZTtcclxuICAgIH1cclxuICB9YDtcclxuICB9O1xyXG5cclxuICBpZiAodXNlU2hhcmVkKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiAnR2VtbVNoYXJlZCcsXHJcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IG51bVRpbGVOICogbnVtVGlsZU0gfSxcclxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICAgIH0pLFxyXG4gICAgICBnZXRTaGFkZXJTb3VyY2U6IGdldFNoYWRlclNvdXJjZVNoYXJlZCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0dlbW0nLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUdlbW1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2VtbUF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IHRyYW5zQSA9IGF0dHJpYnV0ZXMudHJhbnNBIGFzIGJvb2xlYW47XHJcbiAgY29uc3QgdHJhbnNCID0gYXR0cmlidXRlcy50cmFuc0IgYXMgYm9vbGVhbjtcclxuICBjb25zdCBhbHBoYSA9IGF0dHJpYnV0ZXMuYWxwaGEgYXMgbnVtYmVyO1xyXG4gIGNvbnN0IGJldGEgPSBhdHRyaWJ1dGVzLmJldGEgYXMgbnVtYmVyO1xyXG4gIHJldHVybiB7XHJcbiAgICB0cmFuc0EsXHJcbiAgICB0cmFuc0IsXHJcbiAgICBhbHBoYSxcclxuICAgIGJldGEsXHJcbiAgICBjYWNoZUtleTogYCR7YXR0cmlidXRlcy50cmFuc0F9OyR7YXR0cmlidXRlcy50cmFuc0J9OyR7YXR0cmlidXRlcy5hbHBoYSA9PT0gMX1gLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2VtbSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdlbW1Qcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5sZXQgW2lkeE4sIGlkeEMsIGlkeEgsIGlkeFddID0gWzAsIDEsIDIsIDNdOyAvLyBOQ0hXXHJcbnR5cGUgTW9kZSA9ICdiaWxpbmVhcicgfCAnbmVhcmVzdCcgfCAnYmljdWJpYyc7XHJcbnR5cGUgUGFkZGluZ01vZGUgPSAnemVyb3MnIHwgJ2JvcmRlcicgfCAncmVmbGVjdGlvbic7XHJcbnR5cGUgRm9ybWF0ID0gJ05IV0MnIHwgJ05DSFcnO1xyXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRTYW1wZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIGFsaWduQ29ybmVyczogbnVtYmVyO1xyXG4gIG1vZGU6IE1vZGU7XHJcbiAgcGFkZGluZ01vZGU6IFBhZGRpbmdNb2RlO1xyXG4gIGZvcm1hdDogRm9ybWF0O1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignb25seSA0LUQgdGVuc29yIGlzIHN1cHBvcnRlZC4nKTtcclxuICB9XHJcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCB0byBncmlkIGRpbWVuc2lvbnMnKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyICE9PSBpbnB1dHNbMV0uZGltc1tpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAxXSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBsYXN0IGRpbWVuc2lvbiBvZiBncmlkIG11c3QgYmUgZXF1YWwgdG8gJHtpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyfWApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1swXS5kaW1zWzBdICE9PSBpbnB1dHNbMV0uZGltc1swXSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdncmlkIGJhdGNoIHNpemUgbXVzdCBtYXRjaCBpbnB1dCBiYXRjaCBzaXplJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZ3NHZXRDdWJpY0NvZWZmcyA9IGBcclxuICBmbiBnc19nZXRfY3ViaWNfY29lZmZzKHg6IGYzMikgLT4gdmVjNDxmMzI+IHtcclxuICAgIGxldCBjdWJpY19hbHBoYSA9IC0wLjc1ZjtcclxuICAgIGxldCB4X2FicyA9IGFicyh4KTtcclxuICAgIHZhciBjb2VmZnM6IHZlYzQ8ZjMyPjtcclxuICAgIGNvZWZmc1swXSA9ICgoKGN1YmljX2FscGhhICogKHhfYWJzICsgMSkgLSA1ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgKyA4ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgLSA0ICogY3ViaWNfYWxwaGEpO1xyXG4gICAgY29lZmZzWzFdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqIHhfYWJzIC0gKGN1YmljX2FscGhhICsgMykpICogeF9hYnMgKiB4X2FicyArIDEpO1xyXG4gICAgY29lZmZzWzJdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqICgxIC0geF9hYnMpIC0gKGN1YmljX2FscGhhICsgMykpICogKDEgLSB4X2FicykgKiAoMSAtIHhfYWJzKSArIDEpO1xyXG4gICAgY29lZmZzWzNdID0gKCgoY3ViaWNfYWxwaGEgKiAoMiAtIHhfYWJzKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSArIDggKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSAtIDQgKiBjdWJpY19hbHBoYSk7XHJcbiAgICByZXR1cm4gY29lZmZzO1xyXG4gIH1cclxuYDtcclxuXHJcbmNvbnN0IGdzQmljdWJpY0ludGVycG9sYXRlID0gKGRhdGFUeXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4gYFxyXG4gIGZuIGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocDogbWF0NHg0PCR7ZGF0YVR5cGV9PiwgeDogZjMyLCB5OiBmMzIpIC0+ICR7ZGF0YVR5cGV9IHtcclxuICAgIHZhciB2OiB2ZWM0PGYzMj47XHJcbiAgICB2YXIgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4KTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgIHZbaV0gPSBjb2VmZnNbMF0gKiBwW2ldWzBdICsgY29lZmZzWzFdICogcFtpXVsxXSArIGNvZWZmc1syXSAqIHBbaV1bMl0gKyBjb2VmZnNbM10gKiBwW2ldWzNdO1xyXG4gICAgfVxyXG4gICAgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh5KTtcclxuICAgIGxldCBwaXhlbCA9ICR7ZGF0YVR5cGV9KGNvZWZmc1swXSAqIHZbMF0gKyBjb2VmZnNbMV0gKiB2WzFdICsgY29lZmZzWzJdICogdlsyXSArIGNvZWZmc1szXSAqIHZbM10pO1xyXG4gICAgcmV0dXJuIHBpeGVsO1xyXG4gIH1cclxuYDtcclxuXHJcbmNvbnN0IGdzRGVub3JtYWxpemUgPSAoYXR0cmlidXRlczogR3JpZFNhbXBlQXR0cmlidXRlcyk6IHN0cmluZyA9PiBgXHJcbiAgZm4gZ3NfZGVub3JtYWxpemUobjogZjMyLCBsZW5ndGg6IGkzMikgLT4gZjMyIHtcclxuICAgICR7XHJcbiAgICAgIGF0dHJpYnV0ZXMuYWxpZ25Db3JuZXJzID09PSAwXHJcbiAgICAgICAgPyBgXHJcbiAgICAvLyBhbGlnbkNvcm5lcnM6IGZhbHNlID0+IFstMSwgMV0gdG8gWy0wLjUsIGxlbmd0aCAtIDAuNV1cclxuICAgIHJldHVybiAoKG4gKyAxLjApICogZjMyKGxlbmd0aCkgLSAxLjApIC8gMi4wO1xyXG4gICAgYFxyXG4gICAgICAgIDogYFxyXG4gICAgLy8gYWxpZ25Db3JuZXJzOiB0cnVlID0+IFstMSwgMV0gdG8gWzAsIGxlbmd0aCAtIDFdXHJcbiAgICByZXR1cm4gKG4gKyAxLjApIC8gMi4wICogKGYzMihsZW5ndGggLSAxKSk7XHJcbiAgICBgXHJcbiAgICB9XHJcbiAgfVxyXG5gO1xyXG5cclxuY29uc3QgZ3NSZWZsZWN0ID0gKGF0dHJpYnV0ZXM6IEdyaWRTYW1wZUF0dHJpYnV0ZXMpOiBzdHJpbmcgPT4gYFxyXG4gICR7XHJcbiAgICBhdHRyaWJ1dGVzLnBhZGRpbmdNb2RlID09PSAncmVmbGVjdGlvbidcclxuICAgICAgPyBgXHJcbiAgICAgIGZuIGdzX3JlZmxlY3QoeDogaTMyLCB4X21pbjogZjMyLCB4X21heDogZjMyKSAtPiB1MzIge1xyXG4gICAgICAgIHZhciBkeCA9IDAuMDtcclxuICAgICAgICB2YXIgZnggPSBmMzIoeCk7XHJcbiAgICAgICAgbGV0IHJhbmdlID0geF9tYXggLSB4X21pbjtcclxuICAgICAgICBpZiAoZnggPCB4X21pbikge1xyXG4gICAgICAgICAgZHggPSB4X21pbiAtIGZ4O1xyXG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XHJcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XHJcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xyXG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZnggPiB4X21heCkge1xyXG4gICAgICAgICAgZHggPSBmeCAtIHhfbWF4O1xyXG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XHJcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XHJcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xyXG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdTMyKGZ4KTtcclxuICAgICAgfWBcclxuICAgICAgOiAnJ1xyXG4gIH1cclxuYDtcclxuXHJcbmNvbnN0IHBpeGVsQXRHcmlkID0gKGlucHV0OiBJbmRpY2VzSGVscGVyLCBkYXRhVHlwZTogc3RyaW5nLCBhdHRyaWJ1dGVzOiBHcmlkU2FtcGVBdHRyaWJ1dGVzKTogc3RyaW5nID0+XHJcbiAgYFxyXG4gIGZuIHBpeGVsX2F0X2dyaWQocjogaTMyLCBjOiBpMzIsIEg6IGkzMiwgVzogaTMyLCBiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGJvcmRlcjogdmVjNDxmMzI+KSAtPiAke2RhdGFUeXBlfSB7XHJcbiAgICAgdmFyIHBpeGVsID0gJHtkYXRhVHlwZX0oMCk7XHJcbiAgICAgdmFyIGluZGljZXMgPSB2ZWM0PHUzMj4oMCk7XHJcbiAgICAgaW5kaWNlc1ske2lkeE59XSA9IGJhdGNoO1xyXG4gICAgIGluZGljZXNbJHtpZHhDfV0gPSBjaGFubmVsO2AgK1xyXG4gICgoKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMucGFkZGluZ01vZGUpIHtcclxuICAgICAgY2FzZSAnemVyb3MnOlxyXG4gICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICBpZiAociA+PSAwICYmIHIgPCBIICYmIGMgPj0wICYmIGMgPCBXKSB7XHJcbiAgICAgICAgICAgIGluZGljZXNbJHtpZHhIfV0gPSB1MzIocik7XHJcbiAgICAgICAgICAgIGluZGljZXNbJHtpZHhXfV0gPSB1MzIoYyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJHtkYXRhVHlwZX0oMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgYDtcclxuICAgICAgY2FzZSAnYm9yZGVyJzpcclxuICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgaW5kaWNlc1ske2lkeEh9XSA9IHUzMihjbGFtcChyLCAwLCBIIC0gMSkpO1xyXG4gICAgICAgICAgaW5kaWNlc1ske2lkeFd9XSA9IHUzMihjbGFtcChjLCAwLCBXIC0gMSkpO1xyXG4gICAgICAgIGA7XHJcbiAgICAgIGNhc2UgJ3JlZmxlY3Rpb24nOlxyXG4gICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICBpbmRpY2VzWyR7aWR4SH1dID0gZ3NfcmVmbGVjdChyLCBib3JkZXJbMV0sIGJvcmRlclszXSk7XHJcbiAgICAgICAgICBpbmRpY2VzWyR7aWR4V31dID0gZ3NfcmVmbGVjdChjLCBib3JkZXJbMF0sIGJvcmRlclsyXSk7XHJcbiAgICAgICAgYDtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcgbW9kZSAke2F0dHJpYnV0ZXMucGFkZGluZ01vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcclxuICAgIH1cclxuICB9KSgpICtcclxuICBgXHJcbiAgICByZXR1cm4gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2luZGljZXMnKX07XHJcbiAgfVxyXG5gO1xyXG5cclxuY29uc3QgY29tcHV0ZVBpeGVsID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgZGF0YVR5cGU6IHN0cmluZywgYXR0cmlidXRlczogR3JpZFNhbXBlQXR0cmlidXRlcyk6IHN0cmluZyA9PlxyXG4gICgoKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xyXG4gICAgICBjYXNlICduZWFyZXN0JzpcclxuICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHBpeGVsX2F0X2dyaWQoaTMyKHJvdW5kKHkpKSwgaTMyKHJvdW5kKHgpKSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEN9XSwgYm9yZGVyKTtcclxuICAgICAgICBgO1xyXG4gICAgICBjYXNlICdiaWxpbmVhcic6XHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgIGxldCB4MSA9IGkzMihmbG9vcih4KSk7XHJcbiAgICAgICAgICBsZXQgeTEgPSBpMzIoZmxvb3IoeSkpO1xyXG4gICAgICAgICAgbGV0IHgyID0geDEgKyAxO1xyXG4gICAgICAgICAgbGV0IHkyID0geTEgKyAxO1xyXG5cclxuICAgICAgICAgIGxldCBwMTEgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEN9XSwgYm9yZGVyKTtcclxuICAgICAgICAgIGxldCBwMTIgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEN9XSwgYm9yZGVyKTtcclxuICAgICAgICAgIGxldCBwMjEgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEN9XSwgYm9yZGVyKTtcclxuICAgICAgICAgIGxldCBwMjIgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEN9XSwgYm9yZGVyKTtcclxuXHJcbiAgICAgICAgICBsZXQgZHgyID0gJHtkYXRhVHlwZX0oZjMyKHgyKSAtIHgpO1xyXG4gICAgICAgICAgbGV0IGR4MSA9ICR7ZGF0YVR5cGV9KHggLSBmMzIoeDEpKTtcclxuICAgICAgICAgIGxldCBkeTIgPSAke2RhdGFUeXBlfShmMzIoeTIpIC0geSk7XHJcbiAgICAgICAgICBsZXQgZHkxID0gJHtkYXRhVHlwZX0oeSAtIGYzMih5MSkpO1xyXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGR5MiAqIChkeDIgKiBwMTEgKyBkeDEgKiBwMTIpICsgZHkxICogKGR4MiAqIHAyMSArIGR4MSAqIHAyMik7XHJcbiAgICAgICAgYDtcclxuICAgICAgY2FzZSAnYmljdWJpYyc6XHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgIGxldCB4MCA9IGkzMihmbG9vcih4KSkgLSAxO1xyXG4gICAgICAgICAgbGV0IHkwID0gaTMyKGZsb29yKHkpKSAtIDE7XHJcbiAgICAgICAgICB2YXIgcDogbWF0NHg0PCR7ZGF0YVR5cGV9PjtcclxuICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgNDsgaCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgNDsgdysrKSB7XHJcbiAgICAgICAgICAgICAgcFtoXVt3XSA9IHBpeGVsX2F0X2dyaWQoaCArIHkwLCB3ICsgeDAsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBsZXQgZHggPSB4IC0gZjMyKHgwICsgMSk7XHJcbiAgICAgICAgICBsZXQgZHkgPSB5IC0gZjMyKHkwICsgMSk7XHJcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwLCBkeCwgZHkpO1xyXG4gICAgICAgIGA7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtb2RlICR7YXR0cmlidXRlcy5tb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICB9XHJcbiAgfSkoKSArIGAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdyZXN1bHQnKX1gO1xyXG5cclxuY29uc3QgY3JlYXRlR3JpZFNhbXBsZVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHcmlkU2FtcGVBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xyXG4gIC8vIGRpc2NhcmQgbGFzdCBkaW1lbnNpb24gZm9yIHVzaW5nIHZlYzIgdG8gYWNjZXNzIGdyaWQgZGF0YVxyXG4gIGNvbnN0IGdyaWRTaGFwZSA9IFtpbnB1dHNbMV0uZGltc1swXSwgaW5wdXRzWzFdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzJdXTtcclxuICBjb25zdCBncmlkID0gaW5wdXRWYXJpYWJsZSgnZ3JpZCcsIGlucHV0c1sxXS5kYXRhVHlwZSwgZ3JpZFNoYXBlLmxlbmd0aCwgMik7XHJcbiAgbGV0IG91dHB1dFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSwgaW5wdXRzWzFdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzJdXTtcclxuICBpZiAoYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJykge1xyXG4gICAgb3V0cHV0U2hhcGUgPSBbaW5wdXRzWzBdLmRpbXNbMF0sIGlucHV0c1sxXS5kaW1zWzFdLCBpbnB1dHNbMV0uZGltc1syXSwgaW5wdXRzWzBdLmRpbXNbM11dO1xyXG4gICAgW2lkeE4sIGlkeEMsIGlkeEgsIGlkeFddID0gWzAsIDMsIDEsIDJdO1xyXG4gIH1cclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG4gIGNvbnN0IGRhdGFUeXBlID0geC50eXBlLnZhbHVlO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcblxyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgZ3JpZFNoYXBlLCBvdXRwdXRTaGFwZSksXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKHgsIGdyaWQsIG91dHB1dCl9XHJcbiAgJHtnc0dldEN1YmljQ29lZmZzfVxyXG4gICR7Z3NCaWN1YmljSW50ZXJwb2xhdGUoZGF0YVR5cGUpfVxyXG4gICR7Z3NEZW5vcm1hbGl6ZShhdHRyaWJ1dGVzKX1cclxuICAke2dzUmVmbGVjdChhdHRyaWJ1dGVzKX1cclxuICAke3BpeGVsQXRHcmlkKHgsIGRhdGFUeXBlLCBhdHRyaWJ1dGVzKX1cclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG4gICAgICBsZXQgSF9pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7aWR4SH1dKTtcclxuICAgICAgbGV0IFdfaW4gPSBpMzIodW5pZm9ybXMueF9zaGFwZVske2lkeFd9XSk7XHJcblxyXG4gICAgICAke1xyXG4gICAgICAgIGF0dHJpYnV0ZXMuYWxpZ25Db3JuZXJzID09PSAwXHJcbiAgICAgICAgICA/IGBcclxuICAgICAgbGV0IHhfbWluID0gLTAuNTtcclxuICAgICAgbGV0IHhfbWF4ID0gZjMyKFdfaW4pIC0gMC41O1xyXG4gICAgICBsZXQgeV9taW4gPSAtMC41O1xyXG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAwLjU7XHJcbiAgICAgIGBcclxuICAgICAgICAgIDogYFxyXG4gICAgICBsZXQgeF9taW4gPSAwLjA7XHJcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDEuMDtcclxuICAgICAgbGV0IHlfbWluID0gMC4wO1xyXG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAxLjA7XHJcbiAgICAgIGBcclxuICAgICAgfTtcclxuICAgICAgbGV0IGJvcmRlciA9IHZlYzQ8ZjMyPih4X21pbiwgeV9taW4sIHhfbWF4LCB5X21heCk7XHJcblxyXG4gICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgdmFyIGdyaWRfaW5kaWNlcyA9IHZlYzM8dTMyPihpbmRpY2VzWyR7aWR4Tn1dLCBpbmRpY2VzWyR7aWR4SH1dLCBpbmRpY2VzWyR7aWR4V31dKTtcclxuICAgICAgbGV0IG54eSA9ICR7Z3JpZC5nZXRCeUluZGljZXMoJ2dyaWRfaW5kaWNlcycpfTtcclxuICAgICAgdmFyIHggPSBnc19kZW5vcm1hbGl6ZShmMzIobnh5WzBdKSwgV19pbik7XHJcbiAgICAgIHZhciB5ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVsxXSksIEhfaW4pO1xyXG5cclxuICAgICAgJHtjb21wdXRlUGl4ZWwob3V0cHV0LCBkYXRhVHlwZSwgYXR0cmlidXRlcyl9XHJcbiAgfWA7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnR3JpZFNhbXBsZScsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnLCAndHlwZSddIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRzKSA9PiB7XHJcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBncmlkU2FtcGxlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHcmlkU2FtcGVBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHcmlkU2FtcGxlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUdyaWRTYW1wbGVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR3JpZFNhbXBlQXR0cmlidXRlcyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XHJcbiAgICBhbGlnbkNvcm5lcnM6IGF0dHJpYnV0ZXMuYWxpZ25fY29ybmVycyBhcyBudW1iZXIsXHJcbiAgICBtb2RlOiBhdHRyaWJ1dGVzLm1vZGUgYXMgTW9kZSxcclxuICAgIHBhZGRpbmdNb2RlOiBhdHRyaWJ1dGVzLnBhZGRpbmdfbW9kZSBhcyBQYWRkaW5nTW9kZSxcclxuICAgIGZvcm1hdDogYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0LFxyXG4gIH0pO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIEdwdURhdGFUeXBlLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgYXBwbHlBdHRlbnRpb24sXHJcbiAgQXR0ZW50aW9uQXR0cnMsXHJcbiAgQXR0ZW50aW9uTWFza1R5cGUsXHJcbiAgQXR0ZW50aW9uUGFyYW1ldGVycyxcclxuICBBdHRlbnRpb25Ra3ZGb3JtYXQsXHJcbn0gZnJvbSAnLi9hdHRlbnRpb24nO1xyXG5pbXBvcnQgeyBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZSB9IGZyb20gJy4vY29tbW9uJztcclxuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8sIFRyYW5zcG9zZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3RyYW5zcG9zZSc7XHJcblxyXG5jb25zdCBnZXRJbnB1dCA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgaTogbnVtYmVyKSA9PlxyXG4gIGlucHV0cy5sZW5ndGggPiBpICYmIGlucHV0c1tpXS5kaW1zLmxlbmd0aCA+IDAgPyBpbnB1dHNbaV0gOiB1bmRlZmluZWQ7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25QYXJhbWV0ZXJzID0+IHtcclxuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcclxuICBjb25zdCBrZXkgPSBnZXRJbnB1dChpbnB1dHMsIDEpO1xyXG4gIGNvbnN0IHZhbHVlID0gZ2V0SW5wdXQoaW5wdXRzLCAyKTtcclxuICBjb25zdCBiaWFzID0gZ2V0SW5wdXQoaW5wdXRzLCAzKTtcclxuICBjb25zdCBrZXlQYWRkaW5nTWFzayA9IGdldElucHV0KGlucHV0cywgNCk7XHJcbiAgY29uc3QgYXR0ZW50aW9uQmlhcyA9IGdldElucHV0KGlucHV0cywgNSk7XHJcbiAgY29uc3QgcGFzdEtleSA9IGdldElucHV0KGlucHV0cywgNik7XHJcbiAgY29uc3QgcGFzdFZhbHVlID0gZ2V0SW5wdXQoaW5wdXRzLCA3KTtcclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gTm90YXRpb25zOlxyXG4gIC8vICAgIEI6IGJhdGNoX3NpemVcclxuICAvLyAgICBOOiBudW1faGVhZHNcclxuICAvLyAgICBIOiBoZWFkX3NpemUgb2YgUSBhbmQgS1xyXG4gIC8vICAgIEhfdjogaGVhZF9zaXplIG9mIFZcclxuICAvLyAgICBEOiBoaWRkZW5fc2l6ZSBmb3IgUSBhbmQgSywgd2hlcmUgRCA9IE4gKiBIXHJcbiAgLy8gICAgRF92OiBoaWRkZW5fc2l6ZSBvZiBWLCB3aGVyZSBEX3YgPSBOICogSF92XHJcbiAgLy8gICAgUzogcV9zZXF1ZW5jZV9sZW5ndGhcclxuICAvLyAgICBQOiBwYXN0X3NlcXVlbmNlX2xlbmd0aCBvZiBrdiBjYWNoZVxyXG4gIC8vICAgIEw6IGt2X3NlcXVlbmNlX2xlbmd0aFxyXG4gIC8vICAgIFQ6IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IFAgKyBMXHJcbiAgLy8gICAgTTogbWF4X3NlcXVlbmNlX2xlbmd0aCBvZiBrdiBjYWNoZSB3aGVuIHBhc3QgYW5kIHByZXNlbnQgc2hhcmUgYnVmZmVyXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gTXVsdGlIZWFkQXR0ZW50aW9uIGlucHV0czpcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAvLyAgUV9LX1ZfQlNOSCAtIG5vIHBhY2tpbmc6XHJcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXHJcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIEQpXHJcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogKEIsIEwsIERfdilcclxuICAvLyAgUV9LX1ZfQlNOSF9CTlNIX0JOU0ggLSBjcm9zcyBhdHRlbnRpb24gKGt2IGNhY2hlIGlzIG5vdCB1c2VkLCBMID09IFQsIEQgPT0gRF92KTpcclxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcclxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiAoQiwgTiwgTCwgSClcclxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiAoQiwgTiwgTCwgSF92KVxyXG4gIC8vICBRX0tWX0JTTkhfQlNOMkggLSBwYWNrZWQga3YgKGt2IGNhY2hlIGlzIG5vdCB1c2VkLCBiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YpOlxyXG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxyXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLL1YpICAgICA6IChCLCBMLCBOLCAyLCBIKVxyXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICA6IE5vbmVcclxuICAvLyAgUUtWX0JTTjNIIC0gcGFja2VkIHFrdiAoa3YgY2FjaGUgaXMgbm90IHVzZWQsIFMgPT0gTCwgRCA9PSBEX3YpOlxyXG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRL0svVikgICA6IChCLCBTLCBOLCAzLCBIKVxyXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgICAgICAgICAgICA6IE5vbmVcclxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAgICAgICAgICAgOiBOb25lXHJcbiAgLy9cclxuICAvLyAgT3RoZXIgaW5wdXRzOlxyXG4gIC8vICAgICBiaWFzICAgICAgICAgICAgIChRL0svVikgICA6IE5vbmUgb3IgKEQgKyBEICsgRF92KVxyXG4gIC8vICAgICBrZXlfcGFkZGluZ19tYXNrIChLL1YpICAgICA6IChCKSBvciAoMyAqIEIgKyAyKSBvciAoQiwgVCkgb3IgKEIsIFMsIFQpXHJcbiAgLy8gICAgIGF0dGVudGlvbl9iaWFzICAgICAgICAgICAgIDogTm9uZSBvciAoQiwgTiwgUywgVCksICgxLCBOLCBTLCBUKSwgKEIsIDEsIFMsIFQpIG9yICgxLCAxLCBTLCBUKVxyXG4gIC8vICAgICBwYXN0X2tleSAgICAgICAgICAgICAgICAgICA6IChCLCBOLCBQLCBIKSBvciBOb25lLiBQYXN0IHN0YXRlIGlzIG9ubHkgYWxsb3dlZCBmb3IgUV9LX1ZfQlNOSC5cclxuICAvLyAgICAgcGFzdF92YWx1ZSAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUCwgSCkgb3IgTm9uZS4gUGFzdCBzdGF0ZSBpcyBvbmx5IGFsbG93ZWQgZm9yIFFfS19WX0JTTkguXHJcbiAgLy9cclxuICAvLyAgTm90IFN1cHBvcnRlZDpcclxuICAvLyAgICAga2V5X3BhZGRpbmdfbWFzaywgcGFja2VkIGt2LCBwYWNrZWQgcWt2LCBhbmQgYnJvYWRjYXN0IGZvciBhdHRlbnRpb25fYmlhcy5cclxuXHJcbiAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzICYmIHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IHF1ZXJ5LmRpbXNbMF07XHJcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBxdWVyeS5kaW1zWzFdO1xyXG4gIGNvbnN0IGhpZGRlblNpemUgPSBxdWVyeS5kaW1zLmxlbmd0aCA9PT0gMyA/IHF1ZXJ5LmRpbXNbMl0gOiBhdHRyaWJ1dGVzLm51bUhlYWRzICogcXVlcnkuZGltc1s0XTtcclxuICBsZXQga3ZTZXF1ZW5jZUxlbmd0aCA9IHNlcXVlbmNlTGVuZ3RoO1xyXG5cclxuICBsZXQgcGFzdFNlcXVlbmNlTGVuZ3RoID0gMDtcclxuICBsZXQgbWF4U2VxdWVuY2VMZW5ndGggPSAwO1xyXG4gIGNvbnN0IGhlYWRTaXplID0gTWF0aC5mbG9vcihoaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyk7XHJcbiAgaWYgKHBhc3RLZXkgJiYgcGFzdFZhbHVlICYmIFNoYXBlVXRpbC5zaXplKHBhc3RLZXkuZGltcykgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpKSB7XHJcbiAgICBpZiAocGFzdEtleS5kaW1zLmxlbmd0aCAhPT0gNCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhc3RLZXkuZGltc1swXSAhPT0gYmF0Y2hTaXplIHx8IHBhc3RLZXkuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBwYXN0S2V5LmRpbXNbM10gIT09IGhlYWRTaXplKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoXHJcbiAgICAgIHBhc3RWYWx1ZS5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHxcclxuICAgICAgcGFzdFZhbHVlLmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHxcclxuICAgICAgcGFzdFZhbHVlLmRpbXNbM10gIT09IGhlYWRTaXplXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhc3RLZXkuZGltc1syXSAhPT0gcGFzdFZhbHVlLmRpbXNbMl0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAocGFzdF9zZXF1ZW5jZV9sZW5ndGgpJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFzdFZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1syXTtcclxuICAgIG1heFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xyXG4gIH0gZWxzZSBpZiAoKHBhc3RLZXkgJiYgU2hhcGVVdGlsLnNpemUocGFzdEtleS5kaW1zKSkgfHwgKHBhc3RWYWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0VmFsdWUuZGltcykpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7XHJcbiAgfVxyXG5cclxuICBsZXQgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQ7XHJcbiAgaWYgKGtleSAmJiBTaGFwZVV0aWwuc2l6ZShrZXkuZGltcykgPiAwKSB7XHJcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtcclxuICAgIH1cclxuICAgIGlmIChrZXkuZGltcy5sZW5ndGggPCAzIHx8IGtleS5kaW1zLmxlbmd0aCA+IDUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0ga2V5LmRpbXNbMF0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDMpIHtcclxuICAgICAgaWYgKGtleS5kaW1zWzJdICE9PSBxdWVyeS5kaW1zWzJdKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChoaWRkZW5fc2l6ZSknKTtcclxuICAgICAgfVxyXG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOSDtcclxuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xyXG4gICAgfSBlbHNlIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDUpIHtcclxuICAgICAgaWYgKGtleS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSAyIHx8IGtleS5kaW1zWzRdICE9PSBoZWFkU2l6ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7XHJcbiAgICAgIH1cclxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFLdkJTTkh4QlNOMkg7XHJcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGtleV9kaW1zLnNpemUoKSA9PSA0IChjcm9zcy1hdHRlbnRpb24gd2l0aCBwYXN0X2tleSlcclxuICAgICAgaWYgKGtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQudW5rbm93bjsgLy8gUV9LX1ZfQlNOSF9CTlNIX0JOU0hcclxuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzJdO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBwYWNrZWQgUUtWXHJcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtcclxuICAgIH1cclxuICAgIGlmIChxdWVyeS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHF1ZXJ5LmRpbXNbM10gIT09IDMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJTTjNIO1xyXG4gIH1cclxuXHJcbiAgaWYgKGJpYXMgJiYgU2hhcGVVdGlsLnNpemUoYmlhcy5kaW1zKSA+IDApIHtcclxuICAgIGlmIChiaWFzLmRpbXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gNSAmJiBrZXkuZGltc1szXSA9PT0gMikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBub3QgYWxsb3dlZCBmb3IgcGFja2VkIGt2LicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsga3ZTZXF1ZW5jZUxlbmd0aDtcclxuXHJcbiAgbGV0IG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XHJcbiAgaWYgKGtleVBhZGRpbmdNYXNrICYmIFNoYXBlVXRpbC5zaXplKGtleVBhZGRpbmdNYXNrLmRpbXMpID4gMCkge1xyXG4gICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrVW5rbm93bjtcclxuICAgIGNvbnN0IG1hc2tEaW1zID0ga2V5UGFkZGluZ01hc2suZGltcztcclxuICAgIGlmIChtYXNrRGltcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgaWYgKG1hc2tEaW1zWzBdID09PSBiYXRjaFNpemUpIHtcclxuICAgICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2sxZEtleVNlcUxlbjtcclxuICAgICAgfSBlbHNlIGlmIChtYXNrRGltc1swXSA9PT0gMyAqIGJhdGNoU2l6ZSArIDIpIHtcclxuICAgICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2sxREtleVNlcUxlblN0YXJ0O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1hc2tEaW1zLmxlbmd0aCA9PT0gMiAmJiBtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplICYmIG1hc2tEaW1zWzFdID09PSB0b3RhbFNlcXVlbmNlTGVuZ3RoKSB7XHJcbiAgICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFzazJkS2V5UGFkZGluZztcclxuICAgIH1cclxuICAgIGlmIChtYXNrVHlwZSA9PT0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd24pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleV9wYWRkaW5nX21hc2tcIiBzaGFwZSBzaGFsbCBiZSAoYmF0Y2hfc2l6ZSkgb3IgKGJhdGNoX3NpemUsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignTWFzayBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgfVxyXG5cclxuICBsZXQgcGFzc1Bhc3RJbkt2ID0gZmFsc2U7XHJcbiAgbGV0IHZIaWRkZW5TaXplID0gaGlkZGVuU2l6ZTtcclxuICBpZiAodmFsdWUgJiYgU2hhcGVVdGlsLnNpemUodmFsdWUuZGltcykgPiAwKSB7XHJcbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggIT09IDMgJiYgdmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSB2YWx1ZS5kaW1zWzBdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1sxXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcclxuICAgICAgfVxyXG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBRX0tfVl9CU05IX0JOU0hfQk5TSFxyXG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1syXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcclxuICAgICAgfVxyXG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMV0gKiB2YWx1ZS5kaW1zWzNdO1xyXG4gICAgICBwYXNzUGFzdEluS3YgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgYnJvYWRjYXN0UmVzUG9zQmlhcyA9IGZhbHNlO1xyXG5cclxuICBpZiAoa2V5UGFkZGluZ01hc2sgJiYgU2hhcGVVdGlsLnNpemUoa2V5UGFkZGluZ01hc2suZGltcykgPiAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBwYWRkaW5nIG1hc2sgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF0dGVudGlvbkJpYXMgJiYgU2hhcGVVdGlsLnNpemUoYXR0ZW50aW9uQmlhcy5kaW1zKSA+IDApIHtcclxuICAgIGlmIChhdHRlbnRpb25CaWFzLmRpbXMubGVuZ3RoICE9PSA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogc3VwcG9ydCBicm9hZGNhc3RpbmcgdGhlIGZpcnN0IGFuZCBzZWNvbmQgZGltZW5zaW9ucyBvZiBhdHRlbnRpb25fYmlhcy5cclxuICAgIGlmIChcclxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHxcclxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8XHJcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1syXSAhPT0gc2VxdWVuY2VMZW5ndGggfHxcclxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzNdICE9PSB0b3RhbFNlcXVlbmNlTGVuZ3RoXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJhdHRlbnRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGJhdGNoU2l6ZSxcclxuICAgIHNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxyXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcclxuICAgIHRvdGFsU2VxdWVuY2VMZW5ndGgsXHJcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCxcclxuICAgIGlucHV0SGlkZGVuU2l6ZTogMCxcclxuICAgIGhpZGRlblNpemUsXHJcbiAgICB2SGlkZGVuU2l6ZSxcclxuICAgIGhlYWRTaXplLFxyXG4gICAgdkhlYWRTaXplOiBNYXRoLmZsb29yKHZIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyksXHJcbiAgICBudW1IZWFkczogYXR0cmlidXRlcy5udW1IZWFkcyxcclxuICAgIGlzVW5pZGlyZWN0aW9uYWw6IGZhbHNlLFxyXG4gICAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogZmFsc2UsXHJcbiAgICBtYXNrRmlsdGVyVmFsdWU6IGF0dHJpYnV0ZXMubWFza0ZpbHRlclZhbHVlLFxyXG4gICAgbWFza1R5cGUsXHJcbiAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcclxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXMsXHJcbiAgICBwYXNzUGFzdEluS3YsXHJcbiAgICBxa3ZGb3JtYXQsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25BdHRycyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IC4uLmF0dHJpYnV0ZXMgfSk7XHJcblxyXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGU6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBwZXJtOiBbMCwgMiwgMSwgM10gfSk7XHJcblxyXG5jb25zdCBhZGRCaWFzVHJhbnNwb3NlID0gKFxyXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxyXG4gIHFrdjogVGVuc29yVmlldyxcclxuICBiaWFzOiBUZW5zb3JWaWV3LFxyXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxyXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXHJcbiAgaGlkZGVuU2l6ZTogbnVtYmVyLFxyXG4gIGJpYXNPZmZzZXQ6IG51bWJlcixcclxuKSA9PiB7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgaGlkZGVuU2l6ZV07XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJpYXNPZmZzZXQgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBoaWRkZW5TaXplIH0sXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncWt2X3dpdGhfYmlhcycsIHFrdi5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xyXG4gICAgY29uc3QgcWt2SW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdxa3YnLCBxa3YuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcclxuICAgIGNvbnN0IGJpYXNJbnB1dCA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XHJcblxyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2JpYXNfb2Zmc2V0JywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgXTtcclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhxa3ZJbnB1dCwgYmlhc0lucHV0LCBvdXRwdXQpfVxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgIGxldCBiaWFzX29mZnNldF9pZHggPSAoZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLmhpZGRlbl9zaXplKSArIHVuaWZvcm1zLmJpYXNfb2Zmc2V0O1xyXG5cclxuICAgIHFrdl93aXRoX2JpYXNbZ2xvYmFsX2lkeF0gPSBxa3ZbZ2xvYmFsX2lkeF0gKyBiaWFzW2JpYXNfb2Zmc2V0X2lkeF07XHJcbiAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ011bHRpSGVhZEF0dGVudGlvbkFkZEJpYXMnLFxyXG4gICAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXSB9LFxyXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogcWt2LmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9XSxcclxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgICB9KSxcclxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgfSxcclxuICAgIHsgaW5wdXRzOiBbcWt2LCBiaWFzXSwgb3V0cHV0czogWy0xXSB9LFxyXG4gIClbMF07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzID0gKFxyXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxyXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxyXG4gIG51bUhlYWRzOiBudW1iZXIsXHJcbiAgc2VxdWVuY2VMZW5ndGg6IG51bWJlcixcclxuICBoZWFkU2l6ZTogbnVtYmVyLFxyXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxyXG4gIGJpYXM/OiBUZW5zb3JWaWV3LFxyXG4gIGJpYXNPZmZzZXQ/OiBudW1iZXIsXHJcbikgPT4ge1xyXG4gIC8vIGNvbnN0IG5ld0RpbXMgPSBbXTtcclxuXHJcbiAgbGV0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dDtcclxuICBpZiAoIShiaWFzICYmIFNoYXBlVXRpbC5zaXplKGJpYXMuZGltcykgPiAwKSkge1xyXG4gICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgIHJlc2hhcGVkSW5wdXQgPSBpbnB1dC5yZXNoYXBlKFtiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBudW1IZWFkcywgaGVhZFNpemVdKTtcclxuICAgIH1cclxuICAgIGlmIChudW1IZWFkcyA9PT0gMSB8fCBzZXF1ZW5jZUxlbmd0aCA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gcmVzaGFwZWRJbnB1dDtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlLnBlcm0pLCB7XHJcbiAgICAgIGlucHV0czogW3Jlc2hhcGVkSW5wdXRdLFxyXG4gICAgICBvdXRwdXRzOiBbLTFdLFxyXG4gICAgfSlbMF07XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChzZXF1ZW5jZUxlbmd0aCA9PT0gMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZEJpYXNSZXNoYXBlIGlzIG5vdCBpbXBsZW1lbnRlZC4gUGxlYXNlIGV4cG9ydCB5b3VyIG1vZGVsIHdpdGggcGFja2VkIFFLViBvciBLVicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzaGFwZWRJbnB1dCA9IGFkZEJpYXNUcmFuc3Bvc2UoXHJcbiAgICAgICAgY29udGV4dCxcclxuICAgICAgICBpbnB1dCxcclxuICAgICAgICBiaWFzLFxyXG4gICAgICAgIGJhdGNoU2l6ZSxcclxuICAgICAgICBzZXF1ZW5jZUxlbmd0aCxcclxuICAgICAgICBudW1IZWFkcyAqIGhlYWRTaXplLFxyXG4gICAgICAgIGJpYXNPZmZzZXQhLFxyXG4gICAgICApO1xyXG4gICAgICByZXNoYXBlZElucHV0ID0gcmVzaGFwZWRJbnB1dC5yZXNoYXBlKFtiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBudW1IZWFkcywgaGVhZFNpemVdKTtcclxuICAgICAgaWYgKG51bUhlYWRzID09PSAxIHx8IHNlcXVlbmNlTGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc2hhcGVkSW5wdXQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXNoYXBlZElucHV0LCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUucGVybSksIHtcclxuICAgICAgICBpbnB1dHM6IFtyZXNoYXBlZElucHV0XSxcclxuICAgICAgICBvdXRwdXRzOiBbLTFdLFxyXG4gICAgICB9KVswXTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbXVsdGlIZWFkQXR0ZW50aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IHBhcmFtcyA9IHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuICBjb25zdCBxdWVyeSA9IGNvbnRleHQuaW5wdXRzWzBdO1xyXG4gIGNvbnN0IGtleSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCAxKTtcclxuICBjb25zdCB2YWx1ZSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCAyKTtcclxuICBjb25zdCBiaWFzID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDMpO1xyXG4gIGNvbnN0IGtleVBhZGRpbmdNYXNrID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDQpO1xyXG4gIGNvbnN0IGF0dGVudGlvbkJpYXMgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgNSk7XHJcbiAgY29uc3QgcGFzdEtleSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA2KTtcclxuICBjb25zdCBwYXN0VmFsdWUgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgNyk7XHJcbiAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoID09PSA1KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoa2V5Py5kaW1zLmxlbmd0aCA9PT0gNSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG5cclxuICAvLyBhcHBseUF0dGVudGlvbiBleHBlY3RzIEJOU0ggaW5wdXRzXHJcbiAgY29uc3Qga3ZCTlNIID0ga2V5ICYmIHZhbHVlICYmIGtleS5kaW1zLmxlbmd0aCA9PT0gNCAmJiB2YWx1ZS5kaW1zLmxlbmd0aCA9PT0gNDtcclxuXHJcbiAgY29uc3QgUSA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcclxuICAgIGNvbnRleHQsXHJcbiAgICBwYXJhbXMuYmF0Y2hTaXplLFxyXG4gICAgcGFyYW1zLm51bUhlYWRzLFxyXG4gICAgcGFyYW1zLnNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgcGFyYW1zLmhlYWRTaXplLFxyXG4gICAgcXVlcnksXHJcbiAgICBiaWFzLFxyXG4gICAgMCxcclxuICApO1xyXG5cclxuICBpZiAoa3ZCTlNIKSB7XHJcbiAgICByZXR1cm4gYXBwbHlBdHRlbnRpb24oY29udGV4dCwgUSwga2V5LCB2YWx1ZSwga2V5UGFkZGluZ01hc2ssIHVuZGVmaW5lZCwgcGFzdEtleSwgcGFzdFZhbHVlLCBhdHRlbnRpb25CaWFzLCBwYXJhbXMpO1xyXG4gIH1cclxuICBpZiAoIWtleSB8fCAhdmFsdWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigna2V5IGFuZCB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkJyk7XHJcbiAgfVxyXG4gIGNvbnN0IEsgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgcGFyYW1zLmJhdGNoU2l6ZSxcclxuICAgIHBhcmFtcy5udW1IZWFkcyxcclxuICAgIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgcGFyYW1zLmhlYWRTaXplLFxyXG4gICAga2V5LFxyXG4gICAgYmlhcyxcclxuICAgIHBhcmFtcy5oaWRkZW5TaXplLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IFYgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgcGFyYW1zLmJhdGNoU2l6ZSxcclxuICAgIHBhcmFtcy5udW1IZWFkcyxcclxuICAgIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgcGFyYW1zLnZIZWFkU2l6ZSxcclxuICAgIHZhbHVlLFxyXG4gICAgYmlhcyxcclxuICAgIDIgKiBwYXJhbXMuaGlkZGVuU2l6ZSxcclxuICApO1xyXG5cclxuICBhcHBseUF0dGVudGlvbihjb250ZXh0LCBRLCBLLCBWLCBrZXlQYWRkaW5nTWFzaywgdW5kZWZpbmVkLCBwYXN0S2V5LCBwYXN0VmFsdWUsIGF0dGVudGlvbkJpYXMsIHBhcmFtcyk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0sIFRlbnNvckluZm8gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIGdldEVsZW1lbnRBdCxcclxuICBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3BsaXRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBheGlzOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgbnVtT3V0cHV0czogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IHNwbGl0U2l6ZXM6IG51bWJlcltdO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBmZXcgaW5wdXRzJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlU3BsaXRBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMsXHJcbik6IFNwbGl0QXR0cmlidXRlcyA9PiB7XHJcbiAgY29uc3Qgc3BsaXRTaXplczogbnVtYmVyW10gPSBbXTtcclxuICBsZXQgbnVtT3V0cHV0czogbnVtYmVyID0gYXR0cmlidXRlcy5udW1PdXRwdXRzO1xyXG4gIGlmIChpbnB1dHNbMV0uZGltc1swXSA+IDApIHtcclxuICAgIGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodikgPT4gc3BsaXRTaXplcy5wdXNoKE51bWJlcih2KSkpO1xyXG4gICAgbnVtT3V0cHV0cyA9IHNwbGl0U2l6ZXMubGVuZ3RoO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgbnVtT3V0cHV0cywgYXhpczogYXR0cmlidXRlcy5heGlzLCBzcGxpdFNpemVzIH0pO1xyXG59O1xyXG5cclxuY29uc3QgY2FsY3VsYXRlT3V0cHV0SW5kZXhJbXBsID0gKG51bWJlck9mVGVuc29yczogbnVtYmVyKTogc3RyaW5nID0+IGBcclxuZm4gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcclxuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtudW1iZXJPZlRlbnNvcnN9dTsgaSArPSAxdSApIHtcclxuICAgIGlmIChpbmRleCA8ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXMnLCAnaScsIG51bWJlck9mVGVuc29ycyl9KSB7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJHtudW1iZXJPZlRlbnNvcnN9dTtcclxufWA7XHJcbmNvbnN0IHdyaXRlQnVmZmVyRGF0YUltcGwgPSAob3V0cHV0czogcmVhZG9ubHkgSW5kaWNlc0hlbHBlcltdKSA9PiB7XHJcbiAgY29uc3QgbnVtYmVyT2ZUZW5zb3JzID0gb3V0cHV0cy5sZW5ndGg7XHJcbiAgY29uc3QgY29kZUxpbmVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUZW5zb3JzOyArK2kpIHtcclxuICAgIGNvbnN0IHJldHVyblNuaXBwZXQgPSBvdXRwdXRzW2ldLnNldEJ5SW5kaWNlcygnaW5kaWNlcycsICdpbnB1dFtnbG9iYWxfaWR4XScpO1xyXG4gICAgaWYgKG51bWJlck9mVGVuc29ycyA9PT0gMSkge1xyXG4gICAgICBjb2RlTGluZXMucHVzaChyZXR1cm5TbmlwcGV0KTtcclxuICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xyXG4gICAgICBjb2RlTGluZXMucHVzaChgaWYgKG91dHB1dF9udW1iZXIgPT0gJHtpfXUpIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XHJcbiAgICB9IGVsc2UgaWYgKGkgPT09IG51bWJlck9mVGVuc29ycyAtIDEpIHtcclxuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7aX0pIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBgXHJcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyOiB1MzIsIGluZGljZXM6ICR7b3V0cHV0c1swXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcclxuICAgICAgICAke2NvZGVMaW5lcy5qb2luKCdcXG4nKX1cclxuICAgICAgfWA7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBpbnB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTtcclxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcclxuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgY29uc3Qgb3V0cHV0cyA9IG5ldyBBcnJheTxJbmRpY2VzSGVscGVyPihhdHRyaWJ1dGVzLm51bU91dHB1dHMpO1xyXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgpO1xyXG4gIGNvbnN0IHNpemVJblNwbGl0QXhpcyA9IG5ldyBBcnJheTxudW1iZXI+KGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XHJcbiAgY29uc3Qgb3V0cHV0c1RlbnNvckluZm86IFRlbnNvckluZm9bXSA9IFtdO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlczogbnVtYmVyW11bXSA9IFtdO1xyXG4gIGxldCBwcmV2aW91c1N1bSA9IDA7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBpbnB1dFNpemUgfV07XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLm51bU91dHB1dHM7IGkrKykge1xyXG4gICAgcHJldmlvdXNTdW0gKz0gYXR0cmlidXRlcy5zcGxpdFNpemVzW2ldO1xyXG4gICAgc2l6ZUluU3BsaXRBeGlzW2ldID0gcHJldmlvdXNTdW07XHJcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcclxuICAgIG91dHB1dFNoYXBlW2F4aXNdID0gYXR0cmlidXRlcy5zcGxpdFNpemVzW2ldO1xyXG4gICAgb3V0cHV0U2hhcGVzLnB1c2gob3V0cHV0U2hhcGUpO1xyXG4gICAgb3V0cHV0c1tpXSA9IG91dHB1dFZhcmlhYmxlKGBvdXRwdXQke2l9YCwgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgICBvdXRwdXRzVGVuc29ySW5mby5wdXNoKHsgZGltczogb3V0cHV0U2hhcGVzW2ldLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH0pO1xyXG4gIH1cclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaChcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzaXplSW5TcGxpdEF4aXMgfSxcclxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIC4uLm91dHB1dFNoYXBlcyksXHJcbiAgKTtcclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICAke3NoYWRlckhlbHBlclxyXG4gICAgLnJlZ2lzdGVyVW5pZm9ybSgnaW5wdXRfc2l6ZScsICd1MzInKVxyXG4gICAgLnJlZ2lzdGVyVW5pZm9ybSgnc2l6ZV9pbl9zcGxpdF9heGlzJywgJ3UzMicsIHNpemVJblNwbGl0QXhpcy5sZW5ndGgpXHJcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgLi4ub3V0cHV0cyl9XHJcbiAgJHtjYWxjdWxhdGVPdXRwdXRJbmRleEltcGwoc2l6ZUluU3BsaXRBeGlzLmxlbmd0aCl9XHJcbiAgJHt3cml0ZUJ1ZmZlckRhdGFJbXBsKG91dHB1dHMpfVxyXG5cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLmlucHV0X3NpemUnKX1cclxuXHJcbiAgICB2YXIgaW5kaWNlcyA9ICR7aW5wdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgdmFyIGluZGV4ID0gJHtpbnB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgYXhpcyl9O1xyXG4gICAgbGV0IG91dHB1dF9udW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleCk7XHJcbiAgICBpZiAob3V0cHV0X251bWJlciAhPSAwKSB7XHJcbiAgICAgIGluZGV4IC09ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXMnLCAnb3V0cHV0X251bWJlciAtIDF1Jywgc2l6ZUluU3BsaXRBeGlzLmxlbmd0aCl9O1xyXG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2luZGljZXMnLCBheGlzLCAnaW5kZXgnKX07XHJcbiAgICB9XHJcbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XHJcbiAgfWA7XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdTcGxpdCcsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IG91dHB1dHNUZW5zb3JJbmZvLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChpbnB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzcGxpdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID1cclxuICAgIGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVTcGxpdEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpLCB7IGlucHV0czogWzBdIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlU3BsaXRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogU3BsaXRBdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBheGlzID0gYXR0cmlidXRlcy5heGlzIGFzIG51bWJlcjtcclxuICBjb25zdCBzcGxpdFNpemVzOiBudW1iZXJbXSA9IGF0dHJpYnV0ZXMuc3BsaXRTaXplcyBhcyBudW1iZXJbXTtcclxuICBjb25zdCBudW1PdXRwdXRzID0gKGF0dHJpYnV0ZXMubnVtT3V0cHV0cyBhcyBudW1iZXIpIDwgMCA/IHNwbGl0U2l6ZXMubGVuZ3RoIDogKGF0dHJpYnV0ZXMubnVtT3V0cHV0cyBhcyBudW1iZXIpO1xyXG4gIGlmIChudW1PdXRwdXRzICE9PSBzcGxpdFNpemVzLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1PdXRwdXRzIGFuZCBzcGxpdFNpemVzIGxlbmd0aCBtdXN0IGJlIGVxdWFsJyk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzLCBudW1PdXRwdXRzLCBzcGxpdFNpemVzIH0pO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBXT1JLR1JPVVBfU0laRSB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyB7XHJcbiAgcmVhZG9ubHkgaW50ZXJsZWF2ZWQ6IGJvb2xlYW47XHJcbiAgcmVhZG9ubHkgbnVtSGVhZHM6IG51bWJlcjtcclxuICByZWFkb25seSByb3RhcnlFbWJlZGRpbmdEaW06IG51bWJlcjtcclxuICByZWFkb25seSBzY2FsZTogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IFtpbnB1dCwgcG9zaXRpb25JZHMsIGNvc0NhY2hlLCBzaW5DYWNoZV0gPSBpbnB1dHM7XHJcbiAgY29uc3QgeyBudW1IZWFkcywgcm90YXJ5RW1iZWRkaW5nRGltIH0gPSBhdHRyaWJ1dGVzO1xyXG5cclxuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IDMgJiYgaW5wdXQuZGltcy5sZW5ndGggIT09IDQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3gnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMsIGdvdCAke2lucHV0LmRpbXMubGVuZ3RofWApO1xyXG4gIH1cclxuICBpZiAoXHJcbiAgICAhU2hhcGVVdGlsLmFyZUVxdWFsKHBvc2l0aW9uSWRzLmRpbXMsIFtdKSAmJlxyXG4gICAgIVNoYXBlVXRpbC5hcmVFcXVhbChwb3NpdGlvbklkcy5kaW1zLCBbMV0pICYmXHJcbiAgICBwb3NpdGlvbklkcy5kaW1zLmxlbmd0aCAhPT0gMlxyXG4gICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBpcyBleHBlY3RlZCB0byBoYXZlIDAsIDEsIG9yIDIgZGltZW5zaW9ucywgZ290ICR7cG9zaXRpb25JZHMuZGltcy5sZW5ndGh9YCk7XHJcbiAgfVxyXG4gIGlmIChjb3NDYWNoZS5kaW1zLmxlbmd0aCAhPT0gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7Y29zQ2FjaGUuZGltcy5sZW5ndGh9YCk7XHJcbiAgfVxyXG4gIGlmIChzaW5DYWNoZS5kaW1zLmxlbmd0aCAhPT0gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnc2luX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7c2luQ2FjaGUuZGltcy5sZW5ndGh9YCk7XHJcbiAgfVxyXG4gIGlmICghU2hhcGVVdGlsLmFyZUVxdWFsKGNvc0NhY2hlLmRpbXMsIHNpbkNhY2hlLmRpbXMpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dHMgJ2Nvc19jYWNoZScgYW5kICdzaW5fY2FjaGUnIGFyZSBleHBlY3RlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJvdGFyeUVtYmVkZGluZ0RpbSA+IDAgJiYgbnVtSGVhZHMgPT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignbnVtX2hlYWRzIG11c3QgYmUgcHJvdmlkZWQgaWYgcm90YXJ5X2VtYmVkZGluZ19kaW0gaXMgc3BlY2lmaWVkJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dC5kaW1zWzBdO1xyXG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDJdO1xyXG4gIGNvbnN0IG1heFNlcXVlbmNlTGVuZ3RoID0gY29zQ2FjaGUuZGltc1swXTtcclxuICBjb25zdCBoaWRkZW5TaXplID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGlucHV0LmRpbXMsIDEpIC8gc2VxdWVuY2VMZW5ndGg7XHJcbiAgY29uc3QgaGVhZFNpemUgPSByb3RhcnlFbWJlZGRpbmdEaW0gPT09IDAgPyBjb3NDYWNoZS5kaW1zWzFdICogMiA6IGhpZGRlblNpemUgLyBudW1IZWFkcztcclxuICBpZiAocm90YXJ5RW1iZWRkaW5nRGltID4gaGVhZFNpemUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigncm90YXJ5X2VtYmVkZGluZ19kaW0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGVhZF9zaXplJyk7XHJcbiAgfVxyXG5cclxuICBpZiAocG9zaXRpb25JZHMuZGltcy5sZW5ndGggPT09IDIpIHtcclxuICAgIGlmIChiYXRjaFNpemUgIT09IHBvc2l0aW9uSWRzLmRpbXNbMF0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMCBzaG91bGQgYmUgb2Ygc2l6ZSBiYXRjaF9zaXplLCBnb3QgJHtwb3NpdGlvbklkcy5kaW1zWzBdfWApO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlcXVlbmNlTGVuZ3RoICE9PSBwb3NpdGlvbklkcy5kaW1zWzFdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDEgc2hvdWxkIGJlIG9mIHNpemUgc2VxdWVuY2VfbGVuZ3RoLCBnb3QgJHtwb3NpdGlvbklkcy5kaW1zWzFdfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGhlYWRTaXplIC8gMiAhPT0gY29zQ2FjaGUuZGltc1sxXSAmJiByb3RhcnlFbWJlZGRpbmdEaW0gLyAyICE9PSBjb3NDYWNoZS5kaW1zWzFdKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBJbnB1dCAnY29zX2NhY2hlJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgc2FtZSBhcyBoZWFkX3NpemUgLyAyIG9yIHJvdGFyeV9lbWJlZGRpbmdfZGltIC8gMiwgZ290ICR7XHJcbiAgICAgICAgY29zQ2FjaGUuZGltc1sxXVxyXG4gICAgICB9YCxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBpZiAoc2VxdWVuY2VMZW5ndGggPiBtYXhTZXF1ZW5jZUxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVcGRhdGluZyBjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbiBSb3RhcnlFbWJlZGRpbmcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQnKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IHsgaW50ZXJsZWF2ZWQsIG51bUhlYWRzLCByb3RhcnlFbWJlZGRpbmdEaW0sIHNjYWxlIH0gPSBhdHRyaWJ1dGVzO1xyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0c1swXS5kaW1zWzBdO1xyXG4gIGNvbnN0IGJhdGNoU3RyaWRlID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGlucHV0c1swXS5kaW1zLCAxKTtcclxuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0c1swXS5kaW1zW2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDJdO1xyXG4gIGNvbnN0IGhpZGRlblNpemUgPSBiYXRjaFN0cmlkZSAvIHNlcXVlbmNlTGVuZ3RoO1xyXG4gIGNvbnN0IGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0gPSBpbnB1dHNbMl0uZGltc1sxXTtcclxuICBjb25zdCBoZWFkU2l6ZSA9IHJvdGFyeUVtYmVkZGluZ0RpbSA9PT0gMCA/IGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0gKiAyIDogaGlkZGVuU2l6ZSAvIG51bUhlYWRzO1xyXG5cclxuICAvLyBSb3RhcnkgZW1iZWRkaW5ncyB3aWxsIGJlIGNhbGN1bGF0ZWQgaW4gYSBwYWlyLXdpc2UgZmFzaGlvbi4gSW4gYWNjb3JkYW5jZSwgdXNlIHRoZSBzaGFwZVxyXG4gIC8vIFtiYXRjaCBzaXplLCBzZXF1ZW5jZSBsZW5ndGgsIG51bSBvZiBoZWFkcywgbnVtIG9mIHBhaXJzIHRvIHJvdGF0ZSArIG51bSBvZiBkaW1zIHRvIGNvcHldXHJcbiAgLy8gdG8gdW5mb2xkIHRoZSBnbG9iYWwgaW5kZXggaW4gc2hhZGVyLlxyXG4gIGNvbnN0IGdsb2JhbFNoYXBlID0gbmV3IEFycmF5PG51bWJlcj4oXHJcbiAgICBiYXRjaFNpemUsXHJcbiAgICBzZXF1ZW5jZUxlbmd0aCxcclxuICAgIGhpZGRlblNpemUgLyBoZWFkU2l6ZSxcclxuICAgIGhlYWRTaXplIC0gaGFsZlJvdGFyeUVtYmVkZGluZ0RpbSxcclxuICApO1xyXG4gIGNvbnN0IGdsb2JhbFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZ2xvYmFsU2hhcGUpO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBzY2FsZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGdsb2JhbFNoYXBlIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZ2xvYmFsU3RyaWRlcyB9LFxyXG5cclxuICAgIC8vIHN0cmlkZXMgZm9yIGFkZHJlc3NpbmcgdGhlIGlucHV0L291dHB1dCB0ZW5zb3IsIGluIHBlcm11dGF0ZWQgb3JkZXIgdG8gYWxpZ24gd2l0aCB0aGUgdW5mb2xkZWQgZ2xvYmFsIGluZGV4LFxyXG4gICAgLy8gaS5lLiBCU05IXHJcbiAgICAuLi4oaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzXHJcbiAgICAgID8gbmV3IEFycmF5PFByb2dyYW1Vbmlmb3JtPih7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogW2JhdGNoU3RyaWRlLCBoaWRkZW5TaXplLCBoZWFkU2l6ZSwgMV0gfSlcclxuICAgICAgOiBbXSksXHJcbiAgICAuLi4oaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA0XHJcbiAgICAgID8gbmV3IEFycmF5PFByb2dyYW1Vbmlmb3JtPih7XHJcbiAgICAgICAgICB0eXBlOiBEYXRhVHlwZS51aW50MzIsXHJcbiAgICAgICAgICBkYXRhOiBbYmF0Y2hTdHJpZGUsIGhlYWRTaXplLCBzZXF1ZW5jZUxlbmd0aCAqIGhlYWRTaXplLCAxXSxcclxuICAgICAgICB9KVxyXG4gICAgICA6IFtdKSxcclxuXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMsIGlucHV0c1syXS5kaW1zLCBpbnB1dHNbM10uZGltcywgaW5wdXRzWzBdLmRpbXMpLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IHBvc2l0aW9uSWRzID0gaW5wdXRWYXJpYWJsZSgncG9zaXRpb25faWRzJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgpO1xyXG4gICAgY29uc3QgY29zQ2FjaGUgPSBpbnB1dFZhcmlhYmxlKCdjb3NfY2FjaGUnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBzaW5DYWNoZSA9IGlucHV0VmFyaWFibGUoJ3Npbl9jYWNoZScsIGlucHV0c1szXS5kYXRhVHlwZSwgaW5wdXRzWzNdLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XHJcblxyXG4gICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXMoW1xyXG4gICAgICB7IG5hbWU6ICdzY2FsZScsIHR5cGU6ICdmMzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2dsb2JhbF9zaGFwZScsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGdsb2JhbFNoYXBlLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdnbG9iYWxfc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGdsb2JhbFN0cmlkZXMubGVuZ3RoIH0sXHJcbiAgICAgIHsgbmFtZTogJ2lucHV0X291dHB1dF9zdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZ2xvYmFsU3RyaWRlcy5sZW5ndGggfSxcclxuICAgIF0pO1xyXG5cclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgcG9zaXRpb25JZHMsIGNvc0NhY2hlLCBzaW5DYWNoZSwgb3V0cHV0KX1cclxuXHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFdPUktHUk9VUF9TSVpFKX1cclxuICAgICAgICAgIGxldCBoYWxmX3JvdGFyeV9lbWJfZGltID0gdW5pZm9ybXMuJHtjb3NDYWNoZS5uYW1lfV9zaGFwZVsxXTtcclxuICAgICAgICAgIGxldCBic25oID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzICUgdW5pZm9ybXMuZ2xvYmFsX3NoYXBlO1xyXG4gICAgICAgICAgbGV0IHNpemUgPSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGVbMF0gKiB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlc1swXTtcclxuICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3NpemUnKX1cclxuXHJcbiAgICAgICAgICBpZiAoYnNuaFszXSA8IGhhbGZfcm90YXJ5X2VtYl9kaW0pIHtcclxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkc19pZHggPVxyXG4gICAgICAgICAgICAgICAgJHtwb3NpdGlvbklkcy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnYnNuaC54eScsIG91dHB1dFZhcmlhYmxlKCcnLCBwb3NpdGlvbklkcy50eXBlLnRlbnNvciwgMikpfTtcclxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkID1cclxuICAgICAgICAgICAgICAgIHUzMigke3Bvc2l0aW9uSWRzLmdldEJ5T2Zmc2V0KCdwb3NpdGlvbl9pZHNfaWR4Jyl9KSArIHNlbGVjdCgwLCBic25oWzFdLCBwb3NpdGlvbl9pZHNfaWR4ID09IDApO1xyXG4gICAgICAgICAgICBsZXQgaSA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBzZWxlY3QoMCwgYnNuaFszXSwgJHtpbnRlcmxlYXZlZH0pO1xyXG4gICAgICAgICAgICBsZXQgaiA9IGkgKyBzZWxlY3QoaGFsZl9yb3RhcnlfZW1iX2RpbSwgMSwgJHtpbnRlcmxlYXZlZH0pO1xyXG4gICAgICAgICAgICBsZXQgcmUgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdpJyl9ICogJHtjb3NDYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX0gLVxyXG4gICAgICAgICAgICAgICAgJHtpbnB1dC5nZXRCeU9mZnNldCgnaicpfSAqICR7c2luQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9O1xyXG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnaScsICdyZScpfVxyXG4gICAgICAgICAgICBsZXQgaW0gPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdpJyl9ICogJHtzaW5DYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX0gK1xyXG4gICAgICAgICAgICAgICAgJHtpbnB1dC5nZXRCeU9mZnNldCgnaicpfSAqICR7Y29zQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9O1xyXG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnaicsICdpbScpfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGsgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgaGFsZl9yb3RhcnlfZW1iX2RpbTtcclxuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2snLCBpbnB1dC5nZXRCeU9mZnNldCgnaycpKX1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9YDtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ1JvdGFyeUVtYmVkZGluZycsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xyXG4gICAgICAgIGludGVybGVhdmVkLFxyXG4gICAgICB9KS5jYWNoZUtleSxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJywgJ3JhbmsnLCAncmFuayddLFxyXG4gICAgfSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShnbG9iYWxTaGFwZSkgLyBXT1JLR1JPVVBfU0laRSkgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByb3RhcnlFbWJlZGRpbmcgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJvdGFyeUVtYmVkZGluZ1Byb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBhcHBseUF0dGVudGlvbiwgQXR0ZW50aW9uTWFza1R5cGUsIEF0dGVudGlvblBhcmFtZXRlcnMsIEF0dGVudGlvblFrdkZvcm1hdCB9IGZyb20gJy4vYXR0ZW50aW9uJztcclxuaW1wb3J0IHsgbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzIH0gZnJvbSAnLi9tdWx0aWhlYWQtYXR0ZW50aW9uJztcclxuaW1wb3J0IHsgY3JlYXRlU3BsaXRQcm9ncmFtSW5mbywgU3BsaXRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9zcGxpdCc7XHJcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xyXG5pbXBvcnQgeyBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzLCBjcmVhdGVSb3RhcnlFbWJlZGRpbmdQcm9ncmFtSW5mbyB9IGZyb20gJy4vcm90YXJ5LWVtYmVkZGluZyc7XHJcbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xyXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwUXVlcnlBdHRlbnRpb25BdHRyaWJ1dGVzIHtcclxuICBudW1IZWFkczogbnVtYmVyO1xyXG4gIGt2TnVtSGVhZHM6IG51bWJlcjtcclxuICBzY2FsZTogbnVtYmVyO1xyXG4gIHNvZnRjYXA6IG51bWJlcjtcclxuICBkb1JvdGFyeTogbnVtYmVyO1xyXG4gIHJvdGFyeUludGVybGVhdmVkOiBudW1iZXI7XHJcbiAgc21vb3RoU29mdG1heDogYm9vbGVhbjtcclxuICBsb2NhbFdpbmRvd1NpemU6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IEdyb3VwUXVlcnlBdHRlbnRpb25BdHRyaWJ1dGVzLFxyXG4pOiBBdHRlbnRpb25QYXJhbWV0ZXJzID0+IHtcclxuICBpZiAoYXR0cmlidXRlcy5kb1JvdGFyeSAmJiBpbnB1dHMubGVuZ3RoIDw9IDcpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW5wdXRzIGFyZSByZXF1aXJlZCBpZiBkb19yb3RhcnkgaXMgc3BlY2lmaWVkJyk7XHJcbiAgfVxyXG4gIGNvbnN0IHF1ZXJ5ID0gaW5wdXRzWzBdO1xyXG4gIGNvbnN0IGtleSA9IGlucHV0c1sxXTtcclxuICBjb25zdCB2YWx1ZSA9IGlucHV0c1syXTtcclxuICBjb25zdCBwYXN0S2V5ID0gaW5wdXRzWzNdO1xyXG4gIGNvbnN0IHBhc3RWYWx1ZSA9IGlucHV0c1s0XTtcclxuICBpZiAoYXR0cmlidXRlcy5kb1JvdGFyeSAhPT0gMCAmJiBpbnB1dHMubGVuZ3RoIDw9IDcpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignY29zX2Nhc3QgYW5kIHNpbl9jYWNoZSBhcmUgZXhwZWN0ZWQgaWYgZG9fcm90YXJ5IGF0dHJpYnV0ZSBpcyBub24temVybycpO1xyXG4gIH1cclxuICBpZiAoYXR0cmlidXRlcy5sb2NhbFdpbmRvd1NpemUgIT09IC0xKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsIGF0dGVudGlvbiBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgfVxyXG4gIGlmIChhdHRyaWJ1dGVzLnNvZnRjYXAgIT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU29mdGNhcCBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgfVxyXG4gIGlmIChhdHRyaWJ1dGVzLnJvdGFyeUludGVybGVhdmVkICE9PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdGFyeSBpbnRlcmxlYXZlZCBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgfVxyXG4gIGlmIChhdHRyaWJ1dGVzLnNtb290aFNvZnRtYXgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU21vb3RoIHNvZnRtYXggaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuICAvLyBBYmJyZXZpYXRpb24gYW5kIE1lYW5pbmdzOlxyXG4gIC8vICAgQjogICAgYmF0Y2hfc2l6ZVxyXG4gIC8vICAgUzogICAgc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2YgcXVlcnkpXHJcbiAgLy8gICBQOiAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCAocGFzdCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxyXG4gIC8vICAgTDogICAga3Zfc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxyXG4gIC8vICAgTTogICAgbWF4X3NlcXVlbmNlX2xlbmd0aFxyXG4gIC8vICAgVDogICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBrdl9zZXF1ZW5jZV9sZW5ndGhcclxuICAvLyAgIE46ICAgIG51bV9oZWFkc1xyXG4gIC8vICAgSDogICAgaGVhZCBzaXplIGZvciBRIGFuZCBLLCBha2EgcV9oZWFkX3NpemUgb3Iga19oZWFkX3NpemUgb3IgcWtfaGVhZF9zaXplXHJcbiAgLy8gICBIX3Y6ICB2X2hlYWRfc2l6ZVxyXG4gIC8vICAgRF9pOiAgaW5wdXQgaGlkZGVuIHNpemVcclxuICAvLyAgIEQ6ICAgIGhpZGRlbiBzaXplIGZvciBRIGFuZCBLIChEID0gTiAqIEgpLCBha2EgcV9oaWRkZW5fc2l6ZSBvciBrX2hpZGRlbl9zaXplIG9yIHFrX2hpZGRlbl9zaXplXHJcbiAgLy8gICBEX3Y6ICB2X2hpZGRlbl9zaXplID0gbnVtX2hlYWRzICogdl9oZWFkX3NpemVcclxuXHJcbiAgLy8gICAgIHBhc3Rfa2V5ICAgICAgICAgICAgICAgICAgIDogKEIsIE4sIFMqLCBIKVxyXG4gIC8vICAgICBwYXN0X3ZhbHVlICAgICAgICAgICAgICAgICA6IChCLCBOLCBTKiwgSClcclxuICAvLyBXaGVuIG5vIHBhY2tpbmcgZm9yIHEvay92OlxyXG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxyXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBEKSBvciAoQiwgTiwgUyosIEgpXHJcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogKEIsIEwsIERfdikgb3IgKEIsIE4sIFMqLCBIKVxyXG4gIC8vIFdoZW4gcGFja2VkIGt2IGlzIHVzZWQ6XHJcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXHJcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIE4sIDIsIEgpXHJcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogTm9uZVxyXG4gIC8vIFdoZW4gcGFja2VkIHFrdiBpcyB1c2VkOlxyXG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBMLCBOLCAzLCBIKSBvciAoQiwgUywgMypEKVxyXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IE5vbmVcclxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiBOb25lXHJcblxyXG4gIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkbW1oYVBhY2tpbmcgPSBmYWxzZTtcclxuICBjb25zdCBiYXRjaFNpemUgPSBxdWVyeS5kaW1zWzBdO1xyXG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gcXVlcnkuZGltc1sxXTtcclxuICBsZXQgaGlkZGVuU2l6ZSA9XHJcbiAgICBxdWVyeS5kaW1zLmxlbmd0aCA9PT0gMyA/IChkbW1oYVBhY2tpbmcgPyBxdWVyeS5kaW1zWzJdIC8gMyA6IHF1ZXJ5LmRpbXNbMl0pIDogYXR0cmlidXRlcy5udW1IZWFkcyAqIHF1ZXJ5LmRpbXNbNF07XHJcbiAgbGV0IGt2U2VxdWVuY2VMZW5ndGggPSBzZXF1ZW5jZUxlbmd0aDtcclxuXHJcbiAgbGV0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IDA7XHJcbiAgY29uc3QgcGFja2VkUUtWID0gIWtleSB8fCBrZXkuZGltcy5sZW5ndGggPT09IDA7XHJcbiAgY29uc3QgaGVhZFNpemUgPSAhcGFja2VkUUtWXHJcbiAgICA/IE1hdGguZmxvb3IoaGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpXHJcbiAgICA6IE1hdGguZmxvb3IoaGlkZGVuU2l6ZSAvIChhdHRyaWJ1dGVzLm51bUhlYWRzICsgMiAqIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcykpO1xyXG4gIGlmIChwYWNrZWRRS1YpIHtcclxuICAgIGhpZGRlblNpemUgPSBoZWFkU2l6ZSAqIGF0dHJpYnV0ZXMubnVtSGVhZHM7XHJcbiAgfVxyXG4gIGNvbnN0IGhhc1Bhc3RLZXkgPSBwYXN0S2V5ICYmIHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDA7XHJcbiAgY29uc3QgaGFzUGFzdFZhbHVlID0gcGFzdFZhbHVlICYmIHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gMDtcclxuICAvLyBDdXJyZW50bHkgdGhlIG9ubnhydW50aW1lIEdRQSBzcGVjaWZpY2F0aW9uIG9ubHkgc3VwcG9ydCBrZXkvdmFsdWUgQk5TSCBmb3JtYXQuXHJcbiAgY29uc3QgaXNQYXN0a3ZCU05IID1cclxuICAgIGhhc1Bhc3RLZXkgJiZcclxuICAgIHBhc3RLZXkuZGltcy5sZW5ndGggPT09IDQgJiZcclxuICAgIHBhc3RLZXkuZGltc1swXSA9PT0gYmF0Y2hTaXplICYmXHJcbiAgICBwYXN0S2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyAmJlxyXG4gICAgcGFzdEtleS5kaW1zWzJdID09PSBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMgJiZcclxuICAgIHBhc3RLZXkuZGltc1szXSA9PT0gaGVhZFNpemU7XHJcblxyXG4gIGlmIChpc1Bhc3RrdkJTTkgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQlNOSCBwYXN0S2V5L3Bhc3RWYWx1ZSBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgfVxyXG4gIGlmIChoYXNQYXN0S2V5ICYmIGhhc1Bhc3RWYWx1ZSkge1xyXG4gICAgaWYgKHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuICAgIGlmIChwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xyXG4gIH0gZWxzZSBpZiAoaGFzUGFzdEtleSB8fCBoYXNQYXN0VmFsdWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtcclxuICB9XHJcblxyXG4gIGxldCBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCTlNIO1xyXG4gIGlmIChrZXkgJiYga2V5LmRpbXMubGVuZ3RoID4gMCkge1xyXG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoIDwgMyB8fCBrZXkuZGltcy5sZW5ndGggPiA1KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IGtleS5kaW1zWzBdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgIGlmIChxdWVyeS5kaW1zWzJdICUga2V5LmRpbXNbMl0gIT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiAyIG9mIFwicXVlcnlcIiBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiBcImtleVwiJyk7XHJcbiAgICAgIH1cclxuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xyXG4gICAgfSBlbHNlIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDUpIHtcclxuICAgICAgaWYgKGtleS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSAyIHx8IGtleS5kaW1zWzRdICE9PSBoZWFkU2l6ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7XHJcbiAgICAgIH1cclxuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8ga2V5X2RpbXMuc2l6ZSgpID09IDQgKGNyb3NzLWF0dGVudGlvbiB3aXRoIHBhc3Rfa2V5KVxyXG4gICAgICBpZiAoa2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwga2V5LmRpbXNbM10gIT09IGhlYWRTaXplKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7XHJcbiAgICAgIH1cclxuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzJdO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBwYWNrZWQgUUtWXHJcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO1xyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoID09PSA1ICYmIChxdWVyeS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHF1ZXJ5LmRpbXNbM10gIT09IDMpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xyXG4gICAgfVxyXG5cclxuICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU04zSDtcclxuICB9XHJcblxyXG4gIGNvbnN0IG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XHJcbiAgbGV0IHBhc3NQYXN0SW5LdiA9IGZhbHNlO1xyXG4gIGxldCB2SGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyA/IGhlYWRTaXplICogYXR0cmlidXRlcy5rdk51bUhlYWRzIDogaGlkZGVuU2l6ZTtcclxuICBpZiAodmFsdWUgJiYgdmFsdWUuZGltcy5sZW5ndGggPiAwKSB7XHJcbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggIT09IDMgJiYgdmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSB2YWx1ZS5kaW1zWzBdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1sxXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcclxuICAgICAgfVxyXG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1syXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XHJcbiAgICAgIH1cclxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzFdICogdmFsdWUuZGltc1szXTtcclxuICAgICAgcGFzc1Bhc3RJbkt2ID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3Qgc2VxbExlbnMgPSBpbnB1dHMubGVuZ3RoID4gNCA/IGlucHV0c1s1XSA6IHVuZGVmaW5lZDtcclxuICBpZiAoc2VxbExlbnMgJiYgc2VxbExlbnMuZGltcy5sZW5ndGggIT09IDEgJiYgc2VxbExlbnMuZGltc1swXSAhPT0gYmF0Y2hTaXplKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwic2VxbGVuc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24gYW5kIHRoZSBzYW1lIGRpbSAwIGFzIGJhdGNoX3NpemUnKTtcclxuICB9XHJcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IC0xO1xyXG4gIGNvbnN0IG1heFNlcXVlbmNlTGVuZ3RoID0gLTE7XHJcbiAgY29uc3QgYnJvYWRjYXN0UmVzUG9zQmlhcyA9IGZhbHNlO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYmF0Y2hTaXplLFxyXG4gICAgc2VxdWVuY2VMZW5ndGgsXHJcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXHJcbiAgICBrdlNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcclxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgaW5wdXRIaWRkZW5TaXplOiAwLFxyXG4gICAgaGlkZGVuU2l6ZSxcclxuICAgIHZIaWRkZW5TaXplLFxyXG4gICAgaGVhZFNpemUsXHJcbiAgICB2SGVhZFNpemU6IE1hdGguZmxvb3IodkhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMpLFxyXG4gICAgbnVtSGVhZHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMsXHJcbiAgICBrdk51bUhlYWRzOiBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMsXHJcbiAgICBuUmVwczogYXR0cmlidXRlcy5udW1IZWFkcyAvIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyxcclxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxyXG4gICAgbWFza1R5cGUsXHJcbiAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcclxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXMsXHJcbiAgICBwYXNzUGFzdEluS3YsXHJcbiAgICBxa3ZGb3JtYXQsXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZTogVHJhbnNwb3NlQXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHBlcm06IFswLCAyLCAxLCAzXSB9KTtcclxuXHJcbmNvbnN0IG1heWJlVHJhbnNwb3NlVG9CTlNIID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dDogVGVuc29yVmlldywgcGFyYW1zOiBBdHRlbnRpb25QYXJhbWV0ZXJzKSA9PiB7XHJcbiAgbGV0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dDtcclxuICBjb25zdCBudW1IZWFkcyA9IHBhcmFtcy5rdk51bUhlYWRzITtcclxuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggPT09IDMgJiYgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGggIT09IDApIHtcclxuICAgIHJlc2hhcGVkSW5wdXQgPSBpbnB1dC5yZXNoYXBlKFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIHBhcmFtcy5oZWFkU2l6ZV0pO1xyXG4gICAgcmVzaGFwZWRJbnB1dCA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXNoYXBlZElucHV0LCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUucGVybSksIHtcclxuICAgICAgaW5wdXRzOiBbcmVzaGFwZWRJbnB1dF0sXHJcbiAgICAgIG91dHB1dHM6IFstMV0sXHJcbiAgICB9KVswXTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXNoYXBlZElucHV0O1xyXG59O1xyXG5cclxuY29uc3QgZ2VuZXJhdGVQb3NpdGlvbklkc1Byb2dyYW1JbmZvID0gKFxyXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxyXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXHJcbiAgc2VxTGVuczogVGVuc29yVmlldyxcclxuICB0b3RhbFNlcUxlbjogVGVuc29yVmlldyxcclxuKSA9PiB7XHJcbiAgY29uc3Qgb3V0cHV0RGF0YVR5cGUgPSBEYXRhVHlwZS5pbnQ2NDtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplICogc2VxdWVuY2VMZW5ndGhdO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBiYXRjaFNpemUgKiBzZXF1ZW5jZUxlbmd0aDtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNlcXVlbmNlTGVuZ3RoIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmF0Y2hTaXplIH0sXHJcbiAgXTtcclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IHNlcUxlbnNJbnB1dEhlbHBlciA9IGlucHV0VmFyaWFibGUoJ3NlcV9sZW5zJywgc2VxTGVucy5kYXRhVHlwZSwgc2VxTGVucy5kaW1zKTtcclxuICAgIGNvbnN0IHRvdGFsU2VxTGVuSW5wdXRIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCd0b3RhbF9zZXFfbGVucycsIHRvdGFsU2VxTGVuLmRhdGFUeXBlLCB0b3RhbFNlcUxlbi5kaW1zKTtcclxuICAgIGNvbnN0IHBvc2l0aW9uSWRzSGVscGVyID0gb3V0cHV0VmFyaWFibGUoJ3Bvc19pZHMnLCBvdXRwdXREYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xyXG5cclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdzZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdiYXRjaF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHNlcUxlbnNJbnB1dEhlbHBlciwgdG90YWxTZXFMZW5JbnB1dEhlbHBlciwgcG9zaXRpb25JZHNIZWxwZXIpfVxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHt0b3RhbFNlcUxlbklucHV0SGVscGVyLmdldEJ5T2Zmc2V0KCcwJyl9KTtcclxuICAgIGxldCBpc19zdWJzZXF1ZW50X3Byb21wdCA9IHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCA+IDEgJiYgdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoICE9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcclxuICAgIGxldCBpc19maXJzdF9wcm9tcHQgPSAhaXNfc3Vic2VxdWVudF9wcm9tcHQgJiYgdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoID09IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcclxuICAgIGxldCBiYXRjaF9pZHggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoO1xyXG4gICAgbGV0IHNlcXVlbmNlX2lkeCA9IGkzMihnbG9iYWxfaWR4ICUgdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoKTtcclxuICAgIHZhciBwb3NfaWQ6IGkzMiA9IDA7XHJcbiAgICBsZXQgc2VxbGVuID0gJHtzZXFMZW5zSW5wdXRIZWxwZXIuZ2V0QnlPZmZzZXQoJ2JhdGNoX2lkeCcpfTtcclxuICAgIGxldCB0b3RhbF9zZXFsZW4gPSBzZXFsZW4gKyAxO1xyXG4gICAgaWYgKGlzX2ZpcnN0X3Byb21wdCkge1xyXG4gICAgICBpZiAoc2VxdWVuY2VfaWR4IDwgdG90YWxfc2VxbGVuKSB7XHJcbiAgICAgICAgcG9zX2lkID0gc2VxdWVuY2VfaWR4O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBvc19pZCA9IDE7XHJcbiAgICAgIH1cclxuICAgICAgJHtwb3NpdGlvbklkc0hlbHBlci5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdwb3NfaWQnKX1cclxuICAgIH0gZWxzZSBpZiAoaXNfc3Vic2VxdWVudF9wcm9tcHQpIHtcclxuICAgICAgbGV0IHBhc3Rfc2VxbGVuID0gdG90YWxfc2VxbGVuIC0gaTMyKHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCk7XHJcbiAgICAgIGlmIChwYXN0X3NlcWxlbiArIHNlcXVlbmNlX2lkeCA8IHRvdGFsX3NlcWxlbikge1xyXG4gICAgICAgIHBvc19pZCA9IHBhc3Rfc2VxbGVuICsgc2VxdWVuY2VfaWR4O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBvc19pZCA9IDE7XHJcbiAgICAgIH1cclxuICAgICAgJHtwb3NpdGlvbklkc0hlbHBlci5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdwb3NfaWQnKX1cclxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsX2lkeCA8IHVuaWZvcm1zLmJhdGNoX3NpemUpIHtcclxuICAgICAgJHtwb3NpdGlvbklkc0hlbHBlci5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdzZXFsZW4nKX1cclxuICAgIH07XHJcbiAgfVxyXG4gIGA7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0dlbmVyYXRlUG9zaXRpb25JZHMnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YmF0Y2hTaXplfTske3NlcXVlbmNlTGVuZ3RofWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ3JvdXBRdWVyeUF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR3JvdXBRdWVyeUF0dGVudGlvbkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBjb25zdCBwYXJhbXMgPSB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA1KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoY29udGV4dC5pbnB1dHNbMV0/LmRpbXMubGVuZ3RoID09PSA1KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHEgPSBjb250ZXh0LmlucHV0c1swXTtcclxuICBjb25zdCBrID0gY29udGV4dC5pbnB1dHNbMV0gJiYgY29udGV4dC5pbnB1dHNbMV0uZGltcy5sZW5ndGggPiAwID8gY29udGV4dC5pbnB1dHNbMV0gOiB1bmRlZmluZWQ7XHJcbiAgY29uc3QgdiA9IGNvbnRleHQuaW5wdXRzWzJdICYmIGNvbnRleHQuaW5wdXRzWzJdLmRpbXMubGVuZ3RoID4gMCA/IGNvbnRleHQuaW5wdXRzWzJdIDogdW5kZWZpbmVkO1xyXG4gIGNvbnN0IHBhc3RLZXkgPSBjb250ZXh0LmlucHV0c1szXSAmJiBjb250ZXh0LmlucHV0c1szXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGNvbnRleHQuaW5wdXRzWzNdIDogdW5kZWZpbmVkO1xyXG4gIGNvbnN0IHBhc3RWYWx1ZSA9IGNvbnRleHQuaW5wdXRzWzRdICYmIGNvbnRleHQuaW5wdXRzWzRdLmRpbXMubGVuZ3RoICE9PSAwID8gY29udGV4dC5pbnB1dHNbNF0gOiB1bmRlZmluZWQ7XHJcbiAgY29uc3Qgc2VxTGVucyA9IGNvbnRleHQuaW5wdXRzLmxlbmd0aCA+IDQgPyBjb250ZXh0LmlucHV0c1s1XSA6IHVuZGVmaW5lZDtcclxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQgPSBjb250ZXh0LmlucHV0cy5sZW5ndGggPiA1ID8gY29udGV4dC5pbnB1dHNbNl0gOiB1bmRlZmluZWQ7XHJcbiAgY29uc3Qga3ZOdW1IZWFkcyA9IHBhcmFtcy5rdk51bUhlYWRzID8gcGFyYW1zLmt2TnVtSGVhZHMgOiBwYXJhbXMubnVtSGVhZHM7XHJcblxyXG4gIC8vIFRPRE8gUmVtb3ZlIGV4cGxpY2l0IHNwbGl0IG9wZXJhdGlvbiBhbmQgdXNlIGluZGV4aW5nIGluIEF0dGVudGlvbiBpbXBsZW1lbnRhdGlvbiB0byBhdm9pZCBvdmVyaGVhZC5cclxuXHJcbiAgY29uc3Qgc3BsaXRBdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xyXG4gICAgYXhpczogMixcclxuICAgIG51bU91dHB1dHM6IDMsXHJcbiAgICBzcGxpdFNpemVzOiBbcGFyYW1zLm51bUhlYWRzICogcGFyYW1zLmhlYWRTaXplLCBrdk51bUhlYWRzICogcGFyYW1zLmhlYWRTaXplLCBrdk51bUhlYWRzICogcGFyYW1zLmhlYWRTaXplXSxcclxuICB9KTtcclxuICBjb25zdCBbcXVlcnksIGtleSwgdmFsdWVdID1cclxuICAgICFrICYmICF2XHJcbiAgICAgID8gY29udGV4dC5jb21wdXRlKGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8oW3FdLCBzcGxpdEF0dHJpYnV0ZXMpLCB7IGlucHV0czogW3FdLCBvdXRwdXRzOiBbLTEsIC0xLCAtMV0gfSlcclxuICAgICAgOiBbcSwgayEsIHYhXTtcclxuICBsZXQgcVJvdGFyeTogVGVuc29yVmlldyB8IHVuZGVmaW5lZDtcclxuICBsZXQga1JvdGFyeTogVGVuc29yVmlldyB8IHVuZGVmaW5lZDtcclxuICBpZiAoYXR0cmlidXRlcy5kb1JvdGFyeSkge1xyXG4gICAgY29uc3QgcG9zSWRzID0gY29udGV4dC5jb21wdXRlKFxyXG4gICAgICBnZW5lcmF0ZVBvc2l0aW9uSWRzUHJvZ3JhbUluZm8ocGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLnNlcXVlbmNlTGVuZ3RoLCBzZXFMZW5zISwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0ISksXHJcbiAgICAgIHsgaW5wdXRzOiBbc2VxTGVucyEsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCFdLCBvdXRwdXRzOiBbLTFdIH0sXHJcbiAgICApWzBdO1xyXG4gICAgY29uc3QgY29zQ2FjaGUgPSBjb250ZXh0LmlucHV0c1s3XTtcclxuICAgIGNvbnN0IHNpbkNhY2hlID0gY29udGV4dC5pbnB1dHNbOF07XHJcbiAgICBjb25zdCBxUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XHJcbiAgICAgIGludGVybGVhdmVkOiBhdHRyaWJ1dGVzLnJvdGFyeUludGVybGVhdmVkICE9PSAwLFxyXG4gICAgICBudW1IZWFkczogcGFyYW1zLm51bUhlYWRzLFxyXG4gICAgICByb3RhcnlFbWJlZGRpbmdEaW06IDAsXHJcbiAgICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBpbnB1dHMgPSBbcXVlcnksIHBvc0lkcywgY29zQ2FjaGUsIHNpbkNhY2hlXTtcclxuICAgIGNvbnN0IG91dHB1dHMgPSBbLTFdO1xyXG4gICAgcVJvdGFyeSA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVSb3RhcnlFbWJlZGRpbmdQcm9ncmFtSW5mbyhpbnB1dHMsIHFSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzKSwge1xyXG4gICAgICBpbnB1dHMsXHJcbiAgICAgIG91dHB1dHMsXHJcbiAgICB9KVswXTtcclxuICAgIGlucHV0cy5zcGxpY2UoMCwgMSwga2V5KTtcclxuICAgIGNvbnN0IGtSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzOiBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcclxuICAgICAgaW50ZXJsZWF2ZWQ6IGF0dHJpYnV0ZXMucm90YXJ5SW50ZXJsZWF2ZWQgIT09IDAsXHJcbiAgICAgIG51bUhlYWRzOiBwYXJhbXMua3ZOdW1IZWFkcyEsXHJcbiAgICAgIHJvdGFyeUVtYmVkZGluZ0RpbTogMCxcclxuICAgICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXHJcbiAgICB9KTtcclxuICAgIGtSb3RhcnkgPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8oaW5wdXRzLCBrUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyksIHtcclxuICAgICAgaW5wdXRzLFxyXG4gICAgICBvdXRwdXRzLFxyXG4gICAgfSlbMF07XHJcbiAgfVxyXG4gIGNvbnN0IFEgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgcGFyYW1zLmJhdGNoU2l6ZSxcclxuICAgIHBhcmFtcy5udW1IZWFkcyxcclxuICAgIHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCxcclxuICAgIHBhcmFtcy5oZWFkU2l6ZSxcclxuICAgIGF0dHJpYnV0ZXMuZG9Sb3RhcnkgPyBxUm90YXJ5ISA6IHF1ZXJ5LFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgMCxcclxuICApO1xyXG4gIGNvbnN0IEsgPSBtYXliZVRyYW5zcG9zZVRvQk5TSChjb250ZXh0LCBhdHRyaWJ1dGVzLmRvUm90YXJ5ID8ga1JvdGFyeSEgOiBrZXksIHBhcmFtcyk7XHJcbiAgY29uc3QgViA9IG1heWJlVHJhbnNwb3NlVG9CTlNIKGNvbnRleHQsIHZhbHVlLCBwYXJhbXMpO1xyXG5cclxuICBhcHBseUF0dGVudGlvbihcclxuICAgIGNvbnRleHQsXHJcbiAgICBRLFxyXG4gICAgSyxcclxuICAgIFYsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICBwYXN0S2V5LFxyXG4gICAgcGFzdFZhbHVlLFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgcGFyYW1zLFxyXG4gICAgc2VxTGVucyxcclxuICAgIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCxcclxuICApO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIGdldE1heENvbXBvbmVudHMsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgc3VtVmVjdG9yLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMge1xyXG4gIGVwc2lsb246IG51bWJlcjtcclxuICBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcclxufVxyXG5cclxuY29uc3QgY29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0ID0gKFxyXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxyXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxyXG4gIHNjYWxlOiBUZW5zb3JWaWV3LFxyXG4gIGJpYXM6IFRlbnNvclZpZXcsXHJcbiAgbjogbnVtYmVyLFxyXG4gIGg6IG51bWJlcixcclxuICBjOiBudW1iZXIsXHJcbiAgZXBzaWxvbjogbnVtYmVyLFxyXG4pID0+IHtcclxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhoKTtcclxuICBjb25zdCBmMzJUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICdmMzInIDogYHZlYyR7Y29tcG9uZW50c31mYDtcclxuICBjb25zdCB3Z1R5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ3ZlYzJmJyA6IGBtYXQyeCR7Y29tcG9uZW50c31mYDtcclxuICBjb25zdCB1bml0c09mV29yayA9IG4gKiBjO1xyXG4gIGxldCB3b3JrZ3JvdXBTaXplID0gNjQ7XHJcbiAgaWYgKHVuaXRzT2ZXb3JrID09PSAxKSB7XHJcbiAgICB3b3JrZ3JvdXBTaXplID0gMjU2O1xyXG4gIH1cclxuICBjb25zdCBpbnB1dFNoYXBlID0gW24sIGMsIGggLyBjb21wb25lbnRzXTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtuLCBjLCAyXTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICd0eXBlJywgJ3R5cGUnXTtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSkpO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIDMsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgc2NhbGUuZGF0YVR5cGUsIHNjYWxlLmRpbXMpO1xyXG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBiaWFzLmRpbXMpO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCAzLCAyKTtcclxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFt4LCBzLCBiLCBvdXRwdXRdO1xyXG4gICAgcmV0dXJuIGBcclxuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkIDogYXJyYXk8JHt3Z1R5cGV9LCAke3dvcmtncm91cFNpemV9PjtcclxuICBjb25zdCB3b3JrZ3JvdXBfc2l6ZSA9ICR7d29ya2dyb3VwU2l6ZX11O1xyXG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQod29ya2dyb3VwU2l6ZSl9XHJcbiAgICBsZXQgYmF0Y2ggPSB3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy54X3NoYXBlWzFdO1xyXG4gICAgbGV0IGNoYW5uZWwgPSB3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy54X3NoYXBlWzFdO1xyXG4gICAgbGV0IGhpZ2h0ID0gdW5pZm9ybXMueF9zaGFwZVsyXTtcclxuICAgIC8vIGluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeVxyXG4gICAgdmFyIHN1bSA9ICR7ZjMyVHlwZX0oMCk7XHJcbiAgICB2YXIgc3F1YXJlZF9zdW0gPSAke2YzMlR5cGV9KDApO1xyXG4gICAgZm9yICh2YXIgaCA9IGxvY2FsX2lkeDsgaCA8IGhpZ2h0OyBoICs9IHdvcmtncm91cF9zaXplKSB7XHJcbiAgICAgIGxldCB2YWx1ZSA9ICR7ZjMyVHlwZX0oJHt4LmdldCgnYmF0Y2gnLCAnY2hhbm5lbCcsICdoJyl9KTtcclxuICAgICAgc3VtICs9IHZhbHVlO1xyXG4gICAgICBzcXVhcmVkX3N1bSArPSB2YWx1ZSAqIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gJHt3Z1R5cGV9KHN1bSwgc3F1YXJlZF9zdW0pO1xyXG4gICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwX3NpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XHJcbiAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyU2l6ZSkge1xyXG4gICAgICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9IHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSArIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4ICsgY3VyclNpemVdO1xyXG4gICAgICB9XHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuICAgIH1cclxuICAgIGlmIChsb2NhbF9pZHggPT0gMCkge1xyXG4gICAgICBsZXQgc3VtX2ZpbmFsID0gJHtzdW1WZWN0b3IoJ3dvcmtncm91cF9zaGFyZWRbMF1bMF0nLCBjb21wb25lbnRzKX0gLyBmMzIoaGlnaHQgKiAke2NvbXBvbmVudHN9KTtcclxuICAgICAgbGV0IHNxdWFyZWRfc3VtX2ZpbmFsID0gJHtzdW1WZWN0b3IoJ3dvcmtncm91cF9zaGFyZWRbMF1bMV0nLCBjb21wb25lbnRzKX0gLyBmMzIoaGlnaHQgKiAke2NvbXBvbmVudHN9KTtcclxuXHJcbiAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KHNxdWFyZWRfc3VtX2ZpbmFsIC0gc3VtX2ZpbmFsICogc3VtX2ZpbmFsICsgZjMyKCR7ZXBzaWxvbn0pKTtcclxuICAgICAgbGV0IGNoYW5uZWxfc2NhbGUgPSBpbnZfc3RkX2RldiAqIGYzMihzY2FsZVtjaGFubmVsXSk7XHJcbiAgICAgIGxldCBjaGFubmVsX3NoaWZ0ID0gZjMyKGJpYXNbY2hhbm5lbF0pIC0gc3VtX2ZpbmFsICogY2hhbm5lbF9zY2FsZTtcclxuICAgICAgb3V0cHV0W3dvcmtncm91cF9pbmRleF0gPSB2ZWMyZihjaGFubmVsX3NjYWxlLCBjaGFubmVsX3NoaWZ0KTtcclxuICAgIH1cclxuICB9YDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnSW5zdGFuY2VOb3JtQ29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0JyxcclxuICAgICAgLy8gVE9ETzogdXNlIGVwc2lsb24gYXMgdW5pZm9ybS4gQ3VycmVudGx5IGVwc2lsb24gYXMgdW5pZm9ybSBmYWlscyB0ZXN0X2luc3RhbmNlbm9ybV9lcHNpbG9uLlxyXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtjb21wb25lbnRzfTske2Vwc2lsb259OyR7d29ya2dyb3VwU2l6ZX1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiB1bml0c09mV29yayB9LFxyXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgICAgfSksXHJcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIH0sXHJcbiAgICB7IGlucHV0czogW2lucHV0LCBzY2FsZSwgYmlhc10sIG91dHB1dHM6IFstMV0gfSxcclxuICApWzBdO1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlSW5zdGFuY2VOb3JtUHJvZ3JhbUluZm8gPSAoXHJcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogSW5zdGFuY2VOb3JtQXR0cmlidXRlcyxcclxuKSA9PiB7XHJcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XHJcbiAgY29uc3QgYXhpcyA9IDI7XHJcbiAgY29uc3QgTiA9IHhTaGFwZVswXTtcclxuICBjb25zdCBDID0geFNoYXBlWzFdO1xyXG4gIGNvbnN0IEggPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oeFNoYXBlLCBheGlzKTtcclxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhIKTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cztcclxuICAvLyBjb21wdXRlIGNoYW5uZWwgc2NhbGUgYW5kIGNoYW5uZWwgc2hpZnQuXHJcbiAgY29uc3QgY2hhbm5lbFNjYWxlU2hpZnQgPSBjb21wdXRlQ2hhbm5lbFNjYWxlU2hpZnQoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgaW5wdXRzWzBdLFxyXG4gICAgaW5wdXRzWzFdLFxyXG4gICAgaW5wdXRzWzJdLFxyXG4gICAgTixcclxuICAgIEgsXHJcbiAgICBDLFxyXG4gICAgYXR0cmlidXRlcy5lcHNpbG9uLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBbTiwgQywgSCAvIGNvbXBvbmVudHNdO1xyXG4gIGNvbnN0IHNjYWxlU2hhcGUgPSBbTiwgQ107XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAnbm9uZSddO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBzY2FsZSA9IGlucHV0VmFyaWFibGUoJ3NjYWxlX3NoaWZ0JywgRGF0YVR5cGUuZmxvYXQsIHNjYWxlU2hhcGUubGVuZ3RoLCAyKTtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFt4LCBzY2FsZSwgb3V0cHV0XTtcclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICAgIGxldCBiYXRjaCA9IG91dHB1dEluZGljZXNbMF07XHJcbiAgICAgIGxldCBjaGFubmVsID0gb3V0cHV0SW5kaWNlc1sxXTtcclxuICAgICAgbGV0IHNjYWxlX3NoaWZ0ID0gJHtzY2FsZS5nZXRCeUluZGljZXMoJ3ZlYzI8dTMyPihiYXRjaCwgY2hhbm5lbCknKX07XHJcbiAgICAgIGxldCB2YWx1ZSA9ICR7eC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfSAqICR7b3V0cHV0LnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LngpICsgJHtvdXRwdXQudHlwZS52YWx1ZX0oc2NhbGVfc2hpZnQueSk7XHJcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xyXG4gIH1gO1xyXG4gIH07XHJcblxyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ0luc3RhbmNlTm9ybWFsaXphdGlvbicsXHJcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXHJcbiAgICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgc2NhbGVTaGFwZSwgaW5wdXRTaGFwZSksXHJcbiAgICAgICAgXSxcclxuICAgICAgfSksXHJcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIH0sXHJcbiAgICB7IGlucHV0czogW2lucHV0c1swXSwgY2hhbm5lbFNjYWxlU2hpZnRdIH0sXHJcbiAgKTtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUluc3RhbmNlTm9ybU5IV0NQcm9ncmFtSW5mbyA9IChcclxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzLFxyXG4pID0+IHtcclxuICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IHhTaGFwZTtcclxuICBjb25zdCBOID0geFNoYXBlWzBdO1xyXG4gIGNvbnN0IEMgPSB4U2hhcGVbeFNoYXBlLmxlbmd0aCAtIDFdO1xyXG4gIGNvbnN0IEggPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oeFNoYXBlLCAxKSAvIEM7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoQyk7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHM7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEggfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmZsb29yKEMgLyBjb21wb25lbnRzKSB9LFxyXG4gIF07XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xyXG5cclxuICAvLyAxLiB0cmFuc3Bvc2UgeCBmcm9tIE5IV0MgdG8gTkNIV1xyXG4gIGxldCBuZWVkVHJhbnNwb3NlID0gZmFsc2U7XHJcbiAgY29uc3QgdHJhbnNwb3NlZFhQZXJtID0gWzAsIHhTaGFwZS5sZW5ndGggLSAxXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHhTaGFwZS5sZW5ndGggLSAyOyBpKyspIHtcclxuICAgIG5lZWRUcmFuc3Bvc2UgPSBuZWVkVHJhbnNwb3NlIHx8IHhTaGFwZVtpICsgMV0gIT09IDE7XHJcbiAgICB0cmFuc3Bvc2VkWFBlcm0ucHVzaChpICsgMSk7XHJcbiAgfVxyXG5cclxuICBuZWVkVHJhbnNwb3NlID0gbmVlZFRyYW5zcG9zZSAmJiB4U2hhcGVbeFNoYXBlLmxlbmd0aCAtIDFdICE9PSAxO1xyXG5cclxuICBjb25zdCB0cmFuc3Bvc2VkWCA9IG5lZWRUcmFuc3Bvc2VcclxuICAgID8gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCB0cmFuc3Bvc2VkWFBlcm0pLCB7XHJcbiAgICAgICAgaW5wdXRzOiBbY29udGV4dC5pbnB1dHNbMF1dLFxyXG4gICAgICAgIG91dHB1dHM6IFstMV0sXHJcbiAgICAgIH0pWzBdXHJcbiAgICA6IGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoQXJyYXkuZnJvbSh7IGxlbmd0aDogeFNoYXBlLmxlbmd0aCB9LCAoXywgaSkgPT4geFNoYXBlW3RyYW5zcG9zZWRYUGVybVtpXV0pKTtcclxuICAvLyAyLiBjb21wdXRlIGNoYW5uZWwgc2NhbGUgYW5kIGNoYW5uZWwgc2hpZnQuXHJcbiAgY29uc3QgY2hhbm5lbFNjYWxlU2hpZnQgPSBjb21wdXRlQ2hhbm5lbFNjYWxlU2hpZnQoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgdHJhbnNwb3NlZFgsXHJcbiAgICBpbnB1dHNbMV0sXHJcbiAgICBpbnB1dHNbMl0sXHJcbiAgICBOLFxyXG4gICAgSCxcclxuICAgIEMsXHJcbiAgICBhdHRyaWJ1dGVzLmVwc2lsb24sXHJcbiAgKTtcclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgICBjb25zdCBzY2FsZVR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ3ZlYzJmJyA6IGBtYXQke2NvbXBvbmVudHN9eDJmYDtcclxuICAgIGNvbnN0IHNjYWxlRGF0YSA9IChudW06IG51bWJlcikgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IG51bSA9PT0gMCA/ICd4JyA6ICd5JztcclxuICAgICAgY29uc3QgZjMyVHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAnZjMyJyA6IGB2ZWMke2NvbXBvbmVudHN9ZmA7XHJcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHJldHVybiBgJHtkYXRhVHlwZX0oJHtmMzJUeXBlfShzY2FsZS4ke2luZGV4fSkpYDtcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICByZXR1cm4gYHZlYzI8JHtkYXRhVHlwZX0+KCR7ZjMyVHlwZX0oc2NhbGVbMF0uJHtpbmRleH0sIHNjYWxlWzFdLiR7aW5kZXh9KSlgO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIHJldHVybiBgdmVjNDwke2RhdGFUeXBlfT4oJHtmMzJUeXBlfShzY2FsZVswXS4ke2luZGV4fSwgc2NhbGVbMV0uJHtpbmRleH0sIHNjYWxlWzJdLiR7aW5kZXh9LCBzY2FsZVszXS4ke2luZGV4fSkpYDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIGNvbXBvZW50cyAke2NvbXBvbmVudHN9YCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBpbnB1dEhlbHBlciA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcywgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBvdXRwdXRIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cyk7XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGlucHV0IDogYXJyYXk8JHtpbnB1dEhlbHBlci50eXBlLnN0b3JhZ2V9PjtcclxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlX2lucHV0IDogYXJyYXk8JHtzY2FsZVR5cGV9PjtcclxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7b3V0cHV0SGVscGVyLnR5cGUuc3RvcmFnZX0+O1xyXG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcclxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICBsZXQgY3VycmVudF9pbWFnZV9udW1iZXIgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLkMgKiB1bmlmb3Jtcy5IKTtcclxuICAgIGxldCBjdXJyZW50X2NoYW5uZWxfbnVtYmVyID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLkM7XHJcblxyXG4gICAgbGV0IHNjYWxlX29mZnNldCA9IGN1cnJlbnRfaW1hZ2VfbnVtYmVyICogdW5pZm9ybXMuQyArIGN1cnJlbnRfY2hhbm5lbF9udW1iZXI7XHJcbiAgICBsZXQgc2NhbGUgPSBzY2FsZV9pbnB1dFtzY2FsZV9vZmZzZXRdO1xyXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZm1hKGlucHV0W2dsb2JhbF9pZHhdLCAke3NjYWxlRGF0YSgwKX0sICR7c2NhbGVEYXRhKDEpfSk7XHJcbiAgfWA7XHJcbiAgfTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1hbGl6YXRpb25OSFdDJyxcclxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICAgIH0pLFxyXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICB9LFxyXG4gICAgeyBpbnB1dHM6IFtpbnB1dHNbMF0sIGNoYW5uZWxTY2FsZVNoaWZ0XSB9LFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW5zdGFuY2VOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycpIHtcclxuICAgIGNyZWF0ZUluc3RhbmNlTm9ybU5IV0NQcm9ncmFtSW5mbyhjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNyZWF0ZUluc3RhbmNlTm9ybVByb2dyYW1JbmZvKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY2FzdFRvRjMyLFxyXG4gIGZpbGxWZWN0b3IsXHJcbiAgZ2V0TWF4Q29tcG9uZW50cyxcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICBzdW1WZWN0b3IsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmludGVyZmFjZSBMYXllck5vcm1BdHRyaWJ1dGVzIHtcclxuICBzaW1wbGlmaWVkOiBib29sZWFuO1xyXG4gIGF4aXM6IG51bWJlcjtcclxuICBlcHNpbG9uOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDIgaW5wdXRzLicpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUxheWVyTm9ybVByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IExheWVyTm9ybUF0dHJpYnV0ZXMsXHJcbiAgb3V0cHV0Q291bnQ6IG51bWJlcixcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IHNpbXBsaWZpZWQgPSBhdHRyaWJ1dGVzLnNpbXBsaWZpZWQ7XHJcblxyXG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xyXG4gIGNvbnN0IGJpYXMgPSAhc2ltcGxpZmllZCAmJiBpbnB1dHNbMl07XHJcblxyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xyXG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIHhTaGFwZS5sZW5ndGgpO1xyXG4gIGNvbnN0IG5vcm1Db3VudCA9IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oeFNoYXBlLCBheGlzKTtcclxuICBjb25zdCBub3JtU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIGF4aXMpO1xyXG5cclxuICBjb25zdCBzY2FsZVNpemUgPSBTaGFwZVV0aWwuc2l6ZShzY2FsZS5kaW1zKTtcclxuICBjb25zdCBiaWFzU2l6ZSA9IGJpYXMgPyBTaGFwZVV0aWwuc2l6ZShiaWFzLmRpbXMpIDogMDtcclxuICBpZiAoc2NhbGVTaXplICE9PSBub3JtU2l6ZSB8fCAoYmlhcyAmJiBiaWFzU2l6ZSAhPT0gbm9ybVNpemUpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke25vcm1TaXplfS5cclxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXHJcbiAgICAgICBHb3Qgc2NhbGUgc2l6ZSBvZiAke3NjYWxlU2l6ZX0gYW5kIGJpYXMgc2l6ZSBvZiAke2JpYXNTaXplfWApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbWVhbkludlN0ZERldkRpbTogbnVtYmVyW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHhTaGFwZS5sZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKGkgPCBheGlzKSB7XHJcbiAgICAgIG1lYW5JbnZTdGREZXZEaW0ucHVzaCh4U2hhcGVbaV0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWVhbkludlN0ZERldkRpbS5wdXNoKDEpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhub3JtU2l6ZSk7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBub3JtQ291bnQgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IG5vcm1TaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5mbG9vcihub3JtU2l6ZSAvIGNvbXBvbmVudHMpIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmVwc2lsb24gfSxcclxuICBdO1xyXG4gIGlmIChiaWFzKSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGNvbnN0IGhhc01lYW5EYXRhT3V0cHV0ID0gb3V0cHV0Q291bnQgPiAxO1xyXG4gIGNvbnN0IGhhc0ludlN0ZE91dHB1dCA9IG91dHB1dENvdW50ID4gMjtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG4gICAgY29uc3QgdmFyaWFibGVzID0gW1xyXG4gICAgICBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcywgY29tcG9uZW50cyksXHJcbiAgICAgIGlucHV0VmFyaWFibGUoJ3NjYWxlJywgc2NhbGUuZGF0YVR5cGUsIHNjYWxlLmRpbXMsIGNvbXBvbmVudHMpLFxyXG4gICAgXTtcclxuICAgIGlmIChiaWFzKSB7XHJcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBiaWFzLmRpbXMsIGNvbXBvbmVudHMpKTtcclxuICAgIH1cclxuICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCBjb21wb25lbnRzKSk7XHJcbiAgICBpZiAoaGFzTWVhbkRhdGFPdXRwdXQpIHtcclxuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ21lYW5fZGF0YV9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGhhc0ludlN0ZE91dHB1dCkge1xyXG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW52X3N0ZF9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnbm9ybV9jb3VudCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ25vcm1fc2l6ZScsIHR5cGU6ICdmMzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ25vcm1fc2l6ZV92ZWN0b3JpemVkJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnZXBzaWxvbicsIHR5cGU6ICdmMzInIH0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGBcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5ub3JtX2NvdW50Jyl9XHJcbiAgICBsZXQgb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkO1xyXG4gICAgdmFyIG1lYW5fdmVjdG9yID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XHJcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XHJcblxyXG4gICAgZm9yICh2YXIgaDogdTMyID0gMHU7IGggPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaCsrKSB7XHJcbiAgICAgIGxldCB2YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAneFtoICsgb2Zmc2V0XScpfTtcclxuICAgICAgbWVhbl92ZWN0b3IgKz0gdmFsdWU7XHJcbiAgICAgIG1lYW5fc3F1YXJlX3ZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgbGV0IG1lYW4gPSAke3N1bVZlY3RvcignbWVhbl92ZWN0b3InLCBjb21wb25lbnRzKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemU7XHJcbiAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke3N1bVZlY3RvcignbWVhbl9zcXVhcmVfdmVjdG9yJywgY29tcG9uZW50cyl9IC8gdW5pZm9ybXMubm9ybV9zaXplICR7XHJcbiAgICAgIHNpbXBsaWZpZWQgPyAnJyA6ICctIG1lYW4gKiBtZWFuJ1xyXG4gICAgfSArIHVuaWZvcm1zLmVwc2lsb24pO1xyXG5cclxuICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaisrKSB7XHJcbiAgICAgIGxldCBmMzJpbnB1dCA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAneFtqICsgb2Zmc2V0XScpfTtcclxuICAgICAgbGV0IGYzMnNjYWxlID0gJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICdzY2FsZVtqXScpfTtcclxuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHt2YXJpYWJsZXNbMF0udHlwZS52YWx1ZX0oKGYzMmlucHV0ICR7c2ltcGxpZmllZCA/ICcnIDogJy0gbWVhbid9KSAqIGludl9zdGRfZGV2ICogZjMyc2NhbGVcclxuICAgICAgICAke2JpYXMgPyBgKyAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ2JpYXNbal0nKX1gIDogJyd9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgJHtoYXNNZWFuRGF0YU91dHB1dCA/ICdtZWFuX2RhdGFfb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbicgOiAnJ307XHJcbiAgICAke2hhc0ludlN0ZE91dHB1dCA/ICdpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2JyA6ICcnfTtcclxuICB9YDtcclxuICB9O1xyXG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XTtcclxuICBpZiAoaGFzTWVhbkRhdGFPdXRwdXQpIHtcclxuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcclxuICB9XHJcbiAgaWYgKGhhc0ludlN0ZE91dHB1dCkge1xyXG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogbWVhbkludlN0ZERldkRpbSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0IH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdMYXllck5vcm1hbGl6YXRpb24nLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y29tcG9uZW50c307JHtvdXRwdXRDb3VudH07JHtzaW1wbGlmaWVkfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChub3JtQ291bnQgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsYXllck5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IExheWVyTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUxheWVyTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBjb250ZXh0Lm91dHB1dENvdW50KSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgQnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyB9IGZyb20gJy4vbWF0bXVsLXNoYWRlcnMnO1xyXG5pbXBvcnQgeyBjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L21hdG11bF9wYWNrZWRfd2ViZ3B1JztcclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRpbXNbaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV0gIT09IGlucHV0c1sxXS5kaW1zW2lucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDJdKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG1hdE11bCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGNvbnRleHQuaW5wdXRzWzFdLmRpbXMsIHRydWUpO1xyXG4gIGlmICghb3V0cHV0U2hhcGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XHJcbiAgfVxyXG4gIGNvbnN0IE4gPSBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXTtcclxuICBjb25zdCBLID0gY29udGV4dC5pbnB1dHNbMF0uZGltc1tjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdO1xyXG4gIGlmIChOIDwgOCAmJiBLIDwgOCkge1xyXG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHsgYWN0aXZhdGlvbjogJycgfSwgb3V0cHV0U2hhcGUpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgTSA9IG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDJdO1xyXG4gICAgY29uc3QgYmF0Y2hBID0gU2hhcGVVdGlsLnNpemUoY29udGV4dC5pbnB1dHNbMF0uZGltcy5zbGljZSgwLCAtMikpO1xyXG4gICAgY29uc3QgYmF0Y2hCID0gU2hhcGVVdGlsLnNpemUoY29udGV4dC5pbnB1dHNbMV0uZGltcy5zbGljZSgwLCAtMikpO1xyXG4gICAgaWYgKGJhdGNoQSAhPT0gMSAmJiBNID09PSAxICYmIGJhdGNoQiA9PT0gMSkge1xyXG4gICAgICAvLyBPcHRpbWl6YXRpb24gZm9yIGJhdGNoZWQgdmVjLW1hdC1tdWxcclxuICAgICAgY29uc3QgcmVzaGFwZWRBID0gY29udGV4dC5pbnB1dHNbMF0ucmVzaGFwZShbMSwgYmF0Y2hBLCBLXSk7XHJcbiAgICAgIGNvbnN0IHJlc2hhcGVkQiA9IGNvbnRleHQuaW5wdXRzWzFdLnJlc2hhcGUoWzEsIEssIE5dKTtcclxuICAgICAgY29uc3QgbWF0bXVsT3V0cHV0U2hhcGUgPSBbMSwgYmF0Y2hBLCBOXTtcclxuICAgICAgY29uc3QgbWF0bXVsSW5wdXRzID0gW3Jlc2hhcGVkQSwgcmVzaGFwZWRCXTtcclxuICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKG1hdG11bElucHV0cywgeyBhY3RpdmF0aW9uOiAnJyB9LCBvdXRwdXRTaGFwZSwgbWF0bXVsT3V0cHV0U2hhcGUpLCB7XHJcbiAgICAgICAgaW5wdXRzOiBtYXRtdWxJbnB1dHMsXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB7IGFjdGl2YXRpb246ICcnIH0sIG91dHB1dFNoYXBlKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBnZXRNYXhDb21wb25lbnRzLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG4vLyAgVE9ETyBzdXBwb3J0IHF1YW50aXphdGlvbiBiaXRzIG5vdCBlcXVhbCB0byA0XHJcbmV4cG9ydCBpbnRlcmZhY2UgTWF0TXVsTkJpdHNBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICBrOiBudW1iZXI7XHJcbiAgbjogbnVtYmVyO1xyXG4gIGFjY3VyYWN5TGV2ZWw6IG51bWJlcjtcclxuICBiaXRzOiBudW1iZXI7XHJcbiAgYmxvY2tTaXplOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDMgfHwgaW5wdXRzLmxlbmd0aCA+IDQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTWF0TXVsTkJpdHMgcmVxdWlyZXMgMyBvciA0IGlucHV0cycpO1xyXG4gIH1cclxuICBjb25zdCBhID0gaW5wdXRzWzBdO1xyXG4gIGNvbnN0IGFSYW5rID0gYS5kaW1zLmxlbmd0aDtcclxuICBpZiAoYS5kaW1zW2FSYW5rIC0gMV0gIT09IGF0dHJpYnV0ZXMuaykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbGFzdCBkaW0gb2YgaW5wdXQgc2hhcGUgZG9lcyBub3QgbWF0Y2ggdGhlIGsgdmFsdWUnKTtcclxuICB9XHJcbiAgY29uc3QgbkJsb2Nrc1BlckNvbCA9IE1hdGguZmxvb3IoKGF0dHJpYnV0ZXMuayArIGF0dHJpYnV0ZXMuYmxvY2tTaXplIC0gMSkgLyBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSk7XHJcbiAgY29uc3QgYmxvYlNpemUgPSAoYXR0cmlidXRlcy5ibG9ja1NpemUgLyA4KSAqIGF0dHJpYnV0ZXMuYml0cztcclxuICBjb25zdCBiID0gaW5wdXRzWzFdO1xyXG4gIGlmICghU2hhcGVVdGlsLmFyZUVxdWFsKGIuZGltcywgW2F0dHJpYnV0ZXMubiwgbkJsb2Nrc1BlckNvbCwgYmxvYlNpemVdKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGlucHV0cyBtdXN0IGJlIDNEIHRlbnNvciB3aXRoIHNoYXBlIE4gWCBuQmxvY2tzUGVyQ29sIFggYmxvYlNpemUnKTtcclxuICB9XHJcbiAgY29uc3Qgc2NhbGVzID0gaW5wdXRzWzJdO1xyXG4gIGNvbnN0IHNjYWxlc1NoYXBlID0gc2NhbGVzLmRpbXM7XHJcbiAgaWYgKFNoYXBlVXRpbC5zaXplKHNjYWxlc1NoYXBlKSAhPT0gYXR0cmlidXRlcy5uICogbkJsb2Nrc1BlckNvbCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZXMgaW5wdXQgc2l6ZSBlcnJvci4nKTtcclxuICB9XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDQpIHtcclxuICAgIGNvbnN0IHplcm9Qb2ludHMgPSBpbnB1dHNbM107XHJcbiAgICBjb25zdCB6ZXJvUG9pbnRzU2hhcGUgPSB6ZXJvUG9pbnRzLmRpbXM7XHJcblxyXG4gICAgLy8gVGhpcyBhc3N1bWVzIHplcm8gcG9pbnRzIGFyZSBwYWNrZWQuXHJcbiAgICAvLyBVbnBhY2sgZm9ybWF0ICh6ZXJvIHBvaW50IGhhcyBzYW1lIGRhdGEgdHlwZSBhbmQgc2hhcGUgYXMgc2NhbGUpIGlzIG5vdCBzdXBwb3J0ZWQgYnkgd2ViZ3B1LlxyXG4gICAgY29uc3QgZXhwZWN0ZWRaZXJvUG9pbnRzU2l6ZSA9XHJcbiAgICAgIGF0dHJpYnV0ZXMubiAqIChhdHRyaWJ1dGVzLmJpdHMgPT09IDggPyBuQmxvY2tzUGVyQ29sIDogTWF0aC5mbG9vcigobkJsb2Nrc1BlckNvbCAqIGF0dHJpYnV0ZXMuYml0cyArIDcpIC8gOCkpO1xyXG4gICAgaWYgKFNoYXBlVXRpbC5zaXplKHplcm9Qb2ludHNTaGFwZSkgIT09IGV4cGVjdGVkWmVyb1BvaW50c1NpemUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd6ZXJvUG9pbnRzIGlucHV0IHNpemUgZXJyb3IuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdE11bE5CaXRzUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogTWF0TXVsTkJpdHNBdHRyaWJ1dGVzLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGFSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XHJcbiAgY29uc3QgZGltQU91dGVyID0gaW5wdXRTaGFwZVthUmFuayAtIDJdO1xyXG4gIGNvbnN0IGRpbUlubmVyID0gYXR0cmlidXRlcy5rO1xyXG4gIGNvbnN0IGRpbUJPdXRlciA9IGF0dHJpYnV0ZXMubjtcclxuICBjb25zdCBiYXRjaERpbXMgPSBpbnB1dFNoYXBlLnNsaWNlKDAsIGFSYW5rIC0gMik7XHJcbiAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUoYmF0Y2hEaW1zKTtcclxuICBjb25zdCBibG9iU2l6ZSA9IGlucHV0c1sxXS5kaW1zWzJdO1xyXG4gIGNvbnN0IGJsb2JTaXplSW5Xb3JkcyA9IGJsb2JTaXplIC8gNDtcclxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcclxuICBjb25zdCBhQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYXR0cmlidXRlcy5rKTtcclxuICBjb25zdCBiQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYmxvYlNpemVJbldvcmRzKTtcclxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhkaW1CT3V0ZXIpO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYmF0Y2hEaW1zLmNvbmNhdChbZGltQU91dGVyLCBkaW1CT3V0ZXJdKTtcclxuICBjb25zdCBvdXRwdXROdW1iZXIgPSBkaW1BT3V0ZXIgPiAxICYmIChkaW1CT3V0ZXIgLyBjb21wb25lbnRzKSAlIDIgPT09IDAgPyAyIDogMTtcclxuICBjb25zdCBkaXNwYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzIC8gb3V0cHV0TnVtYmVyO1xyXG5cclxuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gNjQ7XHJcblxyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtdO1xyXG4gIGNvbnN0IGlucHV0U2hhcGVUZW1wID0gW2JhdGNoU2l6ZSwgZGltQU91dGVyLCBkaW1Jbm5lciAvIGFDb21wb25lbnRzXTtcclxuICBjb25zdCBiU2hhcGUgPSBTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1sxXS5kaW1zKS5zbGljZSgpO1xyXG4gIGJTaGFwZS5zcGxpY2UoLTEsIDEsIGJsb2JTaXplSW5Xb3JkcyAvIGJDb21wb25lbnRzKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlVGVtcCkpO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGJTaGFwZSkpO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDQpIHtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKFNoYXBlVXRpbC5jb252ZXJ0U2hhcGUoaW5wdXRzWzNdLmRpbXMpKSk7XHJcbiAgfVxyXG4gIGNvbnN0IG91dHB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltQk91dGVyIC8gY29tcG9uZW50c107XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZVRlbXAubGVuZ3RoO1xyXG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0UmFuaywgYUNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2InLCBEYXRhVHlwZS51aW50MzIsIGJTaGFwZS5sZW5ndGgsIGJDb21wb25lbnRzKTtcclxuICAgIGNvbnN0IHNjYWxlcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2EsIGIsIHNjYWxlc107XHJcbiAgICBjb25zdCB6ZXJvUG9pbnRzID1cclxuICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gNCA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnRzJywgRGF0YVR5cGUudWludDMyLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKHplcm9Qb2ludHMpIHtcclxuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnRzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG91dHB1dFJhbmsgPSBvdXRwdXRTaGFwZVRlbXAubGVuZ3RoO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0UmFuaywgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG5cclxuICAgIGNvbnN0IHFEcURhdGFUeXBlID0gKCgpID0+IHtcclxuICAgICAgc3dpdGNoIChhQ29tcG9uZW50cykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHJldHVybiBgYXJyYXk8JHtkYXRhVHlwZX0sIDg+YDtcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICByZXR1cm4gYG1hdDR4Mjwke2RhdGFUeXBlfT5gO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIHJldHVybiBgbWF0Mng0PCR7ZGF0YVR5cGV9PmA7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHthQ29tcG9uZW50c30tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG4gICAgY29uc3QgcHJvY2Vzc09uZVdvcmQgPSAoKTogc3RyaW5nID0+IHtcclxuICAgICAgbGV0IGNhbGNTdHIgPSBgXHJcbiAgICAgICAgICAvLyByZXVzZSBhIGRhdGFcclxuICAgICAgICAgICAgdmFyIGlucHV0X29mZnNldCA9ICR7YS5pbmRpY2VzVG9PZmZzZXQoYCR7YS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIHdvcmRfb2Zmc2V0KWApfTtcclxuICAgICAgICAgICAgdmFyIGFfZGF0YTogJHtxRHFEYXRhVHlwZX07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCAkezggLyBhQ29tcG9uZW50c307IGorKykge1xyXG4gICAgICAgICAgICAgIGFfZGF0YVtqXSA9ICR7YS5nZXRCeU9mZnNldCgnaW5wdXRfb2Zmc2V0Jyl9O1xyXG4gICAgICAgICAgICAgIGlucHV0X29mZnNldCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBgO1xyXG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbXBvbmVudHMgKiBvdXRwdXROdW1iZXI7IGMrKykge1xyXG4gICAgICAgIGNhbGNTdHIgKz0gYFxyXG4gICAgICAgICAgICBiX3ZhbHVlID0gJHtiQ29tcG9uZW50cyA9PT0gMSA/IGBiJHtjfV9kYXRhYCA6IGBiJHtjfV9kYXRhW2ldYH07XHJcbiAgICAgICAgICAgIGJfdmFsdWVfbG93ZXIgPSB1bnBhY2s0eFU4KGJfdmFsdWUgJiBiX21hc2spO1xyXG4gICAgICAgICAgICBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIGJfbWFzayk7XHJcbiAgICAgICAgICAgIGJfcXVhbnRpemVkX3ZhbHVlcyA9ICR7cURxRGF0YVR5cGV9KCR7QXJyYXkuZnJvbShcclxuICAgICAgICAgICAgICB7IGxlbmd0aDogNCB9LFxyXG4gICAgICAgICAgICAgIChfLCBpKSA9PiBgJHtkYXRhVHlwZX0oYl92YWx1ZV9sb3dlclske2l9XSksICR7ZGF0YVR5cGV9KGJfdmFsdWVfdXBwZXJbJHtpfV0pYCxcclxuICAgICAgICAgICAgKS5qb2luKCcsICcpfSk7XHJcbiAgICAgICAgICAgIGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gJHsoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChhQ29tcG9uZW50cyA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3FEcURhdGFUeXBlfSgke0FycmF5LmZyb20oXHJcbiAgICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiA4IH0sXHJcbiAgICAgICAgICAgICAgICAgIChfLCBpKSA9PiBgKGJfcXVhbnRpemVkX3ZhbHVlc1ske2l9XSAtICR7emVyb1BvaW50cyA/IGB6ZXJvX3BvaW50JHtjfWAgOiAnemVyb19wb2ludCd9KSAqIHNjYWxlJHtjfWAsXHJcbiAgICAgICAgICAgICAgICApLmpvaW4oJywgJyl9KTtgO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYChiX3F1YW50aXplZF92YWx1ZXMgLSAke3FEcURhdGFUeXBlfSgke0FycmF5KDgpXHJcbiAgICAgICAgICAgICAgICAgIC5maWxsKGAke3plcm9Qb2ludHMgPyBgemVyb19wb2ludCR7Y31gIDogJ3plcm9fcG9pbnQnfWApXHJcbiAgICAgICAgICAgICAgICAgIC5qb2luKCcsJyl9KSkgKiBzY2FsZSR7Y307YDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKCl9O1xyXG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke291dHB1dE51bWJlcn0gKyAke01hdGguZmxvb3IoYyAvIGNvbXBvbmVudHMpfV0ke2NvbXBvbmVudHMgPiAxID8gYFske2MgJSBjb21wb25lbnRzfV1gIDogJyd9ICs9ICR7QXJyYXkuZnJvbShcclxuICAgICAgICAgICAgICB7IGxlbmd0aDogOCAvIGFDb21wb25lbnRzIH0sXHJcbiAgICAgICAgICAgICAgKF8sIGkpID0+XHJcbiAgICAgICAgICAgICAgICBgJHtcclxuICAgICAgICAgICAgICAgICAgYUNvbXBvbmVudHMgPT09IDFcclxuICAgICAgICAgICAgICAgICAgICA/IGBhX2RhdGFbJHtpfV0gKiBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske2l9XWBcclxuICAgICAgICAgICAgICAgICAgICA6IGBkb3QoYV9kYXRhWyR7aX1dLCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske2l9XSlgXHJcbiAgICAgICAgICAgICAgICB9YCxcclxuICAgICAgICAgICAgKS5qb2luKCcgKyAnKX07XHJcbiAgICAgICAgICBgO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjYWxjU3RyO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByZXBhcmVTY2FsZUFuZFplcm9Qb2ludCA9ICgpOiBzdHJpbmcgPT4ge1xyXG4gICAgICBsZXQgY2FsY1N0ciA9IGBcclxuICAgICAgICAgICAgdmFyIGNvbF9pbmRleCA9IGNvbCAqICR7Y29tcG9uZW50c307XHJcbiAgICAgICAgICAgICR7XHJcbiAgICAgICAgICAgICAgemVyb1BvaW50c1xyXG4gICAgICAgICAgICAgICAgPyBgXHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobkJsb2Nrc1BlckNvbCArIDEpIC8gMjtcclxuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9jb3VudDogdTMyO1xyXG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkX2luZGV4OiB1MzI7XHJcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0OiB1MzI7XHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcclxuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcclxuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZDogdTMyO2BcclxuICAgICAgICAgICAgICAgIDogYFxyXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cclxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2RhdGFUeXBlfSgkezguMH0pO2BcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBgO1xyXG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbXBvbmVudHMgKiBvdXRwdXROdW1iZXI7IGMrKykge1xyXG4gICAgICAgIGNhbGNTdHIgKz0gYFxyXG4gICAgICAgICAgICBsZXQgc2NhbGUke2N9ID0gJHtzY2FsZXMuZ2V0QnlPZmZzZXQoYGNvbF9pbmRleCAqIG5CbG9ja3NQZXJDb2wgKyBibG9ja2ApfTtcclxuICAgICAgICAgICAgJHtcclxuICAgICAgICAgICAgICB6ZXJvUG9pbnRzXHJcbiAgICAgICAgICAgICAgICA/IGBcclxuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX2NvdW50ID0gY29sX2luZGV4ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xyXG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcclxuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX29mZnNldCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XHJcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XHJcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZCA9ICR7emVyb1BvaW50cy5nZXRCeU9mZnNldCgnemVyb19wb2ludF93b3JkX2luZGV4Jyl9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50JHtjfSA9ICR7ZGF0YVR5cGV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YFxyXG4gICAgICAgICAgICAgICAgOiAnJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNhbGNTdHI7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJlcGFyZUJEYXRhID0gKCk6IHN0cmluZyA9PiB7XHJcbiAgICAgIGxldCBjYWxjU3RyID0gYGNvbF9pbmRleCA9IGNvbCAqICR7Y29tcG9uZW50c307YDtcclxuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb21wb25lbnRzICogb3V0cHV0TnVtYmVyOyBjKyspIHtcclxuICAgICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgICAgbGV0IGIke2N9X2RhdGEgPSAke2IuZ2V0QnlJbmRpY2VzKGAke2IudHlwZS5pbmRpY2VzfShjb2xfaW5kZXgsIGJsb2NrLCB3b3JkKWApfTtcclxuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtcclxuICAgICAgfVxyXG4gICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgICAgdmFyIGJfdmFsdWU6IHUzMjtcclxuICAgICAgICAgICAgbGV0IGJfbWFzazogdTMyID0gMHgwRjBGMEYwRnU7XHJcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX2xvd2VyOiB2ZWM0PHUzMj47XHJcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX3VwcGVyOiB2ZWM0PHUzMj47XHJcbiAgICAgICAgICAgIHZhciBiX3F1YW50aXplZF92YWx1ZXM6ICR7cURxRGF0YVR5cGV9O1xyXG4gICAgICAgICAgICB2YXIgYl9kZXF1YW50aXplZF92YWx1ZXM6ICR7cURxRGF0YVR5cGV9O2A7XHJcbiAgICAgIHJldHVybiBjYWxjU3RyO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZDogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0TnVtYmVyICogd29ya2dyb3VwU2l6ZX0+O1xyXG4gICAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFt3b3JrZ3JvdXBTaXplLCAxLCAxXSl9XHJcbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYChnbG9iYWxfaWR4IC8gJHt3b3JrZ3JvdXBTaXplfSkgKiAke291dHB1dE51bWJlcn1gKX07XHJcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XHJcbiAgICAgICAgICBsZXQgcm93ID0gb3V0cHV0X2luZGljZXNbMV07XHJcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcclxuICAgICAgICAgIGxldCBuQmxvY2tzUGVyQ29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBibG9jayA9IGxvY2FsX2lkLng7IGJsb2NrIDwgbkJsb2Nrc1BlckNvbDsgYmxvY2sgKz0gJHt3b3JrZ3JvdXBTaXplfSkge1xyXG4gICAgICAgICAgICAvL3Byb2Nlc3Mgb25lIGJsb2NrXHJcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldDogdTMyID0gYmxvY2sgKiAke2F0dHJpYnV0ZXMuYmxvY2tTaXplIC8gYUNvbXBvbmVudHN9O1xyXG4gICAgICAgICAgICAke3ByZXBhcmVTY2FsZUFuZFplcm9Qb2ludCgpfVxyXG4gICAgICAgICAgICBmb3IgKHZhciB3b3JkOiB1MzIgPSAwOyB3b3JkIDwgJHtibG9iU2l6ZUluV29yZHN9OyB3b3JkICs9ICR7YkNvbXBvbmVudHN9KSB7XHJcbiAgICAgICAgICAgICAgJHtwcmVwYXJlQkRhdGEoKX1cclxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtiQ29tcG9uZW50c307IGkrKykge1xyXG4gICAgICAgICAgICAgICAgJHtwcm9jZXNzT25lV29yZCgpfVxyXG4gICAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4IC8gYUNvbXBvbmVudHN9O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgICAgICAgIGlmIChsb2NhbF9pZC54IDwgJHtvdXRwdXROdW1iZXJ9KSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7b3V0cHV0LnR5cGUudmFsdWV9ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgICAgICAgIHZhciB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldDogdTMyID0gbG9jYWxfaWQueDtcclxuICAgICAgICAgICAgZm9yICh2YXIgYjogdTMyID0gMHU7IGIgPCAke3dvcmtncm91cFNpemV9dTsgYisrKSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IHdvcmtncm91cF9zaGFyZWRbd29ya2dyb3VwX3NoYXJlZF9vZmZzZXRdO1xyXG4gICAgICAgICAgICAgIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0ICs9ICR7b3V0cHV0TnVtYmVyfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAke291dHB1dC5zZXRCeUluZGljZXMoYCR7b3V0cHV0LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWQueClgLCAnb3V0cHV0X3ZhbHVlJyl9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1gO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdNYXRNdWxOQml0cycsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmJsb2NrU2l6ZX07JHthdHRyaWJ1dGVzLmJpdHN9OyR7YUNvbXBvbmVudHN9OyR7YkNvbXBvbmVudHN9OyR7Y29tcG9uZW50c307JHtvdXRwdXROdW1iZXJ9OyR7d29ya2dyb3VwU2l6ZX1gLFxyXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogQXJyYXkoaW5wdXRzLmxlbmd0aCkuZmlsbCgncmFuaycpLFxyXG4gICAgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFNpemUgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbi8vIEN1cnJlbnRseSwgb25seSBzdXBwb3J0IGJsb2NrU2l6ZSA9IDMyLlxyXG5leHBvcnQgY29uc3QgY3JlYXRlTWF0TXVsTkJpdHNCbG9ja1NpemUzMlByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IE1hdE11bE5CaXRzQXR0cmlidXRlcyxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBhUmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xyXG4gIGNvbnN0IGRpbUFPdXRlciA9IGlucHV0U2hhcGVbYVJhbmsgLSAyXTtcclxuICBjb25zdCBkaW1Jbm5lciA9IGF0dHJpYnV0ZXMuaztcclxuICBjb25zdCBkaW1CT3V0ZXIgPSBhdHRyaWJ1dGVzLm47XHJcbiAgY29uc3QgYmF0Y2hEaW1zID0gaW5wdXRTaGFwZS5zbGljZSgwLCBhUmFuayAtIDIpO1xyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGJhdGNoRGltcyk7XHJcbiAgY29uc3QgYmxvYlNpemUgPSBpbnB1dHNbMV0uZGltc1syXTtcclxuICBjb25zdCBibG9iU2l6ZUluV29yZHMgPSBibG9iU2l6ZSAvIDQ7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XHJcbiAgY29uc3QgYUNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGF0dHJpYnV0ZXMuayk7XHJcbiAgY29uc3QgYkNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGJsb2JTaXplSW5Xb3Jkcyk7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBiYXRjaERpbXMuY29uY2F0KFtkaW1BT3V0ZXIsIGRpbUJPdXRlcl0pO1xyXG5cclxuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gMTI4O1xyXG4gIGNvbnN0IHdvcmtncm91cFkgPSBkaW1CT3V0ZXIgJSA4ID09PSAwID8gOCA6IGRpbUJPdXRlciAlIDQgPT09IDAgPyA0IDogMTtcclxuICBjb25zdCB3b3JrZ3JvdXBYID0gd29ya2dyb3VwU2l6ZSAvIHdvcmtncm91cFk7XHJcbiAgY29uc3QgdGlsZVNpemUgPSB3b3JrZ3JvdXBYICogYkNvbXBvbmVudHMgKiA4OyAvLyBlYWNoIHVpbnQzMiBoYXMgOCBkYXRhLlxyXG4gIGNvbnN0IGFMZW5ndGhQZXJUaWxlID0gdGlsZVNpemUgLyBhQ29tcG9uZW50cztcclxuICBjb25zdCBibG9ja3NQZXJUaWxlID0gdGlsZVNpemUgLyBhdHRyaWJ1dGVzLmJsb2NrU2l6ZTtcclxuICBjb25zdCBkaXNwYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyB3b3JrZ3JvdXBZO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXTtcclxuICBjb25zdCBpbnB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltSW5uZXIgLyBhQ29tcG9uZW50c107XHJcbiAgY29uc3QgYlNoYXBlID0gU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbMV0uZGltcykuc2xpY2UoKTtcclxuICBiU2hhcGUuc3BsaWNlKC0xLCAxLCBibG9iU2l6ZUluV29yZHMgLyBiQ29tcG9uZW50cyk7XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZVRlbXApKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiU2hhcGUpKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xyXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1szXS5kaW1zKSkpO1xyXG4gIH1cclxuICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlcl07XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZVRlbXAubGVuZ3RoO1xyXG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0UmFuaywgYUNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2InLCBEYXRhVHlwZS51aW50MzIsIGJTaGFwZS5sZW5ndGgsIGJDb21wb25lbnRzKTtcclxuICAgIGNvbnN0IHNjYWxlcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2EsIGIsIHNjYWxlc107XHJcbiAgICBjb25zdCB6ZXJvUG9pbnRzID1cclxuICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gNCA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnRzJywgRGF0YVR5cGUudWludDMyLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKHplcm9Qb2ludHMpIHtcclxuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnRzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG91dHB1dFJhbmsgPSBvdXRwdXRTaGFwZVRlbXAubGVuZ3RoO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0UmFuayk7XHJcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG4gICAgY29uc3QgcmVhZEEgPSAoKSA9PiB7XHJcbiAgICAgIHN3aXRjaCAoYUNvbXBvbmVudHMpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO1xyXG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDRdLCBzdWJfYVt3b3JkX29mZnNldCArIDVdLCBzdWJfYVt3b3JkX29mZnNldCArIDZdLCBzdWJfYVt3b3JkX29mZnNldCArIDddKTtgO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtkYXRhVHlwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSk7XHJcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHZlYzQ8JHtkYXRhVHlwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO2A7XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgIGxldCBhX2RhdGEwID0gc3ViX2Fbd29yZF9vZmZzZXRdO1xyXG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSBzdWJfYVt3b3JkX29mZnNldCArIDFdO2A7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHthQ29tcG9uZW50c30tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICB2YXI8d29ya2dyb3VwPiBzdWJfYTogYXJyYXk8JHthLnR5cGUudmFsdWV9LCAke2FMZW5ndGhQZXJUaWxlfT47XHJcbiAgICAgICAgdmFyPHdvcmtncm91cD4gaW50ZXJfcmVzdWx0czogYXJyYXk8YXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7d29ya2dyb3VwWH0+LCAke3dvcmtncm91cFl9PjtcclxuICAgICAgICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbd29ya2dyb3VwWCwgd29ya2dyb3VwWSwgMV0pfVxyXG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGB3b3JrZ3JvdXBfaW5kZXggKiAke3dvcmtncm91cFl9YCl9O1xyXG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xyXG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xyXG4gICAgICAgICAgbGV0IGJhdGNoID0gb3V0cHV0X2luZGljZXNbMF07XHJcbiAgICAgICAgICBsZXQgbl9ibG9ja3NfcGVyX2NvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XHJcbiAgICAgICAgICBsZXQgbnVtX3RpbGVzID0gIChuX2Jsb2Nrc19wZXJfY29sIC0gMSkgLyAke2Jsb2Nrc1BlclRpbGV9ICsgMTtcclxuXHJcbiAgICAgICAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cclxuICAgICAgICAgIGZvciAodmFyIHRpbGU6IHUzMiA9IDA7IHRpbGUgPCBudW1fdGlsZXM7IHRpbGUgKz0gMSkge1xyXG4gICAgICAgICAgICBsZXQgYV9jb2xfc3RhcnQgPSB0aWxlICogJHthTGVuZ3RoUGVyVGlsZX07XHJcbiAgICAgICAgICAgIC8vIGxvYWQgb25lIHRpbGUgQSBkYXRhIGludG8gc2hhcmVkIG1lbW9yeS5cclxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHthTGVuZ3RoUGVyVGlsZX07IGFfb2Zmc2V0ICs9ICR7d29ya2dyb3VwU2l6ZX0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBsZXQgYV9jb2wgPSBhX2NvbF9zdGFydCArIGFfb2Zmc2V0O1xyXG4gICAgICAgICAgICAgIGlmIChhX2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMl0pXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHthLmdldEJ5SW5kaWNlcyhgJHthLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgYV9jb2wpYCl9O1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke2EudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGVhY2ggdGhyZWFkIHByb2Nlc3Mgb25lIGJsb2NrXHJcbiAgICAgICAgICAgIGxldCBiX3JvdyA9IGNvbCArIGxvY2FsX2lkLnk7XHJcbiAgICAgICAgICAgIGxldCBibG9jayA9IHRpbGUgKiAke2Jsb2Nrc1BlclRpbGV9ICsgbG9jYWxfaWQueDtcclxuICAgICAgICAgICAgJHtcclxuICAgICAgICAgICAgICB6ZXJvUG9pbnRzXHJcbiAgICAgICAgICAgICAgICA/IGBcclxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuX2Jsb2Nrc19wZXJfY29sICsgMSkgLyAyO1xyXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlX2NvdW50ID0gYl9yb3cgKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgPj4gMHgxdSk7XHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcclxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xyXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9uaWJibGVfb2Zmc2V0OiB1MzIgPSBibG9jayAmIDB4MXU7XHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xyXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkID0gJHt6ZXJvUG9pbnRzLmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X3dvcmRfaW5kZXgnKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcclxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2RhdGFUeXBlfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2BcclxuICAgICAgICAgICAgICAgIDogYFxyXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cclxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2RhdGFUeXBlfSgkezguMH0pO2BcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAke3NjYWxlcy5nZXRCeU9mZnNldChgYl9yb3cgKiBuX2Jsb2Nrc19wZXJfY29sICsgYmxvY2tgKX07XHJcbiAgICAgICAgICAgIGxldCBiX2RhdGEgPSAke2IuZ2V0QnlJbmRpY2VzKGAke2IudHlwZS5pbmRpY2VzfShiX3JvdywgYmxvY2ssIDApYCl9O1xyXG4gICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQgPSBsb2NhbF9pZC54ICogJHthdHRyaWJ1dGVzLmJsb2NrU2l6ZSAvIGFDb21wb25lbnRzfTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7YkNvbXBvbmVudHN9OyBpKyspIHtcclxuICAgICAgICAgICAgICAke3JlYWRBKCl9XHJcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWUgPSAke2JDb21wb25lbnRzID09PSAxID8gYGJfZGF0YWAgOiBgYl9kYXRhW2ldYH07XHJcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfbG93ZXIgPSB1bnBhY2s0eFU4KGJfdmFsdWUgJiAweDBGMEYwRjBGdSk7XHJcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgMHgwRjBGMEYwRnUpO1xyXG4gICAgICAgICAgICAgIGxldCBiX3F1YW50aXplZF92YWx1ZXMgPSBtYXQyeDQ8JHtkYXRhVHlwZX0+KCR7QXJyYXkuZnJvbShcclxuICAgICAgICAgICAgICAgIHsgbGVuZ3RoOiA0IH0sXHJcbiAgICAgICAgICAgICAgICAoXywgaSkgPT4gYCR7ZGF0YVR5cGV9KGJfdmFsdWVfbG93ZXJbJHtpfV0pLCAke2RhdGFUeXBlfShiX3ZhbHVlX3VwcGVyWyR7aX1dKWAsXHJcbiAgICAgICAgICAgICAgKS5qb2luKCcsICcpfSk7XHJcbiAgICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gKGJfcXVhbnRpemVkX3ZhbHVlcyAtIG1hdDJ4NDwke2RhdGFUeXBlfT4oJHtBcnJheSg4KS5maWxsKCd6ZXJvX3BvaW50Jykuam9pbignLCcpfSkpICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgaW50ZXJfcmVzdWx0c1tsb2NhbF9pZC55XVtsb2NhbF9pZC54XSArPSAke0FycmF5LmZyb20oXHJcbiAgICAgICAgICAgICAgICB7IGxlbmd0aDogMiB9LFxyXG4gICAgICAgICAgICAgICAgKF8sIGkpID0+IGAke2Bkb3QoYV9kYXRhJHtpfSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtpfV0pYH1gLFxyXG4gICAgICAgICAgICAgICkuam9pbignICsgJyl9O1xyXG4gICAgICAgICAgICAgIHdvcmRfb2Zmc2V0ICs9ICR7OCAvIGFDb21wb25lbnRzfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGxvY2FsX2lkeCA8ICR7d29ya2dyb3VwWX0pIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtvdXRwdXQudHlwZS52YWx1ZX0gPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHt3b3JrZ3JvdXBYfTsgYisrKSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IGludGVyX3Jlc3VsdHNbbG9jYWxfaWR4XVtiXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlJbmRpY2VzKGAke291dHB1dC50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkeClgLCAnb3V0cHV0X3ZhbHVlJyl9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnQmxvY2t3aXNlTWF0TXVsTkJpdHMzMicsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmJsb2NrU2l6ZX07JHthQ29tcG9uZW50c307JHtiQ29tcG9uZW50c307JHt3b3JrZ3JvdXBYfTske3dvcmtncm91cFl9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IEFycmF5KGlucHV0cy5sZW5ndGgpLmZpbGwoJ3JhbmsnKSxcclxuICAgIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hTaXplIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbWF0TXVsTkJpdHMgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IE1hdE11bE5CaXRzQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuICBpZiAoXHJcbiAgICBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSA9PT0gMzIgJiZcclxuICAgIGNvbnRleHQuYWRhcHRlckluZm8uaXNWZW5kb3IoJ2ludGVsJykgJiZcclxuICAgIGNvbnRleHQuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoJ2dlbi0xMmxwJylcclxuICApIHtcclxuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRNdWxOQml0c0Jsb2NrU2l6ZTMyUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1hdE11bE5CaXRzUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VNYXRNdWxOQml0c0F0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PE1hdE11bE5CaXRzQXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgZ2V0RWxlbWVudEF0LFxyXG4gIEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgVW5pZm9ybURhdGFFbGVtZW50VHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5pbnRlcmZhY2UgUGFkQXR0cmlidXRlcyB7XHJcbiAgLy8gMC1jb25zdGFudCwgMS1yZWZsZWN0LCAyLWVkZ2UsIDMtd3JhcFxyXG4gIHJlYWRvbmx5IG1vZGU6IG51bWJlcjtcclxuICByZWFkb25seSB2YWx1ZTogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IHBhZHM6IG51bWJlcltdO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBmZXcgaW5wdXRzJyk7XHJcbiAgfVxyXG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0ICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQxNikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQgb3IgZmxvYXQxNi4nKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dHMubGVuZ3RoID49IDIpIHtcclxuICAgIGxldCB2YWxpZFBhZHMgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggKiAyID09PSBpbnB1dHNbMV0uZGltc1swXTtcclxuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgIHZhbGlkUGFkcyA9IGlucHV0c1szXS5kaW1zWzBdICogMiA9PT0gaW5wdXRzWzFdLmRpbXNbMF07XHJcbiAgICB9XHJcbiAgICBpZiAoIXZhbGlkUGFkcykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYWRzIHNob3VsZCBiZSBhIDFEIHRlbnNvciBvZiBzaGFwZSBbMiAqIGlucHV0X3JhbmtdIG9yIFsyICogbnVtX2F4ZXNdLicpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGdldFBhZENvbnN0YW50ID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XHJcbiAgbGV0IGJsb2NrID0gJyc7XHJcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICBibG9jayArPSBgXHJcbiAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcclxuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcclxuICAgICAgICBgO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGBcclxuICAgICAgICAgIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0odW5pZm9ybXMuY29uc3RhbnRfdmFsdWUpO1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICAgICAgJHtibG9ja31cclxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgIGA7XHJcbn07XHJcblxyXG5jb25zdCBnZXRQYWRSZWZsZWN0ID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XHJcbiAgbGV0IGJsb2NrID0gJyc7XHJcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICBibG9jayArPSBgXHJcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XHJcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgayA9IC1rO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xyXG4gICAgICAgICAgICAgICAgICBpZihrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XHJcbiAgICAgICAgICAgIGA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICAgICAgICAke2Jsb2NrfVxyXG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xyXG4gICAgICAgICAgYDtcclxufTtcclxuXHJcbmNvbnN0IGdldFBhZEVkZ2UgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICBsZXQgYmxvY2sgPSAnJztcclxuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgIGJsb2NrICs9IGBcclxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcclxuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICBrID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xyXG4gICAgICAgICAgICAgICAgICBrID0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pIC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XHJcbiAgICAgICAgICAgIGA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICAgICAgICAke2Jsb2NrfVxyXG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xyXG4gICAgICAgICAgYDtcclxufTtcclxuXHJcbmNvbnN0IGdldFBhZFdyYXAgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICBsZXQgYmxvY2sgPSAnJztcclxuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgIGJsb2NrICs9IGBcclxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcclxuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcclxuICAgICAgICAgICAgICAgICAgayArPSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XHJcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcclxuICAgICAgICAgICAgYDtcclxuICB9XHJcblxyXG4gIHJldHVybiBgXHJcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgICAgICAgICR7YmxvY2t9XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XHJcbiAgICAgICAgICBgO1xyXG59O1xyXG5cclxuY29uc3QgZ2V0UGFkU25pcHBldCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogc3RyaW5nID0+IHtcclxuICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xyXG4gICAgY2FzZSAwOlxyXG4gICAgICByZXR1cm4gZ2V0UGFkQ29uc3RhbnQob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xyXG4gICAgY2FzZSAxOlxyXG4gICAgICByZXR1cm4gZ2V0UGFkUmVmbGVjdChvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XHJcbiAgICBjYXNlIDI6XHJcbiAgICAgIHJldHVybiBnZXRQYWRFZGdlKG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcclxuICAgIGNhc2UgMzpcclxuICAgICAgcmV0dXJuIGdldFBhZFdyYXAob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGUnKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVQYWRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC5wYWRTaGFwZShpbnB1dHNbMF0uZGltcy5zbGljZSgpLCBhdHRyaWJ1dGVzLnBhZHMpO1xyXG4gIGNvbnN0IGlucHV0RGltcyA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMucGFkcyB9LFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGlzVmFsdWVGcm9tSW5wdXQgPSBpbnB1dHMubGVuZ3RoID49IDMgJiYgaW5wdXRzWzJdLmRhdGE7XHJcbiAgaWYgKGF0dHJpYnV0ZXMubW9kZSA9PT0gMCkge1xyXG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goeyB0eXBlOiBpc1ZhbHVlRnJvbUlucHV0ID8gaW5wdXRzWzJdLmRhdGFUeXBlIDogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMudmFsdWUgfSk7XHJcbiAgfVxyXG5cclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpKTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0RGltcy5sZW5ndGgpO1xyXG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xyXG4gICAgY29uc3QgcGFkU25pcHBldCA9IGdldFBhZFNuaXBwZXQob3V0cHV0LCBpbnB1dERpbXMubGVuZ3RoLCBhdHRyaWJ1dGVzKTtcclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aCB9LFxyXG4gICAgXTtcclxuICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09IDApIHtcclxuICAgICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdjb25zdGFudF92YWx1ZScsIHR5cGU6IChpc1ZhbHVlRnJvbUlucHV0ID8gZGF0YVR5cGUgOiAnZjMyJykgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuXHJcbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oMCk7XHJcbiAgICAgICAgICAgICR7cGFkU25pcHBldH1cclxuICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XHJcbiAgICAgICAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdQYWQnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5tb2RlfSR7aXNWYWx1ZUZyb21JbnB1dH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiBQYWRBdHRyaWJ1dGVzID0+IHtcclxuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcclxuICAgIGNvbnN0IGJpZ0ludDY0UGFkcyA9IGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCk7XHJcbiAgICBjb25zdCB2YWx1ZSA9XHJcbiAgICAgIGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0uZGF0YVxyXG4gICAgICAgID8gaW5wdXRzWzJdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5mbG9hdDE2XHJcbiAgICAgICAgICA/IGlucHV0c1syXS5nZXRVaW50MTZBcnJheSgpWzBdXHJcbiAgICAgICAgICA6IGlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXVxyXG4gICAgICAgIDogMC4wO1xyXG5cclxuICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcclxuICAgIGNvbnN0IHVwZGF0ZVBhZHMgPSBuZXcgSW50MzJBcnJheSgyICogaW5wdXRSYW5rKS5maWxsKDApO1xyXG4gICAgaWYgKGlucHV0cy5sZW5ndGggPj0gNCkge1xyXG4gICAgICBjb25zdCBheGVzID0gaW5wdXRzWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdXBkYXRlUGFkc1tOdW1iZXIoYXhlc1tpXSldID0gTnVtYmVyKGJpZ0ludDY0UGFkc1tpXSk7XHJcbiAgICAgICAgdXBkYXRlUGFkc1tOdW1iZXIoYXhlc1tpXSkgKyBpbnB1dFJhbmtdID0gTnVtYmVyKGJpZ0ludDY0UGFkc1tpICsgYXhlcy5sZW5ndGhdKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmlnSW50NjRQYWRzLmZvckVhY2goKHYsIGkpID0+ICh1cGRhdGVQYWRzW051bWJlcihpKV0gPSBOdW1iZXIodikpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYWRzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgdXBkYXRlUGFkcy5mb3JFYWNoKCh2KSA9PiBwYWRzLnB1c2godikpO1xyXG5cclxuICAgIHJldHVybiB7IG1vZGU6IGF0dHJpYnV0ZXMubW9kZSwgdmFsdWUsIHBhZHMgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlcyA9IGNyZWF0ZVBhZEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUGFkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFBvb2xDb252VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBnZXRFbGVtZW50QXQsXHJcbiAgSW5kaWNlc0hlbHBlcixcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG4vLyBUT0RPOiBzdXBwb3J0OlxyXG4vLyAtIGNlaWxfbW9kZSAgICAgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfY2VpbFwiXHJcbi8vIC0gc3RvcmFnZV9vcmRlciAgICAgICAgICAgICBcInRlc3RfbWF4cG9vbF93aXRoX2FyZ21heF8yZF9wcmVjb21wdXRlZF9zdHJpZGVzXCJcclxuLy8gLSBbTWF4UG9vbF0gZGlsYXRpb25zICAgICAgIFwidGVzdF9tYXhwb29sXzJkX2RpbGF0aW9uc1wiXHJcbi8vIC0gW01heFBvb2xdIG91dHB1dFsxXSAgICAgICBcInRlc3RfbWF4cG9vbF93aXRoX2FyZ21heF8yZF9wcmVjb21wdXRlZF9wYWRzXCJcclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQgJiYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC4nKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUgPSA8QXR0cmlidXRlVHlwZSBleHRlbmRzIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyB8IE1heFBvb2xBdHRyaWJ1dGVzPihcclxuICBpbnB1dDogVGVuc29yVmlldyxcclxuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVUeXBlLFxyXG4gIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXHJcbik6IFtBdHRyaWJ1dGVUeXBlLCBudW1iZXJbXV0gPT4ge1xyXG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcclxuICBjb25zdCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QgPSBpbnB1dC5kaW1zLnNsaWNlKCk7XHJcbiAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XHJcbiAgICBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3Quc3BsaWNlKDEsIDAsIGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdC5wb3AoKSEpOyAvLyBNb3ZlIGNoYW5uZWwgdG8gdGhlIHNlY29uZCBwb3NpdGlvbi5cclxuICB9XHJcbiAgY29uc3QgaGFzRGlsYXRpb25zID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgJ2RpbGF0aW9ucycpO1xyXG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xyXG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMuc2xpY2UoKTtcclxuICBjb25zdCBkaWxhdGlvbnM6IG51bWJlcltdID0gaGFzRGlsYXRpb25zID8gKGF0dHJpYnV0ZXMgYXMgTWF4UG9vbEF0dHJpYnV0ZXMpLmRpbGF0aW9ucy5zbGljZSgpIDogW107XHJcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xyXG4gIFBvb2xDb252VXRpbC5hZGp1c3RQb29sQXR0cmlidXRlcyhpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZHMpO1xyXG5cclxuICBjb25zdCBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0ID0gUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXHJcbiAgICBpc0dsb2JhbE9wZXJhdG9yLFxyXG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LFxyXG4gICAgc3RyaWRlcyxcclxuICAgIGRpbGF0aW9ucyxcclxuICAgIGtlcm5lbFNoYXBlLFxyXG4gICAgcGFkcyxcclxuICAgIGF0dHJpYnV0ZXMuYXV0b1BhZCxcclxuICApO1xyXG5cclxuICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XHJcbiAgaWYgKGhhc0RpbGF0aW9ucykge1xyXG4gICAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzLCBkaWxhdGlvbnMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5IH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHsga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5IH0pO1xyXG4gIH1cclxuICBjb25zdCBvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3QgPSBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LnNsaWNlKCk7XHJcbiAgb3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnB1c2gob3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnNwbGljZSgxLCAxKVswXSk7XHJcbiAgcmV0dXJuIFtuZXdBdHRyaWJ1dGVzLCBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdCA6IG91dHB1dFNoYXBlQXNDaGFubmVsRmlyc3RdO1xyXG59O1xyXG5cclxuY29uc3QgZ2V0VW5pZm9ybUFuZFBhZEluZm8gPSA8QXR0cmlidXRlVHlwZSBleHRlbmRzIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyB8IE1heFBvb2xBdHRyaWJ1dGVzPihcclxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcclxuKTogW1Byb2dyYW1Vbmlmb3JtW10sIFVuaWZvcm1zQXJyYXlUeXBlLCBib29sZWFuLCBib29sZWFuLCBib29sZWFuXSA9PiB7XHJcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgY29uc3Qga2VybmVsU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga2VybmVsU2l6ZSB9LFxyXG4gIF07XHJcbiAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgeyBuYW1lOiAnb3V0cHV0U2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICB7IG5hbWU6ICdrZXJuZWxTaXplJywgdHlwZTogJ3UzMicgfSxcclxuICBdO1xyXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA8PSAyKSB7XHJcbiAgICBjb25zdCBrdyA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggLSAxXTtcclxuICAgIGNvbnN0IHN3ID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAxXTtcclxuICAgIGNvbnN0IHB3U3RhcnQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAvIDIgLSAxXTtcclxuICAgIGNvbnN0IHB3RW5kID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLSAxXTtcclxuICAgIGNvbnN0IHB3U3RhcnRFbmROb3RaZXJvID0gISEocHdTdGFydCArIHB3RW5kKTtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxyXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga3cgfSxcclxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN3IH0sXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwd1N0YXJ0IH0sXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwd0VuZCB9LFxyXG4gICAgKTtcclxuICAgIHVuaWZvcm1zLnB1c2goXHJcbiAgICAgIHsgbmFtZTogJ2t3JywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnc3cnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdwd1N0YXJ0JywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAncHdFbmQnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgcGhTdGFydEVuZE5vdFplcm8gPSBmYWxzZTtcclxuICAgIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICBjb25zdCBraCA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggLSAyXTtcclxuICAgICAgY29uc3Qgc2ggPSBhdHRyaWJ1dGVzLnN0cmlkZXNbYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAtIDJdO1xyXG4gICAgICBjb25zdCBwaFN0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMl07XHJcbiAgICAgIGNvbnN0IHBoRW5kID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLSAyXTtcclxuICAgICAgcGhTdGFydEVuZE5vdFplcm8gPSAhIShwaFN0YXJ0ICsgcGhFbmQpO1xyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga2ggfSxcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2ggfSxcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGhTdGFydCB9LFxyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwaEVuZCB9LFxyXG4gICAgICApO1xyXG5cclxuICAgICAgdW5pZm9ybXMucHVzaChcclxuICAgICAgICB7IG5hbWU6ICdraCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnc2gnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ3BoU3RhcnQnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ3BoRW5kJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgdHJ1ZSwgcHdTdGFydEVuZE5vdFplcm8sIHBoU3RhcnRFbmROb3RaZXJvXTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBrZXJuZWxTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xyXG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrZXJuZWxTdHJpZGVzIH0sXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnBhZHMgfSxcclxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlcyB9LFxyXG4gICAgKTtcclxuICAgIHVuaWZvcm1zLnB1c2goXHJcbiAgICAgIHsgbmFtZTogJ2tlcm5lbFN0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBrZXJuZWxTdHJpZGVzLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCB9LFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBoYXNQYWRzID0gYXR0cmlidXRlcy5wYWRzLnJlZHVjZSgoc3VtLCBjdXIpID0+IHN1bSArIGN1cik7XHJcbiAgICByZXR1cm4gW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsICEhaGFzUGFkcywgZmFsc2UsIGZhbHNlXTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBnZW5lcmF0ZVBvb2xpbmdDb2RlID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXHJcbiAgc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsXHJcbiAgeDogSW5kaWNlc0hlbHBlcixcclxuICByYW5rOiBudW1iZXIsXHJcbiAgb3V0cHV0U2hhcGVSYW5rOiBudW1iZXIsXHJcbiAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcclxuICBvcDE6IHN0cmluZyxcclxuICBvcDI6IHN0cmluZyxcclxuICBzdGFydDogbnVtYmVyLFxyXG4gIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSxcclxuICBoYXNQYWRzOiBib29sZWFuLFxyXG4gIHB3U3RhcnRFbmROb3RaZXJvOiBib29sZWFuLFxyXG4gIHBoU3RhcnRFbmROb3RaZXJvOiBib29sZWFuLFxyXG4pOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcclxuICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgeC50eXBlLnRlbnNvciwgb3V0cHV0U2hhcGVSYW5rKTtcclxuXHJcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIDw9IDIpIHtcclxuICAgIGxldCBjb2RlVyA9ICcnO1xyXG4gICAgbGV0IGNvZGVIID0gJyc7XHJcbiAgICBsZXQgY29kZUhFbmQgPSAnJztcclxuICAgIGNvbnN0IGRpbUlkeFcgPSByYW5rIC0gKGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDEpO1xyXG4gICAgaWYgKHB3U3RhcnRFbmROb3RaZXJvKSB7XHJcbiAgICAgIGNvZGVXID0gYFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4V31dID0gaW5kaWNlc1ske2RpbUlkeFd9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske2RpbUlkeFd9XSA8IDAgfHwgeEluZGljZXNbJHtkaW1JZHhXfV1cclxuICAgICAgICAgICAgICAgICAgICAgID49IHVuaWZvcm1zLnhfc2hhcGVbJHtkaW1JZHhXfV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWQrKztcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7eC5pbmRpY2VzVG9PZmZzZXQoJ3hJbmRpY2VzJyl9XTtcclxuICAgICAgICAgICAgICAgICAgJHtvcDF9XHJcbiAgICAgICAgICAgICAgICB9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvZGVXID0gYFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4V31dID0gaW5kaWNlc1ske2RpbUlkeFd9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XHJcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xyXG4gICAgICAgICAgICAgICAgICAke29wMX1cclxuICAgICAgICAgICAgICAgIH1gO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICBjb25zdCBkaW1JZHhIID0gcmFuayAtIChpc0NoYW5uZWxzTGFzdCA/IDMgOiAyKTtcclxuICAgICAgaWYgKHBoU3RhcnRFbmROb3RaZXJvKSB7XHJcbiAgICAgICAgY29kZUggPSBgXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhIfV0gPSBpbmRpY2VzWyR7ZGltSWR4SH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcclxuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7ZGltSWR4SH1dIDwgMCB8fCB4SW5kaWNlc1ske2RpbUlkeEh9XSA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7ZGltSWR4SH1dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBgO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvZGVIID0gYFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4SH1dID0gaW5kaWNlc1ske2RpbUlkeEh9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XHJcbiAgICAgICAgICAgICAgICBgO1xyXG4gICAgICB9XHJcbiAgICAgIGNvZGVIRW5kID0gYFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxyXG5cclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxyXG5cclxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcblxyXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KCR7c3RhcnR9KTtcclxuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcclxuICAgICAgICAgICAgICAke2NvZGVIfVxyXG4gICAgICAgICAgICAgICR7Y29kZVd9XHJcbiAgICAgICAgICAgICAgJHtjb2RlSEVuZH1cclxuICAgICAgICAgICAgICAke29wMn1cclxuXHJcbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoaXNDaGFubmVsc0xhc3QpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0cmlkZXNSYW5rID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGg7XHJcbiAgICBjb25zdCBwYWRzUmFuayA9IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGg7XHJcbiAgICBsZXQgcGFkQ29kZSA9ICcnO1xyXG4gICAgaWYgKGhhc1BhZHMpIHtcclxuICAgICAgcGFkQ29kZSA9IGBcclxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBhZCsrO1xyXG4gICAgICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7eC5pbmRpY2VzVG9PZmZzZXQoJ3hJbmRpY2VzJyl9XTtcclxuICAgICAgICAgICAgICAgICR7b3AxfVxyXG4gICAgICAgICAgICAgIH1gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGFkQ29kZSA9IGBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XHJcbiAgICAgICAgICAgICAgJHtvcDF9XHJcbiAgICAgICAgICAgIGA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxyXG5cclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxyXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuXHJcbiAgICAgICAgICAgICAgdmFyIG9mZnNldHM6IGFycmF5PHUzMiwgJHtzdHJpZGVzUmFua30+O1xyXG5cclxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgke3N0YXJ0fSk7XHJcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XHJcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua2VybmVsU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7c3RyaWRlc1JhbmsgLSAxfXU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gb2Zmc2V0IC8gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmtlcm5lbFN0cmlkZXMnLCAnaicsIHN0cmlkZXNSYW5rKX07XHJcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICogJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmtlcm5lbFN0cmlkZXMnLCAnaicsIHN0cmlkZXNSYW5rKX07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7c3RyaWRlc1JhbmsgLSAxfV0gPSBvZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke3JhbmsgLSBzdHJpZGVzUmFua311OyBqIDwgJHtyYW5rfXU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiAke2dldEVsZW1lbnRBdChcclxuICAgICAgICAgICAgICAgICAgICAndW5pZm9ybXMuc3RyaWRlcycsXHJcbiAgICAgICAgICAgICAgICAgICAgYGogLSAke3JhbmsgLSBzdHJpZGVzUmFua311YCxcclxuICAgICAgICAgICAgICAgICAgICBzdHJpZGVzUmFuayxcclxuICAgICAgICAgICAgICAgICAgKX1cclxuICAgICAgICAgICAgICAgICAgICArIG9mZnNldHNbaiAtICR7cmFuayAtIHN0cmlkZXNSYW5rfXVdIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCAnaiAtIDJ1JywgcGFkc1JhbmspfTtcclxuICAgICAgICAgICAgICAgICAgJHtwYWRDb2RlfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAke29wMn1cclxuXHJcbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0QXR0cmlidXRlcyB7XHJcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQycgfCAnTkNIVyc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUG9vbENvbW1vbkF0dHJpYnV0ZXMgZXh0ZW5kcyBGb3JtYXRBdHRyaWJ1dGVzIHtcclxuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XHJcbiAgcmVhZG9ubHkgY2VpbE1vZGU6IG51bWJlcjtcclxuICByZWFkb25seSBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XHJcbiAgcmVhZG9ubHkgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XHJcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XHJcbn1cclxuXHJcbmNvbnN0IGNyZWF0ZVNoYWRlcktleUZyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFBvb2xDb21tb25BdHRyaWJ1dGVzKTogc3RyaW5nID0+XHJcbiAgYCR7YXR0cmlidXRlcy5mb3JtYXR9OyR7YXR0cmlidXRlcy5jZWlsTW9kZX07JHthdHRyaWJ1dGVzLmF1dG9QYWR9OyR7YXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGh9YDtcclxuXHJcbmNvbnN0IGNyZWF0ZUF2ZXJhZ2VQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzKTogc3RyaW5nID0+XHJcbiAgYCR7Y3JlYXRlU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyl9OyR7YXR0cmlidXRlcy5jb3VudEluY2x1ZGVQYWR9YDtcclxuXHJcbmNvbnN0IGNyZWF0ZU1heFBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyk6IHN0cmluZyA9PlxyXG4gIGAke2NyZWF0ZVNoYWRlcktleUZyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpfTske2F0dHJpYnV0ZXMuc3RvcmFnZU9yZGVyfTske2F0dHJpYnV0ZXMuZGlsYXRpb25zfWA7XHJcblxyXG5jb25zdCBwYXJzZVBvb2xDb21tb25BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUG9vbENvbW1vbkF0dHJpYnV0ZXMgPT4gKHtcclxuICBmb3JtYXQ6IGF0dHJpYnV0ZXMuZm9ybWF0IGFzIEZvcm1hdEF0dHJpYnV0ZXNbJ2Zvcm1hdCddLFxyXG4gIGF1dG9QYWQ6IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW2F0dHJpYnV0ZXMuYXV0b19wYWQgYXMgbnVtYmVyXSxcclxuICBjZWlsTW9kZTogYXR0cmlidXRlcy5jZWlsX21vZGUgYXMgbnVtYmVyLFxyXG4gIGtlcm5lbFNoYXBlOiBhdHRyaWJ1dGVzLmtlcm5lbF9zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxyXG4gIHN0cmlkZXM6IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdLFxyXG4gIHBhZHM6IGF0dHJpYnV0ZXMucGFkcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxufSk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyBleHRlbmRzIFBvb2xDb21tb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IGNvdW50SW5jbHVkZVBhZDogYm9vbGVhbjtcclxufVxyXG5cclxuY29uc3QgY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbyA9IChcclxuICBuYW1lOiBzdHJpbmcsXHJcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXHJcbiAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcclxuICBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBbYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZV0gPSBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUoXHJcbiAgICBpbnB1dCxcclxuICAgIGF0dHJpYnV0ZXMsXHJcbiAgICBpc0dsb2JhbE9wZXJhdG9yLFxyXG4gICk7XHJcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcy5sZW5ndGgpO1xyXG4gIGNvbnN0IGRhdGFUeXBlID0geC50eXBlLnZhbHVlO1xyXG5cclxuICBjb25zdCBvcDEgPSAndmFsdWUgKz0geF92YWw7JztcclxuICBsZXQgb3AyID0gJyc7XHJcbiAgaWYgKGFkanVzdGVkQXR0cmlidXRlcy5jb3VudEluY2x1ZGVQYWQpIHtcclxuICAgIG9wMiArPSBgdmFsdWUgLz0gJHtkYXRhVHlwZX0odW5pZm9ybXMua2VybmVsU2l6ZSk7YDtcclxuICB9IGVsc2Uge1xyXG4gICAgb3AyICs9IGB2YWx1ZSAvPSAke2RhdGFUeXBlfShpMzIodW5pZm9ybXMua2VybmVsU2l6ZSkgLSBwYWQpO2A7XHJcbiAgfVxyXG4gIGNvbnN0IFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCBoYXNQYWRzLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dID0gZ2V0VW5pZm9ybUFuZFBhZEluZm8oXHJcbiAgICBvdXRwdXRTaGFwZSxcclxuICAgIGFkanVzdGVkQXR0cmlidXRlcyxcclxuICApO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0LmRpbXMsIG91dHB1dFNoYXBlKSk7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZSxcclxuICAgIHNoYWRlckNhY2hlOiB7XHJcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aGFzUGFkc307JHtwd1N0YXJ0RW5kTm90WmVyb307JHtwaFN0YXJ0RW5kTm90WmVyb31gLFxyXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcclxuICAgIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0LmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XHJcbiAgICAgIGdlbmVyYXRlUG9vbGluZ0NvZGUoXHJcbiAgICAgICAgc2hhZGVySGVscGVyLFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgaW5wdXQuZGltcy5sZW5ndGgsXHJcbiAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoLFxyXG4gICAgICAgIGFkanVzdGVkQXR0cmlidXRlcyxcclxuICAgICAgICBvcDEsXHJcbiAgICAgICAgb3AyLFxyXG4gICAgICAgIDAuMCxcclxuICAgICAgICB1bmlmb3JtcyxcclxuICAgICAgICBoYXNQYWRzLFxyXG4gICAgICAgIHB3U3RhcnRFbmROb3RaZXJvLFxyXG4gICAgICAgIHBoU3RhcnRFbmROb3RaZXJvLFxyXG4gICAgICApLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IGNvdW50SW5jbHVkZVBhZCA9IChhdHRyaWJ1dGVzLmNvdW50X2luY2x1ZGVfcGFkIGFzIG51bWJlcikgPT09IDAgPyBmYWxzZSA6IHRydWU7XHJcblxyXG4gIGNvbnN0IGF0dHIgPSBwYXJzZVBvb2xDb21tb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xyXG4gIC8vIFRPRE86IHN1cHBvcnQgYXR0cmlidXRlICdjZWlsX21vZGUnXHJcbiAgaWYgKGF0dHIuY2VpbE1vZGUgIT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbCcpO1xyXG4gIH1cclxuICBjb25zdCBhdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSB7IGNvdW50SW5jbHVkZVBhZCwgLi4uYXR0ciwgY2FjaGVLZXk6ICcnIH07XHJcbiAgcmV0dXJuIHsgLi4uYXZlcmFnZVBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogY3JlYXRlQXZlcmFnZVBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdmVyYWdlUG9vbEF0dHJpYnV0ZXMpIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXZlcmFnZVBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgZmFsc2UsIGF0dHJpYnV0ZXMpKTtcclxufTtcclxuXHJcbmNvbnN0IGdsb2JhbFBvb2xBdHRyaWJ1dGVzID0ge1xyXG4gIGF1dG9QYWQ6ICcnLFxyXG4gIGNlaWxNb2RlOiAwLFxyXG4gIGNvdW50SW5jbHVkZVBhZDogZmFsc2UsXHJcbiAga2VybmVsU2hhcGU6IFtdLFxyXG4gIHN0cmlkZXM6IFtdLFxyXG4gIHBhZHM6IFtdLFxyXG4gIHN0b3JhZ2VPcmRlcjogMCxcclxuICBkaWxhdGlvbnM6IFtdLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXTtcclxuICByZXR1cm4geyBmb3JtYXQsIC4uLmdsb2JhbFBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogZm9ybWF0IH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2xvYmFsQXZlcmFnZVBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbygnR2xvYmFsQXZlcmFnZVBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgdHJ1ZSwgYXR0cmlidXRlcykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXhQb29sQXR0cmlidXRlcyBleHRlbmRzIFBvb2xDb21tb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IHN0b3JhZ2VPcmRlcjogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IGRpbGF0aW9uczogbnVtYmVyW107XHJcbn1cclxuXHJcbmNvbnN0IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyA9IChcclxuICBuYW1lOiBzdHJpbmcsXHJcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXHJcbiAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcclxuICBhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShcclxuICAgIGlucHV0LFxyXG4gICAgYXR0cmlidXRlcyxcclxuICAgIGlzR2xvYmFsT3BlcmF0b3IsXHJcbiAgKTtcclxuICBjb25zdCBvcDEgPSBgXHJcbiAgICAgIHZhbHVlID0gbWF4KHhfdmFsLCB2YWx1ZSk7XHJcbiAgICBgO1xyXG4gIGNvbnN0IG9wMiA9ICcnO1xyXG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMubGVuZ3RoKTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xyXG4gIGNvbnN0IFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCBoYXNQYWRzLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dID0gZ2V0VW5pZm9ybUFuZFBhZEluZm8oXHJcbiAgICBvdXRwdXRTaGFwZSxcclxuICAgIGFkanVzdGVkQXR0cmlidXRlcyxcclxuICApO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0LmRpbXMsIG91dHB1dFNoYXBlKSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWUsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2hhc1BhZHN9OyR7cHdTdGFydEVuZE5vdFplcm99OyR7cGhTdGFydEVuZE5vdFplcm99YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXMsXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dC5kYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyKSA9PlxyXG4gICAgICBnZW5lcmF0ZVBvb2xpbmdDb2RlKFxyXG4gICAgICAgIHNoYWRlckhlbHBlcixcclxuICAgICAgICB4LFxyXG4gICAgICAgIGlucHV0LmRpbXMubGVuZ3RoLFxyXG4gICAgICAgIG91dHB1dFNoYXBlLmxlbmd0aCxcclxuICAgICAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgb3AxLFxyXG4gICAgICAgIG9wMixcclxuICAgICAgICBpbnB1dC5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNiA/IC02NTUwNCA6IC0xZTUsXHJcbiAgICAgICAgdW5pZm9ybXMsXHJcbiAgICAgICAgaGFzUGFkcyxcclxuICAgICAgICBwd1N0YXJ0RW5kTm90WmVybyxcclxuICAgICAgICBwaFN0YXJ0RW5kTm90WmVybyxcclxuICAgICAgKSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG1heFBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8oJ01heFBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgZmFsc2UsIGF0dHJpYnV0ZXMpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZU1heFBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IHN0b3JhZ2VPcmRlciA9IGF0dHJpYnV0ZXMuc3RvcmFnZV9vcmRlciBhcyBudW1iZXI7XHJcbiAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgW251bWJlciwgbnVtYmVyXTtcclxuXHJcbiAgY29uc3QgYXR0ciA9IHBhcnNlUG9vbENvbW1vbkF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XHJcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZScgYW5kICdzdG9yYWdlX29yZGVyJ1xyXG4gIGlmIChzdG9yYWdlT3JkZXIgIT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcclxuICB9XHJcbiAgaWYgKGF0dHIuY2VpbE1vZGUgIT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sJyk7XHJcbiAgfVxyXG4gIGNvbnN0IG1heFBvb2xBdHRyaWJ1dGVzID0geyBzdG9yYWdlT3JkZXIsIGRpbGF0aW9ucywgLi4uYXR0ciwgY2FjaGVLZXk6ICcnIH07XHJcbiAgcmV0dXJuIHsgLi4ubWF4UG9vbEF0dHJpYnV0ZXMsIGNhY2hlS2V5OiBjcmVhdGVNYXhQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMobWF4UG9vbEF0dHJpYnV0ZXMpIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VHbG9iYWxNYXhQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1heFBvb2xBdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXTtcclxuICByZXR1cm4geyBmb3JtYXQsIC4uLmdsb2JhbFBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogZm9ybWF0IH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2xvYmFsTWF4UG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbygnR2xvYmFsTWF4UG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCB0cnVlLCBhdHRyaWJ1dGVzKSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIGdldE1heENvbXBvbmVudHMsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICBheGlzOiBudW1iZXI7XHJcbiAgYmxvY2tTaXplOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPCAyIHx8IGlucHV0cy5sZW5ndGggPiAzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcXVhbnRpemVMaW5lYXIgcmVxdWlyZXMgMiBvciAzIGlucHV0cy4nKTtcclxuICB9XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzFdLmRpbXMgPT09IGlucHV0c1syXS5kaW1zKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3gtc2NhbGUgYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuJyk7XHJcbiAgfVxyXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzJdLmRhdGFUeXBlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLicpO1xyXG4gIH1cclxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMiAmJiBpbnB1dHMubGVuZ3RoID4gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC4nKTtcclxuICB9XHJcbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMCAmJiBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEgJiYgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGUgaW5wdXQgbXVzdCBiZSBhIHNjYWxhciwgYSAxRCB0ZW5zb3IsIG9yIGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yLicpO1xyXG4gIH1cclxuICAvLyB2YWxpZGF0ZSBzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dCBzaGFwZXNcclxuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDIpIHtcclxuICAgIC8vIHplcm8tcG9pbnQgaW5wdXQgdHlwZSBzaG91bGQgYmUgdGhlIHNhbWUgYXMgaW5wdXQgZGF0YSB0eXBlLlxyXG4gICAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzJdLmRhdGFUeXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigneCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBTY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlXHJcbiAgICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMl0uZGltcy5sZW5ndGgpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlucHV0c1sxXS5kaW1zLm1hcCgoZCwgaSkgPT4gZCA9PT0gaW5wdXRzWzJdLmRpbXNbaV0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIFZhbGlkYXRlIGJsb2NrU2l6ZVxyXG4gIGlmIChhdHRyaWJ1dGVzLmJsb2NrU2l6ZSA+IDApIHtcclxuICAgIC8vIEJsb2NrIHF1bmF0aXphdGlvblxyXG4gICAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCA9PT0gMCB8fCAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoID09PSAxICYmIGlucHV0c1sxXS5kaW1zWzBdID09PSAxKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NrU2l6ZSBtdXN0IGJlIHNldCBvbmx5IGZvciBibG9jayBxdWFudGl6YXRpb24uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoXHJcbiAgICAgICFpbnB1dHNbMV0uZGltcy5tYXAoKGQsIGkpID0+IGkgPT09IGF0dHJpYnV0ZXMuYXhpcyB8fCBkID09PSBpbnB1dHNbMF0uZGltc1tpXSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgYmxvY2sgcXVuYXRpemF0aW9uLCBzY2FsZSBpbnB1dCBzaGFwZSB0byBtYXRjaCB0aGUgaW5wdXQgc2hhcGUgZXhjZXB0IGZvciB0aGUgYXhpcycpO1xyXG4gICAgfVxyXG4gICAgLy8gU2NhbGUgaW5wdXQgcmFuayBzaG91bGQgYmUgc2FtZSBhcyB0aGUgaW5wdXQgcmFua1xyXG4gICAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIGJsb2NrIHF1bmF0aXphdGlvbiB0aGUgc2NhbGUgaW5wdXQgcmFuayBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSB4IHJhbmsuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkSSA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuYXhpc107XHJcbiAgICBjb25zdCBzaSA9IGlucHV0c1sxXS5kaW1zW2F0dHJpYnV0ZXMuYXhpc107XHJcbiAgICBpZiAoYXR0cmlidXRlcy5ibG9ja1NpemUgPCBNYXRoLmNlaWwoZEkgLyBzaSkgfHwgYXR0cmlidXRlcy5ibG9ja1NpemUgPiBNYXRoLmNlaWwoZEkgLyAoc2kgLSAxKSAtIDEpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tTaXplIG11c3QgYmUgd2l0aCBpbiB0aGUgcmFuZ2UgW2NlaWwoZEkgLyBTaSksIGNlaWwoZEkgLyAoU2kgLSAxKSAtIDEpXS4nKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVEZXF1YW50aXplTGluZWFyUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogRGVxdWFudGl6ZUxpbmVyQXR0cmlidXRlcyxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XHJcbiAgY29uc3QgaW5wdXRUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xyXG4gIGNvbnN0IGlzU2lnbmVkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ4O1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7IC8vIG91dHB1dCBzaGFwZSBpcyBzYW1lIGFzIHRoZSBpbnB1dCBzaGFwZVxyXG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzFdLmRhdGFUeXBlOyAvLyBvdXRwdXQgdHlwZSBpcyBzYW1lIGFzIHRoZSB0aGUgc2NhbGUgaW5wdXQgdHlwZVxyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgY29uc3QgaXNQYWNrZWQgPSBpbnB1dFR5cGUgPT09IERhdGFUeXBlLmludDggfHwgaW5wdXRUeXBlID09PSBEYXRhVHlwZS51aW50ODtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaXNQYWNrZWQgPyBbTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGlucHV0c1swXS5kaW1zKSAvIDQpXSA6IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IHNjYWxlU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcclxuICBjb25zdCB6ZXJvUG9pbnRJbnB1dCA9IGlucHV0cy5sZW5ndGggPiAyID8gaW5wdXRzWzJdIDogdW5kZWZpbmVkO1xyXG4gIGNvbnN0IHplcm9Qb2ludFNoYXBlID0gemVyb1BvaW50SW5wdXRcclxuICAgID8gaXNQYWNrZWRcclxuICAgICAgPyBbTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKHplcm9Qb2ludElucHV0LmRpbXMpIC8gNCldXHJcbiAgICAgIDogemVyb1BvaW50SW5wdXQuZGltc1xyXG4gICAgOiB1bmRlZmluZWQ7XHJcbiAgLy8gU2NhbGVzIGlucHV0IGlzIGEgc2NhbGVyIGZvciBwZXItdGVuc29yL3Blci1sYXllciBxdWFudGl6YXRpb24sIDEtRCB0ZW5zb3IgZm9yIHBlci1heGlzIHF1YW50aXphdGlvblxyXG4gIC8vIG9yIHRlbnNvciB3aXRoIHNhbWUgcmFuayBhcyBpbnB1dCBmb3IgYmxvY2tlZCBxdWFudGl6YXRpb24uXHJcbiAgY29uc3QgcGVyTGF5ZXJRdWFudGl6YXRpb24gPSBzY2FsZVNoYXBlLmxlbmd0aCA9PT0gMCB8fCAoc2NhbGVTaGFwZS5sZW5ndGggPT09IDEgJiYgc2NhbGVTaGFwZVswXSA9PT0gMSk7XHJcbiAgY29uc3QgcGVyQXhpc1F1YW50aXphdGlvbiA9IHBlckxheWVyUXVhbnRpemF0aW9uID09PSBmYWxzZSAmJiBzY2FsZVNoYXBlLmxlbmd0aCA9PT0gMTtcclxuICAvLyBMZWZ0IHVubmVjZXNzYXJ5IGNvbW1lbnRlZC1vdXQgYXNzaWdubWVudCBmb3IgZG9jdW1lbnRhdGlvblxyXG4gIC8vIGNvbnN0IGJsb2NrUXVhbnRpemF0aW9uID0gcGVyTGF5ZXJRdWFudGl6YXRpb24gPT09IGZhbHNlICYmIHBlckF4aXNRdWFudGl6YXRpb24gPT09IGZhbHNlO1xyXG4gIGNvbnN0IG1heENvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKG91dHB1dFNpemUpO1xyXG4gIGNvbnN0IHVzZUNvbXBvbmVudHMgPSBwZXJMYXllclF1YW50aXphdGlvbiAmJiAoIWlzUGFja2VkIHx8IG1heENvbXBvbmVudHMgPT09IDQpO1xyXG4gIGNvbnN0IGNvbXBvbmVudHMgPSB1c2VDb21wb25lbnRzID8gbWF4Q29tcG9uZW50cyA6IDE7XHJcbiAgY29uc3QgaW5wdXRDb21wb25lbnQgPSB1c2VDb21wb25lbnRzICYmICFpc1BhY2tlZCA/IG1heENvbXBvbmVudHMgOiAxO1xyXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpc1BhY2tlZCA/IERhdGFUeXBlLnVpbnQzMiA6IGlucHV0VHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGlucHV0Q29tcG9uZW50KTtcclxuICBjb25zdCBzY2FsZSA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgZGF0YVR5cGUsIHNjYWxlU2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCB6ZXJvUG9pbnQgPSB6ZXJvUG9pbnRJbnB1dFxyXG4gICAgPyBpbnB1dFZhcmlhYmxlKCd6ZXJvX3BvaW50JywgaXNQYWNrZWQgPyBEYXRhVHlwZS51aW50MzIgOiBpbnB1dFR5cGUsIHplcm9Qb2ludFNoYXBlIS5sZW5ndGgpXHJcbiAgICA6IHVuZGVmaW5lZDtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbaW5wdXQsIHNjYWxlXTtcclxuICBpZiAoemVyb1BvaW50KSB7XHJcbiAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKHplcm9Qb2ludCk7XHJcbiAgfVxyXG4gIGNvbnN0IGlucHV0U2hhcGVzID0gW2lucHV0U2hhcGUsIHNjYWxlU2hhcGVdO1xyXG4gIGlmICh6ZXJvUG9pbnRJbnB1dCkge1xyXG4gICAgaW5wdXRTaGFwZXMucHVzaCh6ZXJvUG9pbnRTaGFwZSEpO1xyXG4gIH1cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSAvIGNvbXBvbmVudHMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5ibG9ja1NpemUgfSxcclxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKC4uLmlucHV0U2hhcGVzLCBvdXRwdXRTaGFwZSksXHJcbiAgXTtcclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdheGlzJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYmxvY2tfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cclxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG5cclxuICAgICAgICAgIC8vIFNldCBpbnB1dCB4XHJcbiAgICAgICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHggLyA0Jyl9O1xyXG4gICAgICAgICAgICBsZXQgeF92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgoaW5wdXQpJyA6ICd1bnBhY2s0eFU4KGlucHV0KSd9O1xyXG4gICAgICAgICAgICBsZXQgeF92YWx1ZSA9ICR7Y29tcG9uZW50cyA9PT0gMSA/ICd4X3ZlY1tnbG9iYWxfaWR4ICUgNF0nIDogJ3hfdmVjJ307YDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXR1cm4gYGxldCB4X3ZhbHVlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KSgpfTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgc2NhbGUgaW5wdXRcclxuICAgICAgICAgICR7KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBlckxheWVyUXVhbnRpemF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgLy8gc2NhbGUgaW5wdXQgaXMgYSBzY2FsYXIgKClcclxuICAgICAgICAgICAgICByZXR1cm4gYGxldCBzY2FsZV92YWx1ZT0gJHtzY2FsZS5nZXRCeU9mZnNldCgnMCcpfWA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGVyQXhpc1F1YW50aXphdGlvbikge1xyXG4gICAgICAgICAgICAgIC8vIHNjYWxlIGlucHV0IGlzIGEgMUQgdGVuc29yXHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfTtcclxuICAgICAgICAgICAgbGV0IHNjYWxlX3ZhbHVlPSAke3NjYWxlLmdldEJ5T2Zmc2V0KCdzY2FsZV9pbmRleCcpfTtgO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIC8vIEJsb2NrIHF1YW50aXphdGlvbi4gU2NhbGUgaW5wdXQgcmFuayBpcyBzYW1lIGFzIGlucHV0L291dHB1dCByYW5rLlxyXG4gICAgICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgIHZhciBzY2FsZV9pbmRpY2VzOiAke3NjYWxlLnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtzY2FsZS5pbmRpY2VzR2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xyXG4gICAgICAgICAgICAke3NjYWxlLmluZGljZXNTZXQoJ3NjYWxlX2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICdpbmRleCcpfTtcclxuICAgICAgICAgICAgbGV0IHNjYWxlX3ZhbHVlPSAke3NjYWxlLmdldEJ5SW5kaWNlcygnc2NhbGVfaW5kaWNlcycpfTtgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KSgpfTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgemVyby1wb2ludCBpbnB1dFxyXG4gICAgICAgICAgJHsoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoemVyb1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHBlckxheWVyUXVhbnRpemF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB6ZXJvLXBvaW50IGlucHV0IGlzIGEgc2NhbGFyXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQYWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJzAnKX07XHJcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAgJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpJyA6ICd1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpJ307XHJcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZT0gemVyb19wb2ludF92ZWNbMF1gO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCcwJyl9YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlckF4aXNRdWFudGl6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIHplcm8tcG9pbnQgaW5wdXQgaXMgYSAxRCB0ZW5zb3JcclxuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJyl9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCAvIDQnKX07XHJcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAgJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpJyA6ICd1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpJ307XHJcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfaW5kZXggJSA0XWA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJyl9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCcpfTtgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCbG9ja2VkUXVhbnRpemF0aW9uLiBUaGUgemVyby1wb2ludCBpbnB1dCBzaGFwZSBpcyBzYW1lIGFzIHRoZSBpbnB1dCBzaGFwZSBleGNlcHQgYWxvbmcgYXhpcy5cclxuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHtzY2FsZS5pbmRpY2VzVG9PZmZzZXQoJ3NjYWxlX2luZGljZXMnKX07XHJcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X29mZnNldCAvIDQnKX07XHJcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgoemVyb19wb2ludF9pbnB1dCknIDogJ3VucGFjazR4VTgoemVyb19wb2ludF9pbnB1dCknfTtcclxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9vZmZzZXQgJSA0XTtgO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7emVyb1BvaW50LmdldEJ5SW5kaWNlcygnc2NhbGVfaW5kaWNlcycpfTtgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXR1cm4gYGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtpc1BhY2tlZCA/IChpc1NpZ25lZCA/ICdpMzInIDogJ3UzMicpIDogaW5wdXQudHlwZS52YWx1ZX0oMCk7YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSkoKX07XHJcbiAgICAgIC8vIENvbXB1dGUgYW5kIHdyaXRlIG91dHB1dFxyXG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGAke291dHB1dC50eXBlLnZhbHVlfSh4X3ZhbHVlIC0gemVyb19wb2ludF92YWx1ZSkgKiBzY2FsZV92YWx1ZWApfTtcclxuICAgICAgfWA7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0RlcXVhbnRpemVMaW5lYXInLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IHplcm9Qb2ludCA/IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXSA6IFsncmFuaycsICdyYW5rJ10sXHJcbiAgICB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gY29tcG9uZW50cyAvIDY0KSwgeTogMSwgejogMSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlcXVhbnRpemVMaW5lYXIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IERlcXVhbnRpemVMaW5lckF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZURlcXVhbnRpemVMaW5lYXJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlciwgYmxvY2tTaXplOiBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSBhcyBudW1iZXIgfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgZW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgVW5pZm9ybURhdGFFbGVtZW50VHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0c0NvbnRlbnQgPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlcik6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IHNhbWVTdGFydExpbWl0ID0gc3RhcnQgPT09IGxpbWl0O1xyXG4gIGNvbnN0IGluY3JlYXNpbmdSYW5nZU5lZ2F0aXZlU3RlcCA9IHN0YXJ0IDwgbGltaXQgJiYgZGVsdGEgPCAwO1xyXG4gIGNvbnN0IGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCA9IHN0YXJ0ID4gbGltaXQgJiYgZGVsdGEgPiAwO1xyXG5cclxuICBpZiAoc2FtZVN0YXJ0TGltaXQgfHwgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwIHx8IGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIik7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlUmFuZ2VQcm9ncmFtSW5mbyA9IChzdGFydDogbnVtYmVyLCBsaW1pdDogbnVtYmVyLCBkZWx0YTogbnVtYmVyLCBkYXRhVHlwZTogRGF0YVR5cGUpOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgbnVtRWxlbWVudHMgPSBNYXRoLmFicyhNYXRoLmNlaWwoKGxpbWl0IC0gc3RhcnQpIC8gZGVsdGEpKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbbnVtRWxlbWVudHNdO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBudW1FbGVtZW50cztcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBkYXRhVHlwZSwgZGF0YTogc3RhcnQgfSxcclxuICAgIHsgdHlwZTogZGF0YVR5cGUsIGRhdGE6IGRlbHRhIH0sXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSksXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgICBjb25zdCB3Z3NsVHlwZSA9IG91dHB1dC50eXBlLnZhbHVlO1xyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdvdXRwdXRTaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnc3RhcnQnLCB0eXBlOiB3Z3NsVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlIH0sXHJcbiAgICAgIHsgbmFtZTogJ2RlbHRhJywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxyXG4gICAgXTtcclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhvdXRwdXQpfVxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cclxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7d2dzbFR5cGV9KGdsb2JhbF9pZHgpICogdW5pZm9ybXMuZGVsdGE7XHJcbiAgICAgIH1gO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnUmFuZ2UnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7ZGF0YVR5cGV9YCB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmFuZ2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBsZXQgc3RhcnQgPSAwO1xyXG4gIGxldCBsaW1pdCA9IDA7XHJcbiAgbGV0IGRlbHRhID0gMDtcclxuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyKSB7XHJcbiAgICBzdGFydCA9IGNvbnRleHQuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXTtcclxuICAgIGxpbWl0ID0gY29udGV4dC5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdO1xyXG4gICAgZGVsdGEgPSBjb250ZXh0LmlucHV0c1syXS5nZXRJbnQzMkFycmF5KClbMF07XHJcbiAgfSBlbHNlIGlmIChjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQpIHtcclxuICAgIHN0YXJ0ID0gY29udGV4dC5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF07XHJcbiAgICBsaW1pdCA9IGNvbnRleHQuaW5wdXRzWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdO1xyXG4gICAgZGVsdGEgPSBjb250ZXh0LmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXTtcclxuICB9XHJcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQpIHtcclxuICAgIHZhbGlkYXRlSW5wdXRzQ29udGVudChzdGFydCwgbGltaXQsIGRlbHRhKTtcclxuICB9XHJcblxyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVSYW5nZVByb2dyYW1JbmZvKHN0YXJ0LCBsaW1pdCwgZGVsdGEsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKSwgeyBpbnB1dHM6IFtdIH0pO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBhdG9taWNPdXRwdXRWYXJpYWJsZSxcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNjYXR0ZXJOREF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlZHVjdGlvbjogc3RyaW5nO1xyXG59XHJcblxyXG50eXBlIFJlZHVjdGlvblR5cGUgPSAnaTMyJyB8ICd1MzInIHwgJ2YzMic7XHJcblxyXG5jb25zdCBhdG9taWNSZWR1Y3Rpb25TbmlwcGV0ID0gKHJlZHVjdGlvbjogc3RyaW5nLCBwdHI6IHN0cmluZywgdjogc3RyaW5nLCB0eXBlOiBSZWR1Y3Rpb25UeXBlKSA9PiB7XHJcbiAgaWYgKHJlZHVjdGlvbiAhPT0gJ25vbmUnICYmIHR5cGUgIT09ICdpMzInICYmIHR5cGUgIT09ICd1MzInICYmIHR5cGUgIT09ICdmMzInKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7dHlwZX0gaXMgbm90IHN1cHBvcnRlZCB3aXRoIHJlZHVjdGlvbiAke3JlZHVjdGlvbn0uYCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmbG9hdFN0YXJ0ID0gYHtcclxuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBsb29wIHtcclxuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlRjMyID1gO1xyXG4gIGNvbnN0IGZsb2F0RW5kID0gYDtcclxuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gYml0Y2FzdDxpMzI+KG5ld1ZhbHVlRjMyKTtcclxuICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsoJiR7cHRyfSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgaWYgcmVzLmV4Y2hhbmdlZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZXMub2xkX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1gO1xyXG5cclxuICBzd2l0Y2ggKHJlZHVjdGlvbikge1xyXG4gICAgY2FzZSAnbm9uZSc6XHJcbiAgICAgIHJldHVybiBgJHtwdHJ9PSR7dn07YDtcclxuICAgIGNhc2UgJ2FkZCc6XHJcbiAgICAgIGlmICh0eXBlID09PSAnaTMyJyB8fCB0eXBlID09PSAndTMyJykge1xyXG4gICAgICAgIHJldHVybiBgYXRvbWljQWRkKCYke3B0cn0sIGJpdGNhc3Q8JHt0eXBlfT4oJHt2fSkpO2A7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gYXRvbWljQWRkIG9ubHkgc3VwcG9ydHMgdWludC9pbnQgdHlwZS4gRm9yIGZsb2F0LCB3ZSB1c2VcclxuICAgICAgICAvLyBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrIHRvIHNpbXVsYXRlLlxyXG4gICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgICAgJHtmbG9hdFN0YXJ0fWJpdGNhc3Q8JHt0eXBlfT4ob2xkVmFsdWUpICsgKCR7dn0pJHtmbG9hdEVuZH1gO1xyXG4gICAgICB9XHJcbiAgICBjYXNlICdtYXgnOlxyXG4gICAgICBpZiAodHlwZSA9PT0gJ2kzMicgfHwgdHlwZSA9PT0gJ3UzMicpIHtcclxuICAgICAgICByZXR1cm4gYGF0b21pY01heCgmJHtwdHJ9LCBiaXRjYXN0PCR7dHlwZX0+KCR7dn0pKTtgO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGF0b21pY01heCBvbmx5IHN1cHBvcnRzIHVpbnQvaW50IHR5cGUuIEZvciBmbG9hdCwgd2UgdXNlXHJcbiAgICAgICAgLy8gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhayB0byBzaW11bGF0ZS5cclxuICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICAgJHtmbG9hdFN0YXJ0fW1heChiaXRjYXN0PGYzMj4ob2xkVmFsdWUpLCAoJHt2fSkpJHtmbG9hdEVuZH1gO1xyXG4gICAgICB9XHJcbiAgICBjYXNlICdtaW4nOlxyXG4gICAgICBpZiAodHlwZSA9PT0gJ2kzMicgfHwgdHlwZSA9PT0gJ3UzMicpIHtcclxuICAgICAgICByZXR1cm4gYGF0b21pY01pbigmJHtwdHJ9LCBiaXRjYXN0PCR7dHlwZX0+KCR7dn0pKTtgO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGF0b21pY01pbiBvbmx5IHN1cHBvcnRzIHVpbnQvaW50IHR5cGUuIEZvciBmbG9hdCwgd2UgdXNlXHJcbiAgICAgICAgLy8gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhayB0byBzaW11bGF0ZS5cclxuICAgICAgICByZXR1cm4gYCR7ZmxvYXRTdGFydH1taW4oYml0Y2FzdDwke3R5cGV9PihvbGRWYWx1ZSksICgke3Z9KSkke2Zsb2F0RW5kfWA7XHJcbiAgICAgIH1cclxuICAgIGNhc2UgJ211bCc6XHJcbiAgICAgIC8vIGF0b21pY011bCBpcyBub3Qgc3VwcG9ydGVkLCB3ZSB1c2UgYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhayB0byBzaW11bGF0ZS5cclxuICAgICAgcmV0dXJuIGAke2Zsb2F0U3RhcnR9KGJpdGNhc3Q8JHt0eXBlfT4ob2xkVmFsdWUpICogKCR7dn0pKSR7ZmxvYXRFbmR9YDtcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZHVjdGlvbiAke3JlZHVjdGlvbn0gaXMgbm90IHN1cHBvcnRlZC5gKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVTY2F0dGVyTkRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU2NhdHRlck5EQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xyXG4gIC8vIFRPRE86IHN1cHBvcnQgYm9vbCB3aXRoIGNvbXBvbmVudHMgNC5cclxuICBjb25zdCBjb21wb25lbnRzID0gMTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oaW5kaWNlc1NoYXBlLCBpbmRpY2VzU2hhcGUubGVuZ3RoIC0gMSkgLyBjb21wb25lbnRzKTtcclxuICBjb25zdCBsYXN0SW5kZXhEaW1lbnNpb24gPSBpbmRpY2VzU2hhcGVbaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDFdO1xyXG4gIGNvbnN0IG51bVVwZGF0ZXNFbGVtZW50cyA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dFNoYXBlLCBsYXN0SW5kZXhEaW1lbnNpb24pO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGxhc3RJbmRleERpbWVuc2lvbiB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG51bVVwZGF0ZXNFbGVtZW50cyB9LFxyXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzFdLmRpbXMsIGlucHV0c1syXS5kaW1zLCBvdXRwdXRTaGFwZSksXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5kaWNlcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IHVwZGF0ZXMgPSBpbnB1dFZhcmlhYmxlKCd1cGRhdGVzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3Qgb3V0cHV0ID1cclxuICAgICAgYXR0cmlidXRlcy5yZWR1Y3Rpb24gIT09ICdub25lJyAmJiBhdHRyaWJ1dGVzLnJlZHVjdGlvbiAhPT0gJydcclxuICAgICAgICA/IGF0b21pY091dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aClcclxuICAgICAgICA6IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAgICAgJHtzaGFkZXJIZWxwZXJcclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKVxyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2xhc3RfaW5kZXhfZGltZW5zaW9uJywgJ3UzMicpXHJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnbnVtX3VwZGF0ZXNfZWxlbWVudHMnLCAndTMyJylcclxuICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbmRpY2VzLCB1cGRhdGVzLCBvdXRwdXQpfVxyXG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG4gIHZhciBkYXRhX29mZnNldCA9IDB1O1xyXG4gIGxldCBpbmRpY2VzX3N0YXJ0ID0gdW5pZm9ybXMubGFzdF9pbmRleF9kaW1lbnNpb24gKiBnbG9iYWxfaWR4O1xyXG4gIGxldCBpbmRpY2VzX2VuZCA9IGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbjtcclxuICBmb3IgKHZhciBpID0gaW5kaWNlc19zdGFydDsgaSA8IGluZGljZXNfZW5kOyBpKyspIHtcclxuICAgIHZhciBpbmRleCA9IGkzMihpbmRpY2VzW2ldLngpO1xyXG4gICAgJHtcclxuICAgICAgaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAxXHJcbiAgICAgICAgPyBgXHJcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlcztcclxuICAgIGxldCBkaW1fdmFsdWUgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGU7YFxyXG4gICAgICAgIDogYFxyXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXNbaSAtIGluZGljZXNfc3RhcnRdO1xyXG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVtpIC0gaW5kaWNlc19zdGFydF07YFxyXG4gICAgfVxyXG4gICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgaWYgKGluZGV4ID49IGkzMihkaW1fdmFsdWUpKSB7XHJcbiAgICAgICAgaW5kZXggPSBpMzIoZGltX3ZhbHVlIC0gMSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChpbmRleCA8IC1pMzIoZGltX3ZhbHVlKSkge1xyXG4gICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbmRleCArPSBpMzIoZGltX3ZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGF0YV9vZmZzZXQgKz0gdTMyKCh1MzIoaW5kZXgpICogZWxlbWVudF9jb3VudF9kaW0pKTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGkgPSAwdTsgaSA8IHVuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzOyBpKyspIHtcclxuICAgIGxldCB2YWx1ZSA9IHVwZGF0ZXNbdW5pZm9ybXMubnVtX3VwZGF0ZXNfZWxlbWVudHMgKiBnbG9iYWxfaWR4ICsgaV07XHJcbiAgICAke2F0b21pY1JlZHVjdGlvblNuaXBwZXQoXHJcbiAgICAgIGF0dHJpYnV0ZXMucmVkdWN0aW9uLFxyXG4gICAgICAnb3V0cHV0W2RhdGFfb2Zmc2V0ICsgaV0nLFxyXG4gICAgICAndmFsdWUnLFxyXG4gICAgICBvdXRwdXQudHlwZS52YWx1ZSBhcyBSZWR1Y3Rpb25UeXBlLFxyXG4gICAgKX1cclxuICB9XHJcblxyXG4gICAgICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnU2NhdHRlck5EJyxcclxuICAgIHNoYWRlckNhY2hlOiB7XHJcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9XyR7YXR0cmlidXRlcy5yZWR1Y3Rpb259YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJ10sXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZVNjYXR0ZXJOREF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTY2F0dGVyTkRBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgcmVkdWN0aW9uOiBhdHRyaWJ1dGVzLnJlZHVjdGlvbiBhcyBzdHJpbmcgfSk7XHJcblxyXG5leHBvcnQgY29uc3Qgc2NhdHRlck5EID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBTY2F0dGVyTkRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNjYXR0ZXJORFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSwge1xyXG4gICAgaW5wdXRzOiBbY29udGV4dC5pbnB1dHNbMV0sIGNvbnRleHQuaW5wdXRzWzJdXSxcclxuICAgIG91dHB1dHM6IFtdLFxyXG4gIH0pO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIGdldEVsZW1lbnRBdCxcclxuICBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuXHJcbnR5cGUgQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPVxyXG4gIHwgJ2hhbGZfcGl4ZWwnXHJcbiAgfCAnYXN5bW1ldHJpYydcclxuICB8ICdweXRvcmNoX2hhbGZfcGl4ZWwnXHJcbiAgfCAndGZfaGFsZl9waXhlbF9mb3Jfbm4nXHJcbiAgfCAnYWxpZ25fY29ybmVycydcclxuICB8ICd0Zl9jcm9wX2FuZF9yZXNpemUnXHJcbiAgfCAnaGFsZl9waXhlbF9zeW1tZXRyaWMnO1xyXG5cclxudHlwZSBLZWVwQXNwZWN0UmF0aW9Qb2xpY3kgPSAnc3RyZXRjaCcgfCAnbm90X3NtYWxsZXInIHwgJ25vdF9sYXJnZXInO1xyXG5cclxudHlwZSBNb2RlID0gJ25lYXJlc3QnIHwgJ2xpbmVhcicgfCAnY3ViaWMnO1xyXG5cclxudHlwZSBOZWFyZXN0TW9kZSA9ICdyb3VuZF9wcmVmZXJfZmxvb3InIHwgJ3JvdW5kX3ByZWZlcl9jZWlsJyB8ICdmbG9vcicgfCAnY2VpbCcgfCAnc2ltcGxlJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVzaXplQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgYW50aWFsaWFzOiBudW1iZXI7XHJcbiAgYXhlczogbnVtYmVyW107XHJcbiAgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6IENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlO1xyXG4gIGN1YmljQ29lZmZBOiBudW1iZXI7XHJcbiAgZXhjbHVkZU91dHNpZGU6IGJvb2xlYW47XHJcbiAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXI7XHJcbiAga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XHJcbiAgbW9kZTogTW9kZTtcclxuICBuZWFyZXN0TW9kZTogTmVhcmVzdE1vZGU7XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlU2NhbGVzID0gKHNjYWxlczogbnVtYmVyW10sIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBzY2FsZXMuZXZlcnkoXHJcbiAgICAodmFsdWUpID0+XHJcbiAgICAgIHZhbHVlID4gMCB8fFxyXG4gICAgICAoKCkgPT4ge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmUnKTtcclxuICAgICAgfSksXHJcbiAgKTtcclxuICAvLyBDaGVjayBzY2FsZXMgZGltcyBiYXNlZCBvbiBtb2RlOiBMSU5FQVIsIENVQklDXHJcbiAgaWYgKHNjYWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAnbGluZWFyJykge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIShcclxuICAgICAgICAgIHNjYWxlcy5sZW5ndGggPT09IDIgfHxcclxuICAgICAgICAgIHNjYWxlcy5sZW5ndGggPT09IDMgfHxcclxuICAgICAgICAgIChzY2FsZXMubGVuZ3RoID09PSA0ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbMV0gPT09IDEpIHx8XHJcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKSB8fFxyXG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDUgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSlcclxuICAgICAgICApXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBGb3IgbGluZWFyIG1vZGUsIFJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgdG8gYmUgMkQsIDNELCA0RCB3aXRoIGVpdGhlciB0d28gb3V0ZXJtb3N0IG9yIG9uZSBpbm5lcm1vc3QgYW5kXHJcbiAgICAgICAgICAgIG9uZSBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDEsIG9yIDVEIHdpdGggdHdvIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMWAsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09ICdjdWJpYycpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICEoXHJcbiAgICAgICAgICBzY2FsZXMubGVuZ3RoID09PSAyIHx8XHJcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzFdID09PSAxKSB8fFxyXG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1szXSA9PT0gMSlcclxuICAgICAgICApXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgY3ViaWMgbW9kZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgdXBkYXRlU2NhbGVzID0gKHNjYWxlczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XHJcbiAgYXhlcy5ldmVyeShcclxuICAgICh2YWx1ZSkgPT5cclxuICAgICAgKHZhbHVlID49IDAgJiYgdmFsdWUgPCByYW5rKSB8fFxyXG4gICAgICAoKCkgPT4ge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIGF4ZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gcmFuaycpO1xyXG4gICAgICB9KSxcclxuICApO1xyXG4gIGNvbnN0IG5ld1NjYWxlcyA9IG5ldyBBcnJheShyYW5rKS5maWxsKDEuMCk7XHJcbiAgYXhlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IChuZXdTY2FsZXNbdmFsdWVdID0gc2NhbGVzW2luZGV4XSkpO1xyXG4gIHJldHVybiBuZXdTY2FsZXM7XHJcbn07XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzLFxyXG4gIG9wc2V0VmVyc2lvbjogbnVtYmVyLFxyXG4gIHNjYWxlczogbnVtYmVyW10sXHJcbiAgc2l6ZXM6IG51bWJlcltdLFxyXG4gIHJvaTogbnVtYmVyW10sXHJcbik6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IFtyb2lJbnB1dEluZGV4LCBzY2FsZXNJbnB1dEluZGV4LCBzaXplc0lucHV0SW5kZXhdID1cclxuICAgIG9wc2V0VmVyc2lvbiA+IDEwID8gWzEsIDIsIDNdIDogWy0xLCBpbnB1dHMubGVuZ3RoID4gMSA/IDEgOiAtMSwgLTFdO1xyXG4gIGNvbnN0IHJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XHJcbiAgaWYgKHJvaUlucHV0SW5kZXggPiAwICYmIGlucHV0cy5sZW5ndGggPiByb2lJbnB1dEluZGV4ICYmIGlucHV0c1tyb2lJbnB1dEluZGV4XS5kaW1zLmxlbmd0aCA+IDApIHtcclxuICAgIGlucHV0c1tyb2lJbnB1dEluZGV4XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gcm9pLnB1c2godmFsdWUpKTtcclxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPT09ICd0Zl9jcm9wX2FuZF9yZXNpemUnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBSb0kgaW5wdXQgdG8gYmUgc3BlY2lmaWVkIHdoZW4gY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgaXMgdGZDcm9wQW5kUmVzaXplJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoXHJcbiAgICBzY2FsZXNJbnB1dEluZGV4ID4gMCAmJlxyXG4gICAgaW5wdXRzLmxlbmd0aCA+IHNjYWxlc0lucHV0SW5kZXggJiZcclxuICAgIGlucHV0c1tzY2FsZXNJbnB1dEluZGV4XS5kaW1zLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgaW5wdXRzW3NjYWxlc0lucHV0SW5kZXhdLmRpbXNbMF0gPiAwXHJcbiAgKSB7XHJcbiAgICBpbnB1dHNbc2NhbGVzSW5wdXRJbmRleF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHNjYWxlcy5wdXNoKHZhbHVlKSk7XHJcbiAgICBpZiAoXHJcbiAgICAgIHNjYWxlcy5sZW5ndGggIT09IDAgJiZcclxuICAgICAgc2NhbGVzLmxlbmd0aCAhPT0gcmFuayAmJlxyXG4gICAgICBvcHNldFZlcnNpb24gPj0gMTggJiZcclxuICAgICAgc2NhbGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aFxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cCcpO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVTY2FsZXMoc2NhbGVzLCBhdHRyaWJ1dGVzKTtcclxuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICB1cGRhdGVTY2FsZXMoc2NhbGVzLCBhdHRyaWJ1dGVzLmF4ZXMsIHJhbmspLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4gKHNjYWxlc1tpbmRleF0gPSB2YWx1ZSkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoXHJcbiAgICBzaXplc0lucHV0SW5kZXggPiAwICYmXHJcbiAgICBpbnB1dHMubGVuZ3RoID4gc2l6ZXNJbnB1dEluZGV4ICYmXHJcbiAgICBpbnB1dHNbc2l6ZXNJbnB1dEluZGV4XS5kaW1zLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgaW5wdXRzW3NpemVzSW5wdXRJbmRleF0uZGltc1swXSA+IDBcclxuICApIHtcclxuICAgIGlucHV0c1tzaXplc0lucHV0SW5kZXhdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gc2l6ZXMucHVzaChOdW1iZXIodmFsdWUpKSk7XHJcbiAgICBpZiAoc2l6ZXMubGVuZ3RoICE9PSAwICYmIHNpemVzLmxlbmd0aCAhPT0gcmFuayAmJiBvcHNldFZlcnNpb24gPj0gMTggJiYgc2l6ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDApIHtcclxuICAgIGlmIChzY2FsZXMubGVuZ3RoICE9PSAwICYmIHNjYWxlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtcclxuICAgIH1cclxuICAgIGlmIChzaXplcy5sZW5ndGggIT09IDAgJiYgc2l6ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAodHlwZW9mIHNjYWxlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHNpemVzICE9PSAndW5kZWZpbmVkJyAmJiBzY2FsZXMubGVuZ3RoID4gMCAmJiBzaXplcy5sZW5ndGggPiByYW5rKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBvbmx5IG9mIHNjYWxlcyBvciBzaXplcyB0byBiZSBzcGVjaWZpZWQnKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBnZXRTYWZlSW50ZWdlckRpdmlzaW9uID0gKGE6IHN0cmluZywgYjogc3RyaW5nLCBjOiBzdHJpbmcsIGRUeXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4gYFxyXG4gIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcclxuICAvLyBwb2ludCBkaXZpc2lvbi4gQXMgYW4gZXhhbXBsZSwgZjMyKDIxKSAvIGYzMig3KSBtYXkgZXZhbHVhdGUgdG8gMi45OS4uLiBpbnN0ZWFkIG9mIDMsIGNhdXNpbmcgYW5cclxuICAvLyBvZmZzZXQtYnktb25lIGVycm9yIGxhdGVyIGluIGZsb29yKCkuXHJcbiAgbGV0IGJpZyA9ICgke2F9KSAqICgke2J9KTtcclxuICBsZXQgd2hvbGUgPSAke2RUeXBlfShiaWcgLyAoJHtjfSkpO1xyXG4gIGxldCBmcmFjdCA9ICR7ZFR5cGV9KGJpZyAlICgke2N9KSkgLyAke2RUeXBlfSgke2N9KTtcclxuICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcclxuYDtcclxuXHJcbmNvbnN0IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSA9IChcclxuICBjb29yZGluYXRlVHJhbnNmZXJNb2RlOiBDb29yZGluYXRlVHJhbnNmb3JtTW9kZSxcclxuICBkVHlwZTogc3RyaW5nLFxyXG4pOiBzdHJpbmcgPT5cclxuICBgZm4gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKHhSZXNpemVkOiB1MzIsIHhTY2FsZTogZjMyLCBsZW5ndGhSZXNpemVkOiB1MzIsXHJcbiAgICAgbGVuZ3RoT3JpZ2luYWw6IHUzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+ICR7ZFR5cGV9IHsgYCArXHJcbiAgKCgpID0+IHtcclxuICAgIHN3aXRjaCAoY29vcmRpbmF0ZVRyYW5zZmVyTW9kZSkge1xyXG4gICAgICBjYXNlICdhc3ltbWV0cmljJzpcclxuICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgaWYgKHhTY2FsZSA8IDEuMCB8fCBmbG9vcih4U2NhbGUpICE9IHhTY2FsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJHtkVHlwZX0oeFJlc2l6ZWQpIC8gJHtkVHlwZX0oeFNjYWxlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICR7Z2V0U2FmZUludGVnZXJEaXZpc2lvbigneFJlc2l6ZWQnLCAnbGVuZ3RoT3JpZ2luYWwnLCAnbGVuZ3RoUmVzaXplZCcsIGRUeXBlKX1cclxuICAgICAgICAgIH1cclxuICAgICAgICBgO1xyXG4gICAgICBjYXNlICdweXRvcmNoX2hhbGZfcGl4ZWwnOlxyXG4gICAgICAgIHJldHVybiBgaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKSAtIDAuNTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xyXG4gICAgICAgICAgICAgICAgICB9YDtcclxuICAgICAgY2FzZSAndGZfaGFsZl9waXhlbF9mb3Jfbm4nOlxyXG4gICAgICAgIHJldHVybiBgcmV0dXJuICgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKTtgO1xyXG4gICAgICBjYXNlICdhbGlnbl9jb3JuZXJzJzpcclxuICAgICAgICByZXR1cm4gYGlmIChsZW5ndGhSZXNpemVkID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICR7Z2V0U2FmZUludGVnZXJEaXZpc2lvbigneFJlc2l6ZWQnLCAnbGVuZ3RoT3JpZ2luYWwgLSAxJywgJ2xlbmd0aFJlc2l6ZWQgLSAxJywgZFR5cGUpfVxyXG4gICAgICAgICAgICAgICAgICB9YDtcclxuICAgICAgY2FzZSAndGZfY3JvcF9hbmRfcmVzaXplJzpcclxuICAgICAgICByZXR1cm4gYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAke2RUeXBlfShyb2lTdGFydCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCR7ZFR5cGV9KHhSZXNpemVkKSAqICR7ZFR5cGV9KHJvaUVuZCAtIHJvaVN0YXJ0KSAqICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsIC0gMSkpIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgJHtkVHlwZX0obGVuZ3RoUmVzaXplZCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke2RUeXBlfShyb2lTdGFydCArIHJvaUVuZCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICB9YDtcclxuICAgICAgY2FzZSAnaGFsZl9waXhlbF9zeW1tZXRyaWMnOlxyXG4gICAgICAgIHJldHVybiBgY29uc3Qgb3V0cHV0V2lkdGggPSAke2RUeXBlfXhTY2FsZSAqICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gJHtkVHlwZX0obGVuZ3RoUmVzaXplZCkgLyBvdXRwdXRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArICgoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkpIC0gMC41O2A7XHJcbiAgICAgIGNhc2UgJ2hhbGZfcGl4ZWwnOlxyXG4gICAgICAgIHJldHVybiBgcmV0dXJuICgoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkpIC0gMC41O2A7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb29yZGluYXRlIHRyYW5zZm9ybSBtb2RlICR7Y29vcmRpbmF0ZVRyYW5zZmVyTW9kZX0gaXMgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgfVxyXG4gIH0pKCkgK1xyXG4gICd9JztcclxuXHJcbmNvbnN0IGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbCA9IChuZWFyZXN0TW9kZTogTmVhcmVzdE1vZGUsIG9wc2V0VmVyc2lvbjogbnVtYmVyLCBkVHlwZTogc3RyaW5nKTogc3RyaW5nID0+XHJcbiAgYGZuIGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbCh4T3JpZ2luYWw6ICR7ZFR5cGV9LCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+ICR7ZFR5cGV9IHtgICtcclxuICAoKCkgPT4ge1xyXG4gICAgc3dpdGNoIChuZWFyZXN0TW9kZSkge1xyXG4gICAgICBjYXNlICdyb3VuZF9wcmVmZXJfY2VpbCc6XHJcbiAgICAgICAgcmV0dXJuICdpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgXFxcclxuICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgXFxcclxuICAgICAgICAgIH0gZWxzZSB7IFxcXHJcbiAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxyXG4gICAgICAgICAgfSc7XHJcbiAgICAgIGNhc2UgJ2Zsb29yJzpcclxuICAgICAgICByZXR1cm4gJ3JldHVybiBmbG9vcih4T3JpZ2luYWwpOyc7XHJcbiAgICAgIGNhc2UgJ2NlaWwnOlxyXG4gICAgICAgIHJldHVybiAncmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsnO1xyXG4gICAgICBjYXNlICdyb3VuZF9wcmVmZXJfZmxvb3InOlxyXG4gICAgICAgIHJldHVybiAnaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7IFxcXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7IFxcXHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxcXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7IFxcXHJcbiAgICAgICAgICAgICAgICAgIH0nO1xyXG4gICAgICBjYXNlICdzaW1wbGUnOlxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGlmIChvcHNldFZlcnNpb24gPCAxMSkge1xyXG4gICAgICAgICAgcmV0dXJuICdpZiAoaXNEb3duU2FtcGxlKSBcXFxyXG4gICAgICAgICAgICAgICAgICAgIHsgXFxcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7IFxcXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgXFxcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7IFxcXHJcbiAgICAgICAgICAgICAgICAgICAgfSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7bmVhcmVzdE1vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcclxuICAgIH1cclxuICB9KSgpICtcclxuICAnfSc7XHJcblxyXG5jb25zdCB1cGRhdGVSb0kgPSAocm9pOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcclxuICBjb25zdCByb2lUbXAgPSBuZXcgQXJyYXkocmFuaykuZmlsbCgwKS5jb25jYXQobmV3IEFycmF5KHJhbmspLmZpbGwoMSkpO1xyXG4gIGNvbnN0IHJvaUxvY2FsID0gcm9pLmxlbmd0aCA9PT0gMCA/IHJvaVRtcCA6IHJvaS5zbGljZSgpO1xyXG4gIGlmIChheGVzLmxlbmd0aCA+IDApIHtcclxuICAgIGF4ZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG4gICAgICByb2lUbXBbdl0gPSByb2lMb2NhbFtpXTtcclxuICAgICAgcm9pVG1wW2kgKyByYW5rXSA9IHJvaUxvY2FsW2F4ZXMubGVuZ3RoICsgaV07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByb2lUbXA7XHJcbiAgfVxyXG4gIHJldHVybiByb2lMb2NhbDtcclxufTtcclxuXHJcbmNvbnN0IGluaXRPdXRwdXRTaGFwZSA9IChcclxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHNpemVzOiByZWFkb25seSBudW1iZXJbXSxcclxuICBheGVzOiByZWFkb25seSBudW1iZXJbXSxcclxuKTogbnVtYmVyW10gPT4ge1xyXG4gIGxldCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcclxuICBpZiAoc2l6ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgaWYgKGF4ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBpbnB1dFNoYXBlLmZvckVhY2goKHYpID0+IG91dHB1dFNoYXBlLnB1c2godikpO1xyXG4gICAgICBpZiAoTWF0aC5tYXgoLi4uYXhlcykgPiBpbnB1dFNoYXBlLmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXhlcyBpcyBvdXQgb2YgYm91bmQnKTtcclxuICAgICAgfVxyXG4gICAgICBheGVzLmZvckVhY2goKHYsIGkpID0+IChvdXRwdXRTaGFwZVt2XSA9IHNpemVzW2ldKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzaXplcy5mb3JFYWNoKCh2KSA9PiBvdXRwdXRTaGFwZS5wdXNoKHYpKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKHNjYWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgZWl0aGVyIHNjYWxlcyBvciBzaXplcy4nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5tYXAoKHZhbHVlLCBpbmRleCkgPT4gTWF0aC5yb3VuZCh2YWx1ZSAqIHNjYWxlc1tpbmRleF0pKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG91dHB1dFNoYXBlO1xyXG59O1xyXG5cclxuY29uc3QgYWRqdXN0T3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNjYWxlczogbnVtYmVyW10sIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMpID0+IHtcclxuICBjb25zdCBzY2FsZUluUG9saWN5ID0gKCgpID0+IHtcclxuICAgIHN3aXRjaCAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpIHtcclxuICAgICAgY2FzZSAnbm90X2xhcmdlcic6XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwXHJcbiAgICAgICAgICA/IE1hdGgubWluKC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoKGkpID0+IHNjYWxlc1tpXSksIE51bWJlci5NQVhfVkFMVUUpXHJcbiAgICAgICAgICA6IE1hdGgubWluKC4uLnNjYWxlcywgTnVtYmVyLk1BWF9WQUxVRSk7XHJcbiAgICAgIGNhc2UgJ25vdF9zbWFsbGVyJzpcclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDBcclxuICAgICAgICAgID8gTWF0aC5tYXgoLi4uYXR0cmlidXRlcy5heGVzLm1hcCgoaSkgPT4gc2NhbGVzW2ldKSwgTnVtYmVyLk1JTl9WQUxVRSlcclxuICAgICAgICAgIDogTWF0aC5tYXgoLi4uc2NhbGVzLCBOdW1iZXIuTUlOX1ZBTFVFKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlZXAgYXNwZWN0IHJhdGlvIHBvbGljeSAke2F0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5fSBpcyBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICB9XHJcbiAgfSkoKTtcclxuICBzY2FsZXMuZmlsbCgxLjAsIDAsIHNjYWxlcy5sZW5ndGgpO1xyXG4gIGNvbnN0IGFkanVzdGVkT3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XHJcbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBhdHRyaWJ1dGVzLmF4ZXMuZm9yRWFjaCgodikgPT4gKHNjYWxlc1t2XSA9IHNjYWxlSW5Qb2xpY3kpKTtcclxuICAgIGF0dHJpYnV0ZXMuYXhlcy5mb3JFYWNoKCh2KSA9PiAoYWRqdXN0ZWRPdXRwdXRTaGFwZVt2XSA9IE1hdGgucm91bmQoaW5wdXRTaGFwZVt2XSAqIHNjYWxlc1t2XSkpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc2NhbGVzLmZpbGwoc2NhbGVJblBvbGljeSwgMCwgc2NhbGVzLmxlbmd0aCk7XHJcbiAgICBhZGp1c3RlZE91dHB1dFNoYXBlLmZvckVhY2goKHYsIGkpID0+IChhZGp1c3RlZE91dHB1dFNoYXBlW2ldID0gTWF0aC5yb3VuZCh2ICogc2NhbGVzW2ldKSkpO1xyXG4gIH1cclxuICByZXR1cm4gYWRqdXN0ZWRPdXRwdXRTaGFwZTtcclxufTtcclxuXHJcbmNvbnN0IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzID0gKFxyXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcclxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgc2NhbGVzTGVuZ3RoOiBudW1iZXIsXHJcbiAgcm9pTGVuZ3RoOiBudW1iZXIsXHJcbik6IHN0cmluZyA9PiBgXHJcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gYXJyYXk8JHtcclxuICAgICAgb3V0cHV0LnR5cGUudmFsdWVcclxuICAgIH0sICR7b3V0cHV0U2hhcGUubGVuZ3RofT4ge1xyXG4gICAgICB2YXIgb3JpZ2luYWxfaW5kaWNlczogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0U2hhcGUubGVuZ3RofT47XHJcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX07XHJcbiAgICAgICAgdmFyIHNjYWxlID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNjYWxlcycsICdpJywgc2NhbGVzTGVuZ3RoKX07XHJcbiAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcclxuICAgICAgICB2YXIgcm9pX2hpID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnJvaScsIGBpICsgJHtpbnB1dFNoYXBlLmxlbmd0aH1gLCByb2lMZW5ndGgpfTtcclxuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XHJcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gJHtvdXRwdXQudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGlucHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XHJcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcclxuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvcmlnaW5hbF9pbmRpY2VzO1xyXG4gICAgfWA7XHJcblxyXG5jb25zdCBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyA9IChcclxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcclxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHNjYWxlc0xlbmd0aDogbnVtYmVyLFxyXG4gIHJvaUxlbmd0aDogbnVtYmVyLFxyXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXHJcbik6IHN0cmluZyA9PiBgXHJcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcclxuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcclxuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9OyBpKyspIHtcclxuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfTtcclxuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcclxuICAgICAgICB2YXIgc2NhbGUgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2NhbGVzJywgJ2knLCBzY2FsZXNMZW5ndGgpfTtcclxuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XHJcbiAgICAgICAgICBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcclxuICAgICAgICAgIHZhciByb2lfaGkgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgYGkgKyAke2lucHV0U2hhcGUubGVuZ3RofWAsIHJvaUxlbmd0aCl9O1xyXG4gICAgICAgICAgdmFyIGlucHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XHJcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcclxuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XHJcbiAgICAgICAgICBpZiAoISR7dXNlRXh0cmFwb2xhdGlvbn0gfHwgKG9yaWdpbmFsX2lkeCA+PSAwICYmIG9yaWdpbmFsX2lkeCA8ICR7b3V0cHV0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xyXG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke291dHB1dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pIC0gMSkpIHtcclxuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlIDwgMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICdpbnB1dF9pbmRleCcpfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xyXG4gICAgfWA7XHJcbmNvbnN0IGNoZWNrSW5wdXRJbmRpY2VzID0gKGlucHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyA9PiBgXHJcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xyXG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke2lucHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gJHtpbnB1dC5pbmRpY2VzR2V0KCdpbnB1dF9pbmRpY2VzJywgJ2knKX07XHJcbiAgICAgICAgaWYgKGlucHV0X2luZGV4IDwgMCB8fCBpbnB1dF9pbmRleCA+PSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX0pIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9YDtcclxuXHJcbmNvbnN0IHNldENoYW5uZWxBbmRCYXRjaEluZGljZXMgPSAoXHJcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgY2hhbm5lbElkeDogbnVtYmVyLFxyXG4gIGJhdGNoSWR4OiBudW1iZXIsXHJcbiAgc3BhY2lhbERpbXM6IG51bWJlcixcclxuKTogc3RyaW5nID0+XHJcbiAgaW5wdXQucmFuayA+IHNwYWNpYWxEaW1zXHJcbiAgICA/IGBcclxuICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGNoYW5uZWxJZHgsICdjaGFubmVsJyl9O1xyXG4gICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgYmF0Y2hJZHgsICdiYXRjaCcpfTtcclxuYFxyXG4gICAgOiAnJztcclxuXHJcbmNvbnN0IGJpbGluZWFySW50ZXJwb2xhdGlvbiA9IChcclxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcclxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbixcclxuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcixcclxuKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBpc05jaHcgPSB0cnVlO1xyXG4gIGNvbnN0IFtiYXRjaElkeCwgaGVpZ2h0SWR4LCB3aWR0aElkeCwgY2hhbm5lbElkeF0gPVxyXG4gICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgPyBbLTEsIDAsIDEsIC0xXSA6IGlzTmNodyA/IFswLCAyLCAzLCAxXSA6IFswLCAxLCAyLCAzXTtcclxuICBjb25zdCBkVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XHJcbiAgcmV0dXJuIGBcclxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7ZFR5cGV9IHtcclxuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcclxuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaGVpZ2h0SWR4LCBgbWF4KDAsIG1pbihyb3csICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKWApfTtcclxuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgd2lkdGhJZHgsIGBtYXgoMCwgbWluKGNvbCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSlgKX07XHJcbiAgICAgICR7c2V0Q2hhbm5lbEFuZEJhdGNoSW5kaWNlcyhpbnB1dCwgY2hhbm5lbElkeCwgYmF0Y2hJZHgsIDIpfVxyXG4gICAgICByZXR1cm4gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XHJcbiAgICB9XHJcblxyXG4gICAgZm4gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XHJcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XHJcbiAgICAgIHZhciByb3c6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHtoZWlnaHRJZHh9XTtcclxuICAgICAgdmFyIGNvbDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske3dpZHRoSWR4fV07XHJcbiAgICAgICR7XHJcbiAgICAgICAgdXNlRXh0cmFwb2xhdGlvblxyXG4gICAgICAgICAgPyBgaWYgKHJvdyA8IDAgfHwgcm93ID4gKCR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpIHx8IGNvbCA8IDAgfHwgY29sID4gKCR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpIHtcclxuICAgICAgICByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O1xyXG4gICAgICB9YFxyXG4gICAgICAgICAgOiAnJ1xyXG4gICAgICB9O1xyXG4gICAgICByb3cgPSBtYXgoMCwgbWluKHJvdywgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpO1xyXG4gICAgICBjb2wgPSBtYXgoMCwgbWluKGNvbCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSk7XHJcbiAgICAgIHZhciByb3cxOiB1MzIgPSB1MzIocm93KTtcclxuICAgICAgdmFyIGNvbDE6IHUzMiA9IHUzMihjb2wpO1xyXG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xyXG4gICAgICB2YXIgY29sMjogdTMyID0gdTMyKGNvbCArIDEpO1xyXG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDIgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2NoYW5uZWxJZHh9XSlgIDogJzAnfTtcclxuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDIgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2JhdGNoSWR4fV0pYCA6ICcwJ307XHJcbiAgICAgIHZhciB4MTE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XHJcbiAgICAgIHZhciB4MTI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XHJcbiAgICAgIHZhciB4MjE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XHJcbiAgICAgIHZhciB4MjI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XHJcbiAgICAgIHZhciBkeDE6ICR7ZFR5cGV9ID0gYWJzKHJvdyAtICR7ZFR5cGV9KHJvdzEpKTtcclxuICAgICAgdmFyIGR4MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0ocm93MikgLSByb3cpO1xyXG4gICAgICB2YXIgZHkxOiAke2RUeXBlfSA9IGFicyhjb2wgLSAke2RUeXBlfShjb2wxKSk7XHJcbiAgICAgIHZhciBkeTI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KGNvbDIpIC0gY29sKTtcclxuICAgICAgaWYgKHJvdzEgPT0gcm93Mikge1xyXG4gICAgICAgIGR4MSA9IDAuNTtcclxuICAgICAgICBkeDIgPSAwLjU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbDEgPT0gY29sMikge1xyXG4gICAgICAgIGR5MSA9IDAuNTtcclxuICAgICAgICBkeTIgPSAwLjU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICh4MTEgKiBkeDIgKiBkeTIgKyB4MTIgKiBkeDIgKiBkeTEgKyB4MjEgKiBkeDEgKiBkeTIgKyB4MjIgKiBkeDEgKiBkeTEpO1xyXG4gICAgfWA7XHJcbn07XHJcblxyXG5jb25zdCBiaWN1YmljSW50ZXJwb2xhdGlvbiA9IChcclxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcclxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHNjYWxlczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgcm9pOiByZWFkb25seSBudW1iZXJbXSxcclxuICBjdWJpY0NvZWZmQTogbnVtYmVyLFxyXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXHJcbiAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsXHJcbiAgZXhjbHVkZU91dHNpZGU6IGJvb2xlYW4sXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3QgaXMyRCA9IGlucHV0U2hhcGUubGVuZ3RoID09PSAyO1xyXG4gIGNvbnN0IGlzTmNodyA9IHRydWU7XHJcbiAgY29uc3QgW2hlaWdodElkeCwgd2lkdGhJZHhdID0gaXMyRCA/IFswLCAxXSA6IGlzTmNodyA/IFsyLCAzXSA6IFsxLCAyXTtcclxuICBjb25zdCBkVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XHJcbiAgY29uc3QgY3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSAoaWR4OiBudW1iZXIpOiBzdHJpbmcgPT4ge1xyXG4gICAgY29uc3QgZGlyZWN0aW9uID0gaWR4ID09PSBoZWlnaHRJZHggPyAncm93JyA6ICdjb2wnO1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgZm4gJHtkaXJlY3Rpb259Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSwgb3V0cHV0X2luZGljZXM6ICR7XHJcbiAgICAgICAgb3V0cHV0LnR5cGUuaW5kaWNlc1xyXG4gICAgICB9KSAtPiAke2RUeXBlfSB7XHJcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgaWR4KX07XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsSWR4OiAke2RUeXBlfSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsICR7c2NhbGVzW2lkeF19LFxyXG4gICAgICAgICR7b3V0cHV0U2hhcGVbaWR4XX0sICR7aW5wdXRTaGFwZVtpZHhdfSwgJHtyb2lbaWR4XX0sICR7cm9pW2lkeF19ICsgJHtpbnB1dFNoYXBlLmxlbmd0aH0pO1xyXG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiAke2RUeXBlfSA9IG9yaWdpbmFsSWR4IC0gZmxvb3Iob3JpZ2luYWxJZHgpO1xyXG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xyXG5cclxuICAgICAgICBpZiAoJHt1c2VFeHRyYXBvbGF0aW9ufSAmJiAob3JpZ2luYWxJZHggPCAwIHx8IG9yaWdpbmFsSWR4ID4gKCR7aW5wdXRTaGFwZVtpZHhdfSAtIDEpKSkge1xyXG4gICAgICAgICAgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PCR7ZFR5cGV9LCA0PiA9IGFycmF5PCR7ZFR5cGV9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xyXG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgJHtkaXJlY3Rpb259OiAke2RUeXBlfSA9IG9yaWdpbmFsSWR4ICsgJHtkVHlwZX0oaSk7XHJcbiAgICAgICAgICBpZiAoJHtkaXJlY3Rpb259IDwgMCB8fCAke2RpcmVjdGlvbn0gPj0gJHtpbnB1dFNoYXBlW2lkeF19KSB7XHJcbiAgICAgICAgICAgICR7KCgpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoZXhjbHVkZU91dHNpZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgY29lZnNbaSArIDFdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtgO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlRXh0cmFwb2xhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O2A7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtkaXJlY3Rpb259ID0gbWF4KDAsIG1pbigke2RpcmVjdGlvbn0sICR7aW5wdXRTaGFwZVtpZHhdfSAtIDEpKTtgO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkoKX07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlucHV0X2luZGljZXNfY29weTogJHtpbnB1dC50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcclxuICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlc19jb3B5JywgaWR4LCBgdTMyKCR7ZGlyZWN0aW9ufSlgKX07XHJcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7XHJcbiAgICAgICAgICAgIGlkeCA9PT0gaGVpZ2h0SWR4XHJcbiAgICAgICAgICAgICAgPyBpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXNfY29weScpXHJcbiAgICAgICAgICAgICAgOiAncm93Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXNfY29weSwgb3V0cHV0X2luZGljZXMpJ1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcclxuICAgICAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGBcclxuICAgICR7Y3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24oaGVpZ2h0SWR4KX07XHJcbiAgICAke2NyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uKHdpZHRoSWR4KX07XHJcbiAgZm4gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoczogJHtkVHlwZX0pIC0+IGFycmF5PCR7ZFR5cGV9LCA0PiB7XHJcbiAgICB2YXIgYWJzUyA9IGFicyhzKTtcclxuICAgIHZhciBjb2VmZnM6IGFycmF5PCR7ZFR5cGV9LCA0PiA9IGFycmF5PCR7ZFR5cGV9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xyXG4gICAgdmFyIG9uZU1pbnVzQWJzUzogJHtkVHlwZX0gPSAxLjAgLSBhYnNTO1xyXG4gICAgdmFyIHR3b01pbnVzQWJzUzogJHtkVHlwZX0gPSAyLjAgLSBhYnNTO1xyXG4gICAgdmFyIG9uZVBsdXNBYnNTOiAke2RUeXBlfSA9IDEuMCArIGFic1M7XHJcbiAgICBjb2VmZnNbMF0gPSAoKCR7Y3ViaWNDb2VmZkF9ICogb25lUGx1c0Fic1MgLSA1ICogJHtjdWJpY0NvZWZmQX0pICogb25lUGx1c0Fic1MgKyA4ICogJHtcclxuICAgICAgY3ViaWNDb2VmZkFcclxuICAgIH0pICogb25lUGx1c0Fic1MgLSA0ICogJHtjdWJpY0NvZWZmQX07XHJcbiAgICBjb2VmZnNbMV0gPSAoKCR7Y3ViaWNDb2VmZkF9ICsgMikgKiBhYnNTIC0gKCR7Y3ViaWNDb2VmZkF9ICsgMykpICogYWJzUyAqIGFic1MgKyAxO1xyXG4gICAgY29lZmZzWzJdID0gKCgke2N1YmljQ29lZmZBfSArIDIpICogb25lTWludXNBYnNTIC0gKCR7Y3ViaWNDb2VmZkF9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcclxuICAgIGNvZWZmc1szXSA9ICgoJHtjdWJpY0NvZWZmQX0gKiB0d29NaW51c0Fic1MgLSA1ICogJHtjdWJpY0NvZWZmQX0pICogdHdvTWludXNBYnNTICsgOCAqICR7XHJcbiAgICAgIGN1YmljQ29lZmZBXHJcbiAgICB9KSAqIHR3b01pbnVzQWJzUyAtIDQgKiAke2N1YmljQ29lZmZBfTtcclxuICAgIHJldHVybiBjb2VmZnM7XHJcbiAgfVxyXG5cclxuICBmbiBjdWJpY0ludGVycG9sYXRpb24xRCh4OiBhcnJheTwke2RUeXBlfSwgND4sIGNvZWZzOiBhcnJheTwke2RUeXBlfSwgND4pIC0+ICR7ZFR5cGV9IHtcclxuICAgIHZhciBjb2Vmc1N1bTogJHtkVHlwZX0gPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcclxuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcclxuICB9XHJcblxyXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XHJcbiAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XHJcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXMsIG91dHB1dF9pbmRpY2VzKTtcclxuICB9XHJcbiAgICBgO1xyXG59O1xyXG5cclxuY29uc3QgdHJpbGluZWFySW50ZXJwb2xhdGlvbiA9IChcclxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcclxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbixcclxuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcixcclxuKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBpc05jaHcgPSB0cnVlO1xyXG4gIGNvbnN0IFtiYXRjaElkeCwgZGVwdGhJZHgsIGhlaWdodElkeCwgd2lkdGhJZHgsIGNoYW5uZWxJZHhdID1cclxuICAgIGlucHV0U2hhcGUubGVuZ3RoID09PSAzID8gWy0xLCAwLCAxLCAyLCAtMV0gOiBpc05jaHcgPyBbMCwgMiwgMywgNCwgMV0gOiBbMCwgMSwgMiwgMywgNF07XHJcbiAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xyXG4gIHJldHVybiBgXHJcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgZGVwdGg6dTMyLCBoZWlnaHQ6IHUzMiwgd2lkdGg6IHUzMikgLT4gJHtkVHlwZX0ge1xyXG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xyXG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBkZXB0aElkeCwgYG1heCgwLCBtaW4oZGVwdGgsICR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkpYCl9O1xyXG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBoZWlnaHRJZHgsIGBtYXgoMCwgbWluKGhlaWdodCwgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpYCl9O1xyXG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCB3aWR0aElkeCwgYG1heCgwLCBtaW4od2lkdGgsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpYCl9O1xyXG4gICAgICAke3NldENoYW5uZWxBbmRCYXRjaEluZGljZXMoaW5wdXQsIGNoYW5uZWxJZHgsIGJhdGNoSWR4LCAzKX1cclxuICAgICAgcmV0dXJuICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xyXG4gICAgfVxyXG5cclxuICAgIGZuIHRyaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZFR5cGV9IHtcclxuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcclxuICAgICAgdmFyIGRlcHRoOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZGVwdGhJZHh9XTtcclxuICAgICAgdmFyIGhlaWdodDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske2hlaWdodElkeH1dO1xyXG4gICAgICB2YXIgd2lkdGg6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHt3aWR0aElkeH1dO1xyXG4gICAgICAke1xyXG4gICAgICAgIHVzZUV4dHJhcG9sYXRpb25cclxuICAgICAgICAgID8gYGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtpbnB1dFNoYXBlW2RlcHRoSWR4XX0gLSAxKSB8fCBoZWlnaHQgPCAwIHx8IGhlaWdodCA+ICgke1xyXG4gICAgICAgICAgICAgIGlucHV0U2hhcGVbaGVpZ2h0SWR4XVxyXG4gICAgICAgICAgICB9IC0gMSkgfHwgd2lkdGggPCAwIHx8ICh3aWR0aCA+ICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpIHtcclxuICAgICAgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtcclxuICAgICAgICB9YFxyXG4gICAgICAgICAgOiAnJ1xyXG4gICAgICB9O1xyXG5cclxuICAgIGRlcHRoID0gbWF4KDAsIG1pbihkZXB0aCwgJHtpbnB1dFNoYXBlW2RlcHRoSWR4XX0gLSAxKSk7XHJcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSk7XHJcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSk7XHJcbiAgICAgIHZhciBkZXB0aDE6IHUzMiA9IHUzMihkZXB0aCk7XHJcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcclxuICAgICAgdmFyIHdpZHRoMTogdTMyID0gdTMyKHdpZHRoKTtcclxuICAgICAgdmFyIGRlcHRoMjogdTMyID0gdTMyKGRlcHRoICsgMSk7XHJcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XHJcbiAgICAgIHZhciB3aWR0aDI6IHUzMiA9IHUzMih3aWR0aCArIDEpO1xyXG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDMgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2NoYW5uZWxJZHh9XSlgIDogJzAnfTtcclxuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDMgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2JhdGNoSWR4fV0pYCA6ICcwJ307XHJcblxyXG4gICAgICB2YXIgeDExMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMSk7XHJcbiAgICAgIHZhciB4MTEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgyKTtcclxuICAgICAgdmFyIHgxMjE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDEpO1xyXG4gICAgICB2YXIgeDEyMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMik7XHJcbiAgICAgIHZhciB4MjExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgxKTtcclxuICAgICAgdmFyIHgyMTI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDIpO1xyXG4gICAgICB2YXIgeDIyMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMSk7XHJcbiAgICAgIHZhciB4MjIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgyKTtcclxuICAgICAgdmFyIGR4MTogJHtkVHlwZX0gPSBhYnMoZGVwdGggLSAke2RUeXBlfShkZXB0aDEpKTtcclxuICAgICAgdmFyIGR4MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0oZGVwdGgyKSAtIGRlcHRoKTtcclxuICAgICAgdmFyIGR5MTogJHtkVHlwZX0gPSBhYnMoaGVpZ2h0IC0gJHtkVHlwZX0oaGVpZ2h0MSkpO1xyXG4gICAgICB2YXIgZHkyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShoZWlnaHQyKSAtIGhlaWdodCk7XHJcbiAgICAgIHZhciBkejE6ICR7ZFR5cGV9ID0gYWJzKHdpZHRoIC0gJHtkVHlwZX0od2lkdGgxKSk7XHJcbiAgICAgIHZhciBkejI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KHdpZHRoMikgLSB3aWR0aCk7XHJcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XHJcbiAgICAgICAgZHgxID0gMC41O1xyXG4gICAgICAgIGR4MiA9IDAuNTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaGVpZ2h0MSA9PSBoZWlnaHQyKSB7XHJcbiAgICAgICAgZHkxID0gMC41O1xyXG4gICAgICAgIGR5MiA9IDAuNTtcclxuICAgICAgfVxyXG4gICAgICBpZiAod2lkdGgxID09IHdpZHRoMikge1xyXG4gICAgICAgIGR6MSA9IDAuNTtcclxuICAgICAgICBkejIgPSAwLjU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xyXG4gICAgICAgICAgICAgIHgyMTEgKiBkeDEgKiBkeTIgKiBkejIgKyB4MjEyICogZHgxICogZHkyICogZHoxICsgeDIyMSAqIGR4MSAqIGR5MSAqZHoyICsgeDIyMiAqIGR4MSAqIGR5MSAqIGR6MSk7XHJcbiAgICB9YDtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZVJlc2l6ZVByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0VGVuc29yOiBUZW5zb3JWaWV3LFxyXG4gIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMsXHJcbiAgb3BzZXRWZXJzaW9uOiBudW1iZXIsXHJcbiAgc2NhbGVzSW5wdXQ6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHNpemVzOiByZWFkb25seSBudW1iZXJbXSxcclxuICByb2lJbnB1dDogcmVhZG9ubHkgbnVtYmVyW10sXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRUZW5zb3IuZGltcztcclxuICBjb25zdCByb2kgPSB1cGRhdGVSb0kocm9pSW5wdXQsIGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xyXG5cclxuICBsZXQgb3V0cHV0U2hhcGUgPSBpbml0T3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgc2NhbGVzSW5wdXQsIHNpemVzLCBhdHRyaWJ1dGVzLmF4ZXMpO1xyXG4gIGxldCBzY2FsZXMgPSBzY2FsZXNJbnB1dC5zbGljZSgpO1xyXG4gIGlmIChzY2FsZXNJbnB1dC5sZW5ndGggPT09IDApIHtcclxuICAgIHNjYWxlcyA9IGlucHV0U2hhcGUubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh2YWx1ZSA9PT0gMCA/IDEuMCA6IG91dHB1dFNoYXBlW2luZGV4XSAvIHZhbHVlKSk7XHJcbiAgICBpZiAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kgIT09ICdzdHJldGNoJykge1xyXG4gICAgICBvdXRwdXRTaGFwZSA9IGFkanVzdE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNjYWxlcywgYXR0cmlidXRlcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dFRlbnNvci5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRUZW5zb3IuZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gIGNvbnN0IG5vU2NhbGUgPSBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gb3V0cHV0U2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGUuZXZlcnkoKGQsIGkpID0+IGQgPT09IG91dHB1dFNoYXBlW2ldKTtcclxuICBjb25zdCB1c2VFeHRyYXBvbGF0aW9uID0gYXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9PT0gJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSc7XHJcbiAgY29uc3QgZXh0cmFwb2xhdGlvblZhbHVlID0gYXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWU7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxyXG4gICAgICAke1xyXG4gICAgICAgIG5vU2NhbGVcclxuICAgICAgICAgID8gJydcclxuICAgICAgICAgIDogYFxyXG4gICAgICAke2dldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLCBkYXRhVHlwZSl9O1xyXG4gICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcclxuICAgICAgICAgIGNhc2UgJ25lYXJlc3QnOlxyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICR7Y2hlY2tJbnB1dEluZGljZXMoaW5wdXQsIGlucHV0U2hhcGUpfTtcclxuICAgICAgICAgICAgICAke2dldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChhdHRyaWJ1dGVzLm5lYXJlc3RNb2RlLCBvcHNldFZlcnNpb24sIGRhdGFUeXBlKX07XHJcbiAgICAgICAgICAgICAgJHtjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhcclxuICAgICAgICAgICAgICAgIGlucHV0LFxyXG4gICAgICAgICAgICAgICAgb3V0cHV0LFxyXG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZSxcclxuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgICAgICAgc2NhbGVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHJvaS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB1c2VFeHRyYXBvbGF0aW9uLFxyXG4gICAgICAgICAgICAgICl9O1xyXG4gICAgICAgICAgICAgIGA7XHJcbiAgICAgICAgICBjYXNlICdsaW5lYXInOlxyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICR7Y2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0LCBpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSwgc2NhbGVzLmxlbmd0aCwgcm9pLmxlbmd0aCl9O1xyXG4gICAgICAgICAgICAgICR7KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiB8fCBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYCR7YmlsaW5lYXJJbnRlcnBvbGF0aW9uKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUsIHVzZUV4dHJhcG9sYXRpb24sIGV4dHJhcG9sYXRpb25WYWx1ZSl9YDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDMgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDUpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3RyaWxpbmVhckludGVycG9sYXRpb24oaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSwgdXNlRXh0cmFwb2xhdGlvbiwgZXh0cmFwb2xhdGlvblZhbHVlKX1gO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0xpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSkoKX07XHJcbiAgICAgICAgICAgIGA7XHJcbiAgICAgICAgICBjYXNlICdjdWJpYyc6XHJcbiAgICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgICR7KCgpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtiaWN1YmljSW50ZXJwb2xhdGlvbihcclxuICAgICAgICAgICAgICAgICAgaW5wdXQsXHJcbiAgICAgICAgICAgICAgICAgIG91dHB1dCxcclxuICAgICAgICAgICAgICAgICAgaW5wdXRTaGFwZSxcclxuICAgICAgICAgICAgICAgICAgb3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICAgICAgICAgIHNjYWxlcyxcclxuICAgICAgICAgICAgICAgICAgcm9pLFxyXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmN1YmljQ29lZmZBLFxyXG4gICAgICAgICAgICAgICAgICB1c2VFeHRyYXBvbGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5leGNsdWRlT3V0c2lkZSxcclxuICAgICAgICAgICAgICAgICl9YDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0N1YmljIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIgYW5kIDQgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS4nKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKCl9O1xyXG4gICAgICAgICAgICBgO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgcmVzaXplIG1vZGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pKCl9O1xyXG4gICAgICBgXHJcbiAgICAgIH1cclxuICAgICAgJHtzaGFkZXJIZWxwZXJcclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKVxyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NjYWxlcycsICdmMzInLCBzY2FsZXMubGVuZ3RoKVxyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3JvaScsICdmMzInLCByb2kubGVuZ3RoKVxyXG4gICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG4gICAgICAgICR7XHJcbiAgICAgICAgICBub1NjYWxlXHJcbiAgICAgICAgICAgID8gJ291dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdOydcclxuICAgICAgICAgICAgOiBgXHJcbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XHJcbiAgICAgICAgJHsoKCkgPT4ge1xyXG4gICAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnbmVhcmVzdCc6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHthdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZX07XHJcbiAgICAgICAgICAgICAgICB9YDtcclxuICAgICAgICAgICAgY2FzZSAnbGluZWFyJzpcclxuICAgICAgICAgICAgICByZXR1cm4gYG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7XHJcbiAgICAgICAgICAgICAgICBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiB8fCBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gNCA/ICdiaWxpbmVhckludGVycG9sYXRpb24nIDogJ3RyaWxpbmVhckludGVycG9sYXRpb24nXHJcbiAgICAgICAgICAgICAgfShvdXRwdXRfaW5kaWNlcyk7YDtcclxuICAgICAgICAgICAgY2FzZSAnY3ViaWMnOlxyXG4gICAgICAgICAgICAgIHJldHVybiAnb3V0cHV0W2dsb2JhbF9pZHhdID0gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXMpOyc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2l6ZSBtb2RlOiAke2F0dHJpYnV0ZXMubW9kZX1gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSgpfTtcclxuYFxyXG4gICAgICAgIH1cclxuICAgICAgfWA7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnUmVzaXplJyxcclxuICAgIHNoYWRlckNhY2hlOiB7XHJcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9fCR7b3BzZXRWZXJzaW9ufXwke1xyXG4gICAgICAgIHNjYWxlcy5sZW5ndGggPiAwID8gKGF0dHJpYnV0ZXMubW9kZSA9PT0gJ2N1YmljJyA/IHNjYWxlcyA6IHNjYWxlcy5sZW5ndGgpIDogJydcclxuICAgICAgfXwke3NpemVzLmxlbmd0aCA+IDAgPyBzaXplcyA6ICcnfXwke3JvaS5sZW5ndGggPiAwID8gcm9pIDogJyd9fCR7bm9TY2FsZX18JHtcclxuICAgICAgICBhdHRyaWJ1dGVzLm1vZGUgPT09ICduZWFyZXN0JyA/IGlucHV0U2hhcGUubGVuZ3RoIDogaW5wdXRTaGFwZVxyXG4gICAgICB9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddLFxyXG4gICAgfSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUZW5zb3IuZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBzY2FsZXMgfSxcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiByb2kgfSxcclxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSksXHJcbiAgICAgIF0sXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgZ2V0T3BzZXRWZXJzaW9uRnJvbUN1c3RvbURhdGFCdWZmZXIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiBudW1iZXIgPT4ge1xyXG4gIGNvbnN0IGN1c3RvbURhdGFCdWZmZXIgPSBjb250ZXh0LmN1c3RvbURhdGFCdWZmZXI7XHJcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlcjMyID0gbmV3IFVpbnQzMkFycmF5KGN1c3RvbURhdGFCdWZmZXIsIGN1c3RvbURhdGFCdWZmZXIuYnl0ZU9mZnNldCwgMSk7XHJcbiAgY29uc3Qgb3BzZXRWZXJzaW9uID0gY3VzdG9tRGF0YUJ1ZmZlcjMyWzBdO1xyXG4gIHJldHVybiBvcHNldFZlcnNpb247XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVzaXplID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3Qgc2NhbGVzOiBudW1iZXJbXSA9IFtdO1xyXG4gIGNvbnN0IHNpemVzOiBudW1iZXJbXSA9IFtdO1xyXG4gIGNvbnN0IHJvaTogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgLy8gTm90ZSB0aGF0IHNjYWxlcyBpbiByZXNpemUgYXJlIGFsd2F5cyBmMzIuIHJvaSBjYW4gYmUgZjMyIG9yIGYxNi5cclxuICAvLyBUT0RPOiBDdXJyZW50bHkgdGhpcyBjb2RlIGRvZXMgbm90IHN1cHBvcnQgZjE2IGZvciByb2kgd2hlbiBwYXNzZWQgYXMgb3B0aW9uYWwgaW5wdXQuXHJcblxyXG4gIGNvbnN0IG9wc2V0VmVyc2lvbiA9IGdldE9wc2V0VmVyc2lvbkZyb21DdXN0b21EYXRhQnVmZmVyKGNvbnRleHQpO1xyXG4gIGlmIChhdHRyaWJ1dGVzLmFudGlhbGlhcyAhPT0gMCkge1xyXG4gICAgdGhyb3cgRXJyb3IoJ09ubHkgZGVmYXVsdCB2YWx1ZSAoMCkgZm9yIEFudGlhbGlhcyBhdHRyaWJ1dGUgaXMgc3VwcG9ydGVkJyk7XHJcbiAgfVxyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBvcHNldFZlcnNpb24sIHNjYWxlcywgc2l6ZXMsIHJvaSk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJlc2l6ZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzLCBvcHNldFZlcnNpb24sIHNjYWxlcywgc2l6ZXMsIHJvaSksIHtcclxuICAgIGlucHV0czogWzBdLFxyXG4gIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlUmVzaXplQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFJlc2l6ZUF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IGFudGlhbGlhcyA9IGF0dHJpYnV0ZXMuYW50aWFsaWFzIGFzIG51bWJlcjtcclxuICBjb25zdCBheGVzID0gYXR0cmlidXRlcy5heGVzIGFzIG51bWJlcltdO1xyXG4gIGNvbnN0IGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiBDb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9XHJcbiAgICBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGFzIENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlO1xyXG4gIGNvbnN0IGN1YmljQ29lZmZBID0gYXR0cmlidXRlcy5jdWJpY0NvZWZmQSBhcyBudW1iZXI7XHJcbiAgY29uc3QgZXhjbHVkZU91dHNpZGUgPSAoYXR0cmlidXRlcy5leGNsdWRlT3V0c2lkZSBhcyBudW1iZXIpICE9PSAwO1xyXG4gIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlIGFzIG51bWJlcjtcclxuICBjb25zdCBrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6IEtlZXBBc3BlY3RSYXRpb1BvbGljeSA9IGF0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5IGFzIEtlZXBBc3BlY3RSYXRpb1BvbGljeTtcclxuICBjb25zdCBtb2RlOiBNb2RlID0gYXR0cmlidXRlcy5tb2RlIGFzIE1vZGU7XHJcbiAgLy8gSWYgbmVhcmVzdE1vZGUgaXMgbm90IHNwZWNpZmllZCwgdXNlIHNpbXBsZSBtb2RlLlxyXG4gIGNvbnN0IG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZSA9IChhdHRyaWJ1dGVzLm5lYXJlc3RNb2RlID09PSAnJyA/ICdzaW1wbGUnIDogYXR0cmlidXRlcy5uZWFyZXN0TW9kZSkgYXMgTmVhcmVzdE1vZGU7XHJcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XHJcbiAgICBhbnRpYWxpYXMsXHJcbiAgICBheGVzLFxyXG4gICAgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsXHJcbiAgICBjdWJpY0NvZWZmQSxcclxuICAgIGV4Y2x1ZGVPdXRzaWRlLFxyXG4gICAgZXh0cmFwb2xhdGlvblZhbHVlLFxyXG4gICAga2VlcEFzcGVjdFJhdGlvUG9saWN5LFxyXG4gICAgbW9kZSxcclxuICAgIG5lYXJlc3RNb2RlLFxyXG4gIH0pO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY2FzdFRvRjMyLFxyXG4gIGdldE1heENvbXBvbmVudHMsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgc3VtVmVjdG9yLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNraXBMYXllck5vcm1BdHRyaWJ1dGVzIHtcclxuICBzaW1wbGlmaWVkOiBib29sZWFuO1xyXG4gIGVwc2lsb246IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBpbnB1dDogVGVuc29yVmlldyA9IGlucHV0c1swXTtcclxuICBjb25zdCBza2lwOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzFdO1xyXG4gIGNvbnN0IGdhbW1hOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzJdO1xyXG5cclxuICBpZiAoaW5wdXQuZGF0YVR5cGUgIT09IHNraXAuZGF0YVR5cGUgfHwgaW5wdXQuZGF0YVR5cGUgIT09IGdhbW1hLmRhdGFUeXBlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZScpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzICYmIGlucHV0LmRpbXMubGVuZ3RoICE9PSAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgMkQgb3IgM0QnKTtcclxuICB9XHJcblxyXG4gIGlmIChza2lwLmRpbXMubGVuZ3RoICE9PSAzICYmIHNraXAuZGltcy5sZW5ndGggIT09IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU2tpcCBtdXN0IGJlIDJEIG9yIDNEJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBoaWRkZW5TaXplID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDFdO1xyXG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDJdO1xyXG4gIGlmIChza2lwLmRpbXNbc2tpcC5kaW1zLmxlbmd0aCAtIDFdICE9PSBoaWRkZW5TaXplKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XHJcbiAgfVxyXG4gIGlmIChza2lwLmRpbXNbc2tpcC5kaW1zLmxlbmd0aCAtIDJdICE9PSBzZXF1ZW5jZUxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBzZXF1ZW5jZSBsZW5ndGggYXMgaW5wdXQnKTtcclxuICB9XHJcblxyXG4gIGlmIChnYW1tYS5kaW1zLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYW1tYSBtdXN0IGJlIDFEJyk7XHJcbiAgfVxyXG4gIGlmIChnYW1tYS5kaW1zW2dhbW1hLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XHJcbiAgfVxyXG4gIGlmIChpbnB1dHMubGVuZ3RoID4gMykge1xyXG4gICAgY29uc3QgYmV0YTogVGVuc29yVmlldyA9IGlucHV0c1szXTtcclxuICAgIGlmIChiZXRhLmRpbXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmV0YSBtdXN0IGJlIDFEJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYmV0YS5kaW1zW2JldGEuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChpbnB1dHMubGVuZ3RoID4gNCkge1xyXG4gICAgY29uc3QgYmlhczogVGVuc29yVmlldyA9IGlucHV0c1s0XTtcclxuICAgIGlmIChiaWFzLmRpbXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmlhcyBtdXN0IGJlIDFEJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYmlhcy5kaW1zW2JpYXMuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpYXMgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlU2tpcExheWVyTm9ybVByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IFNraXBMYXllck5vcm1BdHRyaWJ1dGVzLFxyXG4gIG91dHB1dENvdW50OiBudW1iZXIsXHJcbiAgaXNUcmFpbmluZzogYm9vbGVhbixcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IHNpbXBsaWZpZWQgPSBhdHRyaWJ1dGVzLnNpbXBsaWZpZWQ7XHJcblxyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBpbnB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGU7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IGlucHV0U2l6ZTtcclxuICBjb25zdCBoaWRkZW5TaXplID0gaW5wdXRTaGFwZS5zbGljZSgtMSlbMF07XHJcbiAgY29uc3QgbWVhbkludlN0ZERldkRpbSA9IGlzVHJhaW5pbmcgPyBpbnB1dFNoYXBlLnNsaWNlKDAsIC0xKS5jb25jYXQoMSkgOiBbXTtcclxuICBjb25zdCBoYXNCZXRhSW5wdXQgPSAhc2ltcGxpZmllZCAmJiBpbnB1dHMubGVuZ3RoID4gMztcclxuICBjb25zdCBoYXNCaWFzSW5wdXQgPSBpbnB1dHMubGVuZ3RoID4gNDtcclxuICBjb25zdCBoYXNNZWFuT3V0cHV0ID0gaXNUcmFpbmluZyAmJiBvdXRwdXRDb3VudCA+IDE7XHJcbiAgY29uc3QgaGFzSW52U3RkRGV2T3V0cHV0ID0gaXNUcmFpbmluZyAmJiBvdXRwdXRDb3VudCA+IDI7XHJcbiAgY29uc3QgaGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dCA9IG91dHB1dENvdW50ID4gMztcclxuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gNjQ7XHJcblxyXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGhpZGRlblNpemUpO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGNvbXBvbmVudHMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBoaWRkZW5TaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmVwc2lsb24gfSxcclxuICBdO1xyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgdW5pZm9ybXNBcnJheTogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnY29tcG9uZW50cycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnZXBzaWxvbicsIHR5cGU6ICdmMzInIH0sXHJcbiAgICBdO1xyXG4gICAgY29uc3QgdmFyaWFibGVzID0gW1xyXG4gICAgICBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcywgY29tcG9uZW50cyksXHJcbiAgICAgIGlucHV0VmFyaWFibGUoJ3NraXAnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLCBjb21wb25lbnRzKSxcclxuICAgICAgaW5wdXRWYXJpYWJsZSgnZ2FtbWEnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLCBjb21wb25lbnRzKSxcclxuICAgIF07XHJcbiAgICBpZiAoaGFzQmV0YUlucHV0KSB7XHJcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JldGEnLCBpbnB1dHNbM10uZGF0YVR5cGUsIGlucHV0c1szXS5kaW1zLCBjb21wb25lbnRzKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzQmlhc0lucHV0KSB7XHJcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbNF0uZGF0YVR5cGUsIGlucHV0c1s0XS5kaW1zLCBjb21wb25lbnRzKSk7XHJcbiAgICB9XHJcbiAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xyXG4gICAgaWYgKGhhc01lYW5PdXRwdXQpIHtcclxuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ21lYW5fb3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIG1lYW5JbnZTdGREZXZEaW0pKTtcclxuICAgIH1cclxuICAgIGlmIChoYXNJbnZTdGREZXZPdXRwdXQpIHtcclxuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ2ludl9zdGRfb3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIG1lYW5JbnZTdGREZXZEaW0pKTtcclxuICAgIH1cclxuICAgIGlmIChoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0KSB7XHJcbiAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdpbnB1dF9za2lwX2JpYXNfc3VtJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICAgIGNvbnN0IHZlY0RhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKERhdGFUeXBlLmZsb2F0LCBjb21wb25lbnRzKTtcclxuICAgIHJldHVybiBgXHJcblxyXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zQXJyYXkpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cclxuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcclxuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NxdWFyZWRfc2hhcmVkIDogYXJyYXk8JHt2ZWNEYXRhVHlwZX0sICR7d29ya2dyb3VwU2l6ZX0+O1xyXG5cclxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFt3b3JrZ3JvdXBTaXplLCAxLCAxXSl9XHJcbiAgICAgICAgbGV0IGl4ID0gbG9jYWxfaWQueDtcclxuICAgICAgICBsZXQgaXkgPSBnbG9iYWxfaWQueCAvICR7d29ya2dyb3VwU2l6ZX07XHJcblxyXG4gICAgICAgIGxldCBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkOiB1MzIgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSAvIHVuaWZvcm1zLmNvbXBvbmVudHM7XHJcbiAgICAgICAgdmFyIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLyAke3dvcmtncm91cFNpemV9O1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSBpeCAqIHN0cmlkZSArIGl5ICogaGlkZGVuX3NpemVfdmVjdG9yaXplZDtcclxuICAgICAgICBsZXQgb2Zmc2V0MWQgPSBzdHJpZGUgKiBpeDtcclxuICAgICAgICBpZiAoaXggPT0gJHt3b3JrZ3JvdXBTaXplIC0gMX0pIHtcclxuICAgICAgICAgIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLSBzdHJpZGUgKiBpeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgc2tpcF92YWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XHJcbiAgICAgICAgICBsZXQgYmlhc192YWx1ZSA9ICR7aGFzQmlhc0lucHV0ID8gJ2JpYXNbb2Zmc2V0MWQgKyBpXScgOiBkYXRhVHlwZSArICcoMC4wKSd9O1xyXG4gICAgICAgICAgbGV0IGlucHV0X3ZhbHVlID0geFtvZmZzZXQgKyBpXTtcclxuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XHJcbiAgICAgICAgICAke2hhc0lucHV0U2tpcEJpYXNTdW1PdXRwdXQgPyAnaW5wdXRfc2tpcF9iaWFzX3N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlOycgOiAnJ31cclxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHZhbHVlO1xyXG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAndmFsdWUnKX07XHJcbiAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBmMzJfdmFsdWU7XHJcbiAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZSAqIGYzMl92YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgICAgICB2YXIgcmVkdWNlX3NpemUgOiB1MzIgPSAke3dvcmtncm91cFNpemV9O1xyXG4gICAgICAgIGZvciAodmFyIGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDE7ICBjdXJyX3NpemUgPiAwOyBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxKSB7XHJcbiAgICAgICAgICByZWR1Y2Vfc2l6ZSA9IGN1cnJfc2l6ZSArIChyZWR1Y2Vfc2l6ZSAmIDEpO1xyXG4gICAgICAgICAgaWYgKGl4IDwgY3Vycl9zaXplKSB7XHJcbiAgICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IHN1bV9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XHJcbiAgICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gc3VtX3NxdWFyZWRfc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHN1bSA9IHN1bV9zaGFyZWRbMF07XHJcbiAgICAgICAgbGV0IHNxdWFyZV9zdW0gPSBzdW1fc3F1YXJlZF9zaGFyZWRbMF07XHJcbiAgICAgICAgbGV0IG1lYW4gPSAke3N1bVZlY3Rvcignc3VtJywgY29tcG9uZW50cyl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKTtcclxuICAgICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke3N1bVZlY3Rvcignc3F1YXJlX3N1bScsIGNvbXBvbmVudHMpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgJHtcclxuICAgICAgICAgIHNpbXBsaWZpZWQgPyAnJyA6ICctIG1lYW4gKiBtZWFuJ1xyXG4gICAgICAgIH0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcclxuICAgICAgICAke2hhc01lYW5PdXRwdXQgPyAnbWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuOycgOiAnJ31cclxuICAgICAgICAke2hhc0ludlN0ZERldk91dHB1dCA/ICdpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2OycgOiAnJ31cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XHJcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldICR7c2ltcGxpZmllZCA/ICcnIDogYC0gJHtkYXRhVHlwZX0obWVhbilgfSkgKlxyXG4gICAgICAgICAgICAke2RhdGFUeXBlfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXHJcbiAgICAgICAgICAgICR7aGFzQmV0YUlucHV0ID8gJysgYmV0YVtvZmZzZXQxZCArIGldJyA6ICcnfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1gO1xyXG4gIH07XHJcbiAgY29uc3Qgb3V0cHV0cyA9IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dO1xyXG4gIGlmIChvdXRwdXRDb3VudCA+IDEpIHtcclxuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcclxuICB9XHJcbiAgaWYgKG91dHB1dENvdW50ID4gMikge1xyXG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogbWVhbkludlN0ZERldkRpbSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0IH0pO1xyXG4gIH1cclxuICBpZiAob3V0cHV0Q291bnQgPiAzKSB7XHJcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBpbnB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH0pO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ1NraXBMYXllck5vcm1hbGl6YXRpb24nLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7Y29tcG9uZW50c307JHtoYXNNZWFuT3V0cHV0fTske2hhc0ludlN0ZERldk91dHB1dH07JHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0fWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBpbnB1dHMubWFwKChfaW5wdXQsIF9pbmRleCkgPT4gJ3R5cGUnKSxcclxuICAgIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7XHJcbiAgICAgICAgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyBoaWRkZW5TaXplKSxcclxuICAgICAgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBza2lwTGF5ZXJOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBTa2lwTGF5ZXJOb3JtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIC8vIFRPRE86IGluaXRpYWxpemUgaXNUcmFpbmluZyBmcm9tIENvbXB1dGVDb250ZXh0XHJcbiAgY29uc3QgaXNUcmFpbmluZyA9IGZhbHNlO1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICAvLyBNZWFuIGFuZCBJbnZTdGREZXYgYXJlIG9ubHkgdXNlZCBpbiB0cmFpbmluZyBtb2RlIGFuZCBhcmUgbm90IHJlcXVpcmVkIGZvciBpbmZlcmVuY2UuXHJcbiAgLy8gVGhleSBhcmUgYWRkZWQgaGVyZSBmb3IgY29tcGxldGVuZXNzIG9ubHkuXHJcbiAgY29uc3Qgb3V0cHV0cyA9IFswXTtcclxuICBpZiAoY29udGV4dC5vdXRwdXRDb3VudCA+IDEpIHtcclxuICAgIG91dHB1dHMucHVzaChpc1RyYWluaW5nID8gMSA6IC0zKTtcclxuICB9XHJcbiAgaWYgKGNvbnRleHQub3V0cHV0Q291bnQgPiAyKSB7XHJcbiAgICBvdXRwdXRzLnB1c2goaXNUcmFpbmluZyA/IDIgOiAtMyk7XHJcbiAgfVxyXG4gIGlmIChjb250ZXh0Lm91dHB1dENvdW50ID4gMykge1xyXG4gICAgb3V0cHV0cy5wdXNoKDMpO1xyXG4gIH1cclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU2tpcExheWVyTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBjb250ZXh0Lm91dHB1dENvdW50LCBpc1RyYWluaW5nKSwge1xyXG4gICAgb3V0cHV0cyxcclxuICB9KTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSwgVGVuc29ySW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgZ2V0RWxlbWVudEF0LFxyXG4gIEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGljZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XHJcbiAgcmVhZG9ubHkgZW5kczogbnVtYmVyW107XHJcbiAgcmVhZG9ubHkgYXhlczogbnVtYmVyW107XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b28gZmV3IGlucHV0cycpO1xyXG4gIH1cclxuICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuc3RhcnRzLmxlbmd0aCB8fCBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmVuZHMubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXhlcywgc3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGgnKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuc3RhcnRzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5lbmRzLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xyXG4gIH1cclxuICBpbnB1dHMuc2xpY2UoMSkuZm9yRWFjaCgoXywgaWR4KSA9PiB7XHJcbiAgICBpZiAoaW5wdXRzW2lkeCArIDFdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQzMiAmJiBpbnB1dHNbaWR4ICsgMV0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDY0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbmNvbnN0IHJlYWRJbnB1dCA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgaWR4OiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XHJcbiAgY29uc3QgaW5wdXQ6IG51bWJlcltdID0gW107XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPiBpZHgpIHtcclxuICAgIGlmIChpbnB1dHNbaWR4XS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50NjQpIHtcclxuICAgICAgaW5wdXRzW2lkeF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goKHYpID0+IGlucHV0LnB1c2goTnVtYmVyKHYpKSk7XHJcbiAgICB9IGVsc2UgaWYgKGlucHV0c1tpZHhdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMikge1xyXG4gICAgICBpbnB1dHNbaWR4XS5nZXRJbnQzMkFycmF5KCkuZm9yRWFjaCgodikgPT4gaW5wdXQucHVzaChOdW1iZXIodikpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGlucHV0O1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMsXHJcbik6IFNsaWNlQXR0cmlidXRlcyA9PiB7XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPiAxKSB7XHJcbiAgICBjb25zdCBzdGFydHM6IG51bWJlcltdID0gcmVhZElucHV0KGlucHV0cywgMSk7XHJcbiAgICBjb25zdCBlbmRzOiBudW1iZXJbXSA9IHJlYWRJbnB1dChpbnB1dHMsIDIpO1xyXG4gICAgbGV0IGF4ZXM6IG51bWJlcltdID0gcmVhZElucHV0KGlucHV0cywgMyk7XHJcbiAgICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgYXhlcyA9IFsuLi5BcnJheShpbnB1dHNbMF0uZGltcy5sZW5ndGgpLmtleXMoKV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgc3RhcnRzLCBlbmRzLCBheGVzIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gYXR0cmlidXRlcztcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBmaXhTdGFydEVuZFZhbHVlcyA9IChcclxuICB2YWx1ZTogbnVtYmVyLFxyXG4gIGluZGV4OiBudW1iZXIsXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgc3RlcHM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4pOiBudW1iZXIgPT4ge1xyXG4gIGxldCBuZXdWYWx1ZSA9IHZhbHVlO1xyXG4gIGlmICh2YWx1ZSA8IDApIHtcclxuICAgIG5ld1ZhbHVlICs9IGlucHV0U2hhcGVbYXhlc1tpbmRleF1dO1xyXG4gIH1cclxuICBpZiAoc3RlcHNbaW5kZXhdIDwgMCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG5ld1ZhbHVlLCBpbnB1dFNoYXBlW2F4ZXNbaW5kZXhdXSAtIDEpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG5ld1ZhbHVlLCBpbnB1dFNoYXBlW2F4ZXNbaW5kZXhdXSkpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0ltcGwgPSAoXHJcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4pOiBzdHJpbmcgPT5cclxuICBgZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xyXG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcclxuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9ICR7aW5wdXRTaGFwZS5sZW5ndGggLSAxfTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgbGV0IGlucHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XHJcbiAgICAgICAgICAgIGxldCBzdGVwc19pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnN0ZXBzJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xyXG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaWducycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0c19pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnN0YXJ0cycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcclxuICAgICAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX07XHJcbiAgICAgICAgICAgIHZhciBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleCAqIHN0ZXBzX2kgKyBzdGFydHNfaSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IGlucHV0X2luZGV4IC8gaW5wdXRfc2hhcGVfaTtcclxuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9pbmRleCAlIGlucHV0X3NoYXBlX2k7XHJcbiAgICAgICAgICAgIGlmIChzaWduc19pIDwgMCkge1xyXG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIGlucHV0X2luZGV4IC0gMXUgKyBzdGFydHNfaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICdpbnB1dF9pbmRleCcpfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xyXG4gICAgICB9YDtcclxuXHJcbmNvbnN0IGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XHJcbiAgY29uc3QgYXhlcyA9XHJcbiAgICBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMFxyXG4gICAgICA/IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRTaGFwZS5sZW5ndGgpXHJcbiAgICAgIDogWy4uLkFycmF5KGlucHV0U2hhcGUubGVuZ3RoKS5rZXlzKCldO1xyXG4gIGxldCBzdGVwcyA9IHJlYWRJbnB1dChpbnB1dHMsIDQpO1xyXG4gIHN0ZXBzLmZvckVhY2goXHJcbiAgICAoc3RlcCkgPT5cclxuICAgICAgc3RlcCAhPT0gMCB8fFxyXG4gICAgICAoKCkgPT4ge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RlcCBjYW5ub3QgYmUgMCcpO1xyXG4gICAgICB9KSxcclxuICApO1xyXG4gIGlmIChzdGVwcy5sZW5ndGggPT09IDApIHtcclxuICAgIHN0ZXBzID0gQXJyYXkoYXhlcy5sZW5ndGgpLmZpbGwoMSk7XHJcbiAgfVxyXG4gIGNvbnN0IHN0YXJ0cyA9IGF0dHJpYnV0ZXMuc3RhcnRzLm1hcCgoc3RhcnQsIGkpID0+IGZpeFN0YXJ0RW5kVmFsdWVzKHN0YXJ0LCBpLCBpbnB1dFNoYXBlLCBheGVzLCBzdGVwcykpO1xyXG5cclxuICBjb25zdCBlbmRzID0gYXR0cmlidXRlcy5lbmRzLm1hcCgoZW5kLCBpKSA9PiBmaXhTdGFydEVuZFZhbHVlcyhlbmQsIGksIGlucHV0U2hhcGUsIGF4ZXMsIHN0ZXBzKSk7XHJcblxyXG4gIGlmIChheGVzLmxlbmd0aCAhPT0gc3RhcnRzLmxlbmd0aCB8fCBheGVzLmxlbmd0aCAhPT0gZW5kcy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoYXhlcy5sZW5ndGggIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgaWYgKCFheGVzLmluY2x1ZGVzKGkpKSB7XHJcbiAgICAgICAgc3RhcnRzLnNwbGljZShpLCAwLCAwKTtcclxuICAgICAgICBlbmRzLnNwbGljZShpLCAwLCBpbnB1dFNoYXBlW2ldKTtcclxuICAgICAgICBzdGVwcy5zcGxpY2UoaSwgMCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgY29uc3Qgc2lnbnMgPSBzdGVwcy5tYXAoKHN0ZXApID0+IE1hdGguc2lnbihzdGVwKSk7XHJcbiAgLy8gQ29udmVydCBuZWdhdGl2ZSBzdGVwcyB0byBwb3NpdGl2ZSBzdGVwcyBhbmQgcmV2ZXJzZSBzdGFydHMgYW5kIGVuZHNcclxuICBzdGVwcy5mb3JFYWNoKChzdGVwLCBpLCBhcnJheSkgPT4ge1xyXG4gICAgaWYgKHN0ZXAgPCAwKSB7XHJcbiAgICAgIGNvbnN0IG51bVN0ZXBzID0gKGVuZHNbaV0gLSBzdGFydHNbaV0pIC8gc3RlcDtcclxuICAgICAgY29uc3QgbmV3RW5kID0gc3RhcnRzW2ldO1xyXG4gICAgICBjb25zdCBuZXdTdGFydCA9IG5ld0VuZCArIG51bVN0ZXBzICogc3RlcHNbaV07XHJcbiAgICAgIHN0YXJ0c1tpXSA9IG5ld1N0YXJ0O1xyXG4gICAgICBlbmRzW2ldID0gbmV3RW5kO1xyXG4gICAgICBhcnJheVtpXSA9IC1zdGVwO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIC8vIE91dHB1dCByYW5rIGlzIGV4cGVjdGVkIHRvIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgaW5wdXQgcmFuay5cclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XHJcbiAgYXhlcy5mb3JFYWNoKChheGlzLCBfKSA9PiB7XHJcbiAgICBvdXRwdXRTaGFwZVtheGlzXSA9IE1hdGguY2VpbCgoZW5kc1theGlzXSAtIHN0YXJ0c1theGlzXSkgLyBzdGVwc1theGlzXSk7XHJcbiAgfSk7XHJcbiAgY29uc3Qgb3V0cHV0VGVuc29ySW5mbzogVGVuc29ySW5mbyA9IHsgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfTtcclxuXHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgeyBuYW1lOiAnb3V0cHV0U2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICB7IG5hbWU6ICdzdGFydHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdGFydHMubGVuZ3RoIH0sXHJcbiAgICB7IG5hbWU6ICdzaWducycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IHNpZ25zLmxlbmd0aCB9LFxyXG4gICAgeyBuYW1lOiAnc3RlcHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdGVwcy5sZW5ndGggfSxcclxuICBdO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0YXJ0cyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogc2lnbnMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzdGVwcyB9LFxyXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIG91dHB1dFNoYXBlKSxcclxuICBdO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cclxuICAgICAgICAke2NhbGN1bGF0ZUlucHV0SW5kaWNlc0ltcGwoaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSl9XHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XHJcbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICAgICAgICBsZXQgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XHJcbiAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpKX1cclxuICAgICAgfWA7XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdTbGljZScsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtzaWducy5sZW5ndGh9XyR7c3RhcnRzLmxlbmd0aH1fJHtzdGVwcy5sZW5ndGh9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbb3V0cHV0VGVuc29ySW5mb10sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKGlucHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNsaWNlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBjcmVhdGVTbGljZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpLCB7IGlucHV0czogWzBdIH0pO1xyXG4gIC8vIGlmIChTaGFwZVV0aWwuc2l6ZShwcm9ncmFtLm91dHB1dHNbMF0uZGltcykgPiAwKSB7XHJcbiAgLy8gICBjb250ZXh0LmNvbXB1dGUocHJvZ3JhbUluZm9Mb2FkZXIsIHtpbnB1dHM6IFswXX0pO1xyXG4gIC8vIH0gZWxzZSB7XHJcbiAgLy8gICAvLyBUT0RPOiBzdXBwb3J0IGVtcHR5IG91dHB1dFxyXG4gIC8vICAgdGhyb3cgbmV3IEVycm9yKCdzbGljZTogb3V0cHV0IHNpemUgaXMgMCcpO1xyXG4gIC8vIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZVNsaWNlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNsaWNlQXR0cmlidXRlcyA9PiB7XHJcbiAgY29uc3Qgc3RhcnRzID0gYXR0cmlidXRlcy5zdGFydHMgYXMgbnVtYmVyW107XHJcbiAgY29uc3QgZW5kcyA9IGF0dHJpYnV0ZXMuZW5kcyBhcyBudW1iZXJbXTtcclxuICBjb25zdCBheGVzID0gYXR0cmlidXRlcy5heGVzIGFzIG51bWJlcltdO1xyXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBzdGFydHMsIGVuZHMsIGF4ZXMgfSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuLy8gVE9ETzogdGhpcyBpcyB0aGUgc2FtZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB3ZSB1c2UgZm9yIHJlZHVjZSB0aGF0IGhhc1xyXG4vLyBwZXJmb3JtYW5jZSBsaW1pdGF0aW9ucyB3aGVuIHRoZSByZWR1Y2VkIGF4aXMgaXMgbG9uZy4gTmVlZCB0byBhZGRcclxuLy8gYSBvcHRpbWl6ZWQgY29kZXBhdGggZm9yIHRoaXMuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xyXG5cclxuaW1wb3J0IHtcclxuICBnZXRNYXhDb21wb25lbnRzLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIHN1bVZlY3RvcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC4nKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNvZnRtYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBheGlzOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IGNyZWF0ZVNvZnRtYXhQcm9ncmFtSW5mbyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMpID0+IHtcclxuICBjb25zdCBpbnB1dCA9IGNvbnRleHQuaW5wdXRzWzBdO1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTtcclxuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcclxuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xyXG4gIGNvbnN0IGlzVHJhbnNwb3NlUmVxdWlyZWQgPSBheGlzIDwgaW5wdXRTaGFwZS5sZW5ndGggLSAxO1xyXG4gIGxldCB0cmFuc3Bvc2VkSW5wdXQ6IFRlbnNvclZpZXc7XHJcbiAgbGV0IHBlcm06IG51bWJlcltdID0gW107XHJcblxyXG4gIGlmIChpc1RyYW5zcG9zZVJlcXVpcmVkKSB7XHJcbiAgICBwZXJtID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogaW5wdXRSYW5rIH0sIChfLCBpKSA9PiBpKTtcclxuICAgIHBlcm1bYXhpc10gPSBpbnB1dFJhbmsgLSAxO1xyXG4gICAgcGVybVtpbnB1dFJhbmsgLSAxXSA9IGF4aXM7XHJcblxyXG4gICAgdHJhbnNwb3NlZElucHV0ID0gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0LCBwZXJtKSwge1xyXG4gICAgICBpbnB1dHM6IFtpbnB1dF0sXHJcbiAgICAgIG91dHB1dHM6IFstMV0sXHJcbiAgICB9KVswXTtcclxuICB9IGVsc2Uge1xyXG4gICAgdHJhbnNwb3NlZElucHV0ID0gaW5wdXQ7XHJcbiAgfVxyXG5cclxuICBjb25zdCB0cmFuc3Bvc2VkSW5wdXRTaGFwZSA9IHRyYW5zcG9zZWRJbnB1dC5kaW1zO1xyXG4gIGNvbnN0IGNvbHMgPSB0cmFuc3Bvc2VkSW5wdXRTaGFwZVtpbnB1dFJhbmsgLSAxXTtcclxuICBjb25zdCByb3dzID0gb3V0cHV0U2l6ZSAvIGNvbHM7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoY29scyk7XHJcbiAgY29uc3QgcGFja2VkQ29scyA9IGNvbHMgLyBjb21wb25lbnRzO1xyXG4gIGxldCBXRyA9IDY0O1xyXG4gIC8vIElmIG9ubHkgb25lIHdvcmtncm91cCBpcyBkaXNwYXRjaGVkLCBpbmNyZWFzZSB3b3JrZ3JvdXBTaXplIHRvIGltcHJvdmUgcGFyYWxsZWxpc20uXHJcbiAgaWYgKHJvd3MgPT09IDEpIHtcclxuICAgIFdHID0gMjU2O1xyXG4gIH1cclxuICBjb25zdCBtYXhWZWN0b3IgPSAobmFtZTogc3RyaW5nLCBjb21wb25lbnRzOiBudW1iZXIpID0+IHtcclxuICAgIGlmIChjb21wb25lbnRzID09PSA0KSB7XHJcbiAgICAgIHJldHVybiBgbWF4KG1heCgke25hbWV9LngsICR7bmFtZX0ueSksIG1heCgke25hbWV9LnosICR7bmFtZX0udykpYDtcclxuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMikge1xyXG4gICAgICByZXR1cm4gYG1heCgke25hbWV9LngsICR7bmFtZX0ueSlgO1xyXG4gICAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAzKSB7XHJcbiAgICAgIHJldHVybiBgbWF4KG1heCgke25hbWV9LngsICR7bmFtZX0ueSksICR7bmFtZX0ueilgO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuYW1lO1xyXG4gIH07XHJcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCB0cmFuc3Bvc2VkSW5wdXQuZGF0YVR5cGUsIHRyYW5zcG9zZWRJbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgdHJhbnNwb3NlZElucHV0LmRhdGFUeXBlLCB0cmFuc3Bvc2VkSW5wdXQuZGltcywgY29tcG9uZW50cyk7XHJcbiAgY29uc3QgdmFsdWVUeXBlID0geC50eXBlLnZhbHVlO1xyXG4gIC8vIDYuMi40IGluIHdnc2wgc3BlY1xyXG4gIGNvbnN0IHRocmVhZE1heERlY2wgPVxyXG4gICAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKHRyYW5zcG9zZWRJbnB1dC5kYXRhVHlwZSkgPT09ICdmMzInXHJcbiAgICAgID8gYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTMuNDAyODIzZSszOGYpO2BcclxuICAgICAgOiBgdmFyIHRocmVhZE1heCA9ICR7dmFsdWVUeXBlfSgtNjU1MDQuMGgpO2A7XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcclxuICAgICAgdmFyPHdvcmtncm91cD4gcm93U3VtU2hhcmVkIDogJHt2YWx1ZVR5cGV9O1xyXG4gICAgICB2YXI8d29ya2dyb3VwPiB0aHJlYWRTaGFyZWQgOiBhcnJheTwke3ZhbHVlVHlwZX0sICR7V0d9PjtcclxuXHJcbiAgICAgIGZuIGdldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyKSAtPiAke3ZhbHVlVHlwZX0ge1xyXG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XHJcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XHJcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgncGFja2VkQ29scycsICdpMzInKS5kZWNsYXJlVmFyaWFibGVzKHgsIG91dHB1dCl9XHJcbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChXRyl9XHJcbiAgICAgICAgbGV0IGdpbmRleCA9IGkzMihnbG9iYWxfaWR4KTtcclxuICAgICAgICBsZXQgbGluZGV4ID0gaTMyKGxvY2FsX2lkeCk7XHJcbiAgICAgICAgY29uc3Qgd2cgPSAke1dHfTtcclxuICAgICAgICBsZXQgcm93ID0gZ2luZGV4IC8gd2c7XHJcbiAgICAgICAgbGV0IGNvbHMgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xyXG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcclxuXHJcbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBtYXhcclxuICAgICAgICAke3RocmVhZE1heERlY2x9XHJcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcclxuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKTtcclxuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmRleCA8IGNvbHMpIHtcclxuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKGNvbHMsIHdnKTtcclxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDEpIHtcclxuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XHJcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcclxuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSBtYXgodGhyZWFkU2hhcmVkW2xpbmRleF0sIHRocmVhZFNoYXJlZFtsaW5kZXggKyByZWR1Y2VTaXplXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xyXG4gICAgICAgICAgcm93TWF4U2hhcmVkID0gJHt2YWx1ZVR5cGV9KCR7bWF4VmVjdG9yKCd0aHJlYWRTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3Mgc3VtXHJcbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7dmFsdWVUeXBlfSgwLjApO1xyXG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XHJcbiAgICAgICAgICBsZXQgc3ViRXhwID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCk7XHJcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFN1bTtcclxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gd2cgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XHJcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcclxuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTaGFyZWRbbGluZGV4XSArIHRocmVhZFNoYXJlZFtsaW5kZXggKyBjdXJyU2l6ZV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xyXG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHt2YWx1ZVR5cGV9KCR7c3VtVmVjdG9yKCd0aHJlYWRTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcclxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xyXG4gICAgICAgICAgdmFyIHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XHJcbiAgICAgICAgICAvLyBtYXggb3BlcmF0aW9uIHByb3RlY3RzIGFnYWluc3QgTmFOIHNpbmNlIGFsbCB2YWx1ZXMgc2hvdWxkIGJlID49MFxyXG4gICAgICAgICAgdmFsdWUgPSBtYXgodmFsdWUsICR7dmFsdWVUeXBlfSgwLjApKTtcclxuICAgICAgICAgIHNldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9YDtcclxuICBjb25zdCByZXN1bHQgPSBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdTb2Z0bWF4JyxcclxuICAgICAgLy8gTm90ZSB0aGF0IGluIEpTRVAsIFdHIHNpemUgaXMgbm90IGluY2x1ZGVkIGluIGNhY2hlIGJ5IGRlZmF1bHQsIGJ1dCBXZWJHUFUgRVAgaXQgaXMuXHJcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7V0d9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZSddIH0sXHJcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogdHJhbnNwb3NlZElucHV0U2hhcGUsIGRhdGFUeXBlOiB0cmFuc3Bvc2VkSW5wdXQuZGF0YVR5cGUgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiByb3dzIH0sXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogcGFja2VkQ29scyB9XSxcclxuICAgICAgfSksXHJcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIGlucHV0czogW3RyYW5zcG9zZWRJbnB1dF0sXHJcbiAgICAgIG91dHB1dHM6IFtpc1RyYW5zcG9zZVJlcXVpcmVkID8gLTEgOiAwXSxcclxuICAgIH0sXHJcbiAgKVswXTtcclxuXHJcbiAgaWYgKGlzVHJhbnNwb3NlUmVxdWlyZWQpIHtcclxuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXN1bHQsIHBlcm0pLCB7XHJcbiAgICAgIGlucHV0czogW3Jlc3VsdF0sXHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc29mdG1heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY3JlYXRlU29mdG1heFByb2dyYW1JbmZvKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTb2Z0bWF4QXR0cmlidXRlcyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIgfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmNvbnN0IGdldFJlcGVhdHMgPSAocmVwZWF0c1RlbnNvclZpZXc6IFRlbnNvclZpZXcpOiByZWFkb25seSBudW1iZXJbXSA9PlxyXG4gIEFycmF5LmZyb20ocmVwZWF0c1RlbnNvclZpZXcuZ2V0QmlnSW50NjRBcnJheSgpLCBOdW1iZXIpO1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoXHJcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0ICYmXHJcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0MTYgJiZcclxuICAgIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50MzIgJiZcclxuICAgIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUudWludDMyXHJcbiAgKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBmbG9hdDE2LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzFdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQ2NCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLUQnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdID0gZ2V0UmVwZWF0cyhpbnB1dHNbMV0pO1xyXG5cclxuICBpZiAocmVwZWF0cy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZ2V0T3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10gPT4ge1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcclxuICAgIG91dHB1dFNoYXBlLnB1c2goaW5wdXRTaGFwZVtpXSAqIHJlcGVhdHNbaV0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG91dHB1dFNoYXBlO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgc2hhcGU/OiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgcmVwZWF0czogcmVhZG9ubHkgbnVtYmVyW10gPSBzaGFwZSA9PSBudWxsID8gZ2V0UmVwZWF0cyhpbnB1dHNbMV0pIDogc2hhcGU7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBnZXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCByZXBlYXRzKTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG5cclxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxyXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gJHtpbnB1dC5pbmRpY2VzKC4uLmlucHV0U2hhcGUpfTtcclxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7aW5wdXRTaGFwZS5sZW5ndGh9OyBpKyspIHtcclxuICAgICAgICBsZXQgaW5wdXRfZGltX2kgPSAke2lucHV0LmluZGljZXNHZXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knKX07XHJcbiAgICAgICAgbGV0IGlucHV0X2RpbV92YWx1ZSA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX0gICUgaW5wdXRfZGltX2k7XHJcblxyXG4gICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJ2lucHV0X2RpbV92YWx1ZScpfVxyXG4gICAgICB9XHJcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJykpfVxyXG4gICAgfWA7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnVGlsZScsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtyZXBlYXRzfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpLFxyXG4gICAgICBdLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0aWxlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUaWxlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpLCB7IGlucHV0czogWzBdIH0pO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5jb25zdCBjcmVhdGVXaGVyZU9wUHJvZ3JhbVNoYWRlciA9IChcclxuICBzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcixcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBkaW1zT3V0cHV0OiByZWFkb25seSBudW1iZXJbXSxcclxuICBpc0Jyb2FkY2FzdDogYm9vbGVhbixcclxuICB0eXBlT3V0cHV0OiBudW1iZXIsXHJcbikgPT4ge1xyXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfZGF0YScsIHR5cGVPdXRwdXQsIGRpbXNPdXRwdXQubGVuZ3RoLCA0KTtcclxuICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYV9kYXRhJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIDQpO1xyXG4gIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiX2RhdGEnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgNCk7XHJcbiAgY29uc3QgYyA9IGlucHV0VmFyaWFibGUoJ2NfZGF0YScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLCA0KTtcclxuXHJcbiAgbGV0IGFzc2lnbm1lbnQ6IHN0cmluZztcclxuICBjb25zdCBleHByZXNzaW9uID0gKGE6IHN0cmluZywgYjogc3RyaW5nLCBjOiBzdHJpbmcpID0+IGBzZWxlY3QoJHtifSwgJHthfSwgJHtjfSlgO1xyXG4gIGlmICghaXNCcm9hZGNhc3QpIHtcclxuICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXHJcbiAgICAgICdnbG9iYWxfaWR4JyxcclxuICAgICAgZXhwcmVzc2lvbihhLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksIGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSxcclxuICAgICk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4ge1xyXG4gICAgICBjb25zdCBleHByZXNzaW9uQSA9IGBhX2RhdGFbaW5kZXhfYSR7eH1dW2NvbXBvbmVudF9hJHt4fV1gO1xyXG4gICAgICBjb25zdCBleHByZXNzaW9uQiA9IGBiX2RhdGFbaW5kZXhfYiR7eH1dW2NvbXBvbmVudF9iJHt4fV1gO1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICBjb25zdCBleHByZXNzaW9uQyA9IGBib29sKGNfZGF0YVtpbmRleF9jJHt4fV0gJiAoMHhmZnUgPDwgKGNvbXBvbmVudF9jJHt4fSAqIDgpKSlgO1xyXG4gICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke3h9dWApfTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldF9hJHt4fSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3h9YCwgb3V0cHV0KX07XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYiR7eH0gPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Mke3h9ID0gJHtjLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcclxuICAgICAgICAgICAgbGV0IGluZGV4X2Eke3h9ID0gb2Zmc2V0X2Eke3h9IC8gNHU7XHJcbiAgICAgICAgICAgIGxldCBpbmRleF9iJHt4fSA9IG9mZnNldF9iJHt4fSAvIDR1O1xyXG4gICAgICAgICAgICBsZXQgaW5kZXhfYyR7eH0gPSBvZmZzZXRfYyR7eH0gLyA0dTtcclxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9hJHt4fSA9IG9mZnNldF9hJHt4fSAlIDR1O1xyXG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Ike3h9ID0gb2Zmc2V0X2Ike3h9ICUgNHU7XHJcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYyR7eH0gPSBvZmZzZXRfYyR7eH0gJSA0dTtcclxuICAgICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtleHByZXNzaW9uKGV4cHJlc3Npb25BLCBleHByZXNzaW9uQiwgZXhwcmVzc2lvbkMpfSk7XHJcbiAgICAgICAgICBgO1xyXG4gICAgfTtcclxuICAgIGlmICh0eXBlT3V0cHV0ID09PSBEYXRhVHlwZS5ib29sKSB7XHJcbiAgICAgIGFzc2lnbm1lbnQgPSBgXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDEsICd1MzInKX1cclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XHJcbiAgICAgICAgICAgIG91dHB1dF9kYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhc3NpZ25tZW50ID0gYFxyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dF9kYXRhW2dsb2JhbF9pZHhdJywgMCl9XHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAxKX1cclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDIpfVxyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dF9kYXRhW2dsb2JhbF9pZHhdJywgMyl9XHJcbiAgICAgICAgICBgO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGBcclxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoYywgYSwgYiwgb3V0cHV0KX1cclxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxyXG4gICAgICAgICR7YXNzaWdubWVudH1cclxuICAgICAgfWA7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVXaGVyZU9wUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgZGltc0EgPSBpbnB1dHNbMV0uZGltcztcclxuICBjb25zdCBkaW1zQiA9IGlucHV0c1syXS5kaW1zO1xyXG4gIGNvbnN0IGRpbXNDID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3Qgb3V0cHV0RGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7XHJcblxyXG4gIGNvbnN0IGlzQnJvYWRjYXN0ID0gIShTaGFwZVV0aWwuYXJlRXF1YWwoZGltc0EsIGRpbXNCKSAmJiBTaGFwZVV0aWwuYXJlRXF1YWwoZGltc0IsIGRpbXNDKSk7XHJcbiAgbGV0IG91dHB1dFNoYXBlID0gZGltc0E7XHJcbiAgbGV0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQSk7XHJcbiAgLy8gVE9ETzogZGVhbCB3aXRoIHplcm8tc2l6ZWQgdGVuc29ycyAoZWcuIGRpbXM9WzEsMF0pXHJcblxyXG4gIGlmIChpc0Jyb2FkY2FzdCkge1xyXG4gICAgY29uc3QgY2FsY3VsYXRlZFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZGltc0EsIGRpbXNCLCBmYWxzZSkhLCBkaW1zQywgZmFsc2UpO1xyXG4gICAgaWYgKCFjYWxjdWxhdGVkU2hhcGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSB3aGVyZSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtcclxuICAgIH1cclxuICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlO1xyXG4gICAgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHZlY1NpemUgPSBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDQpO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ1doZXJlJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ10gfSxcclxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cclxuICAgICAgY3JlYXRlV2hlcmVPcFByb2dyYW1TaGFkZXIoc2hhZGVySGVscGVyLCBpbnB1dHMsIG91dHB1dFNoYXBlLCBpc0Jyb2FkY2FzdCwgb3V0cHV0RGF0YVR5cGUpLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovIC8gNCAvKiB2ZWMgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHZlY1NpemUgfSxcclxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhkaW1zQywgZGltc0EsIGRpbXNCLCBvdXRwdXRTaGFwZSksXHJcbiAgICAgIF0sXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHdoZXJlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVdoZXJlT3BQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IGFyZ01heCwgYXJnTWluLCBwYXJzZUFyZ01pbk1heEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9hcmdtaW5tYXgnO1xyXG5pbXBvcnQgeyBhdHRlbnRpb24gfSBmcm9tICcuL29wcy9hdHRlbnRpb24nO1xyXG5pbXBvcnQgeyBiYXRjaE5vcm0gfSBmcm9tICcuL29wcy9iYXRjaC1ub3JtJztcclxuaW1wb3J0IHsgYmlhc0FkZCB9IGZyb20gJy4vb3BzL2JpYXMtYWRkJztcclxuaW1wb3J0IHsgYmlhc1NwbGl0R2VsdSB9IGZyb20gJy4vb3BzL2JpYXMtc3BsaXQtZ2VsdSc7XHJcbmltcG9ydCAqIGFzIGJpbmFyeU9wcyBmcm9tICcuL29wcy9iaW5hcnktb3AnO1xyXG5pbXBvcnQgeyBjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbmNhdCc7XHJcbmltcG9ydCB7IGNvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9jb252JztcclxuaW1wb3J0IHsgY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbnYtdHJhbnNwb3NlJztcclxuaW1wb3J0IHsgY3Vtc3VtLCBwYXJzZUN1bVN1bUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9jdW1zdW0nO1xyXG5pbXBvcnQgeyBkZXB0aFRvU3BhY2UsIHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2RlcHRoLXRvLXNwYWNlJztcclxuaW1wb3J0IHsgZWluc3VtLCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9laW5zdW0nO1xyXG5pbXBvcnQgeyBleHBhbmQgfSBmcm9tICcuL29wcy9leHBhbmQnO1xyXG5pbXBvcnQgeyBmYXN0R2VsdSB9IGZyb20gJy4vb3BzL2Zhc3QtZ2VsdSc7XHJcbmltcG9ydCB7IGdhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2F0aGVyJztcclxuaW1wb3J0IHsgZ2F0aGVyTkQsIHBhcnNlR2F0aGVyTkRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2F0aGVyLW5kJztcclxuaW1wb3J0IHsgZ2F0aGVyQmxvY2tRdWFudGl6ZWQsIHBhcnNlR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2F0aGVyLWJsb2NrLXF1YW50aXplZCc7XHJcbmltcG9ydCB7IGdhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlci1lbGVtZW50cyc7XHJcbmltcG9ydCB7IGdlbW0sIHBhcnNlR2VtbUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9nZW1tJztcclxuaW1wb3J0IHsgZ3JpZFNhbXBsZSwgcGFyc2VHcmlkU2FtcGxlQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dyaWQtc2FtcGxlJztcclxuaW1wb3J0IHsgZ3JvdXBRdWVyeUF0dGVudGlvbiB9IGZyb20gJy4vb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbic7XHJcbmltcG9ydCB7IGluc3RhbmNlTm9ybSB9IGZyb20gJy4vb3BzL2luc3RhbmNlLW5vcm0nO1xyXG5pbXBvcnQgeyBsYXllck5vcm0gfSBmcm9tICcuL29wcy9sYXllci1ub3JtJztcclxuaW1wb3J0IHsgbWF0TXVsIH0gZnJvbSAnLi9vcHMvbWF0bXVsJztcclxuaW1wb3J0IHsgbWF0TXVsTkJpdHMsIHBhcnNlTWF0TXVsTkJpdHNBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvbWF0bXVsbmJpdHMnO1xyXG5pbXBvcnQgeyBtdWx0aUhlYWRBdHRlbnRpb24sIHBhcnNlTXVsdGlIZWFkQXR0ZW50aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL211bHRpaGVhZC1hdHRlbnRpb24nO1xyXG5pbXBvcnQgeyBwYWQgfSBmcm9tICcuL29wcy9wYWQnO1xyXG5pbXBvcnQgKiBhcyBwb29sIGZyb20gJy4vb3BzL3Bvb2wnO1xyXG5pbXBvcnQgeyBkZXF1YW50aXplTGluZWFyLCBwYXJzZURlcXVhbnRpemVMaW5lYXJBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvcXVhbnRpemUtbGluZWFyJztcclxuaW1wb3J0IHsgcmFuZ2UgfSBmcm9tICcuL29wcy9yYW5nZSc7XHJcbmltcG9ydCB7IHNjYXR0ZXJORCwgcGFyc2VTY2F0dGVyTkRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvc2NhdHRlci1uZCc7XHJcbmltcG9ydCB7XHJcbiAgcmVkdWNlTDEsXHJcbiAgcmVkdWNlTDIsXHJcbiAgcmVkdWNlTG9nU3VtLFxyXG4gIHJlZHVjZUxvZ1N1bUV4cCxcclxuICByZWR1Y2VNYXgsXHJcbiAgcmVkdWNlTWVhbixcclxuICByZWR1Y2VNaW4sXHJcbiAgcmVkdWNlUHJvZCxcclxuICByZWR1Y2VTdW0sXHJcbiAgcmVkdWNlU3VtU3F1YXJlLFxyXG59IGZyb20gJy4vb3BzL3JlZHVjZSc7XHJcbmltcG9ydCB7IHBhcnNlUmVzaXplQXR0cmlidXRlcywgcmVzaXplIH0gZnJvbSAnLi9vcHMvcmVzaXplJztcclxuaW1wb3J0IHsgcm90YXJ5RW1iZWRkaW5nIH0gZnJvbSAnLi9vcHMvcm90YXJ5LWVtYmVkZGluZyc7XHJcbmltcG9ydCB7IHNraXBMYXllck5vcm0gfSBmcm9tICcuL29wcy9za2lwLWxheWVyLW5vcm0nO1xyXG5pbXBvcnQgeyBwYXJzZVNsaWNlQXR0cmlidXRlcywgc2xpY2UgfSBmcm9tICcuL29wcy9zbGljZSc7XHJcbmltcG9ydCB7IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMsIHNvZnRtYXggfSBmcm9tICcuL29wcy9zb2Z0bWF4JztcclxuaW1wb3J0IHsgcGFyc2VTcGxpdEF0dHJpYnV0ZXMsIHNwbGl0IH0gZnJvbSAnLi9vcHMvc3BsaXQnO1xyXG5pbXBvcnQgeyB0aWxlIH0gZnJvbSAnLi9vcHMvdGlsZSc7XHJcbmltcG9ydCB7IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcywgdHJhbnNwb3NlIH0gZnJvbSAnLi9vcHMvdHJhbnNwb3NlJztcclxuaW1wb3J0ICogYXMgdW5hcnlPcHMgZnJvbSAnLi9vcHMvdW5hcnktb3AnO1xyXG5pbXBvcnQgeyB3aGVyZSB9IGZyb20gJy4vb3BzL3doZXJlJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbmV4cG9ydCB0eXBlIFJ1bkZ1bmN0aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGU/OiB1bmtub3duKSA9PiB2b2lkO1xyXG5leHBvcnQgdHlwZSBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uID0gKGF0dHJpYnV0ZVJhdzogdW5rbm93bikgPT4gdW5rbm93bjtcclxuZXhwb3J0IHR5cGUgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbiA9IFtSdW5GdW5jdGlvbl0gfCBbUnVuRnVuY3Rpb24sIFBhcnNlQXR0cmlidXRlRnVuY3Rpb25dO1xyXG5cclxuZXhwb3J0IGNvbnN0IFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTOiBNYXA8c3RyaW5nLCBPcGVyYXRvckltcGxlbWVudGF0aW9uPiA9IG5ldyBNYXAoW1xyXG4gIFsnQWJzJywgW3VuYXJ5T3BzLmFic11dLFxyXG4gIFsnQWNvcycsIFt1bmFyeU9wcy5hY29zXV0sXHJcbiAgWydBY29zaCcsIFt1bmFyeU9wcy5hY29zaF1dLFxyXG4gIFsnQWRkJywgW2JpbmFyeU9wcy5hZGRdXSxcclxuICBbJ0FyZ01heCcsIFthcmdNYXgsIHBhcnNlQXJnTWluTWF4QXR0cmlidXRlc11dLFxyXG4gIFsnQXJnTWluJywgW2FyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzXV0sXHJcbiAgWydBc2luJywgW3VuYXJ5T3BzLmFzaW5dXSxcclxuICBbJ0FzaW5oJywgW3VuYXJ5T3BzLmFzaW5oXV0sXHJcbiAgWydBdGFuJywgW3VuYXJ5T3BzLmF0YW5dXSxcclxuICBbJ0F0YW5oJywgW3VuYXJ5T3BzLmF0YW5oXV0sXHJcbiAgWydBdHRlbnRpb24nLCBbYXR0ZW50aW9uXV0sXHJcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgQXZlcmFnZVBvb2wtMTBcclxuICBbJ0F2ZXJhZ2VQb29sJywgW3Bvb2wuYXZlcmFnZVBvb2wsIHBvb2wucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdXSxcclxuICBbJ0JhdGNoTm9ybWFsaXphdGlvbicsIFtiYXRjaE5vcm1dXSxcclxuICBbJ0JpYXNBZGQnLCBbYmlhc0FkZF1dLFxyXG4gIFsnQmlhc1NwbGl0R2VsdScsIFtiaWFzU3BsaXRHZWx1XV0sXHJcbiAgWydDYXN0JywgW3VuYXJ5T3BzLmNhc3QsIHVuYXJ5T3BzLnBhcnNlQ2FzdEF0dHJpYnV0ZXNdXSxcclxuICBbJ0NlaWwnLCBbdW5hcnlPcHMuY2VpbF1dLFxyXG4gIFsnQ2xpcCcsIFt1bmFyeU9wcy5jbGlwXV0sXHJcbiAgWydDb25jYXQnLCBbY29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXNdXSxcclxuICBbJ0NvbnYnLCBbY29udiwgcGFyc2VDb252QXR0cmlidXRlc11dLFxyXG4gIFsnQ29udlRyYW5zcG9zZScsIFtjb252VHJhbnNwb3NlLCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXV0sXHJcbiAgWydDb3MnLCBbdW5hcnlPcHMuY29zXV0sXHJcbiAgWydDb3NoJywgW3VuYXJ5T3BzLmNvc2hdXSxcclxuICBbJ0N1bVN1bScsIFtjdW1zdW0sIHBhcnNlQ3VtU3VtQXR0cmlidXRlc11dLFxyXG4gIFsnRGVwdGhUb1NwYWNlJywgW2RlcHRoVG9TcGFjZSwgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzXV0sXHJcbiAgWydEZXF1YW50aXplTGluZWFyJywgW2RlcXVhbnRpemVMaW5lYXIsIHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXNdXSxcclxuICBbJ0RpdicsIFtiaW5hcnlPcHMuZGl2XV0sXHJcbiAgWydFaW5zdW0nLCBbZWluc3VtLCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXNdXSxcclxuICBbJ0VsdScsIFt1bmFyeU9wcy5lbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXHJcbiAgWydFcXVhbCcsIFtiaW5hcnlPcHMuZXF1YWxdXSxcclxuICBbJ0VyZicsIFt1bmFyeU9wcy5lcmZdXSxcclxuICBbJ0V4cCcsIFt1bmFyeU9wcy5leHBdXSxcclxuICBbJ0V4cGFuZCcsIFtleHBhbmRdXSxcclxuICBbJ0Zhc3RHZWx1JywgW2Zhc3RHZWx1XV0sXHJcbiAgWydGbG9vcicsIFt1bmFyeU9wcy5mbG9vcl1dLFxyXG4gIFsnRnVzZWRDb252JywgW2NvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXNdXSxcclxuICBbJ0dhdGhlcicsIFtnYXRoZXIsIHBhcnNlR2F0aGVyQXR0cmlidXRlc11dLFxyXG4gIFsnR2F0aGVyRWxlbWVudHMnLCBbZ2F0aGVyRWxlbWVudHMsIHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzXV0sXHJcbiAgWydHYXRoZXJCbG9ja1F1YW50aXplZCcsIFtnYXRoZXJCbG9ja1F1YW50aXplZCwgcGFyc2VHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXNdXSxcclxuICBbJ0dhdGhlck5EJywgW2dhdGhlck5ELCBwYXJzZUdhdGhlck5EQXR0cmlidXRlc11dLFxyXG4gIFsnR2VsdScsIFt1bmFyeU9wcy5nZWx1XV0sXHJcbiAgWydHZW1tJywgW2dlbW0sIHBhcnNlR2VtbUF0dHJpYnV0ZXNdXSxcclxuICBbJ0dsb2JhbEF2ZXJhZ2VQb29sJywgW3Bvb2wuZ2xvYmFsQXZlcmFnZVBvb2wsIHBvb2wucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdXSxcclxuICBbJ0dsb2JhbE1heFBvb2wnLCBbcG9vbC5nbG9iYWxNYXhQb29sLCBwb29sLnBhcnNlR2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXNdXSxcclxuICBbJ0dyZWF0ZXInLCBbYmluYXJ5T3BzLmdyZWF0ZXJdXSxcclxuICBbJ0dyZWF0ZXJPckVxdWFsJywgW2JpbmFyeU9wcy5ncmVhdGVyT3JFcXVhbF1dLFxyXG4gIFsnR3JpZFNhbXBsZScsIFtncmlkU2FtcGxlLCBwYXJzZUdyaWRTYW1wbGVBdHRyaWJ1dGVzXV0sXHJcbiAgWydHcm91cFF1ZXJ5QXR0ZW50aW9uJywgW2dyb3VwUXVlcnlBdHRlbnRpb25dXSxcclxuICBbJ0hhcmRTaWdtb2lkJywgW3VuYXJ5T3BzLmhhcmRTaWdtb2lkLCB1bmFyeU9wcy5wYXJzZUhhcmRTaWdtb2lkQXR0cmlidXRlc11dLFxyXG4gIFsnSW5zdGFuY2VOb3JtYWxpemF0aW9uJywgW2luc3RhbmNlTm9ybV1dLFxyXG4gIFsnTGF5ZXJOb3JtYWxpemF0aW9uJywgW2xheWVyTm9ybV1dLFxyXG4gIFsnTGVha3lSZWx1JywgW3VuYXJ5T3BzLmxlYWt5UmVsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcclxuICBbJ0xlc3MnLCBbYmluYXJ5T3BzLmxlc3NdXSxcclxuICBbJ0xlc3NPckVxdWFsJywgW2JpbmFyeU9wcy5sZXNzT3JFcXVhbF1dLFxyXG4gIFsnTG9nJywgW3VuYXJ5T3BzLmxvZ11dLFxyXG4gIFsnTWF0TXVsJywgW21hdE11bF1dLFxyXG4gIFsnTWF0TXVsTkJpdHMnLCBbbWF0TXVsTkJpdHMsIHBhcnNlTWF0TXVsTkJpdHNBdHRyaWJ1dGVzXV0sXHJcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgTWF4UG9vbC04IGFuZCBNYXhQb29sLTEwXHJcbiAgWydNYXhQb29sJywgW3Bvb2wubWF4UG9vbCwgcG9vbC5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzXV0sXHJcbiAgWydNdWwnLCBbYmluYXJ5T3BzLm11bF1dLFxyXG4gIFsnTXVsdGlIZWFkQXR0ZW50aW9uJywgW211bHRpSGVhZEF0dGVudGlvbiwgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzXV0sXHJcbiAgWydOZWcnLCBbdW5hcnlPcHMubmVnXV0sXHJcbiAgWydOb3QnLCBbdW5hcnlPcHMubm90XV0sXHJcbiAgWydQYWQnLCBbcGFkXV0sXHJcbiAgWydQb3cnLCBbYmluYXJ5T3BzLnBvd11dLFxyXG4gIFsnUXVpY2tHZWx1JywgW3VuYXJ5T3BzLnF1aWNrZ2VsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcclxuICBbJ1JhbmdlJywgW3JhbmdlXV0sXHJcbiAgWydSZWNpcHJvY2FsJywgW3VuYXJ5T3BzLnJlY2lwcm9jYWxdXSxcclxuICBbJ1JlZHVjZU1pbicsIFtyZWR1Y2VNaW5dXSxcclxuICBbJ1JlZHVjZU1lYW4nLCBbcmVkdWNlTWVhbl1dLFxyXG4gIFsnUmVkdWNlTWF4JywgW3JlZHVjZU1heF1dLFxyXG4gIFsnUmVkdWNlU3VtJywgW3JlZHVjZVN1bV1dLFxyXG4gIFsnUmVkdWNlUHJvZCcsIFtyZWR1Y2VQcm9kXV0sXHJcbiAgWydSZWR1Y2VMMScsIFtyZWR1Y2VMMV1dLFxyXG4gIFsnUmVkdWNlTDInLCBbcmVkdWNlTDJdXSxcclxuICBbJ1JlZHVjZUxvZ1N1bScsIFtyZWR1Y2VMb2dTdW1dXSxcclxuICBbJ1JlZHVjZUxvZ1N1bUV4cCcsIFtyZWR1Y2VMb2dTdW1FeHBdXSxcclxuICBbJ1JlZHVjZVN1bVNxdWFyZScsIFtyZWR1Y2VTdW1TcXVhcmVdXSxcclxuICBbJ1JlbHUnLCBbdW5hcnlPcHMucmVsdV1dLFxyXG4gIFsnUmVzaXplJywgW3Jlc2l6ZSwgcGFyc2VSZXNpemVBdHRyaWJ1dGVzXV0sXHJcbiAgWydSb3RhcnlFbWJlZGRpbmcnLCBbcm90YXJ5RW1iZWRkaW5nXV0sXHJcbiAgWydTY2F0dGVyTkQnLCBbc2NhdHRlck5ELCBwYXJzZVNjYXR0ZXJOREF0dHJpYnV0ZXNdXSxcclxuICBbJ1NpZ21vaWQnLCBbdW5hcnlPcHMuc2lnbW9pZF1dLFxyXG4gIFsnU2luJywgW3VuYXJ5T3BzLnNpbl1dLFxyXG4gIFsnU2luaCcsIFt1bmFyeU9wcy5zaW5oXV0sXHJcbiAgWydTbGljZScsIFtzbGljZSwgcGFyc2VTbGljZUF0dHJpYnV0ZXNdXSxcclxuICBbJ1NraXBMYXllck5vcm1hbGl6YXRpb24nLCBbc2tpcExheWVyTm9ybV1dLFxyXG4gIFsnU3BsaXQnLCBbc3BsaXQsIHBhcnNlU3BsaXRBdHRyaWJ1dGVzXV0sXHJcbiAgWydTcXJ0JywgW3VuYXJ5T3BzLnNxcnRdXSxcclxuICBbJ1NvZnRtYXgnLCBbc29mdG1heCwgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc11dLFxyXG4gIFsnU3ViJywgW2JpbmFyeU9wcy5zdWJdXSxcclxuICBbJ1RhbicsIFt1bmFyeU9wcy50YW5dXSxcclxuICBbJ1RhbmgnLCBbdW5hcnlPcHMudGFuaF1dLFxyXG4gIFsnVGhyZXNob2xkZWRSZWx1JywgW3VuYXJ5T3BzLnRocmVzaG9sZGVkUmVsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcclxuICBbJ1RpbGUnLCBbdGlsZV1dLFxyXG4gIFsnVHJhbnNwb3NlJywgW3RyYW5zcG9zZSwgcGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzXV0sXHJcbiAgWydXaGVyZScsIFt3aGVyZV1dLFxyXG5dKTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBUUkFDRV9GVU5DX0JFR0lOLCBUUkFDRV9GVU5DX0VORCB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJncHUnO1xyXG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi9sb2cnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlU2hhZGVySGVscGVyIH0gZnJvbSAnLi9vcHMvY29tbW9uJztcclxuaW1wb3J0IHsgQXJ0aWZhY3QsIEdwdURhdGEsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG4vKipcclxuICogUHJvZ3JhbU1hbmFnZXIgaXMgdGhlIG1haW4gY2xhc3MgYmVoaW5kIHJ1bm5pbmcgY29tcHV0YXRpb25zXHJcbiAqIEl0IGJ1aWxkcyBQcm9ncmFtSW5mbydzIGludG8gQXJ0aWZhY3RzXHJcbiAqIEl0IGNvbXBpbGVzIGdpdmVuIFByb2dyYW1JbmZvJ3MgaW50byBXZWJHTCBQcm9yYW1zIChjYWNoZWQgYXMgQXJ0aWZhY3RzKVxyXG4gKiBVc2VzIHRoZSBhcnRpZmFjdCB0byBydW4gdGhlIGNvbXB1dGF0aW9uIGJ5IGNhbGxpbmcgRHJhdyBvblxyXG4gKiB0aGUgV2ViR0wgZHJhd2luZyBidWZmZXJcclxuICogUHJvZ3JhbU1hbmFnZXIgYXV0b21hdGljYWxseSBtYXBzIChiaW5kcykgaW5wdXQgdmFyaWFibGVzIHRvIHRoZWlyXHJcbiAqIGNvcnJlc3BvbmRpbmcgTG9jYXRpb24ncyBpbiB0aGUgYmluYXJ5IHByb2dyYW1cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm9ncmFtTWFuYWdlciB7XHJcbiAgcmVwbzogTWFwPHVua25vd24sIEFydGlmYWN0PjsgLy8gdGhpcyBzaG91bGQgYmUgcGVyLXNlc3Npb24gb2JqZWN0XHJcbiAgYXR0cmlidXRlc0JvdW5kOiBib29sZWFuO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGJhY2tlbmQ6IFdlYkdwdUJhY2tlbmQpIHtcclxuICAgIHRoaXMucmVwbyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gZmFsc2U7XHJcbiAgfVxyXG4gIGdldEFydGlmYWN0KGtleTogdW5rbm93bik6IEFydGlmYWN0IHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLnJlcG8uZ2V0KGtleSk7XHJcbiAgfVxyXG4gIHNldEFydGlmYWN0KGtleTogdW5rbm93biwgYXJ0aWZhY3Q6IEFydGlmYWN0KTogdm9pZCB7XHJcbiAgICB0aGlzLnJlcG8uc2V0KGtleSwgYXJ0aWZhY3QpO1xyXG4gIH1cclxuICBydW4oXHJcbiAgICBidWlsZEFydGlmYWN0OiBBcnRpZmFjdCxcclxuICAgIGlucHV0czogR3B1RGF0YVtdLFxyXG4gICAgb3V0cHV0czogR3B1RGF0YVtdLFxyXG4gICAgZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gICAgdW5pZm9ybUJ1ZmZlckJpbmRpbmc6IEdQVUJpbmRpbmdSZXNvdXJjZSB8IHVuZGVmaW5lZCxcclxuICApOiB2b2lkIHtcclxuICAgIFRSQUNFX0ZVTkNfQkVHSU4oYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lKTtcclxuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XHJcbiAgICBjb25zdCBjb21wdXRlUGFzc0VuY29kZXIgPSB0aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7XHJcbiAgICB0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIpO1xyXG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcclxuICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB7IGJ1ZmZlcjogaW5wdXQuYnVmZmVyIH0gfSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XHJcbiAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCByZXNvdXJjZTogeyBidWZmZXI6IG91dHB1dC5idWZmZXIgfSB9KTtcclxuICAgIH1cclxuICAgIGlmICh1bmlmb3JtQnVmZmVyQmluZGluZykge1xyXG4gICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBlbnRyaWVzLmxlbmd0aCwgcmVzb3VyY2U6IHVuaWZvcm1CdWZmZXJCaW5kaW5nIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmluZEdyb3VwID0gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCh7XHJcbiAgICAgIGxheW91dDogYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLFxyXG4gICAgICBlbnRyaWVzLFxyXG4gICAgICBsYWJlbDogYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzID09PSAnY2FwdHVyaW5nJykge1xyXG4gICAgICBjb25zdCBjb21tYW5kSW5mbyA9IHtcclxuICAgICAgICBrZXJuZWxJZDogdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCEsXHJcbiAgICAgICAgY29tcHV0ZVBpcGVsaW5lOiBidWlsZEFydGlmYWN0LmNvbXB1dGVQaXBlbGluZSxcclxuICAgICAgICBiaW5kR3JvdXAsXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cCxcclxuICAgICAgfTtcclxuICAgICAgY29uc3Qgc2Vzc2lvbkNvbW1hbmRMaXN0ID0gdGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISk7XHJcbiAgICAgIHNlc3Npb25Db21tYW5kTGlzdCEucHVzaChjb21tYW5kSW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKGJ1aWxkQXJ0aWZhY3QuY29tcHV0ZVBpcGVsaW5lKTtcclxuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMCwgYmluZEdyb3VwKTtcclxuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5kaXNwYXRjaFdvcmtncm91cHMoLi4uZGlzcGF0Y2hHcm91cCk7XHJcbiAgICB0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKyAxKTtcclxuICAgIHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKztcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPj0gdGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyIHx8XHJcbiAgICAgIHRoaXMuYmFja2VuZC5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXIpIHtcclxuICAgICAgdGhpcy5iYWNrZW5kLmZsdXNoKCk7XHJcbiAgICB9XHJcbiAgICBUUkFDRV9GVU5DX0VORChidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUpO1xyXG4gIH1cclxuICBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgLy8gdGhpcy5yZXBvLmZvckVhY2goYSA9PiB0aGlzLmdsQ29udGV4dC5kZWxldGVQcm9ncmFtKGEucHJvZ3JhbSkpO1xyXG4gIH1cclxuICBidWlsZChwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogQXJ0aWZhY3Qge1xyXG4gICAgVFJBQ0VfRlVOQ19CRUdJTihwcm9ncmFtSW5mby5uYW1lKTtcclxuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XHJcbiAgICBjb25zdCBlbmFibGVEaXJlY3RpdmVzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIC8vIEVuYWJsZSBXR1NMIGV4dGVuc2lvbnMgYmFzZWQgb24gYXZhaWxhYmxlIFdlYkdQVSBmZWF0dXJlc1xyXG4gICAgY29uc3QgZXh0ZW5zaW9uc0luZm86IEFycmF5PHsgZmVhdHVyZTogR1BVRmVhdHVyZU5hbWU7IGV4dGVuc2lvbjogc3RyaW5nIH0+ID0gW1xyXG4gICAgICB7IGZlYXR1cmU6ICdzaGFkZXItZjE2JywgZXh0ZW5zaW9uOiAnZjE2JyB9LFxyXG4gICAgICB7IGZlYXR1cmU6ICdzdWJncm91cHMnIGFzIEdQVUZlYXR1cmVOYW1lLCBleHRlbnNpb246ICdzdWJncm91cHMnIH0sXHJcbiAgICBdO1xyXG4gICAgZXh0ZW5zaW9uc0luZm8uZm9yRWFjaCgoaW5mbykgPT4ge1xyXG4gICAgICBpZiAoZGV2aWNlLmZlYXR1cmVzLmhhcyhpbmZvLmZlYXR1cmUpKSB7XHJcbiAgICAgICAgZW5hYmxlRGlyZWN0aXZlcy5wdXNoKGBlbmFibGUgJHtpbmZvLmV4dGVuc2lvbn07YCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHNoYWRlckhlbHBlciA9IGNyZWF0ZVNoYWRlckhlbHBlcihub3JtYWxpemVkRGlzcGF0Y2hHcm91cFNpemUsIHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKTtcclxuICAgIGNvbnN0IHVzZXJDb2RlID0gcHJvZ3JhbUluZm8uZ2V0U2hhZGVyU291cmNlKHNoYWRlckhlbHBlcik7XHJcbiAgICBjb25zdCBjb2RlID0gYCR7ZW5hYmxlRGlyZWN0aXZlcy5qb2luKCdcXG4nKX1cXG4ke3NoYWRlckhlbHBlci5hZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zfVxcbiR7dXNlckNvZGV9YDtcclxuICAgIGNvbnN0IHNoYWRlck1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoeyBjb2RlLCBsYWJlbDogcHJvZ3JhbUluZm8ubmFtZSB9KTtcclxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSAke3Byb2dyYW1JbmZvLm5hbWV9IHNoYWRlciBjb2RlOiAke2NvZGV9YCk7XHJcblxyXG4gICAgY29uc3QgY29tcHV0ZVBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7XHJcbiAgICAgIGNvbXB1dGU6IHsgbW9kdWxlOiBzaGFkZXJNb2R1bGUsIGVudHJ5UG9pbnQ6ICdtYWluJyB9LFxyXG4gICAgICBsYXlvdXQ6ICdhdXRvJyxcclxuICAgICAgbGFiZWw6IHByb2dyYW1JbmZvLm5hbWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBUUkFDRV9GVU5DX0VORChwcm9ncmFtSW5mby5uYW1lKTtcclxuICAgIHJldHVybiB7IHByb2dyYW1JbmZvLCBjb21wdXRlUGlwZWxpbmUsIHVuaWZvcm1WYXJpYWJsZXNJbmZvOiBzaGFkZXJIZWxwZXIudmFyaWFibGVzSW5mbyB9O1xyXG4gIH1cclxuXHJcbiAgbm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUoXHJcbiAgICBkaXNwYXRjaEdyb3VwOiBSZXR1cm5UeXBlPFByb2dyYW1JbmZvWydnZXRSdW5EYXRhJ10+WydkaXNwYXRjaEdyb3VwJ10sXHJcbiAgKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcclxuICAgIGNvbnN0IHggPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyBkaXNwYXRjaEdyb3VwIDogZGlzcGF0Y2hHcm91cC54O1xyXG4gICAgY29uc3QgeSA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IDEgOiBkaXNwYXRjaEdyb3VwLnkgfHwgMTtcclxuICAgIGNvbnN0IHogPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyAxIDogZGlzcGF0Y2hHcm91cC56IHx8IDE7XHJcbiAgICBjb25zdCBsaW1pdFBlckRpbWVuc2lvbiA9IHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO1xyXG4gICAgaWYgKHggPD0gbGltaXRQZXJEaW1lbnNpb24gJiYgeSA8PSBsaW1pdFBlckRpbWVuc2lvbiAmJiB6IDw9IGxpbWl0UGVyRGltZW5zaW9uKSB7XHJcbiAgICAgIHJldHVybiBbeCwgeSwgel07XHJcbiAgICB9XHJcbiAgICBjb25zdCBzaXplID0geCAqIHkgKiB6O1xyXG4gICAgbGV0IGRpc3BhdGNoQXZlcmFnZSA9IE1hdGguY2VpbChNYXRoLnNxcnQoc2l6ZSkpO1xyXG4gICAgaWYgKGRpc3BhdGNoQXZlcmFnZSA+IGxpbWl0UGVyRGltZW5zaW9uKSB7XHJcbiAgICAgIGRpc3BhdGNoQXZlcmFnZSA9IE1hdGguY2VpbChNYXRoLmNicnQoc2l6ZSkpO1xyXG4gICAgICBpZiAoZGlzcGF0Y2hBdmVyYWdlID4gbGltaXRQZXJEaW1lbnNpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS4nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gW2Rpc3BhdGNoQXZlcmFnZSwgZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2VdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIFtkaXNwYXRjaEF2ZXJhZ2UsIGRpc3BhdGNoQXZlcmFnZSwgMV07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRW52LCBUZW5zb3IsIFRSQUNFLCBUUkFDRV9GVU5DX0JFR0lOLCBUUkFDRV9GVU5DX0VORCB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSwgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcgfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBjb25maWd1cmVMb2dnZXIsIExPR19ERUJVRyB9IGZyb20gJy4vbG9nJztcclxuaW1wb3J0IHsgY3JlYXRlVmlldywgVGVuc29yVmlldyB9IGZyb20gJy4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBjcmVhdGVHcHVEYXRhTWFuYWdlciwgZG93bmxvYWRHcHVEYXRhLCBHcHVEYXRhTWFuYWdlciB9IGZyb20gJy4vd2ViZ3B1L2dwdS1kYXRhLW1hbmFnZXInO1xyXG5pbXBvcnQgeyBSdW5GdW5jdGlvbiwgV0VCR1BVX09QX1JFU09MVkVfUlVMRVMgfSBmcm9tICcuL3dlYmdwdS9vcC1yZXNvbHZlLXJ1bGVzJztcclxuaW1wb3J0IHsgUHJvZ3JhbU1hbmFnZXIgfSBmcm9tICcuL3dlYmdwdS9wcm9ncmFtLW1hbmFnZXInO1xyXG5pbXBvcnQge1xyXG4gIEFkYXB0ZXJJbmZvLFxyXG4gIENvbXB1dGVDb250ZXh0LFxyXG4gIEdwdUFyY2hpdGVjdHVyZSxcclxuICBHcHVEYXRhLFxyXG4gIEdwdVZlbmRvcixcclxuICBQcm9ncmFtSW5mbyxcclxuICBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSxcclxuICBTZXNzaW9uU3RhdGUsXHJcbiAgVGltZXN0YW1wUXVlcnksXHJcbn0gZnJvbSAnLi93ZWJncHUvdHlwZXMnO1xyXG5cclxuaW50ZXJmYWNlIENvbW1hbmRJbmZvIHtcclxuICByZWFkb25seSBrZXJuZWxJZDogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IGNvbXB1dGVQaXBlbGluZTogR1BVQ29tcHV0ZVBpcGVsaW5lO1xyXG4gIHJlYWRvbmx5IGJpbmRHcm91cDogR1BVQmluZEdyb3VwO1xyXG4gIHJlYWRvbmx5IGRpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIEtlcm5lbEluZm8ge1xyXG4gIHJlYWRvbmx5IGtlcm5lbFR5cGU6IHN0cmluZztcclxuICByZWFkb25seSBrZXJuZWxOYW1lOiBzdHJpbmc7XHJcbiAgcmVhZG9ubHkga2VybmVsRW50cnk6IFJ1bkZ1bmN0aW9uO1xyXG4gIHJlYWRvbmx5IGF0dHJpYnV0ZXM6IFsoKGF0dHJpYnV0ZTogdW5rbm93bikgPT4gdW5rbm93bikgfCB1bmRlZmluZWQsIHVua25vd25dO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgUGVuZGluZ0tlcm5lbEluZm8ge1xyXG4gIHJlYWRvbmx5IGtlcm5lbElkOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgcHJvZ3JhbU5hbWU6IHN0cmluZztcclxuICByZWFkb25seSBpbnB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W107XHJcbiAgcmVhZG9ubHkgb3V0cHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcclxufVxyXG5cclxuY29uc3QgZ2V0UHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lLZXkgPSAoXHJcbiAgaW5wdXRUZW5zb3JzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgaW5wdXREZXBlbmRlbmNpZXM6IHJlYWRvbmx5IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10sXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgaWYgKGlucHV0RGVwZW5kZW5jaWVzLmxlbmd0aCAhPT0gaW5wdXRUZW5zb3JzLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgaW5wdXREZXBlbmRlbmNpZXMgbGVuZ3RoICR7aW5wdXREZXBlbmRlbmNpZXMubGVuZ3RofSBpcyBub3QgZXF1YWwgdG8gaW5wdXRUZW5zb3JzIGxlbmd0aCAke1xyXG4gICAgICAgIGlucHV0VGVuc29ycy5sZW5ndGhcclxuICAgICAgfS5gLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGlucHV0SW5mb3M6IHN0cmluZ1tdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFRlbnNvcnMubGVuZ3RoOyArK2kpIHtcclxuICAgIGNvbnN0IHR5cGUgPSBpbnB1dFRlbnNvcnNbaV0uZGF0YVR5cGU7XHJcbiAgICBzd2l0Y2ggKGlucHV0RGVwZW5kZW5jaWVzW2ldKSB7XHJcbiAgICAgIGNhc2UgJ25vbmUnOiB7XHJcbiAgICAgICAgaW5wdXRJbmZvcy5wdXNoKCcnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlICd0eXBlJzoge1xyXG4gICAgICAgIGlucHV0SW5mb3MucHVzaChgJHt0eXBlfWApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgJ3JhbmsnOiB7XHJcbiAgICAgICAgY29uc3QgcmFuayA9IGlucHV0VGVuc29yc1tpXS5kaW1zLmxlbmd0aDtcclxuICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX07JHtyYW5rfWApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNhc2UgJ2RpbXMnOiB7XHJcbiAgICAgICAgY29uc3QgZGltcyA9IGlucHV0VGVuc29yc1tpXS5kaW1zLmpvaW4oJywnKTtcclxuICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX07JHtkaW1zfWApO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke2lucHV0RGVwZW5kZW5jaWVzW2ldfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlucHV0SW5mb3Muam9pbignfCcpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGdldCBhIHVuaXF1ZSBrZXkgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmFtIGZyb20gdGhlIHByb2dyYW0gaW5mbywgaW5wdXQgc2hhcGVzIGFuZCB0eXBlcy5cclxuICpcclxuICogQHJldHVybnMgYSB1bmlxdWUga2V5IGlzIGEgc2hvcnRlciBzdHJpbmcgdGhhbiB0aGUgc2hhZGVyIHNvdXJjZSwgd2hpY2ggY29udGFpbnMgYWxsIHRoZSBpbmZvcm1hdGlvbiB0byBpZGVudGlmeSBhXHJcbiAqIHByb2dyYW0uIGlmIHRoZSBrZXkgaXMgdGhlIHNhbWUsIHRoZSBwcm9ncmFtIHNoYWRlciBzb3VyY2Ugc2hvdWxkIGJlIHRoZSBzYW1lLCBzbyB3ZSBjYW4gcmV1c2UgdGhlIHByb2dyYW0uXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleSA9IChcclxuICBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sXHJcbiAgaW5wdXRUZW5zb3JzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgaXMxRGltZW5zaW9uRGlzcGF0Y2g6IGJvb2xlYW4sXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgLy8gZmluYWwga2V5IGZvcm1hdDpcclxuICAvLyA8UFJPR1JBTV9OQU1FPls8UFJPR1JBTV9DVVNUT01fQ0FDSEVfSElOVD5dOmlzMURpbWVuc2lvbkRpc3BhdGNoOjxJTlBVVFNfSU5GT18wPnw8SU5QVVRTX0lORk9fMT58Li4uXHJcbiAgbGV0IGtleSA9IHByb2dyYW1JbmZvLm5hbWU7XHJcbiAgaWYgKHByb2dyYW1JbmZvLnNoYWRlckNhY2hlPy5oaW50KSB7XHJcbiAgICBrZXkgKz0gJ1snICsgcHJvZ3JhbUluZm8uc2hhZGVyQ2FjaGUuaGludCArICddJztcclxuICB9XHJcbiAga2V5ICs9XHJcbiAgICAnOicgK1xyXG4gICAgaXMxRGltZW5zaW9uRGlzcGF0Y2ggK1xyXG4gICAgYDoke2dldFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5S2V5KFxyXG4gICAgICBpbnB1dFRlbnNvcnMsXHJcbiAgICAgIHByb2dyYW1JbmZvLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcyA/P1xyXG4gICAgICAgIG5ldyBBcnJheTxQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeT4oaW5wdXRUZW5zb3JzLmxlbmd0aCkuZmlsbCgnZGltcycpLFxyXG4gICAgKX1gO1xyXG4gIHJldHVybiBrZXk7XHJcbn07XHJcblxyXG5jbGFzcyBBZGFwdGVySW5mb0ltcGwgaW1wbGVtZW50cyBBZGFwdGVySW5mbyB7XHJcbiAgcmVhZG9ubHkgYXJjaGl0ZWN0dXJlPzogc3RyaW5nO1xyXG4gIHJlYWRvbmx5IHZlbmRvcj86IHN0cmluZztcclxuXHJcbiAgY29uc3RydWN0b3IoYWRhcHRlckluZm86IEdQVUFkYXB0ZXJJbmZvKSB7XHJcbiAgICBpZiAoYWRhcHRlckluZm8pIHtcclxuICAgICAgdGhpcy5hcmNoaXRlY3R1cmUgPSBhZGFwdGVySW5mby5hcmNoaXRlY3R1cmU7XHJcbiAgICAgIHRoaXMudmVuZG9yID0gYWRhcHRlckluZm8udmVuZG9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaXNBcmNoaXRlY3R1cmUoYXJjaGl0ZWN0dXJlOiBHcHVBcmNoaXRlY3R1cmUpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmFyY2hpdGVjdHVyZSA9PT0gYXJjaGl0ZWN0dXJlO1xyXG4gIH1cclxuXHJcbiAgaXNWZW5kb3IodmVuZG9yOiBHcHVWZW5kb3IpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnZlbmRvciA9PT0gdmVuZG9yO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIHRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gc3RvcmUgc3RhdHVzIGFuZCBiZWluZyB1c2VkIGFzIGEgc2luZ2xldG9uIGZvciBKU0VQLiBJdCB3aWxsIGJlIHBhc3NlZCB0byBqc2VwSW5pdCgpIGFzXHJcbiAqIHRoZSBmaXJzdCBwYXJhbWV0ZXIgc28gdGhhdCBpdCBpcyBzdG9yZWQgZm9yIGZ1dHVyZSB1c2UuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViR3B1QmFja2VuZCB7XHJcbiAgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvSW1wbDtcclxuICBkZXZpY2U6IEdQVURldmljZTtcclxuICAvKipcclxuICAgKiBhbiBpbnN0YW5jZSBvZiBHcHVEYXRhTWFuYWdlciB0byBtYW5hZ2UgYSBHcHVEYXRhSWQgLT4gR3B1QnVmZmVyIG1hcHBpbmdcclxuICAgKi9cclxuICBncHVEYXRhTWFuYWdlcjogR3B1RGF0YU1hbmFnZXI7XHJcbiAgLyoqXHJcbiAgICogYW4gaW5zdGFuY2Ugb2YgUHJvZ3JhbU1hbmFnZXIgdG8gYnVpbGQgYW5kIHJ1biBXZWJHUFUgY29tcHV0ZSBzaGFkZXIgcHJvZ3JhbSwgYW5kIG1hbmFnZSBhIFByb2dyYW1LZXkgLT4gUHJvZ3JhbVxyXG4gICAqIGFydGlmYWN0cyBtYXBwaW5nXHJcbiAgICovXHJcbiAgcHJvZ3JhbU1hbmFnZXI6IFByb2dyYW1NYW5hZ2VyO1xyXG5cclxuICAvKipcclxuICAgKiByZXByZXNlbnRpbmcgdGhlIHNlc3Npb24gSUQgb2Ygd2hpY2ggaXMgY3VycmVudGx5IGJlaW5nIHJ1bi5cclxuICAgKiBgbnVsbGAgbWVhbnMgbm8gc2Vzc2lvbiBpcyBiZWluZyBydW4uXHJcbiAgICogb25seSB2YWxpZCB3aGVuIHNlc3Npb24ucnVuIGlzIGV4ZWN1dGVkLlxyXG4gICAqL1xyXG4gIGN1cnJlbnRTZXNzaW9uSWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiByZXByZXNlbnRpbmcgdGhlIGtlcm5lbCBJRCBvZiB3aGljaCBpcyBjdXJyZW50bHkgYmVpbmcgY29tcHV0ZWQgKENQVSBjb2RlIHBlcnNwZWN0aXZlKS5cclxuICAgKiBgbnVsbGAgbWVhbnMgbm8ga2VybmVsIGlzIGJlaW5nIGNvbXB1dGVkLlxyXG4gICAqIG9ubHkgb25lIGtlcm5lbCBjYW4gYmUgY29tcHV0ZWQgYXQgYSBtb21lbnQuXHJcbiAgICovXHJcbiAgY3VycmVudEtlcm5lbElkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAvKipcclxuICAgKiBhIGxpc3Qgb2YgdGVtcG9yYXJ5IEdQVSBkYXRhIGZvciB0aGUgY3VycmVudCBrZXJuZWwuIHNob3VsZCByZWxlYXNlIHdoZW4gdGhlIGtlcm5lbCBkb25lIGNvbXB1dGF0aW9uLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdGVtcG9yYXJ5RGF0YTogR3B1RGF0YVtdO1xyXG4gIC8qKlxyXG4gICAqIGEgS2VybmVsSUQgLT4gYSBHUFUgZGF0YSBsaXN0LCB3aGljaCBzdG9yZXMgcGVyc2lzdGVudCBHUFUgZGF0YSBvd25lZCBieSB0aGUgc3BlY2lmaWMga2VybmVsLlxyXG4gICAqL1xyXG4gIHByaXZhdGUga2VybmVsUGVyc2lzdGVudERhdGE6IE1hcDxudW1iZXIsIEdwdURhdGFbXT47XHJcbiAgLyoqXHJcbiAgICogYSBLZXJuZWxJRCAtPiBhIGN1c3RvbSBkYXRhLCB3aGljaCBzdG9yZXMgY3VzdG9tIGRhdGEgb3duZWQgYnkgdGhlIHNwZWNpZmljIGtlcm5lbC5cclxuICAgKi9cclxuICBwcml2YXRlIGtlcm5lbEN1c3RvbURhdGE6IE1hcDxudW1iZXIsIHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9PjtcclxuICAvKipcclxuICAgKiBnZXQgdGhlIGN1c3RvbSBkYXRhIG9mIHRoZSBjdXJyZW50IGtlcm5lbFxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfSB7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50S2VybmVsSWQgPT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKScpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkYXRhID0gdGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7XHJcbiAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgZGF0YSA9IHt9O1xyXG4gICAgICB0aGlzLmtlcm5lbEN1c3RvbURhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcblxyXG4gIC8vIEtlcm5lbElEIC0+IGtlcm5lbEluZm8gbWFwcGluZ1xyXG4gIGtlcm5lbHM6IE1hcDxudW1iZXIsIEtlcm5lbEluZm8+O1xyXG4gIHByaXZhdGUgY29tbWFuZEVuY29kZXI6IEdQVUNvbW1hbmRFbmNvZGVyIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBjb21wdXRlUGFzc0VuY29kZXI6IEdQVUNvbXB1dGVQYXNzRW5jb2RlciB8IG51bGwgPSBudWxsO1xyXG4gIG1heERpc3BhdGNoTnVtYmVyID0gMTY7XHJcbiAgcGVuZGluZ0Rpc3BhdGNoTnVtYmVyID0gMDtcclxuXHJcbiAgLy8gaW5mbyBvZiBrZXJuZWxzIHBlbmRpbmcgc3VibWlzc2lvbiBmb3IgYSBzaW5nbGUgYmF0Y2hcclxuICBwcml2YXRlIHBlbmRpbmdLZXJuZWxzOiBQZW5kaW5nS2VybmVsSW5mb1tdID0gW107XHJcbiAgLy8gcXVlcnlSZWFkQnVmZmVyIC0+IHBlbmRpbmdLZXJuZWxzIG1hcHBpbmcgZm9yIGFsbCB0aGUgYmF0Y2hlc1xyXG4gIHByaXZhdGUgcGVuZGluZ1F1ZXJpZXM6IE1hcDxHUFVCdWZmZXIsIFBlbmRpbmdLZXJuZWxJbmZvW10+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgcXVlcnlSZXNvbHZlQnVmZmVyPzogR1BVQnVmZmVyO1xyXG4gIHByaXZhdGUgcXVlcnlTZXQ/OiBHUFVRdWVyeVNldDtcclxuICBwcml2YXRlIHF1ZXJ5VGltZUJhc2U/OiBiaWdpbnQ7XHJcbiAgcXVlcnlUeXBlOiBUaW1lc3RhbXBRdWVyeTtcclxuXHJcbiAgZW52OiBFbnY7XHJcbiAgc2Vzc2lvblN0YXR1czogU2Vzc2lvblN0YXRlID0gJ2RlZmF1bHQnO1xyXG4gIC8qKlxyXG4gICAqIGEgU2Vzc2lvbklEIC0+IENvbW1hbmRJbmZvW10gbWFwcGluZy4gSXQncyB1c2VkIHRvIHJlY29yZCBhbGwgR1BVIGNvbW1hbmRzIGZvciBjb3JyZXNwb25kaW5nIHNlc3Npb24uXHJcbiAgICovXHJcbiAgY2FwdHVyZWRDb21tYW5kTGlzdDogTWFwPG51bWJlciwgQ29tbWFuZEluZm9bXT4gPSBuZXcgTWFwKCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGEgU2Vzc2lvbklEIC0+IFBlbmRpbmdLZXJuZWxJbmZvW10gbWFwcGluZyBmb3IgcHJvZmlsaW5nLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgY2FwdHVyZWRQZW5kaW5nS2VybmVsczogTWFwPG51bWJlciwgUGVuZGluZ0tlcm5lbEluZm9bXT4gPSBuZXcgTWFwKCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGEgU2Vzc2lvbklEIC0+IGEgTWFwIG9mIChJbnB1dE91dHB1dEluZGV4IC0+IFtJRCwgR1BVQnVmZmVyXSkgbWFwcGluZy5cclxuICAgKi9cclxuICBzZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZzogTWFwPG51bWJlciwgTWFwPG51bWJlciwgW251bWJlciwgR1BVQnVmZmVyXT4+ID0gbmV3IE1hcCgpO1xyXG5cclxuICBhc3luYyBpbml0aWFsaXplKGVudjogRW52LCBhZGFwdGVyOiBHUFVBZGFwdGVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLmVudiA9IGVudjtcclxuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZXM6IEdQVUZlYXR1cmVOYW1lW10gPSBbXTtcclxuICAgIGNvbnN0IGRldmljZURlc2NyaXB0b3I6IEdQVURldmljZURlc2NyaXB0b3IgPSB7XHJcbiAgICAgIHJlcXVpcmVkTGltaXRzOiB7XHJcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsXHJcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uLFxyXG4gICAgICAgIG1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZTogYWRhcHRlci5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplLFxyXG4gICAgICAgIG1heEJ1ZmZlclNpemU6IGFkYXB0ZXIubGltaXRzLm1heEJ1ZmZlclNpemUsXHJcbiAgICAgICAgbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAsXHJcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVYOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsXHJcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksXHJcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVosXHJcbiAgICAgIH0sXHJcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXMsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRyeSByZXF1aXJpbmcgV2ViR1BVIGZlYXR1cmVzXHJcbiAgICBjb25zdCByZXF1aXJlRmVhdHVyZUlmQXZhaWxhYmxlID0gKGZlYXR1cmU6IEdQVUZlYXR1cmVOYW1lKSA9PlxyXG4gICAgICBhZGFwdGVyLmZlYXR1cmVzLmhhcyhmZWF0dXJlKSAmJiByZXF1aXJlZEZlYXR1cmVzLnB1c2goZmVhdHVyZSkgJiYgdHJ1ZTtcclxuICAgIC8vIFRyeSBjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMgYW5kIGZhbGxiYWNrIHRvIHRpbWVzdGFtcC1xdWVyeVxyXG4gICAgaWYgKCFyZXF1aXJlRmVhdHVyZUlmQXZhaWxhYmxlKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnIGFzIEdQVUZlYXR1cmVOYW1lKSkge1xyXG4gICAgICByZXF1aXJlRmVhdHVyZUlmQXZhaWxhYmxlKCd0aW1lc3RhbXAtcXVlcnknKTtcclxuICAgIH1cclxuICAgIHJlcXVpcmVGZWF0dXJlSWZBdmFpbGFibGUoJ3NoYWRlci1mMTYnKTtcclxuICAgIC8vIFRyeSBzdWJncm91cHNcclxuICAgIHJlcXVpcmVGZWF0dXJlSWZBdmFpbGFibGUoJ3N1Ymdyb3VwcycgYXMgR1BVRmVhdHVyZU5hbWUpO1xyXG5cclxuICAgIHRoaXMuZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKGRldmljZURlc2NyaXB0b3IpO1xyXG4gICAgdGhpcy5hZGFwdGVySW5mbyA9IG5ldyBBZGFwdGVySW5mb0ltcGwoYWRhcHRlci5pbmZvIHx8IChhd2FpdCBhZGFwdGVyLnJlcXVlc3RBZGFwdGVySW5mbygpKSk7XHJcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyID0gY3JlYXRlR3B1RGF0YU1hbmFnZXIodGhpcyk7XHJcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKHRoaXMpO1xyXG4gICAgdGhpcy5rZXJuZWxzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YSA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMua2VybmVsQ3VzdG9tRGF0YSA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAvLyBzZXQgdXAgZmxhZ3MgZm9yIGxvZ2dlclxyXG4gICAgY29uZmlndXJlTG9nZ2VyKGVudi5sb2dMZXZlbCEsICEhZW52LmRlYnVnKTtcclxuXHJcbiAgICAvLyBUT0RPOiBzZXQgdXAgZmxhZ3NcclxuXHJcbiAgICB0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvciA9IChldikgPT4ge1xyXG4gICAgICBpZiAoZXYuZXJyb3IgaW5zdGFuY2VvZiBHUFVWYWxpZGF0aW9uRXJyb3IpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7ZXYuZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LCAnZGV2aWNlJywge1xyXG4gICAgICB2YWx1ZTogdGhpcy5kZXZpY2UsXHJcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSwgJ2FkYXB0ZXInLCB7XHJcbiAgICAgIHZhbHVlOiBhZGFwdGVyLFxyXG4gICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBpbml0IHF1ZXJ5VHlwZSwgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBJbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZVxyXG4gICAgdGhpcy5zZXRRdWVyeVR5cGUoKTtcclxuICB9XHJcblxyXG4gIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMucXVlcnlTZXQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRoaXMucXVlcnlTZXQuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICBnZXRDb21tYW5kRW5jb2RlcigpOiBHUFVDb21tYW5kRW5jb2RlciB7XHJcbiAgICBpZiAoIXRoaXMuY29tbWFuZEVuY29kZXIpIHtcclxuICAgICAgdGhpcy5jb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kRW5jb2RlcjtcclxuICB9XHJcblxyXG4gIGdldENvbXB1dGVQYXNzRW5jb2RlcigpOiBHUFVDb21wdXRlUGFzc0VuY29kZXIge1xyXG4gICAgaWYgKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcikge1xyXG4gICAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKTtcclxuICAgICAgY29uc3QgY29tcHV0ZVBhc3NEZXNjcmlwdG9yOiBHUFVDb21wdXRlUGFzc0Rlc2NyaXB0b3IgPSB7fTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSA9PT0gJ2F0LXBhc3NlcycpIHtcclxuICAgICAgICBjb21wdXRlUGFzc0Rlc2NyaXB0b3IudGltZXN0YW1wV3JpdGVzID0ge1xyXG4gICAgICAgICAgcXVlcnlTZXQ6IHRoaXMucXVlcnlTZXQhLFxyXG4gICAgICAgICAgYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDogdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyLFxyXG4gICAgICAgICAgZW5kT2ZQYXNzV3JpdGVJbmRleDogdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luQ29tcHV0ZVBhc3MoY29tcHV0ZVBhc3NEZXNjcmlwdG9yKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlcjtcclxuICB9XHJcblxyXG4gIGVuZENvbXB1dGVQYXNzKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKSB7XHJcbiAgICAgIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLmVuZCgpO1xyXG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmbHVzaCgpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5jb21tYW5kRW5jb2Rlcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xyXG5cclxuICAgIHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtcclxuICAgIGxldCBxdWVyeVJlYWRCdWZmZXI6IEdQVUJ1ZmZlcjtcclxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgIHRoaXMuY29tbWFuZEVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KFxyXG4gICAgICAgIHRoaXMucXVlcnlTZXQhLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyLFxyXG4gICAgICAgIHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyISxcclxuICAgICAgICAwLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgcXVlcnlSZWFkQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgeyBzaXplOiB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKiA4LCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB9LFxyXG4gICAgICApO1xyXG5cclxuICAgICAgdGhpcy5wZW5kaW5nUXVlcmllcy5zZXQocXVlcnlSZWFkQnVmZmVyLCB0aGlzLnBlbmRpbmdLZXJuZWxzKTtcclxuICAgICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xyXG4gICAgICB0aGlzLmNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcclxuICAgICAgICB0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciEsXHJcbiAgICAgICAgMCxcclxuICAgICAgICBxdWVyeVJlYWRCdWZmZXIsXHJcbiAgICAgICAgMCxcclxuICAgICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKiA4LFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5jb21tYW5kRW5jb2Rlci5maW5pc2goKV0pO1xyXG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKTtcclxuICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSBudWxsO1xyXG4gICAgdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPSAwO1xyXG5cclxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgIHZvaWQgcXVlcnlSZWFkQnVmZmVyIS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1hcHBlZERhdGEgPSBuZXcgQmlnVWludDY0QXJyYXkocXVlcnlSZWFkQnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpO1xyXG4gICAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxzID0gdGhpcy5wZW5kaW5nUXVlcmllcy5nZXQocXVlcnlSZWFkQnVmZmVyKSE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZWREYXRhLmxlbmd0aCAvIDI7IGkrKykge1xyXG4gICAgICAgICAgY29uc3QgcGVuZGluZ0tlcm5lbEluZm8gPSBwZW5kaW5nS2VybmVsc1tpXTtcclxuICAgICAgICAgIGNvbnN0IGtlcm5lbElkID0gcGVuZGluZ0tlcm5lbEluZm8ua2VybmVsSWQ7XHJcbiAgICAgICAgICBjb25zdCBrZXJuZWxJbmZvID0gdGhpcy5rZXJuZWxzLmdldChrZXJuZWxJZCkhO1xyXG4gICAgICAgICAgY29uc3Qga2VybmVsVHlwZSA9IGtlcm5lbEluZm8ua2VybmVsVHlwZTtcclxuICAgICAgICAgIGNvbnN0IGtlcm5lbE5hbWUgPSBrZXJuZWxJbmZvLmtlcm5lbE5hbWU7XHJcbiAgICAgICAgICBjb25zdCBwcm9ncmFtTmFtZSA9IHBlbmRpbmdLZXJuZWxJbmZvLnByb2dyYW1OYW1lO1xyXG4gICAgICAgICAgY29uc3QgaW5wdXRUZW5zb3JWaWV3cyA9IHBlbmRpbmdLZXJuZWxJbmZvLmlucHV0VGVuc29yVmlld3M7XHJcbiAgICAgICAgICBjb25zdCBvdXRwdXRUZW5zb3JWaWV3cyA9IHBlbmRpbmdLZXJuZWxJbmZvLm91dHB1dFRlbnNvclZpZXdzO1xyXG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lVTY0ID0gbWFwcGVkRGF0YVtpICogMl07XHJcbiAgICAgICAgICBjb25zdCBlbmRUaW1lVTY0ID0gbWFwcGVkRGF0YVtpICogMiArIDFdO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5xdWVyeVRpbWVCYXNlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5VGltZUJhc2UgPSBzdGFydFRpbWVVNjQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gTnVtYmVyKHN0YXJ0VGltZVU2NCAtIHRoaXMucXVlcnlUaW1lQmFzZSk7XHJcbiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gTnVtYmVyKGVuZFRpbWVVNjQgLSB0aGlzLnF1ZXJ5VGltZUJhc2UpO1xyXG5cclxuICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoc3RhcnRUaW1lKSB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZW5kVGltZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2UnKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ub25kYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmcub25kYXRhKHtcclxuICAgICAgICAgICAgICB2ZXJzaW9uOiAxLFxyXG4gICAgICAgICAgICAgIGlucHV0c01ldGFkYXRhOiBpbnB1dFRlbnNvclZpZXdzLm1hcCgodmFsdWUpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBkaW1zOiB2YWx1ZS5kaW1zLFxyXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKSxcclxuICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgb3V0cHV0c01ldGFkYXRhOiBvdXRwdXRUZW5zb3JWaWV3cy5tYXAoKHZhbHVlKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgZGltczogdmFsdWUuZGltcyxcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSksXHJcbiAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgIGtlcm5lbElkLFxyXG4gICAgICAgICAgICAgIGtlcm5lbFR5cGUsXHJcbiAgICAgICAgICAgICAga2VybmVsTmFtZSxcclxuICAgICAgICAgICAgICBwcm9ncmFtTmFtZSxcclxuICAgICAgICAgICAgICBzdGFydFRpbWUsXHJcbiAgICAgICAgICAgICAgZW5kVGltZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZCwgcHJpbnQgdGhlIHByb2ZpbGluZyBtZXNzYWdlIHRvIGNvbnNvbGVcclxuICAgICAgICAgICAgbGV0IGlucHV0U2hhcGVzID0gJyc7XHJcbiAgICAgICAgICAgIGlucHV0VGVuc29yVmlld3MuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcclxuICAgICAgICAgICAgICBpbnB1dFNoYXBlcyArPSBgaW5wdXRbJHtpfV06IFske3ZhbHVlLmRpbXN9XSB8ICR7dGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpfSwgYDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCBvdXRwdXRTaGFwZXMgPSAnJztcclxuICAgICAgICAgICAgb3V0cHV0VGVuc29yVmlld3MuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcclxuICAgICAgICAgICAgICBvdXRwdXRTaGFwZXMgKz0gYG91dHB1dFske2l9XTogWyR7dmFsdWUuZGltc31dIHwgJHt0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSl9LCBgO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7a2VybmVsSWR9fCR7a2VybmVsVHlwZX18JHtrZXJuZWxOYW1lfXwke3Byb2dyYW1OYW1lfVwiICR7aW5wdXRTaGFwZXN9JHtcclxuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlc1xyXG4gICAgICAgICAgICAgIH1zdGFydCB0aW1lOiAke3N0YXJ0VGltZX0gbnMsIGV4ZWN1dGlvbiB0aW1lOiAke2VuZFRpbWUgLSBzdGFydFRpbWV9IG5zYCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFRSQUNFKCdHUFUnLCBgJHtwcm9ncmFtTmFtZX06OiR7c3RhcnRUaW1lVTY0fTo6JHtlbmRUaW1lVTY0fWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeVJlYWRCdWZmZXIudW5tYXAoKTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdRdWVyaWVzLmRlbGV0ZShxdWVyeVJlYWRCdWZmZXIpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBydW4gYSBXZWJHUFUgcHJvZ3JhbS5cclxuICAgKiBAcGFyYW0gcHJvZ3JhbSBhIFByb2dyYW1JbmZvIGluc3RhbmNlXHJcbiAgICogQHBhcmFtIGlucHV0VGVuc29yVmlld3MgYSBUZW5zb3JWaWV3IGFycmF5LiBlYWNoIGVsZW1lbnQgcmVwcmVzZW50cyBhIHZhbHVlIGFscmVhZHkgZXhpc3RzIGluIEdQVS5cclxuICAgKiBAcGFyYW0gb3V0cHV0SW5kaWNlcyBhbiBpbmRpY2VzIGFycmF5LiBlYWNoIGVsZW1lbnQgY2FuIGJlIGVpdGhlciAtMSAodGVtcG9yYXJ5IGRhdGEpLCAtMiAocGVyc2lzdGVudCBkYXRhKSBvciBhblxyXG4gICAqIGluZGV4IHRvIHRoZSBrZXJuZWwncyBvdXRwdXQuXHJcbiAgICogQHBhcmFtIGNyZWF0ZUtlcm5lbE91dHB1dCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY3JlYXRlIGEgdmFsdWUgdG8ga2VybmVsJ3Mgb3V0cHV0IHdpdGggdGhlIGdpdmVuIGluZGV4XHJcbiAgICogQHBhcmFtIGNyZWF0ZUludGVybWVkaWF0ZU91dHB1dCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY3JlYXRlIGEgdmFsdWUgYXMgYSBpbnRlcm1lZGlhdGUgdmFsdWUsIGVpdGhlciB0ZW1wb3JhcnlcclxuICAgKiBvciBwZXJzaXN0ZW50IChvd25lZCBieSB0aGUgY3VycmVudCBrZXJuZWwpXHJcbiAgICogQHJldHVybnMgYSBUZW5zb3JWaWV3IGFycmF5IHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxyXG4gICAqL1xyXG4gIHJ1bihcclxuICAgIHByb2dyYW06IFByb2dyYW1JbmZvLFxyXG4gICAgaW5wdXRUZW5zb3JWaWV3czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gICAgb3V0cHV0SW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgICBjcmVhdGVLZXJuZWxPdXRwdXQ6IChpbmRleDogbnVtYmVyLCBkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSkgPT4gVGVuc29yVmlldyxcclxuICAgIGNyZWF0ZUludGVybWVkaWF0ZU91dHB1dDogKGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBUZW5zb3JWaWV3LFxyXG4gICAgb3V0cHV0Q291bnQ6IG51bWJlcixcclxuICApOiBUZW5zb3JWaWV3W10ge1xyXG4gICAgVFJBQ0VfRlVOQ19CRUdJTihwcm9ncmFtLm5hbWUpO1xyXG4gICAgLy8gY3JlYXRlIGluZm8gZm9yIGlucHV0c1xyXG4gICAgY29uc3QgaW5wdXREYXRhczogR3B1RGF0YVtdID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0VGVuc29yVmlld3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgY29uc3QgZGF0YSA9IGlucHV0VGVuc29yVmlld3NbaV0uZGF0YTtcclxuICAgICAgLy8gaWYgdGVuc29yIHZpZXcgZGF0YSBpcyAwLCBpdCBtZWFucyB0aGUgb3V0cHV0IGlzIHplcm8tc2l6ZWQgdGVuc29yLCBhbmQgdGhlcmUgaXMgbm8gR1BVIGRhdGEgZm9yIGl0LlxyXG4gICAgICBpZiAoZGF0YSA9PT0gMCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldChkYXRhKTtcclxuICAgICAgaWYgKCFncHVEYXRhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7ZGF0YX1gKTtcclxuICAgICAgfVxyXG4gICAgICBpbnB1dERhdGFzLnB1c2goZ3B1RGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBvdXRwdXRzLCBkaXNwYXRjaEdyb3VwLCBwcm9ncmFtVW5pZm9ybXMgfSA9IHByb2dyYW0uZ2V0UnVuRGF0YShpbnB1dFRlbnNvclZpZXdzKTtcclxuXHJcbiAgICAvLyBjaGVjayBvdXRwdXQgaW5kaWNlc1xyXG4gICAgY29uc3QgdmFsaWRhdGVkT3V0cHV0SW5kaWNlcyA9IG91dHB1dEluZGljZXMubGVuZ3RoID09PSAwID8gb3V0cHV0cy5tYXAoKF8sIGkpID0+IGkpIDogb3V0cHV0SW5kaWNlcztcclxuICAgIGlmICh2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzLmxlbmd0aCAhPT0gb3V0cHV0cy5sZW5ndGgpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke3ZhbGlkYXRlZE91dHB1dEluZGljZXMubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7b3V0cHV0cy5sZW5ndGh9LmApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNyZWF0ZSBpbmZvIGZvciBvdXRwdXRzXHJcbiAgICBjb25zdCBvdXRwdXRUZW5zb3JWaWV3czogVGVuc29yVmlld1tdID0gW107XHJcbiAgICBjb25zdCBvdXRwdXREYXRhczogR3B1RGF0YVtdID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgLy8gdmFsdWUgLTEgYW5kIC0yIGFyZSB1c2VkIGZvciBjcmVhdGluZyB0ZW1wb3JhcnkgYW5kIHBlcnNpc3RlbnQgb3V0cHV0cy5cclxuICAgICAgLy8gdmFsdWUgLTMgaXMgdXNlZCBmb3IgcGxhY2Vob2xkZXIgb3V0cHV0LiBTbyAtMywgLTIsIC0xIGFuZCAwLCAxLCAyLCAuLi4gYXJlIHZhbGlkXHJcbiAgICAgIC8vIG91dHB1dCBpbmRpY2VzLiBzZWUgdHlwZSBkZWZpbml0aW9uIG9mIENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcgZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAgaWYgKFxyXG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0pIHx8XHJcbiAgICAgICAgdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA8IC0zIHx8XHJcbiAgICAgICAgdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA+PSBvdXRwdXRDb3VudFxyXG4gICAgICApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke3ZhbGlkYXRlZE91dHB1dEluZGljZXNbaV19YCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPT09IC0zKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaXNUZW1wb3JhcnkgPSB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMTtcclxuICAgICAgY29uc3QgaXNQZXJzaXN0ZW50ID0gdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA9PT0gLTI7XHJcbiAgICAgIGNvbnN0IHRlbnNvclZpZXcgPVxyXG4gICAgICAgIGlzVGVtcG9yYXJ5IHx8IGlzUGVyc2lzdGVudFxyXG4gICAgICAgICAgPyBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQob3V0cHV0c1tpXS5kYXRhVHlwZSwgb3V0cHV0c1tpXS5kaW1zKVxyXG4gICAgICAgICAgOiBjcmVhdGVLZXJuZWxPdXRwdXQodmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSwgb3V0cHV0c1tpXS5kYXRhVHlwZSwgb3V0cHV0c1tpXS5kaW1zKTtcclxuICAgICAgb3V0cHV0VGVuc29yVmlld3MucHVzaCh0ZW5zb3JWaWV3KTtcclxuICAgICAgLy8gaWYgdGVuc29yIHZpZXcgZGF0YSBpcyAwLCBpdCBtZWFucyB0aGUgb3V0cHV0IGlzIHplcm8tc2l6ZWQgdGVuc29yLCBhbmQgdGhlcmUgaXMgbm8gR1BVIGRhdGEgZm9yIGl0LlxyXG4gICAgICBpZiAodGVuc29yVmlldy5kYXRhID09PSAwKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZ3B1RGF0YSA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHRlbnNvclZpZXcuZGF0YSk7XHJcbiAgICAgIGlmICghZ3B1RGF0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHt0ZW5zb3JWaWV3LmRhdGF9YCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzVGVtcG9yYXJ5KSB7XHJcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goZ3B1RGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzUGVyc2lzdGVudCkge1xyXG4gICAgICAgIGxldCBwZXJzaXN0ZW50RGF0YSA9IHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkISk7XHJcbiAgICAgICAgaWYgKCFwZXJzaXN0ZW50RGF0YSkge1xyXG4gICAgICAgICAgcGVyc2lzdGVudERhdGEgPSBbXTtcclxuICAgICAgICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkISwgcGVyc2lzdGVudERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwZXJzaXN0ZW50RGF0YS5wdXNoKGdwdURhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIG91dHB1dERhdGFzLnB1c2goZ3B1RGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2hlbiB0aGVyZSBhcmUgYW55IHplcm8tc2l6ZWQgdGVuc29yIGluIHRoZSBpbnB1dHMgb3Igb3V0cHV0cywgd2Ugc2hvdWxkIHJlcG9ydCBlcnJvciB1bmxlc3MgYWxsIG91dHB1dHMgYXJlXHJcbiAgICAvLyB6ZXJvLXNpemVkIHRlbnNvcnMuXHJcbiAgICBpZiAoaW5wdXREYXRhcy5sZW5ndGggIT09IGlucHV0VGVuc29yVmlld3MubGVuZ3RoIHx8IG91dHB1dERhdGFzLmxlbmd0aCAhPT0gb3V0cHV0VGVuc29yVmlld3MubGVuZ3RoKSB7XHJcbiAgICAgIC8vIGlmIGFsbCBvdXRwdXRzIGFyZSB6ZXJvLXNpemVkIHRlbnNvcnMsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcnVuIHRoZSBwcm9ncmFtLlxyXG4gICAgICBpZiAob3V0cHV0RGF0YXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbS5uYW1lKTtcclxuICAgICAgICByZXR1cm4gb3V0cHV0VGVuc29yVmlld3M7XHJcbiAgICAgIH1cclxuICAgICAgLy8gaWYgc29tZSBvdXRwdXRzIGFyZSB6ZXJvLXNpemVkIHRlbnNvcnMsIHJlcG9ydCBhbiBlcnJvci5cclxuICAgICAgLy9cclxuICAgICAgLy8gVE9ETzogc28gZmFyIHdlIGRvbid0IHNlZSBhbnkgdXNlIGNhc2UgdGhhdCBvdXRwdXRzIGluY2x1ZGUgYm90aCB6ZXJvLXNpemVkIHRlbnNvcnMgYW5kIG5vbi16ZXJvLXNpemVkIHRlbnNvcnMuXHJcbiAgICAgIC8vIElmIHdlIHNlZSBzdWNoIHVzZSBjYXNlLCB3ZSBuZWVkIHRvIG1ha2UgYSBjaGFuZ2UgaGVyZSB0byBzdXBwb3J0IGl0LlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYFByb2dyYW0gJHtwcm9ncmFtLm5hbWV9IGhhcyB6ZXJvLXNpemVkIHRlbnNvcihzKSBpbiBpbnB1dHMgb3Igb3V0cHV0cy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIG5vdy5gLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGxvYWQgdW5pZm9ybXNcclxuICAgIC8vIFRPRE86IGFkZCBjYWNoZSBmb3IgdW5pZm9ybSAoaXMgaXQgbmVjZXNzYXJ5PylcclxuICAgIC8vXHJcbiAgICBsZXQgdW5pZm9ybUJ1ZmZlckJpbmRpbmc6IEdQVUJpbmRpbmdSZXNvdXJjZSB8IHVuZGVmaW5lZDtcclxuICAgIGlmIChwcm9ncmFtVW5pZm9ybXMpIHtcclxuICAgICAgbGV0IGN1cnJlbnRPZmZzZXQgPSAwO1xyXG4gICAgICBjb25zdCBvZmZzZXRzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLmZvckVhY2goKHYpID0+IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIHYuZGF0YSA9PT0gJ251bWJlcicgPyBbdi5kYXRhXSA6IHYuZGF0YTtcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL1dHU0wvI2FsaWdub2ZcclxuICAgICAgICBjb25zdCBzaXplT2ZFbGVtZW50ID0gdi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2ID8gMiA6IDQ7XHJcbiAgICAgICAgbGV0IHNpemVPZlZlY09yTWF0O1xyXG4gICAgICAgIGxldCBiYXNlQWxpZ25tZW50O1xyXG4gICAgICAgIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYpIHtcclxuICAgICAgICAgIGJhc2VBbGlnbm1lbnQgPSBkYXRhLmxlbmd0aCA+IDQgPyAxNiA6IGRhdGEubGVuZ3RoID4gMiA/IDggOiBkYXRhLmxlbmd0aCAqIHNpemVPZkVsZW1lbnQ7XHJcbiAgICAgICAgICBzaXplT2ZWZWNPck1hdCA9IGRhdGEubGVuZ3RoID4gNCA/IDE2IDogc2l6ZU9mRWxlbWVudCAqIGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBiYXNlQWxpZ25tZW50ID0gZGF0YS5sZW5ndGggPD0gMiA/IGRhdGEubGVuZ3RoICogc2l6ZU9mRWxlbWVudCA6IDE2O1xyXG4gICAgICAgICAgc2l6ZU9mVmVjT3JNYXQgPSAxNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudE9mZnNldCA9IE1hdGguY2VpbChjdXJyZW50T2Zmc2V0IC8gYmFzZUFsaWdubWVudCkgKiBiYXNlQWxpZ25tZW50O1xyXG4gICAgICAgIG9mZnNldHMucHVzaChjdXJyZW50T2Zmc2V0KTtcclxuICAgICAgICAvLyBGb3Igbm9uLWZsb2F0MTYgdHlwZSwgd2hlbiBkYXRhLmxlbmd0aCA+IDQsIHRoZSB1bmlmb3JtIHZhcmlhYmxlIGlzIG9mIHR5cGUgYXJyYXk8dmVjNDxpMzJ8dTMyfGYzMj4sTj4sIHdoZXJlXHJcbiAgICAgICAgLy8gTiA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDQpIGFuZCBTaXplT2YodmVjNDxpMzJ8dTMyfGYzMj4pID0gMTYuIFRoZSB0b3RhbCBieXRlIGxlbmd0aCBpcyBOICpcclxuICAgICAgICAvLyBTaXplT2YodmVjNDxpMzJ8dTMyfGYzMj4pLiBGb3IgZmxvYXQxNiB0eXBlLCB3aGVuIGRhdGEubGVuZ3RoID4gNCwgdGhlIHVuaWZvcm0gdmFyaWFibGUgaXMgb2YgdHlwZVxyXG4gICAgICAgIC8vIGFycmF5PG1hdDJ4NDxmMTY+LE4+LCB3aGVyZSBOID0gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gOCkgYW5kIFNpemVPZihtYXQyeDQ8ZjE2PikgPSAxNi4gVGhlIHRvdGFsIGJ5dGVcclxuICAgICAgICAvLyBsZW5ndGggaXMgTiAqIFNpemVPZihtYXQyeDQ8ZjE2PikuXHJcbiAgICAgICAgY29uc3QgZWxlbWVudFBlclZlY09yTWF0ID0gdi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2ID8gOCA6IDQ7XHJcbiAgICAgICAgY3VycmVudE9mZnNldCArPVxyXG4gICAgICAgICAgZGF0YS5sZW5ndGggPiA0ID8gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gZWxlbWVudFBlclZlY09yTWF0KSAqIHNpemVPZlZlY09yTWF0IDogZGF0YS5sZW5ndGggKiBzaXplT2ZFbGVtZW50O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIE1lZXQgYWxpZ25tZW50IG9mIHN0cnVjdCBoZXJlOiBodHRwczovL3d3dy53My5vcmcvVFIvV0dTTC8jYWxpZ25tZW50LWFuZC1zaXplLiBGb3Igc2ltcGxpY2l0eSwgc2V0XHJcbiAgICAgIC8vIG1heEFsaWdubWVudE9mRmllbGQgdG8gMTYgc2luY2UgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGhhcyBiZWVuIHJvdW5kZWQgdXAgdG8gMTYuXHJcbiAgICAgIGNvbnN0IG1heEFsaWdubWVudE9mRmllbGQgPSAxNjtcclxuICAgICAgY3VycmVudE9mZnNldCA9IE1hdGguY2VpbChjdXJyZW50T2Zmc2V0IC8gbWF4QWxpZ25tZW50T2ZGaWVsZCkgKiBtYXhBbGlnbm1lbnRPZkZpZWxkO1xyXG4gICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjdXJyZW50T2Zmc2V0KTtcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLmZvckVhY2goKHYsIGkpID0+IHtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRzW2ldO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2Ygdi5kYXRhID09PSAnbnVtYmVyJyA/IFt2LmRhdGFdIDogdi5kYXRhO1xyXG4gICAgICAgIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmludDMyKSB7XHJcbiAgICAgICAgICBuZXcgSW50MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSBEYXRhVHlwZS51aW50MzIpIHtcclxuICAgICAgICAgIG5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2KSB7XHJcbiAgICAgICAgICBuZXcgVWludDE2QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQpIHtcclxuICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGU6ICR7dGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodi50eXBlKX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgdW5pZm9ybUJ1ZmZlckRhdGEgPVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoY3VycmVudE9mZnNldCwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKTtcclxuICAgICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIodW5pZm9ybUJ1ZmZlckRhdGEuYnVmZmVyLCAwLCBhcnJheUJ1ZmZlciwgMCwgY3VycmVudE9mZnNldCk7XHJcbiAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZSh1bmlmb3JtQnVmZmVyRGF0YS5pZCk7XHJcbiAgICAgIHVuaWZvcm1CdWZmZXJCaW5kaW5nID0geyBvZmZzZXQ6IDAsIHNpemU6IGN1cnJlbnRPZmZzZXQsIGJ1ZmZlcjogdW5pZm9ybUJ1ZmZlckRhdGEuYnVmZmVyIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgbm9ybWFsaXplZERpc3BhdGNoR3JvdXAgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKGRpc3BhdGNoR3JvdXApO1xyXG4gICAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXSA9PT0gMSAmJiBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXSA9PT0gMTtcclxuICAgIC8vIGdldCBwcm9ncmFtIGluZm9cclxuICAgIGNvbnN0IGtleSA9IGdldFByb2dyYW1JbmZvVW5pcXVlS2V5KHByb2dyYW0sIGlucHV0VGVuc29yVmlld3MsIGlzMURpbWVuc2lvbkRpc3BhdGNoKTtcclxuICAgIGxldCBhcnRpZmFjdCA9IHRoaXMucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qoa2V5KTtcclxuICAgIGlmICghYXJ0aWZhY3QpIHtcclxuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHByb2dyYW0sIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwKTtcclxuICAgICAgdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChrZXksIGFydGlmYWN0KTtcclxuICAgICAgTE9HX0RFQlVHKCdpbmZvJywgKCkgPT4gYFthcnRpZmFjdF0ga2V5OiAke2tleX0sIHByb2dyYW1OYW1lOiAke3Byb2dyYW0ubmFtZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB2YWxpZGF0ZSB1bmlmb3JtIHZhcmlhYmxlc1xyXG4gICAgaWYgKHByb2dyYW1Vbmlmb3JtcyAmJiBhcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mbykge1xyXG4gICAgICBpZiAocHJvZ3JhbVVuaWZvcm1zLmxlbmd0aCAhPT0gYXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYFVuaWZvcm0gdmFyaWFibGVzIGNvdW50IG1pc21hdGNoOiBleHBlY3QgJHthcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mby5sZW5ndGh9LCBnb3QgJHtcclxuICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLmxlbmd0aFxyXG4gICAgICAgICAgfSBpbiBwcm9ncmFtIFwiJHthcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lfVwiLmAsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW1Vbmlmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHVuaWZvcm0gPSBwcm9ncmFtVW5pZm9ybXNbaV07XHJcbiAgICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IHVuaWZvcm0udHlwZTtcclxuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSB0eXBlb2YgdW5pZm9ybS5kYXRhID09PSAnbnVtYmVyJyA/IDEgOiB1bmlmb3JtLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IFt0eXBlLCBsZW5ndGhdID0gYXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm9baV07XHJcbiAgICAgICAgaWYgKGFjdHVhbFR5cGUgIT09IHR5cGUgfHwgYWN0dWFsTGVuZ3RoICE9PSBsZW5ndGgpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgYFVuaWZvcm0gdmFyaWFibGUgJHtpfSBtaXNtYXRjaDogZXhwZWN0IHR5cGUgJHt0eXBlfSB3aXRoIHNpemUgJHtsZW5ndGh9LCBnb3QgdHlwZSAke1xyXG4gICAgICAgICAgICAgIGFjdHVhbFR5cGVcclxuICAgICAgICAgICAgfSB3aXRoIHNpemUgJHthY3R1YWxMZW5ndGh9IGluIHByb2dyYW0gXCIke2FydGlmYWN0LnByb2dyYW1JbmZvLm5hbWV9XCIuYCxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgTE9HX0RFQlVHKFxyXG4gICAgICAnaW5mbycsXHJcbiAgICAgICgpID0+XHJcbiAgICAgICAgYFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHtwcm9ncmFtLm5hbWV9XCIgKGtleT0ke2tleX0pIHdpdGggJHtub3JtYWxpemVkRGlzcGF0Y2hHcm91cFswXX14JHtcclxuICAgICAgICAgIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdXHJcbiAgICAgICAgfXgke25vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdfWAsXHJcbiAgICApO1xyXG5cclxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnIHx8IHRoaXMuc2Vzc2lvblN0YXR1cyA9PT0gJ2NhcHR1cmluZycpIHtcclxuICAgICAgY29uc3QgcGVuZGluZ0tlcm5lbEluZm86IFBlbmRpbmdLZXJuZWxJbmZvID0ge1xyXG4gICAgICAgIGtlcm5lbElkOiB0aGlzLmN1cnJlbnRLZXJuZWxJZCEsXHJcbiAgICAgICAgcHJvZ3JhbU5hbWU6IGFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUsXHJcbiAgICAgICAgaW5wdXRUZW5zb3JWaWV3cyxcclxuICAgICAgICBvdXRwdXRUZW5zb3JWaWV3cyxcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHBlbmRpbmdLZXJuZWxJbmZvKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnNlc3Npb25TdGF0dXMgPT09ICdjYXB0dXJpbmcnKSB7XHJcbiAgICAgICAgY29uc3Qgc2Vzc2lvblBlbmRpbmdLZXJuZWxzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhKTtcclxuICAgICAgICBzZXNzaW9uUGVuZGluZ0tlcm5lbHMhLnB1c2gocGVuZGluZ0tlcm5lbEluZm8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4oYXJ0aWZhY3QsIGlucHV0RGF0YXMsIG91dHB1dERhdGFzLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cCwgdW5pZm9ybUJ1ZmZlckJpbmRpbmcpO1xyXG5cclxuICAgIFRSQUNFX0ZVTkNfRU5EKHByb2dyYW0ubmFtZSk7XHJcbiAgICByZXR1cm4gb3V0cHV0VGVuc29yVmlld3M7XHJcbiAgfVxyXG5cclxuICB1cGxvYWQoZ3B1RGF0YUlkOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcclxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIudXBsb2FkKGdwdURhdGFJZCwgZGF0YSk7XHJcbiAgfVxyXG5cclxuICBtZW1jcHkoc3JjOiBudW1iZXIsIGRzdDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweShzcmMsIGRzdCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkb3dubG9hZChncHVEYXRhSWQ6IG51bWJlciwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyB0aGUgdW5kZXJseWluZyBidWZmZXIgbWF5IGJlIGNoYW5nZWQgYWZ0ZXIgdGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGNhbGxlZC4gc28gd2UgdXNlIGEgZ2V0dGVyIGZ1bmN0aW9uIHRvIG1ha2Ugc3VyZVxyXG4gICAgLy8gdGhlIGJ1ZmZlciBpcyB1cC10by1kYXRlLlxyXG4gICAgYXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZChncHVEYXRhSWQsIGdldFRhcmdldEJ1ZmZlcik7XHJcbiAgfVxyXG5cclxuICBhbGxvYyhzaXplOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemUpLmlkO1xyXG4gIH1cclxuXHJcbiAgZnJlZShwdHI6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHB0cik7XHJcbiAgfVxyXG5cclxuICBjcmVhdGVLZXJuZWwoa2VybmVsVHlwZTogc3RyaW5nLCBrZXJuZWxJZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHVua25vd24sIGtlcm5lbE5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgY29uc3Qgb3AgPSBXRUJHUFVfT1BfUkVTT0xWRV9SVUxFUy5nZXQoa2VybmVsVHlwZSk7XHJcbiAgICBpZiAoIW9wKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHtrZXJuZWxUeXBlfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGtlcm5lbEluZm86IEtlcm5lbEluZm8gPSB7XHJcbiAgICAgIGtlcm5lbFR5cGUsXHJcbiAgICAgIGtlcm5lbE5hbWUsXHJcbiAgICAgIGtlcm5lbEVudHJ5OiBvcFswXSxcclxuICAgICAgYXR0cmlidXRlczogW29wWzFdLCBhdHRyaWJ1dGVdLFxyXG4gICAgfTtcclxuICAgIHRoaXMua2VybmVscy5zZXQoa2VybmVsSWQsIGtlcm5lbEluZm8pO1xyXG4gIH1cclxuXHJcbiAgcmVsZWFzZUtlcm5lbChrZXJuZWxJZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBjb25zdCBwZXJzaXN0ZW50RGF0YSA9IHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KGtlcm5lbElkKTtcclxuICAgIGlmIChwZXJzaXN0ZW50RGF0YSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgcGVyc2lzdGVudERhdGEpIHtcclxuICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZGF0YS5pZCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5kZWxldGUoa2VybmVsSWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUoa2VybmVsSWQpO1xyXG4gICAgdGhpcy5rZXJuZWxzLmRlbGV0ZShrZXJuZWxJZCk7XHJcbiAgfVxyXG5cclxuICBjb21wdXRlS2VybmVsKGtlcm5lbElkOiBudW1iZXIsIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBlcnJvcnM6IEFycmF5PFByb21pc2U8c3RyaW5nIHwgbnVsbD4+KTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpO1xyXG4gICAgaWYgKCFrZXJuZWwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGNyZWF0ZWQ6ICR7a2VybmVsSWR9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBrZXJuZWxUeXBlID0ga2VybmVsLmtlcm5lbFR5cGU7XHJcbiAgICBjb25zdCBrZXJuZWxOYW1lID0ga2VybmVsLmtlcm5lbE5hbWU7XHJcbiAgICBjb25zdCBrZXJuZWxFbnRyeSA9IGtlcm5lbC5rZXJuZWxFbnRyeTtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBrZXJuZWwuYXR0cmlidXRlcztcclxuICAgIGlmICh0aGlzLmN1cnJlbnRLZXJuZWxJZCAhPT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmN1cnJlbnRLZXJuZWxJZCA9IGtlcm5lbElkO1xyXG5cclxuICAgIC8vIHBhcnNlIGF0dHJpYnV0ZXMgaWYgbmVjZXNzYXJ5XHJcbiAgICBpZiAoYXR0cmlidXRlc1swXSkge1xyXG4gICAgICBhdHRyaWJ1dGVzWzFdID0gYXR0cmlidXRlc1swXShhdHRyaWJ1dGVzWzFdKTtcclxuICAgICAgYXR0cmlidXRlc1swXSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBMT0dfREVCVUcoJ2luZm8nLCAoKSA9PiBgW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIuLi5gKTtcclxuXHJcbiAgICBjb25zdCB1c2VFcnJvclNjb3BlID0gdGhpcy5lbnYuZGVidWc7XHJcblxyXG4gICAgdGhpcy50ZW1wb3JhcnlEYXRhID0gW107XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodXNlRXJyb3JTY29wZSkge1xyXG4gICAgICAgIHRoaXMuZGV2aWNlLnB1c2hFcnJvclNjb3BlKCd2YWxpZGF0aW9uJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGtlcm5lbEVudHJ5KGNvbnRleHQsIGF0dHJpYnV0ZXNbMV0pO1xyXG4gICAgICByZXR1cm4gMDsgLy8gT1JUX09LXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGVycm9ycy5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIiBmYWlsZWQuICR7ZX1gKSk7XHJcbiAgICAgIHJldHVybiAxOyAvLyBPUlRfRkFJTFxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgaWYgKHVzZUVycm9yU2NvcGUpIHtcclxuICAgICAgICBlcnJvcnMucHVzaChcclxuICAgICAgICAgIHRoaXMuZGV2aWNlXHJcbiAgICAgICAgICAgIC5wb3BFcnJvclNjb3BlKClcclxuICAgICAgICAgICAgLnRoZW4oKGVycikgPT5cclxuICAgICAgICAgICAgICBlcnIgPyBgR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCI6ICR7ZXJyLm1lc3NhZ2V9YCA6IG51bGwsXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChjb25zdCBkYXRhIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSkge1xyXG4gICAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShkYXRhLmlkKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRlbXBvcmFyeURhdGEgPSBbXTtcclxuICAgICAgdGhpcy5jdXJyZW50S2VybmVsSWQgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gI3JlZ2lvbiBleHRlcm5hbCBidWZmZXJcclxuICByZWdpc3RlckJ1ZmZlcihzZXNzaW9uSWQ6IG51bWJlciwgaW5kZXg6IG51bWJlciwgYnVmZmVyOiBHUFVCdWZmZXIsIHNpemU6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBsZXQgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHNlc3Npb25JZCk7XHJcbiAgICBpZiAoIXNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpIHtcclxuICAgICAgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IG5ldyBNYXAoKTtcclxuICAgICAgdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQoc2Vzc2lvbklkLCBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGUgYnVmZmVyIG1heSBiZSB1c2VyIGNyZWF0ZWQsIG9yIG1hbmFnZWQgYnkgR1BVIGRhdGEgbWFuYWdlci5cclxuICAgIC8vIFRoZSBHUFUgZGF0YSBtYW5hZ2VyIHdpbGwgbm90IG1hbmFnZSB0aGVzZSBidWZmZXJzLiB3ZSByZWdpc3RlciB0aGVtIGFzIGV4dGVybmFsIGJ1ZmZlcnMuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIG1hcCBgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZ2AgaXMgdXNlZCB0byBzdG9yZSB0aGUgZGF0YSBJRCBhbmQgYnVmZmVyIGZvciBlYWNoIGlucHV0L291dHB1dC4gT25jZSBhXHJcbiAgICAvLyBzcGVjaWZpYyBpbnB1dC9vdXRwdXQgaXMgcmVnaXN0ZXJlZCwgdGhlIGRhdGEgSUQgd2lsbCBub3QgY2hhbmdlLlxyXG4gICAgY29uc3QgcHJldmlvdXNCdWZmZXIgPSBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nLmdldChpbmRleCk7XHJcbiAgICBjb25zdCBpZCA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXIsIHNpemUsIHByZXZpb3VzQnVmZmVyKTtcclxuICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuc2V0KGluZGV4LCBbaWQsIGJ1ZmZlcl0pO1xyXG4gICAgcmV0dXJuIGlkO1xyXG4gIH1cclxuICB1bnJlZ2lzdGVyQnVmZmVycyhzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3Qgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHNlc3Npb25JZCk7XHJcbiAgICBpZiAoc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZykge1xyXG4gICAgICBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nLmZvckVhY2goKGJ1ZmZlckluZm8pID0+IHRoaXMuZ3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlckluZm9bMF0pKTtcclxuICAgICAgdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUoc2Vzc2lvbklkKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0QnVmZmVyKGdwdURhdGFJZDogbnVtYmVyKTogR1BVQnVmZmVyIHtcclxuICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldChncHVEYXRhSWQpO1xyXG4gICAgaWYgKCFncHVEYXRhKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHtncHVEYXRhSWR9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ3B1RGF0YS5idWZmZXI7XHJcbiAgfVxyXG4gIGNyZWF0ZURvd25sb2FkZXIoXHJcbiAgICBncHVCdWZmZXI6IEdQVUJ1ZmZlcixcclxuICAgIHNpemU6IG51bWJlcixcclxuICAgIHR5cGU6IFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXMsXHJcbiAgKTogKCkgPT4gUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGU+IHtcclxuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBkb3dubG9hZEdwdURhdGEodGhpcywgZ3B1QnVmZmVyLCBzaXplKTtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVZpZXcoZGF0YS5idWZmZXIsIHR5cGUpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgLy8gI2VuZHJlZ2lvblxyXG4gIHdyaXRlVGltZXN0YW1wKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ2luc2lkZS1wYXNzZXMnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyIGFzIGFueSkud3JpdGVUaW1lc3RhbXAodGhpcy5xdWVyeVNldCwgaW5kZXgpO1xyXG4gIH1cclxuICBzZXRRdWVyeVR5cGUoKTogdm9pZCB7XHJcbiAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdub25lJztcclxuICAgIGlmIChcclxuICAgICAgdGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ubW9kZSA9PT0gJ2RlZmF1bHQnIHx8XHJcbiAgICAgICh0eXBlb2YgdGhpcy5lbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gdGhpcy5lbnYud2FzbS50cmFjZSA6IHRoaXMuZW52LnRyYWNlKVxyXG4gICAgKSB7XHJcbiAgICAgIGlmICh0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoJ2Nocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3NlcycpKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAnaW5zaWRlLXBhc3Nlcyc7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKCd0aW1lc3RhbXAtcXVlcnknKSkge1xyXG4gICAgICAgIHRoaXMucXVlcnlUeXBlID0gJ2F0LXBhc3Nlcyc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnICYmIHR5cGVvZiB0aGlzLnF1ZXJ5U2V0ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRoaXMucXVlcnlTZXQgPSB0aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7XHJcbiAgICAgICAgICB0eXBlOiAndGltZXN0YW1wJyxcclxuICAgICAgICAgIGNvdW50OiB0aGlzLm1heERpc3BhdGNoTnVtYmVyICogMixcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgICB7IHNpemU6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyICogOCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRSB9LFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNhcHR1cmVCZWdpbigpOiB2b2lkIHtcclxuICAgIExPR19ERUJVRygnaW5mbycsICdjYXB0dXJlQmVnaW4nKTtcclxuICAgIGlmICghdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhKSkge1xyXG4gICAgICB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3Quc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhKSkge1xyXG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcclxuICAgIH1cclxuICAgIC8vIGZsdXNoIHRoZSBsZWZ0IGNvbW1hbmRzIGJlZm9yZSB3ZSBjaGFuZ2UgdGhlIHN0YXR1cy5cclxuICAgIHRoaXMuZmx1c2goKTtcclxuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdjYXB0dXJpbmcnO1xyXG4gIH1cclxuICBjYXB0dXJlRW5kKCk6IHZvaWQge1xyXG4gICAgTE9HX0RFQlVHKCdpbmZvJywgJ2NhcHR1cmVFbmQnKTtcclxuICAgIC8vIGZsdXNoIHRoZSBsZWZ0IGNvbW1hbmRzIGJlZm9yZSB3ZSBjaGFuZ2UgdGhlIHN0YXR1cy5cclxuICAgIHRoaXMuZmx1c2goKTtcclxuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdkZWZhdWx0JztcclxuICB9XHJcbiAgcmVwbGF5KCk6IHZvaWQge1xyXG4gICAgTE9HX0RFQlVHKCdpbmZvJywgJ3JlcGxheScpO1xyXG4gICAgdGhpcy5zZXNzaW9uU3RhdHVzID0gJ3JlcGxheWluZyc7XHJcbiAgICBjb25zdCBzZXNzaW9uQ29tbWFuZExpc3QgPSB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpO1xyXG4gICAgY29uc3Qgc2Vzc2lvblBlbmRpbmdLZXJuZWxzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhKTtcclxuICAgIGNvbnN0IGxlbmd0aCA9IHNlc3Npb25Db21tYW5kTGlzdCEubGVuZ3RoO1xyXG4gICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBjb21wdXRlUGFzc0VuY29kZXIgPSB0aGlzLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO1xyXG4gICAgICBjb25zdCBjb21tYW5kID0gc2Vzc2lvbkNvbW1hbmRMaXN0IVtpXTtcclxuICAgICAgdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIpO1xyXG4gICAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0UGlwZWxpbmUoY29tbWFuZC5jb21wdXRlUGlwZWxpbmUpO1xyXG4gICAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGNvbW1hbmQuYmluZEdyb3VwKTtcclxuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLmRpc3BhdGNoV29ya2dyb3VwcyguLi5jb21tYW5kLmRpc3BhdGNoR3JvdXApO1xyXG4gICAgICB0aGlzLndyaXRlVGltZXN0YW1wKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiArIDEpO1xyXG4gICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrO1xyXG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0tlcm5lbHMucHVzaChzZXNzaW9uUGVuZGluZ0tlcm5lbHMhW2ldKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPj0gdGhpcy5tYXhEaXNwYXRjaE51bWJlciB8fCB0aGlzLnF1ZXJ5VHlwZSA9PT0gJ2F0LXBhc3NlcycpIHtcclxuICAgICAgICB0aGlzLmVuZENvbXB1dGVQYXNzKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIpIHtcclxuICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGZsdXNoIHRoZSBsZWZ0IGNvbW1hbmRzIGJlZm9yZSB3ZSBjaGFuZ2UgdGhlIHN0YXR1cy5cclxuICAgIHRoaXMuZmx1c2goKTtcclxuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdkZWZhdWx0JztcclxuICB9XHJcblxyXG4gIG9uQ3JlYXRlU2Vzc2lvbigpOiB2b2lkIHtcclxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIub25DcmVhdGVTZXNzaW9uKCk7XHJcbiAgfVxyXG5cclxuICBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLnVucmVnaXN0ZXJCdWZmZXJzKHNlc3Npb25JZCk7XHJcbiAgICBpZiAodGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmhhcyhzZXNzaW9uSWQpKSB7XHJcbiAgICAgIHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5kZWxldGUoc2Vzc2lvbklkKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuaGFzKHNlc3Npb25JZCkpIHtcclxuICAgICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmRlbGV0ZShzZXNzaW9uSWQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5vblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZCk7XHJcbiAgfVxyXG5cclxuICBvblJ1blN0YXJ0KHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLmN1cnJlbnRTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XHJcbiAgICB0aGlzLnNldFF1ZXJ5VHlwZSgpO1xyXG4gIH1cclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB0eXBlIHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcclxuXHJcbmltcG9ydCB7IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzLCBEYXRhVHlwZSB9IGZyb20gJy4uL3dhc20tY29tbW9uJztcclxuXHJcbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1vZHVsZSB9IGZyb20gJy4uL3dhc20tdHlwZXMnO1xyXG5cclxuaW1wb3J0IHR5cGUgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLXdlYmdwdSc7XHJcbmltcG9ydCB7IExPR19ERUJVRyB9IGZyb20gJy4vbG9nJztcclxuaW1wb3J0IHR5cGUgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4vdXRpbCc7XHJcbmltcG9ydCB0eXBlIHsgQWRhcHRlckluZm8sIENvbXB1dGVDb250ZXh0LCBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nLCBQcm9ncmFtSW5mbyB9IGZyb20gJy4vd2ViZ3B1L3R5cGVzJztcclxuaW1wb3J0IHsgV2ViTk5CYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLXdlYm5uJztcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cclxuXHJcbmNsYXNzIFRlbnNvclZpZXdJbXBsIGltcGxlbWVudHMgVGVuc29yVmlldyB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIG1vZHVsZTogT3J0V2FzbU1vZHVsZSxcclxuICAgIHB1YmxpYyByZWFkb25seSBkYXRhVHlwZTogbnVtYmVyLFxyXG4gICAgcHVibGljIHJlYWRvbmx5IGRhdGE6IG51bWJlcixcclxuICAgIHB1YmxpYyByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXSxcclxuICApIHt9XHJcblxyXG4gIGdldEZsb2F0MzJBcnJheSgpOiBGbG9hdDMyQXJyYXkge1xyXG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XHJcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwXHJcbiAgICAgID8gbmV3IEZsb2F0MzJBcnJheSgpXHJcbiAgICAgIDogbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcclxuICB9XHJcblxyXG4gIGdldEJpZ0ludDY0QXJyYXkoKTogQmlnSW50NjRBcnJheSB7XHJcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZScpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcclxuICAgIHJldHVybiBlbGVtZW50Q291bnQgPT09IDBcclxuICAgICAgPyBuZXcgQmlnSW50NjRBcnJheSgpXHJcbiAgICAgIDogbmV3IEJpZ0ludDY0QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLCB0aGlzLmRhdGEsIGVsZW1lbnRDb3VudCk7XHJcbiAgfVxyXG5cclxuICBnZXRJbnQzMkFycmF5KCk6IEludDMyQXJyYXkge1xyXG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XHJcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IEludDMyQXJyYXkoKSA6IG5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xyXG4gIH1cclxuXHJcbiAgZ2V0VWludDE2QXJyYXkoKTogVWludDE2QXJyYXkge1xyXG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0MTYgJiYgdGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUudWludDE2KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XHJcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IFVpbnQxNkFycmF5KCkgOiBuZXcgVWludDE2QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLCB0aGlzLmRhdGEsIGVsZW1lbnRDb3VudCk7XHJcbiAgfVxyXG5cclxuICByZXNoYXBlKG5ld0RpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yVmlldyB7XHJcbiAgICBpZiAoU2hhcGVVdGlsLnNpemUobmV3RGltcykgIT09IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5ldyBzaGFwZScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBUZW5zb3JWaWV3SW1wbCh0aGlzLm1vZHVsZSwgdGhpcy5kYXRhVHlwZSwgdGhpcy5kYXRhLCBuZXdEaW1zKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIENvbXB1dGVDb250ZXh0SW1wbCBpbXBsZW1lbnRzIENvbXB1dGVDb250ZXh0IHtcclxuICByZWFkb25seSBhZGFwdGVySW5mbzogQWRhcHRlckluZm87XHJcbiAgcmVhZG9ubHkgb3BLZXJuZWxDb250ZXh0OiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W107XHJcbiAgcmVhZG9ubHkgb3V0cHV0Q291bnQ6IG51bWJlcjtcclxuICBnZXQga2VybmVsQ3VzdG9tRGF0YSgpOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfSB7XHJcbiAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxDdXN0b21EYXRhO1xyXG4gIH1cclxuICBnZXQgY3VzdG9tRGF0YUJ1ZmZlcigpOiBVaW50OEFycmF5IHtcclxuICAgIHJldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LCB0aGlzLmN1c3RvbURhdGFPZmZzZXQgKyB0aGlzLmN1c3RvbURhdGFTaXplKTtcclxuICB9XHJcbiAgcHJpdmF0ZSBjdXN0b21EYXRhT2Zmc2V0ID0gMDtcclxuICBwcml2YXRlIGN1c3RvbURhdGFTaXplID0gMDtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgbW9kdWxlOiBPcnRXYXNtTW9kdWxlLFxyXG4gICAgcHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kLFxyXG4gICAgY29udGV4dERhdGFPZmZzZXQ6IG51bWJlcixcclxuICApIHtcclxuICAgIHRoaXMuYWRhcHRlckluZm8gPSBiYWNrZW5kLmFkYXB0ZXJJbmZvO1xyXG5cclxuICAgIC8vIGV4dHJhY3QgY29udGV4dCBkYXRhXHJcbiAgICBjb25zdCBwdHJTaXplID0gbW9kdWxlLlBUUl9TSVpFO1xyXG4gICAgbGV0IGRhdGFJbmRleCA9IGNvbnRleHREYXRhT2Zmc2V0IC8gbW9kdWxlLlBUUl9TSVpFO1xyXG4gICAgY29uc3QgdHlwZSA9IHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnO1xyXG4gICAgdGhpcy5vcEtlcm5lbENvbnRleHQgPSBOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgdHlwZSkpO1xyXG4gICAgY29uc3QgaW5wdXRDb3VudCA9IE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCB0eXBlKSk7XHJcbiAgICB0aGlzLm91dHB1dENvdW50ID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcclxuICAgIHRoaXMuY3VzdG9tRGF0YU9mZnNldCA9IE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCAnKicpKTtcclxuICAgIHRoaXMuY3VzdG9tRGF0YVNpemUgPSBOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgdHlwZSkpO1xyXG5cclxuICAgIGNvbnN0IGlucHV0czogVGVuc29yVmlld1tdID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xyXG4gICAgICBjb25zdCBkYXRhVHlwZSA9IE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCB0eXBlKSk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgJyonKSk7XHJcbiAgICAgIGNvbnN0IGRpbSA9IE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCB0eXBlKSk7XHJcbiAgICAgIGNvbnN0IGRpbXM6IG51bWJlcltdID0gW107XHJcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyBkKyspIHtcclxuICAgICAgICBkaW1zLnB1c2goTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKSk7XHJcbiAgICAgIH1cclxuICAgICAgaW5wdXRzLnB1c2gobmV3IFRlbnNvclZpZXdJbXBsKG1vZHVsZSwgZGF0YVR5cGUsIGRhdGEsIGRpbXMpKTtcclxuICAgIH1cclxuICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZShwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRzT3V0cHV0c01hcHBpbmc/OiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nKTogVGVuc29yVmlld1tdIHtcclxuICAgIC8vIHByZXBhcmUgaW5wdXRzLiBpbnB1dHMgc2hvdWxkIGFsd2F5cyBiZSB2YWxpZCBkYXRhLlxyXG4gICAgY29uc3QgbWFwcGVkSW5wdXRzID1cclxuICAgICAgaW5wdXRzT3V0cHV0c01hcHBpbmc/LmlucHV0cz8ubWFwKChpKSA9PiAodHlwZW9mIGkgPT09ICdudW1iZXInID8gdGhpcy5pbnB1dHNbaV0gOiBpKSkgPz8gdGhpcy5pbnB1dHM7XHJcbiAgICAvLyBwcmVwYXJlIG91dHB1dHMuXHJcbiAgICBjb25zdCBvdXRwdXRJbmRpY2VzID0gaW5wdXRzT3V0cHV0c01hcHBpbmc/Lm91dHB1dHMgPz8gW107XHJcbiAgICBjb25zdCBjcmVhdGVLZXJuZWxPdXRwdXQgPSAoaW5kZXg6IG51bWJlciwgZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3ID0+XHJcbiAgICAgIG5ldyBUZW5zb3JWaWV3SW1wbCh0aGlzLm1vZHVsZSwgZGF0YVR5cGUsIHRoaXMub3V0cHV0KGluZGV4LCBkaW1zKSwgZGltcyk7XHJcbiAgICBjb25zdCBjcmVhdGVUZW1wb3JhcnlPdXRwdXQgPSAoZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3ID0+IHtcclxuICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKGRhdGFUeXBlLCBkaW1zKTtcclxuICAgICAgaWYgKCFidWZmZXJTaXplKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZGF0YVR5cGV9YCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZ3B1RGF0YUlkID0gYnVmZmVyU2l6ZSA+IDAgPyB0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKGJ1ZmZlclNpemUpLmlkIDogMDtcclxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3JWaWV3SW1wbCh0aGlzLm1vZHVsZSwgZGF0YVR5cGUsIGdwdURhdGFJZCwgZGltcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHRoaXMuYmFja2VuZC5ydW4oXHJcbiAgICAgIHByb2dyYW0sXHJcbiAgICAgIG1hcHBlZElucHV0cyxcclxuICAgICAgb3V0cHV0SW5kaWNlcyxcclxuICAgICAgY3JlYXRlS2VybmVsT3V0cHV0LFxyXG4gICAgICBjcmVhdGVUZW1wb3JhcnlPdXRwdXQsXHJcbiAgICAgIHRoaXMub3V0cHV0Q291bnQsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgb3V0cHV0KGluZGV4OiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IHN0YWNrID0gdGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwdHJTaXplID0gdGhpcy5tb2R1bGUuUFRSX1NJWkU7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBwdHJTaXplID09PSA0ID8gJ2kzMicgOiAnaTY0JztcclxuICAgICAgY29uc3QgZGF0YSA9IHRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDEgKyBkaW1zLmxlbmd0aCkgKiBwdHJTaXplIC8qIHNpemVvZihzaXplX3QpICovKTtcclxuICAgICAgdGhpcy5tb2R1bGUuc2V0VmFsdWUoZGF0YSwgZGltcy5sZW5ndGgsIHR5cGUpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLm1vZHVsZS5zZXRWYWx1ZShkYXRhICsgcHRyU2l6ZSAqIChpICsgMSksIGRpbXNbaV0sIHR5cGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCEodGhpcy5vcEtlcm5lbENvbnRleHQsIGluZGV4LCBkYXRhKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7aW5kZXh9XSB3aXRoIGRpbXMgWyR7ZGltc31dLiBgICtcclxuICAgICAgICAgICdJZiB5b3UgYXJlIHJ1bm5pbmcgd2l0aCBwcmUtYWxsb2NhdGVkIG91dHB1dCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3V0cHV0IHR5cGUvZGltcyBhcmUgY29ycmVjdC4gJyArXHJcbiAgICAgICAgICBgRXJyb3I6ICR7ZX1gLFxyXG4gICAgICApO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKHN0YWNrKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIEpTRVAgd2l0aCBXZWJHUFUgYmFja2VuZC5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQgKFwiX09ydEluaXRcIiBpcyBjYWxsZWQpLCBvbmNlIGZvclxyXG4gKiBlYWNoIG9mIHRoZSBmb2xsb3dpbmcgRVBzIGlmIHRoZXkgYXJlIHNwZWNpZmllZDpcclxuICogLSBcIndlYmdwdVwiXHJcbiAqIC0gXCJ3ZWJublwiXHJcbiAqXHJcbiAqIEZvciBXZWJHUFUsIHRoaXMgZnVuY3Rpb24gZXhwZWN0czpcclxuICogIC0gV2ViR1BVIGlzIGVuYWJsZWQgaW4gYnVpbGQgKEJVSUxEX0RFRlMuRElTQUJMRV9KU0VQID09PSBmYWxzZSkuXHJcbiAqICAtIFdlYkdQVSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC4gKGEgdmFsaWQgR1BVQWRhcHRlciBpcyBwYXNzZWQgaW4pXHJcbiAqXHJcbiAqIEZvciBXZWJOTiwgdGhpcyBmdW5jdGlvbiBleHBlY3RzOlxyXG4gKiAtIFdlYk5OIGlzIGVuYWJsZWQgaW4gYnVpbGQgKEJVSUxEX0RFRlMuRElTQUJMRV9KU0VQID09PSBmYWxzZSkuXHJcbiAqIC0gV2ViTk4gaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuIChuYXZpZ2F0b3IubWwgaXMgbm90IHVuZGVmaW5lZClcclxuICpcclxuICogSWYgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQsIHRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBlcnJvci4gVGhpcyB3aWxsIGludmFsaWRhdGVcclxuICogJ3dlYmdwdScvJ3dlYm5uJyBiYWNrZW5kLlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBFUCwgZWl0aGVyIFwid2ViZ3B1XCIgb3IgXCJ3ZWJublwiXHJcbiAqIEBwYXJhbSBtb2R1bGUgLSB0aGUgT1JUIFdlYkFzc2VtYmx5IG1vZHVsZVxyXG4gKiBAcGFyYW0gZW52IC0gdGhlIE9SVCBlbnZpcm9ubWVudCB2YXJpYWJsZSAob3J0LmVudilcclxuICogQHBhcmFtIGdwdUFkYXB0ZXIgLSB0aGUgcHJlLWNyZWF0ZWQgR1BVIGFkYXB0ZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBpbml0ID0gYXN5bmMgKFxyXG4gIG5hbWU6ICd3ZWJncHUnIHwgJ3dlYm5uJyxcclxuICBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsXHJcbiAgZW52OiBFbnYsXHJcbiAgZ3B1QWRhcHRlcj86IEdQVUFkYXB0ZXIsXHJcbik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGNvbnN0IGpzZXBJbml0ID0gbW9kdWxlLmpzZXBJbml0O1xyXG4gIGlmICghanNlcEluaXQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAobmFtZSA9PT0gJ3dlYmdwdScpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXHJcbiAgICBjb25zdCB3ZWJHcHVCYWNrZW5kSW1wbCA9IHJlcXVpcmUoJy4vYmFja2VuZC13ZWJncHUnKS5XZWJHcHVCYWNrZW5kO1xyXG4gICAgY29uc3QgYmFja2VuZCA9IG5ldyB3ZWJHcHVCYWNrZW5kSW1wbCgpO1xyXG4gICAgYXdhaXQgYmFja2VuZC5pbml0aWFsaXplKGVudiwgZ3B1QWRhcHRlciEpO1xyXG5cclxuICAgIGpzZXBJbml0KCd3ZWJncHUnLCBbXHJcbiAgICAgIC8vIGJhY2tlbmRcclxuICAgICAgYmFja2VuZCxcclxuXHJcbiAgICAgIC8vIGpzZXBBbGxvYygpXHJcbiAgICAgIChzaXplOiBudW1iZXIpID0+IGJhY2tlbmQuYWxsb2MoTnVtYmVyKHNpemUpKSxcclxuXHJcbiAgICAgIC8vIGpzZXBGcmVlKClcclxuICAgICAgKHB0cjogbnVtYmVyKSA9PiBiYWNrZW5kLmZyZWUocHRyKSxcclxuXHJcbiAgICAgIC8vIGpzZXBDb3B5KHNyYywgZHN0LCBzaXplLCBpc1NvdXJjZUdwdSlcclxuICAgICAgKHNyYzogbnVtYmVyLCBkc3Q6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBpc1NvdXJjZUdwdSA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzU291cmNlR3B1KSB7XHJcbiAgICAgICAgICBMT0dfREVCVUcoXHJcbiAgICAgICAgICAgICd2ZXJib3NlJyxcclxuICAgICAgICAgICAgKCkgPT4gYFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke051bWJlcihzcmMpfSwgZHN0PSR7TnVtYmVyKGRzdCl9LCBzaXplPSR7TnVtYmVyKHNpemUpfWAsXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgYmFja2VuZC5tZW1jcHkoTnVtYmVyKHNyYyksIE51bWJlcihkc3QpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgTE9HX0RFQlVHKFxyXG4gICAgICAgICAgICAndmVyYm9zZScsXHJcbiAgICAgICAgICAgICgpID0+XHJcbiAgICAgICAgICAgICAgYFtXZWJHUFVdIGpzZXBDb3B5Q3B1VG9HcHU6IGRhdGFPZmZzZXQ9JHtOdW1iZXIoc3JjKX0sIGdwdURhdGFJZD0ke051bWJlcihkc3QpfSwgc2l6ZT0ke051bWJlcihzaXplKX1gLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBtb2R1bGUuSEVBUFU4LnN1YmFycmF5KE51bWJlcihzcmMgPj4+IDApLCBOdW1iZXIoc3JjID4+PiAwKSArIE51bWJlcihzaXplKSk7XHJcbiAgICAgICAgICBiYWNrZW5kLnVwbG9hZChOdW1iZXIoZHN0KSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8ganNlcENvcHlBc3luYyhzcmMsIGRzdCwgc2l6ZSlcclxuICAgICAgYXN5bmMgKGdwdURhdGFJZDogbnVtYmVyLCBkYXRhT2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gICAgICAgIExPR19ERUJVRyhcclxuICAgICAgICAgICd2ZXJib3NlJyxcclxuICAgICAgICAgICgpID0+IGBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHtncHVEYXRhSWR9LCBkYXRhT2Zmc2V0PSR7ZGF0YU9mZnNldH0sIHNpemU9JHtzaXplfWAsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgYXdhaXQgYmFja2VuZC5kb3dubG9hZChOdW1iZXIoZ3B1RGF0YUlkKSwgKCkgPT5cclxuICAgICAgICAgIG1vZHVsZS5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKGRhdGFPZmZzZXQpID4+PiAwLCBOdW1iZXIoZGF0YU9mZnNldCArIHNpemUpID4+PiAwKSxcclxuICAgICAgICApO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8ganNlcENyZWF0ZUtlcm5lbFxyXG4gICAgICAoa2VybmVsVHlwZTogc3RyaW5nLCBrZXJuZWxJZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHVua25vd24pID0+XHJcbiAgICAgICAgYmFja2VuZC5jcmVhdGVLZXJuZWwoXHJcbiAgICAgICAgICBrZXJuZWxUeXBlLFxyXG4gICAgICAgICAgTnVtYmVyKGtlcm5lbElkKSxcclxuICAgICAgICAgIGF0dHJpYnV0ZSxcclxuICAgICAgICAgIG1vZHVsZS5VVEY4VG9TdHJpbmcobW9kdWxlLl9Kc2VwR2V0Tm9kZU5hbWUhKE51bWJlcihrZXJuZWxJZCkpKSxcclxuICAgICAgICApLFxyXG5cclxuICAgICAgLy8ganNlcFJlbGVhc2VLZXJuZWxcclxuICAgICAgKGtlcm5lbDogbnVtYmVyKSA9PiBiYWNrZW5kLnJlbGVhc2VLZXJuZWwoa2VybmVsKSxcclxuXHJcbiAgICAgIC8vIGpzZXBSdW5cclxuICAgICAgKGtlcm5lbDogbnVtYmVyLCBjb250ZXh0RGF0YU9mZnNldDogbnVtYmVyLCBzZXNzaW9uSGFuZGxlOiBudW1iZXIsIGVycm9yczogQXJyYXk8UHJvbWlzZTxzdHJpbmcgfCBudWxsPj4pID0+IHtcclxuICAgICAgICBMT0dfREVCVUcoXHJcbiAgICAgICAgICAndmVyYm9zZScsXHJcbiAgICAgICAgICAoKSA9PlxyXG4gICAgICAgICAgICBgW1dlYkdQVV0ganNlcFJ1bjogc2Vzc2lvbkhhbmRsZT0ke3Nlc3Npb25IYW5kbGV9LCBrZXJuZWw9JHtrZXJuZWx9LCBjb250ZXh0RGF0YU9mZnNldD0ke2NvbnRleHREYXRhT2Zmc2V0fWAsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IENvbXB1dGVDb250ZXh0SW1wbChtb2R1bGUsIGJhY2tlbmQsIE51bWJlcihjb250ZXh0RGF0YU9mZnNldCkpO1xyXG4gICAgICAgIHJldHVybiBiYWNrZW5kLmNvbXB1dGVLZXJuZWwoTnVtYmVyKGtlcm5lbCksIGNvbnRleHQsIGVycm9ycyk7XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIGpzZXBDYXB0dXJlQmVnaW5cclxuICAgICAgKCkgPT4gYmFja2VuZC5jYXB0dXJlQmVnaW4oKSxcclxuICAgICAgLy8ganNlcENhcHR1cmVFbmRcclxuICAgICAgKCkgPT4gYmFja2VuZC5jYXB0dXJlRW5kKCksXHJcbiAgICAgIC8vIGpzZXBSZXBsYXlcclxuICAgICAgKCkgPT4gYmFja2VuZC5yZXBsYXkoKSxcclxuICAgIF0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBiYWNrZW5kID0gbmV3IFdlYk5OQmFja2VuZChlbnYpO1xyXG4gICAganNlcEluaXQoJ3dlYm5uJywgW1xyXG4gICAgICBiYWNrZW5kLFxyXG4gICAgICAvLyB3ZWJublJlc2VydmVUZW5zb3JJZFxyXG4gICAgICAoKSA9PiBiYWNrZW5kLnJlc2VydmVUZW5zb3JJZCgpLFxyXG4gICAgICAvLyB3ZWJublJlbGVhc2VUZW5zb3JJZFxyXG4gICAgICAodGVuc29ySWQ6IG51bWJlcikgPT4gYmFja2VuZC5yZWxlYXNlVGVuc29ySWQodGVuc29ySWQpLFxyXG4gICAgICAvLyB3ZWJubkVuc3VyZVRlbnNvclxyXG4gICAgICBhc3luYyAoXHJcbiAgICAgICAgc2Vzc2lvbklkOiBudW1iZXIgfCB1bmRlZmluZWQsXHJcbiAgICAgICAgdGVuc29ySWQ6IG51bWJlcixcclxuICAgICAgICBvbm54RGF0YVR5cGU6IG51bWJlcixcclxuICAgICAgICBzaGFwZTogbnVtYmVyW10sXHJcbiAgICAgICAgY29weU9sZDogYm9vbGVhbixcclxuICAgICAgKSA9PiBiYWNrZW5kLmVuc3VyZVRlbnNvcihzZXNzaW9uSWQsIHRlbnNvcklkLCBvbm54RGF0YVR5cGUsIHNoYXBlLCBjb3B5T2xkKSxcclxuICAgICAgLy8gd2Vibm5VcGxvYWRUZW5zb3JcclxuICAgICAgKHRlbnNvcklkOiBudW1iZXIsIGRhdGE6IFVpbnQ4QXJyYXkpID0+IHtcclxuICAgICAgICBiYWNrZW5kLnVwbG9hZFRlbnNvcih0ZW5zb3JJZCwgZGF0YSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIHdlYm5uRG93bmxvYWRUZW5zb3JcclxuICAgICAgYXN5bmMgKHRlbnNvcklkOiBudW1iZXIsIGRzdEJ1ZmZlcjogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpID0+IGJhY2tlbmQuZG93bmxvYWRUZW5zb3IodGVuc29ySWQsIGRzdEJ1ZmZlciksXHJcbiAgICAgIC8vIHdlYm5uUmVnaXN0ZXJNTENvbnRleHRcclxuICAgICAgKHNlc3Npb25JZDogbnVtYmVyLCBtbENvbnRleHQ6IE1MQ29udGV4dCkgPT4gYmFja2VuZC5yZWdpc3Rlck1MQ29udGV4dChzZXNzaW9uSWQsIG1sQ29udGV4dCksXHJcbiAgICAgIC8vIHdlYm5uRW5hYmxlVHJhY2VFdmVudFxyXG4gICAgICAhIWVudi50cmFjZSxcclxuICAgIF0pO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG4vLyBXZWJOTiBBUEkgY3VycmVudGx5IGRvZXMgbm90IGhhdmUgYSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZS4gVGhpcyBmaWxlIGlzIGEgd29ya2Fyb3VuZCB3aXRoIHR5cGVzIGdlbmVyYXRlZCBmcm9tXHJcbi8vIFdlYk5OIEFQSSBzcGVjaWZpY2F0aW9uLlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VibWFjaGluZWxlYXJuaW5nL3dlYm5uL2lzc3Vlcy82NzdcclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cImpzZXAvd2Vibm4vd2Vibm4uZC50c1wiIC8+XHJcblxyXG5pbXBvcnQgeyBFbnYsIEluZmVyZW5jZVNlc3Npb24sIFRlbnNvciwgVFJBQ0VfRVZFTlRfQkVHSU4sIFRSQUNFX0VWRU5UX0VORCB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcblxyXG5pbXBvcnQge1xyXG4gIFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLFxyXG4gIFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YSxcclxuICBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YSxcclxuICBUZW5zb3JNZXRhZGF0YSxcclxufSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcclxuaW1wb3J0IHsgc2V0UnVuT3B0aW9ucyB9IGZyb20gJy4vcnVuLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBzZXRTZXNzaW9uT3B0aW9ucyB9IGZyb20gJy4vc2Vzc2lvbi1vcHRpb25zJztcclxuaW1wb3J0IHtcclxuICBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyxcclxuICBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0sXHJcbiAgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLFxyXG4gIGlzTUxUZW5zb3JTdXBwb3J0ZWRUeXBlLFxyXG4gIGxvZ0xldmVsU3RyaW5nVG9FbnVtLFxyXG4gIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nLFxyXG4gIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtLFxyXG4gIHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvcixcclxufSBmcm9tICcuL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XHJcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xyXG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xyXG5cclxuLy8gI3JlZ2lvbiBJbml0aWFsaXphdGlvbnNcclxuXHJcbi8qKlxyXG4gKiBUaGVyZSBhcmUgNCBkaWZmZXJlbnQgXCJpbml0aWFsaXphdGlvblwiIHN0ZXBzIGZvciBPUlQuIFRoZXkgaGFwcGVuIGluIGRpZmZlcmVudCBwbGFjZXMgYW5kIGRpZmZlcmVudCB0aW1lLlxyXG4gKlxyXG4gKiAxLiBKYXZhU2NyaXB0IGluaXRpYWxpemF0aW9uIGZvciBvbm54cnVudGltZS1jb21tb24gYW5kIG9ubnhydW50aW1lLXdlYi5cclxuICogICAgVGhpcyBpcyB0aGUgZmlyc3QgaW5pdGlhbGl6YXRpb24gc3RlcC4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgY2FsbHMgb25ueHJ1bnRpbWUtY29tbW9uJ3MgcmVnaXN0ZXJCYWNrZW5kKClcclxuICogZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgYWxsIHRoZSBhdmFpbGFibGUgYmFja2VuZHMuIFRoZSBiYWNrZW5kIHJlZ2lzdHJhdGlvbiBpcyB2ZXJ5IGZhc3QuIEl0IG9ubHlcclxuICogcmVnaXN0ZXJzIHRoZSBiYWNrZW5kIG5hbWUgd2l0aCB0aGUgdW5pbml0aWFsaXplZCBiYWNrZW5kIG9iamVjdC4gTm8gaGVhdnkgaW5pdGlhbGl6YXRpb24gaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXHJcbiAqICAgIFJlZmVyIHRvIHdlYi9saWIvaW5kZXgudHMgZm9yIHRoZSBiYWNrZW5kIHJlZ2lzdHJhdGlvbi5cclxuICpcclxuICogMi4gV2ViQXNzZW1ibHkgYXJ0aWZhY3QgaW5pdGlhbGl6YXRpb24uXHJcbiAqICAgIFRoaXMgaGFwcGVucyB3aGVuIGFueSByZWdpc3RlcmVkIHdhc20gYmFja2VuZCBpcyB1c2VkIGZvciB0aGUgZmlyc3QgdGltZSAoaWUuIGBvcnQuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoKWAgaXNcclxuICogY2FsbGVkKS4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcclxuICogICAgIC0gY3JlYXRlIGEgcHJveHkgd29ya2VyIGFuZCBtYWtlIHN1cmUgdGhlIHByb3h5IHdvcmtlciBpcyByZWFkeSB0byByZWNlaXZlIG1lc3NhZ2VzLCBpZiBwcm94eSBpcyBlbmFibGVkLlxyXG4gKiAgICAgLSBwZXJmb3JtIGZlYXR1cmUgZGV0ZWN0aW9uLCBsb2NhdGUgY29ycmVjdCBXZWJBc3NlbWJseSBhcnRpZmFjdCBwYXRoIGFuZCBjYWxsIHRoZSBFbXNjcmlwdGVuIGdlbmVyYXRlZFxyXG4gKiBKYXZhU2NyaXB0IGNvZGUgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViQXNzZW1ibHkgcnVudGltZS5cclxuICogICAgICAgICAtIGlmIHByb3h5IGlzIGVuYWJsZWQsIHRoaXMgc3RlcCBoYXBwZW5zIGluIHRoZSBwcm94eSB3b3JrZXIgdXNpbmcgbWVzc2FnZSAnaW5pdC13YXNtJy5cclxuICogICAgICAgICAtIGRvd25sb2FkaW5nIHRoZSAnb3J0LXdhc217Li4ufS53YXNtJyBmaWxlIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxyXG4gKiAgICAgICAgIC0gaWYgbXVsdGktdGhyZWFkIGlzIGVuYWJsZWQsIG9uZSBvciBtb3JlIHdlYndvcmtlciB3aWxsIGJlIGNyZWF0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgUFRocmVhZCB0aHJlYWRwb29sLlxyXG4gKlxyXG4gKiAzLiBPUlQgZW52aXJvbm1lbnQgaW5pdGlhbGl6YXRpb24uXHJcbiAqICAgIFRoaXMgaGFwcGVucyBhZnRlciBzdGVwIDIuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIHBlcmZvcm1zIE9OTlggUnVudGltZSBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cclxuICogRnVuY3Rpb24gYF9PcnRJbml0KClgIGlzIGNhbGxlZCBpbiB0aGlzIHN0ZXAuXHJcbiAqICAgICAtIGlmIHByb3h5IGlzIGVuYWJsZWQsIHRoaXMgc3RlcCBoYXBwZW5zIGluIHRoZSBwcm94eSB3b3JrZXIgdXNpbmcgbWVzc2FnZSAnaW5pdC1vcnQnLlxyXG4gKiAgICAgLSBsb2dnaW5nIGxldmVsIChvcnQuZW52LmxvZ0xldmVsKSBhbmQgdGhyZWFkIG51bWJlciAob3J0LmVudi53YXNtLm51bVRocmVhZHMpIGFyZSBzZXQgaW4gdGhpcyBzdGVwLlxyXG4gKlxyXG4gKiA0LiBTZXNzaW9uIGluaXRpYWxpemF0aW9uLlxyXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIGlzIGNhbGxlZC4gVW5saWtlIHRoZSBmaXJzdCAzIHN0ZXBzICh0aGV5IG9ubHkgY2FsbGVkIG9uY2UpLFxyXG4gKiB0aGlzIHN0ZXAgd2lsbCBiZSBkb25lIGZvciBlYWNoIHNlc3Npb24uIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGRvZXMgdGhlIGZvbGxvd2luZ3M6XHJcbiAqICAgIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBVUkw6XHJcbiAqICAgIC0gZG93bmxvYWQgdGhlIG1vZGVsIGRhdGEgZnJvbSB0aGUgVVJMLlxyXG4gKiAgICAtIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC4gKHByb3h5OiAnY29weS1mcm9tJylcclxuICogICAgLSBkZXJlZmVyZW5jZSB0aGUgbW9kZWwgYnVmZmVyLiBUaGlzIHN0ZXAgYWxsb3dzIHRoZSBvcmlnaW5hbCBBcnJheUJ1ZmZlciB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cclxuICogICAgLSBjYWxsIGBfT3J0Q3JlYXRlU2Vzc2lvbigpYCB0byBjcmVhdGUgdGhlIHNlc3Npb24uIChwcm94eTogJ2NyZWF0ZScpXHJcbiAqXHJcbiAqICAgIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBVaW50OEFycmF5IG9iamVjdDpcclxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXHJcbiAqICAgIC0gY2FsbCBgX09ydENyZWF0ZVNlc3Npb24oKWAgdG8gY3JlYXRlIHRoZSBzZXNzaW9uLiAocHJveHk6ICdjcmVhdGUnKVxyXG4gKlxyXG4gKlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBpbml0aWFsaXplIE9SVCBlbnZpcm9ubWVudC5cclxuICpcclxuICogQHBhcmFtIG51bVRocmVhZHMgU2V0R2xvYmFsSW50cmFPcE51bVRocmVhZHMobnVtVGhyZWFkcylcclxuICogQHBhcmFtIGxvZ2dpbmdMZXZlbCBDcmVhdGVFbnYoc3RhdGljX2Nhc3Q8T3J0TG9nZ2luZ0xldmVsPihsb2dnaW5nX2xldmVsKSlcclxuICovXHJcbmNvbnN0IGluaXRPcnQgPSAobnVtVGhyZWFkczogbnVtYmVyLCBsb2dnaW5nTGV2ZWw6IG51bWJlcik6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGVycm9yQ29kZSA9IGdldEluc3RhbmNlKCkuX09ydEluaXQobnVtVGhyZWFkcywgbG9nZ2luZ0xldmVsKTtcclxuICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XHJcbiAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBpbml0aWFsaXplIHJ1bnRpbWUgZW52aXJvbm1lbnQuXHJcbiAqIEBwYXJhbSBlbnYgcGFzc2VkIGluIHRoZSBlbnZpcm9ubWVudCBjb25maWcgb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGluaXRSdW50aW1lID0gYXN5bmMgKGVudjogRW52KTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgLy8gaW5pdCBPUlRcclxuICBpbml0T3J0KGVudi53YXNtLm51bVRocmVhZHMhLCBsb2dMZXZlbFN0cmluZ1RvRW51bShlbnYubG9nTGV2ZWwpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBwZXJmb3JtIEVQIHNwZWNpZmljIGluaXRpYWxpemF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gZW52XHJcbiAqIEBwYXJhbSBlcE5hbWVcclxuICovXHJcbmV4cG9ydCBjb25zdCBpbml0RXAgPSBhc3luYyAoZW52OiBFbnYsIGVwTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgLy8gaW5pdGlhbGl6ZSBBU1lOQ0lGWSBzdXBwb3J0XHJcbiAgZ2V0SW5zdGFuY2UoKS5hc3luY0luaXQ/LigpO1xyXG5cclxuICAvLyBwZXJmb3JtIFdlYkdQVSBhdmFpbGFiaWxpdHkgY2hlY2sgKCBlaXRoZXIgSlNFUCBvciBXZWJHUFUgRVAgKVxyXG4gIGxldCB3ZWJncHVBZGFwdGVyID0gZW52LndlYmdwdS5hZGFwdGVyIGFzIEdQVUFkYXB0ZXIgfCBudWxsO1xyXG4gIGlmIChlcE5hbWUgPT09ICd3ZWJncHUnKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5ncHUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXdlYmdwdUFkYXB0ZXIpIHtcclxuICAgICAgLy8gaWYgYWRhcHRlciBpcyBub3Qgc2V0LCByZXF1ZXN0IGEgbmV3IGFkYXB0ZXIuXHJcbiAgICAgIGNvbnN0IHBvd2VyUHJlZmVyZW5jZSA9IGVudi53ZWJncHUucG93ZXJQcmVmZXJlbmNlO1xyXG4gICAgICBpZiAocG93ZXJQcmVmZXJlbmNlICE9PSB1bmRlZmluZWQgJiYgcG93ZXJQcmVmZXJlbmNlICE9PSAnbG93LXBvd2VyJyAmJiBwb3dlclByZWZlcmVuY2UgIT09ICdoaWdoLXBlcmZvcm1hbmNlJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke3Bvd2VyUHJlZmVyZW5jZX1cImApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGZvcmNlRmFsbGJhY2tBZGFwdGVyID0gZW52LndlYmdwdS5mb3JjZUZhbGxiYWNrQWRhcHRlcjtcclxuICAgICAgaWYgKGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9yY2VGYWxsYmFja0FkYXB0ZXIgc2V0dGluZzogXCIke2ZvcmNlRmFsbGJhY2tBZGFwdGVyfVwiYCk7XHJcbiAgICAgIH1cclxuICAgICAgd2ViZ3B1QWRhcHRlciA9IGF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoeyBwb3dlclByZWZlcmVuY2UsIGZvcmNlRmFsbGJhY2tBZGFwdGVyIH0pO1xyXG4gICAgICBpZiAoIXdlYmdwdUFkYXB0ZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAnRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gJyArXHJcbiAgICAgICAgICAgICdZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGZsYWcgXCItLWVuYWJsZS11bnNhZmUtd2ViZ3B1XCIgaWYgeW91IGFyZSB1c2luZyBDaHJvbWUuJyxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBpZiBhZGFwdGVyIGlzIHNldCwgdmFsaWRhdGUgaXQuXHJcbiAgICAgIGlmIChcclxuICAgICAgICB0eXBlb2Ygd2ViZ3B1QWRhcHRlci5saW1pdHMgIT09ICdvYmplY3QnIHx8XHJcbiAgICAgICAgdHlwZW9mIHdlYmdwdUFkYXB0ZXIuZmVhdHVyZXMgIT09ICdvYmplY3QnIHx8XHJcbiAgICAgICAgdHlwZW9mIHdlYmdwdUFkYXB0ZXIucmVxdWVzdERldmljZSAhPT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR1BVIGFkYXB0ZXIgc2V0IGluIGBlbnYud2ViZ3B1LmFkYXB0ZXJgLiBJdCBtdXN0IGJlIGEgR1BVQWRhcHRlciBvYmplY3QuJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHBlcmZvcm0gV2ViTk4gYXZhaWxhYmlsaXR5IGNoZWNrICggZWl0aGVyIEpTRVAgb3IgV2ViTk4gRVAgKVxyXG4gIGlmIChlcE5hbWUgPT09ICd3ZWJubicpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhKG5hdmlnYXRvciBhcyB1bmtub3duIGFzIHsgbWw6IHVua25vd24gfSkubWwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJOTiBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnQnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVApIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXHJcbiAgICBjb25zdCBpbml0SnNlcCA9IHJlcXVpcmUoJy4vanNlcC9pbml0JykuaW5pdDtcclxuXHJcbiAgICBpZiAoZXBOYW1lID09PSAnd2ViZ3B1Jykge1xyXG4gICAgICBhd2FpdCBpbml0SnNlcCgnd2ViZ3B1JywgZ2V0SW5zdGFuY2UoKSwgZW52LCB3ZWJncHVBZGFwdGVyKTtcclxuICAgIH1cclxuICAgIGlmIChlcE5hbWUgPT09ICd3ZWJubicpIHtcclxuICAgICAgYXdhaXQgaW5pdEpzZXAoJ3dlYm5uJywgZ2V0SW5zdGFuY2UoKSwgZW52KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVICYmIGVwTmFtZSA9PT0gJ3dlYmdwdScpIHtcclxuICAgICAgZ2V0SW5zdGFuY2UoKS53ZWJncHVJbml0ISgoZGV2aWNlKSA9PiB7XHJcbiAgICAgICAgZW52LndlYmdwdS5kZXZpY2UgPSBkZXZpY2U7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCTk4gJiYgZXBOYW1lID09PSAnd2Vibm4nKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXHJcbiAgICAgIGNvbnN0IGJhY2tlbmQgPSBuZXcgKHJlcXVpcmUoJy4vanNlcC9iYWNrZW5kLXdlYm5uJykuV2ViTk5CYWNrZW5kKShlbnYpO1xyXG4gICAgICBnZXRJbnN0YW5jZSgpLndlYm5uSW5pdCEoW1xyXG4gICAgICAgIGJhY2tlbmQsXHJcbiAgICAgICAgLy8gd2Vibm5SZXNlcnZlVGVuc29ySWRcclxuICAgICAgICAoKSA9PiBiYWNrZW5kLnJlc2VydmVUZW5zb3JJZCgpLFxyXG4gICAgICAgIC8vIHdlYm5uUmVsZWFzZVRlbnNvcklkLFxyXG4gICAgICAgICh0ZW5zb3JJZDogbnVtYmVyKSA9PiBiYWNrZW5kLnJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZCksXHJcbiAgICAgICAgLy8gd2Vibm5FbnN1cmVUZW5zb3JcclxuICAgICAgICBhc3luYyAoc2Vzc2lvbklkOiBudW1iZXIgfCB1bmRlZmluZWQsIHRlbnNvcklkOiBudW1iZXIsIG9ubnhEYXRhVHlwZTogbnVtYmVyLCBzaGFwZTogbnVtYmVyW10sIGNvcHlPbGQpID0+XHJcbiAgICAgICAgICBiYWNrZW5kLmVuc3VyZVRlbnNvcihzZXNzaW9uSWQsIHRlbnNvcklkLCBvbm54RGF0YVR5cGUsIHNoYXBlLCBjb3B5T2xkKSxcclxuICAgICAgICAvLyB3ZWJublVwbG9hZFRlbnNvclxyXG4gICAgICAgICh0ZW5zb3JJZDogbnVtYmVyLCBkYXRhOiBVaW50OEFycmF5KSA9PiB7XHJcbiAgICAgICAgICBiYWNrZW5kLnVwbG9hZFRlbnNvcih0ZW5zb3JJZCwgZGF0YSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyB3ZWJubkRvd25sb2FkVGVuc29yXHJcbiAgICAgICAgYXN5bmMgKHRlbnNvcklkOiBudW1iZXIsIGRzdEJ1ZmZlcjogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpID0+XHJcbiAgICAgICAgICBiYWNrZW5kLmRvd25sb2FkVGVuc29yKHRlbnNvcklkLCBkc3RCdWZmZXIpLFxyXG4gICAgICAgIC8vIHdlYm5uUmVnaXN0ZXJNTENvbnRleHRcclxuICAgICAgICAoc2Vzc2lvbklkOiBudW1iZXIsIG1sQ29udGV4dDogTUxDb250ZXh0KSA9PiBiYWNrZW5kLnJlZ2lzdGVyTUxDb250ZXh0KHNlc3Npb25JZCwgbWxDb250ZXh0KSxcclxuICAgICAgICAvLyB3ZWJubkVuYWJsZVRyYWNlRXZlbnRcclxuICAgICAgICAhIWVudi50cmFjZSxcclxuICAgICAgXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gI2VuZHJlZ2lvbiBJbml0aWFsaXphdGlvbnNcclxuXHJcbi8qKlxyXG4gKiB2YWxpZCBkYXRhIGxvY2F0aW9ucyBmb3IgaW5wdXQvb3V0cHV0IHRlbnNvcnMuXHJcbiAqL1xyXG50eXBlIFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0ID1cclxuICB8ICdjcHUnXHJcbiAgfCAnY3B1LXBpbm5lZCdcclxuICB8ICdncHUtYnVmZmVyJ1xyXG4gIHwgJ21sLXRlbnNvcidcclxuICAvLyBVc2UgJ21sLXRlbnNvcicgZHVyaW5nIGluZmVyZW5jZSwgYnV0IG91dHB1dCBhIHRlbnNvciBsb2NhdGVkIG9uIHRoZSBDUFUuXHJcbiAgfCAnbWwtdGVuc29yLWNwdS1vdXRwdXQnO1xyXG5cclxudHlwZSBJT0JpbmRpbmdTdGF0ZSA9IHtcclxuICAvKipcclxuICAgKiB0aGUgaGFuZGxlIG9mIElPIGJpbmRpbmcuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgaGFuZGxlOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIHRoZSBwcmVmZXJyZWQgbG9jYXRpb24gZm9yIGVhY2ggb3V0cHV0IHRlbnNvci5cclxuICAgKlxyXG4gICAqIHZhbHVlIGlzIG9uZSBvZiAnY3B1JywgJ2NwdS1waW5uZWQnLCAnZ3B1LWJ1ZmZlcicsICdtbC10ZW5zb3InLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IG91dHB1dFByZWZlcnJlZExvY2F0aW9uczogcmVhZG9ubHkgU3VwcG9ydGVkVGVuc29yRGF0YUxvY2F0aW9uRm9ySW5wdXRPdXRwdXRbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogZW51bSB2YWx1ZSBvZiB0aGUgcHJlZmVycmVkIGxvY2F0aW9uIGZvciBlYWNoIG91dHB1dCB0ZW5zb3IuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDogcmVhZG9ubHkgbnVtYmVyW107XHJcbn07XHJcblxyXG4vKipcclxuICogIHR1cGxlIGVsZW1lbnRzIGFyZTogSW5mZXJlbmNlU2Vzc2lvbiBJRDsgaW5wdXROYW1lc1VURjhFbmNvZGVkOyBvdXRwdXROYW1lc1VURjhFbmNvZGVkOyBiaW5kaW5nU3RhdGVcclxuICovXHJcbnR5cGUgU2Vzc2lvbk1ldGFkYXRhID0gW1xyXG4gIGluZmVyZW5jZVNlc3Npb25JZDogbnVtYmVyLFxyXG4gIGlucHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sXHJcbiAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sXHJcbiAgYmluZGluZ1N0YXRlOiBJT0JpbmRpbmdTdGF0ZSB8IG51bGwsXHJcbiAgZW5hYmxlR3JhcGhDYXB0dXJlOiBib29sZWFuLFxyXG4gIGlucHV0T3V0cHV0Qm91bmQ6IGJvb2xlYW4sXHJcbl07XHJcblxyXG5jb25zdCBhY3RpdmVTZXNzaW9ucyA9IG5ldyBNYXA8bnVtYmVyLCBTZXNzaW9uTWV0YWRhdGE+KCk7XHJcblxyXG4vKipcclxuICogZ2V0IHRoZSBpbnB1dC9vdXRwdXQgY291bnQgb2YgdGhlIHNlc3Npb24uXHJcbiAqIEBwYXJhbSBzZXNzaW9uSGFuZGxlIHRoZSBoYW5kbGUgcmVwcmVzZW50aW5nIHRoZSBzZXNzaW9uLiBzaG91bGQgYmUgbm9uLXplcm8uXHJcbiAqIEByZXR1cm5zIGEgdHVwbGUgaW5jbHVkaW5nIDIgbnVtYmVycywgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBjb3VudCBhbmQgb3V0cHV0IGNvdW50LlxyXG4gKi9cclxuY29uc3QgZ2V0U2Vzc2lvbklucHV0T3V0cHV0Q291bnQgPSAoc2Vzc2lvbkhhbmRsZTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSA9PiB7XHJcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XHJcbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcclxuICAgIGNvbnN0IGRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoMiAqIHB0clNpemUpO1xyXG4gICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChzZXNzaW9uSGFuZGxlLCBkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgcHRyU2l6ZSk7XHJcbiAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XHJcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHR5cGUgPSBwdHJTaXplID09PSA0ID8gJ2kzMicgOiAnaTY0JztcclxuICAgIHJldHVybiBbTnVtYmVyKHdhc20uZ2V0VmFsdWUoZGF0YU9mZnNldCwgdHlwZSkpLCBOdW1iZXIod2FzbS5nZXRWYWx1ZShkYXRhT2Zmc2V0ICsgcHRyU2l6ZSwgdHlwZSkpXTtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGdldFNlc3Npb25JbnB1dE91dHB1dE1ldGFkYXRhID0gKFxyXG4gIHNlc3Npb25IYW5kbGU6IG51bWJlcixcclxuICBpbmRleDogbnVtYmVyLFxyXG4pOiBbbmFtZU9mZnNldDogbnVtYmVyLCBlbGVtZW50VHlwZTogbnVtYmVyLCBkaW1zPzogQXJyYXk8bnVtYmVyIHwgc3RyaW5nPl0gPT4ge1xyXG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xyXG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcclxuICBsZXQgbWV0YWRhdGFPZmZzZXQgPSAwO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcclxuICAgIGNvbnN0IGRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoMiAqIHB0clNpemUpO1xyXG4gICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0R2V0SW5wdXRPdXRwdXRNZXRhZGF0YShzZXNzaW9uSGFuZGxlLCBpbmRleCwgZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIHB0clNpemUpO1xyXG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBtZXRhZGF0YS5cIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYW1lT2Zmc2V0ID0gTnVtYmVyKHdhc20uZ2V0VmFsdWUoZGF0YU9mZnNldCwgJyonKSk7XHJcbiAgICBtZXRhZGF0YU9mZnNldCA9IE51bWJlcih3YXNtLmdldFZhbHVlKGRhdGFPZmZzZXQgKyBwdHJTaXplLCAnKicpKTtcclxuICAgIC8vIGdldCBlbGVtZW50IHR5cGVcclxuICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gd2FzbS5IRUFQMzJbbWV0YWRhdGFPZmZzZXQgLyA0XTtcclxuICAgIGlmIChlbGVtZW50VHlwZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gW25hbWVPZmZzZXQsIDBdOyAvLyBub24tdGVuc29yXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IGRpbXMgY291bnRcclxuICAgIGNvbnN0IGRpbXNDb3VudCA9IHdhc20uSEVBUFUzMlttZXRhZGF0YU9mZnNldCAvIDQgKyAxXTtcclxuICAgIC8vIGdldCBkaW1zXHJcbiAgICBjb25zdCBkaW1zOiBBcnJheTxudW1iZXIgfCBzdHJpbmc+ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXNDb3VudDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHN5bWJvbGljRGltTmFtZU9mZnNldCA9IE51bWJlcih3YXNtLmdldFZhbHVlKG1ldGFkYXRhT2Zmc2V0ICsgOCArIGkgKiBwdHJTaXplLCAnKicpKTtcclxuICAgICAgZGltcy5wdXNoKFxyXG4gICAgICAgIHN5bWJvbGljRGltTmFtZU9mZnNldCAhPT0gMFxyXG4gICAgICAgICAgPyB3YXNtLlVURjhUb1N0cmluZyhzeW1ib2xpY0RpbU5hbWVPZmZzZXQpXHJcbiAgICAgICAgICA6IE51bWJlcih3YXNtLmdldFZhbHVlKG1ldGFkYXRhT2Zmc2V0ICsgOCArIChpICsgZGltc0NvdW50KSAqIHB0clNpemUsICcqJykpLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtuYW1lT2Zmc2V0LCBlbGVtZW50VHlwZSwgZGltc107XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcclxuICAgIGlmIChtZXRhZGF0YU9mZnNldCAhPT0gMCkge1xyXG4gICAgICB3YXNtLl9PcnRGcmVlKG1ldGFkYXRhT2Zmc2V0KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogYWxsb2NhdGUgdGhlIG1lbW9yeSBhbmQgbWVtY3B5IHRoZSBleHRlcm5hbCBidWZmZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBtb2RlbCAtIHRoZSBleHRlcm5hbCBidWZmZXIgY29udGFpbmluZyB0aGUgbW9kZWwgZGF0YS4gTXVzdCBub3QgYmUgdGhlIHNhbWUgYnVmZmVyIGFzIHRoZSBXQVNNIGhlYXAuXHJcbiAqIEByZXR1cm5zIGEgMi1lbGVtZW50cyB0dXBsZSAtIHRoZSBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBhbGxvY2F0ZWQgYnVmZmVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29weUZyb21FeHRlcm5hbEJ1ZmZlciA9IChtb2RlbDogVWludDhBcnJheSk6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xyXG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xyXG4gIGNvbnN0IG1vZGVsRGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhtb2RlbC5ieXRlTGVuZ3RoKTtcclxuICBpZiAobW9kZWxEYXRhT2Zmc2V0ID09PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7bW9kZWwuYnl0ZUxlbmd0aH0uYCk7XHJcbiAgfVxyXG4gIHdhc20uSEVBUFU4LnNldChtb2RlbCwgbW9kZWxEYXRhT2Zmc2V0KTtcclxuICByZXR1cm4gW21vZGVsRGF0YU9mZnNldCwgbW9kZWwuYnl0ZUxlbmd0aF07XHJcbn07XHJcblxyXG4vKipcclxuICogY3JlYXRlIGFuIGluZmVyZW5jZSBzZXNzaW9uIGZyb20gYSBtb2RlbCBkYXRhIGJ1ZmZlci5cclxuICpcclxuICogQHBhcmFtIG1vZGVsRGF0YSAtIGVpdGhlciBhIFVpbnQ4QXJyYXkgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbW9kZWwgZGF0YSwgb3IgYSAyLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgdGhlXHJcbiAqICAgICBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBtb2RlbCBkYXRhIGJ1ZmZlci5cclxuICogQHBhcmFtIG9wdGlvbnMgYW4gb3B0aW9uYWwgc2Vzc2lvbiBvcHRpb25zIG9iamVjdC5cclxuICogQHJldHVybnMgYSAzLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgW3Nlc3Npb24gaGFuZGxlLCBpbnB1dCBuYW1lcywgb3V0cHV0IG5hbWVzXVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNlc3Npb24gPSBhc3luYyAoXHJcbiAgbW9kZWxEYXRhOiBVaW50OEFycmF5IHwgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXHJcbiAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXHJcbik6IFByb21pc2U8U2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhPiA9PiB7XHJcbiAgbGV0IG1vZGVsRGF0YU9mZnNldDogbnVtYmVyLCBtb2RlbERhdGFMZW5ndGg6IG51bWJlcjtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxEYXRhKSkge1xyXG4gICAgLy8gaWYgbW9kZWwgZGF0YSBpcyBhbiBhcnJheSwgaXQgbXVzdCBiZSBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGUgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgbW9kZWwgZGF0YVxyXG4gICAgW21vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoXSA9IG1vZGVsRGF0YTtcclxuICB9IGVsc2UgaWYgKG1vZGVsRGF0YS5idWZmZXIgPT09IHdhc20uSEVBUFU4LmJ1ZmZlcikge1xyXG4gICAgLy8gaWYgbW9kZWwgZGF0YSB1c2VzIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXQuXHJcbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gW21vZGVsRGF0YS5ieXRlT2Zmc2V0LCBtb2RlbERhdGEuYnl0ZUxlbmd0aF07XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIG90aGVyd2lzZSwgY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLlxyXG4gICAgW21vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoXSA9IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIobW9kZWxEYXRhKTtcclxuICB9XHJcblxyXG4gIGxldCBzZXNzaW9uSGFuZGxlID0gMDtcclxuICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xyXG4gIGxldCBpb0JpbmRpbmdIYW5kbGUgPSAwO1xyXG4gIGxldCBhbGxvY3M6IG51bWJlcltdID0gW107XHJcbiAgY29uc3QgaW5wdXROYW1lc1VURjhFbmNvZGVkID0gW107XHJcbiAgY29uc3Qgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IFtdO1xyXG5cclxuICB0cnkge1xyXG4gICAgW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdID0gYXdhaXQgc2V0U2Vzc2lvbk9wdGlvbnMob3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnM/LmV4dGVybmFsRGF0YSAmJiB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhKSB7XHJcbiAgICAgIGNvbnN0IGxvYWRpbmdQcm9taXNlcyA9IFtdO1xyXG4gICAgICBmb3IgKGNvbnN0IGZpbGUgb2Ygb3B0aW9ucy5leHRlcm5hbERhdGEpIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gdHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUucGF0aDtcclxuICAgICAgICBsb2FkaW5nUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgIGxvYWRGaWxlKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJyA/IGZpbGUgOiBmaWxlLmRhdGEpLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgd2FzbS5tb3VudEV4dGVybmFsRGF0YShwYXRoLCBkYXRhKTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHdhaXQgZm9yIGFsbCBleHRlcm5hbCBkYXRhIGZpbGVzIHRvIGJlIGxvYWRlZFxyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChsb2FkaW5nUHJvbWlzZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2Ygb3B0aW9ucz8uZXhlY3V0aW9uUHJvdmlkZXJzID8/IFtdKSB7XHJcbiAgICAgIGNvbnN0IHByb3ZpZGVyTmFtZSA9IHR5cGVvZiBwcm92aWRlciA9PT0gJ3N0cmluZycgPyBwcm92aWRlciA6IHByb3ZpZGVyLm5hbWU7XHJcbiAgICAgIGlmIChwcm92aWRlck5hbWUgPT09ICd3ZWJubicpIHtcclxuICAgICAgICB3YXNtLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBjb25zdCB3ZWJubk9wdGlvbnMgPSBwcm92aWRlciBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dpdGhNTENvbnRleHQpPy5jb250ZXh0O1xyXG4gICAgICAgICAgY29uc3QgZ3B1RGV2aWNlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dlYkdwdSk/LmdwdURldmljZTtcclxuICAgICAgICAgIGNvbnN0IGRldmljZVR5cGUgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LmRldmljZVR5cGU7XHJcbiAgICAgICAgICBjb25zdCBwb3dlclByZWZlcmVuY2UgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LnBvd2VyUHJlZmVyZW5jZTtcclxuICAgICAgICAgIGlmIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBjb250ZXh0IGFzIE1MQ29udGV4dDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZ3B1RGV2aWNlKSB7XHJcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCB3YXNtLndlYm5uQ3JlYXRlTUxDb250ZXh0IShncHVEZXZpY2UpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGF3YWl0IHdhc20ud2Vibm5DcmVhdGVNTENvbnRleHQhKHsgZGV2aWNlVHlwZSwgcG93ZXJQcmVmZXJlbmNlIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gYXdhaXQgd2FzbS53ZWJubkNyZWF0ZU1MQ29udGV4dCEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXNzaW9uSGFuZGxlID0gYXdhaXQgd2FzbS5fT3J0Q3JlYXRlU2Vzc2lvbihtb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aCwgc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xyXG4gICAgd2FzbS53ZWJncHVPbkNyZWF0ZVNlc3Npb24/LihzZXNzaW9uSGFuZGxlKTtcclxuICAgIGlmIChzZXNzaW9uSGFuZGxlID09PSAwKSB7XHJcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgd2FzbS5qc2VwT25DcmVhdGVTZXNzaW9uPy4oKTtcclxuXHJcbiAgICAvLyBjbGVhciBjdXJyZW50IE1MQ29udGV4dCBhZnRlciBzZXNzaW9uIGNyZWF0aW9uXHJcbiAgICBpZiAod2FzbS5jdXJyZW50Q29udGV4dCkge1xyXG4gICAgICB3YXNtLndlYm5uUmVnaXN0ZXJNTENvbnRleHQhKHNlc3Npb25IYW5kbGUsIHdhc20uY3VycmVudENvbnRleHQpO1xyXG4gICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICB3YXNtLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgW2lucHV0Q291bnQsIG91dHB1dENvdW50XSA9IGdldFNlc3Npb25JbnB1dE91dHB1dENvdW50KHNlc3Npb25IYW5kbGUpO1xyXG5cclxuICAgIGNvbnN0IGVuYWJsZUdyYXBoQ2FwdHVyZSA9ICEhb3B0aW9ucz8uZW5hYmxlR3JhcGhDYXB0dXJlO1xyXG5cclxuICAgIGNvbnN0IGlucHV0TmFtZXMgPSBbXTtcclxuICAgIGNvbnN0IG91dHB1dE5hbWVzID0gW107XHJcbiAgICBjb25zdCBpbnB1dE1ldGFkYXRhOiBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXSA9IFtdO1xyXG4gICAgY29uc3Qgb3V0cHV0TWV0YWRhdGE6IEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YVtdID0gW107XHJcbiAgICBjb25zdCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W10gPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IFtuYW1lT2Zmc2V0LCBlbGVtZW50VHlwZSwgc2hhcGVdID0gZ2V0U2Vzc2lvbklucHV0T3V0cHV0TWV0YWRhdGEoc2Vzc2lvbkhhbmRsZSwgaSk7XHJcbiAgICAgIGlmIChuYW1lT2Zmc2V0ID09PSAwKSB7XHJcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gaW5wdXQgbmFtZS5cIik7XHJcbiAgICAgIH1cclxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLnB1c2gobmFtZU9mZnNldCk7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSB3YXNtLlVURjhUb1N0cmluZyhuYW1lT2Zmc2V0KTtcclxuICAgICAgaW5wdXROYW1lcy5wdXNoKG5hbWUpO1xyXG4gICAgICBpbnB1dE1ldGFkYXRhLnB1c2goXHJcbiAgICAgICAgZWxlbWVudFR5cGUgPT09IDBcclxuICAgICAgICAgID8geyBuYW1lLCBpc1RlbnNvcjogZmFsc2UgfVxyXG4gICAgICAgICAgOiB7IG5hbWUsIGlzVGVuc29yOiB0cnVlLCB0eXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyhlbGVtZW50VHlwZSksIHNoYXBlOiBzaGFwZSEgfSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xyXG4gICAgICBjb25zdCBbbmFtZU9mZnNldCwgZWxlbWVudFR5cGUsIHNoYXBlXSA9IGdldFNlc3Npb25JbnB1dE91dHB1dE1ldGFkYXRhKHNlc3Npb25IYW5kbGUsIGkgKyBpbnB1dENvdW50KTtcclxuICAgICAgaWYgKG5hbWVPZmZzZXQgPT09IDApIHtcclxuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZS5cIik7XHJcbiAgICAgIH1cclxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWVPZmZzZXQpO1xyXG4gICAgICBjb25zdCBuYW1lU3RyaW5nID0gd2FzbS5VVEY4VG9TdHJpbmcobmFtZU9mZnNldCk7XHJcbiAgICAgIG91dHB1dE5hbWVzLnB1c2gobmFtZVN0cmluZyk7XHJcbiAgICAgIG91dHB1dE1ldGFkYXRhLnB1c2goXHJcbiAgICAgICAgZWxlbWVudFR5cGUgPT09IDBcclxuICAgICAgICAgID8geyBuYW1lOiBuYW1lU3RyaW5nLCBpc1RlbnNvcjogZmFsc2UgfVxyXG4gICAgICAgICAgOiB7IG5hbWU6IG5hbWVTdHJpbmcsIGlzVGVuc29yOiB0cnVlLCB0eXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyhlbGVtZW50VHlwZSksIHNoYXBlOiBzaGFwZSEgfSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcclxuICAgICAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5wdXNoKCdncHUtYnVmZmVyJyk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPVxyXG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICA/IG9wdGlvbnMucHJlZmVycmVkT3V0cHV0TG9jYXRpb25cclxuICAgICAgICAgICAgOiAob3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24/LltuYW1lU3RyaW5nXSA/PyAnY3B1Jyk7XHJcbiAgICAgICAgY29uc3QgaXNHcmFwaE91dHB1dCA9IHdhc20ud2Vibm5Jc0dyYXBoT3V0cHV0O1xyXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gJ2NwdScgJiYgaXNHcmFwaE91dHB1dCAmJiBpc0dyYXBoT3V0cHV0KHNlc3Npb25IYW5kbGUsIG5hbWVTdHJpbmcpKSB7XHJcbiAgICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaCgnbWwtdGVuc29yLWNwdS1vdXRwdXQnKTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobG9jYXRpb24gIT09ICdjcHUnICYmIGxvY2F0aW9uICE9PSAnY3B1LXBpbm5lZCcgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJyAmJiBsb2NhdGlvbiAhPT0gJ21sLXRlbnNvcicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke2xvY2F0aW9ufS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7bG9jYXRpb259LiBPbmx5ICdncHUtYnVmZmVyJyBsb2NhdGlvbiBpcyBzdXBwb3J0ZWQgd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnB1c2gobG9jYXRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdXNlIElPIGJpbmRpbmcgb25seSB3aGVuIGF0IGxlYXN0IG9uZSBvdXRwdXQgaXMgcHJlZmVycmVkIHRvIGJlIG9uIEdQVS5cclxuICAgIGxldCBiaW5kaW5nU3RhdGU6IElPQmluZGluZ1N0YXRlIHwgbnVsbCA9IG51bGw7XHJcbiAgICBpZiAoXHJcbiAgICAgICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpICYmXHJcbiAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5zb21lKChsKSA9PiBsID09PSAnZ3B1LWJ1ZmZlcicgfHwgbCA9PT0gJ21sLXRlbnNvcicgfHwgbCA9PT0gJ21sLXRlbnNvci1jcHUtb3V0cHV0JylcclxuICAgICkge1xyXG4gICAgICBpb0JpbmRpbmdIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVCaW5kaW5nKHNlc3Npb25IYW5kbGUpO1xyXG4gICAgICBpZiAoaW9CaW5kaW5nSGFuZGxlID09PSAwKSB7XHJcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgSU8gYmluZGluZy5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJpbmRpbmdTdGF0ZSA9IHtcclxuICAgICAgICBoYW5kbGU6IGlvQmluZGluZ0hhbmRsZSxcclxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsXHJcbiAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDogb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zXHJcbiAgICAgICAgICAvLyAnbWwtdGVuc29yLWNwdS1vdXRwdXQnIGlzIHRyZWF0ZWQgYXMgJ21sLXRlbnNvcicgZm9yIHRoZSBwdXJwb3NlIG9mIElPIGJpbmRpbmcuXHJcbiAgICAgICAgICAubWFwKChsKSA9PiAobCA9PT0gJ21sLXRlbnNvci1jcHUtb3V0cHV0JyA/ICdtbC10ZW5zb3InIDogbCkpXHJcbiAgICAgICAgICAubWFwKChsKSA9PiBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0obCkpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSGFuZGxlLCBbXHJcbiAgICAgIHNlc3Npb25IYW5kbGUsXHJcbiAgICAgIGlucHV0TmFtZXNVVEY4RW5jb2RlZCxcclxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCxcclxuICAgICAgYmluZGluZ1N0YXRlLFxyXG4gICAgICBlbmFibGVHcmFwaENhcHR1cmUsXHJcbiAgICAgIGZhbHNlLFxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXMsIG91dHB1dE5hbWVzLCBpbnB1dE1ldGFkYXRhLCBvdXRwdXRNZXRhZGF0YV07XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcclxuICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaCgoYnVmKSA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xyXG5cclxuICAgIGlmIChpb0JpbmRpbmdIYW5kbGUgIT09IDApIHtcclxuICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ0hhbmRsZSkgIT09IDApIHtcclxuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2UgSU8gYmluZGluZy5cIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSAhPT0gMCkge1xyXG4gICAgICBpZiAod2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSkgIT09IDApIHtcclxuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IGU7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHdhc20uX2ZyZWUobW9kZWxEYXRhT2Zmc2V0KTtcclxuICAgIGlmIChzZXNzaW9uT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xyXG4gICAgICBpZiAod2FzbS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHNlc3Npb25PcHRpb25zSGFuZGxlKSAhPT0gMCkge1xyXG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBhbGxvY3MuZm9yRWFjaCgoYWxsb2MpID0+IHdhc20uX2ZyZWUoYWxsb2MpKTtcclxuXHJcbiAgICAvLyB1bm1vdW50IGV4dGVybmFsIGRhdGEgaWYgbmVjZXNzYXJ5XHJcbiAgICB3YXNtLnVubW91bnRFeHRlcm5hbERhdGE/LigpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWxlYXNlU2Vzc2lvbiA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xyXG4gIGNvbnN0IHNlc3Npb24gPSBhY3RpdmVTZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcclxuICBpZiAoIXNlc3Npb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke3Nlc3Npb25JZH1gKTtcclxuICB9XHJcbiAgY29uc3QgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgaW9CaW5kaW5nU3RhdGUsIGVuYWJsZUdyYXBoQ2FwdHVyZV0gPSBzZXNzaW9uO1xyXG5cclxuICBpZiAoaW9CaW5kaW5nU3RhdGUpIHtcclxuICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUpIHtcclxuICAgICAgaWYgKHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSkgIT09IDApIHtcclxuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAod2FzbS5fT3J0UmVsZWFzZUJpbmRpbmcoaW9CaW5kaW5nU3RhdGUuaGFuZGxlKSAhPT0gMCkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2UgSU8gYmluZGluZy5cIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB3YXNtLmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oc2Vzc2lvbklkKTtcclxuICB3YXNtLndlYm5uT25SZWxlYXNlU2Vzc2lvbj8uKHNlc3Npb25JZCk7XHJcbiAgd2FzbS53ZWJncHVPblJlbGVhc2VTZXNzaW9uPy4oc2Vzc2lvbklkKTtcclxuXHJcbiAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcclxuICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcclxuICBpZiAod2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSkgIT09IDApIHtcclxuICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKTtcclxuICB9XHJcbiAgYWN0aXZlU2Vzc2lvbnMuZGVsZXRlKHNlc3Npb25JZCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yID0gYXN5bmMgKFxyXG4gIHRlbnNvcjogVGVuc29yTWV0YWRhdGEgfCBudWxsLFxyXG4gIHRlbnNvckhhbmRsZXM6IG51bWJlcltdLFxyXG4gIGFsbG9jczogbnVtYmVyW10sXHJcbiAgc2Vzc2lvbklkOiBudW1iZXIsXHJcbiAgdGVuc29yTmFtZVVURjhFbmNvZGVkOiBudW1iZXIsXHJcbiAgaW5kZXg6IG51bWJlcixcclxuICBlbmFibGVHcmFwaENhcHR1cmUgPSBmYWxzZSxcclxuKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgaWYgKCF0ZW5zb3IpIHtcclxuICAgIHRlbnNvckhhbmRsZXMucHVzaCgwKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xyXG4gIGNvbnN0IHB0clNpemUgPSB3YXNtLlBUUl9TSVpFO1xyXG5cclxuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcclxuICBjb25zdCBkaW1zID0gdGVuc29yWzFdO1xyXG4gIGNvbnN0IGxvY2F0aW9uID0gdGVuc29yWzNdO1xyXG4gIGxldCBhY3R1YWxMb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG5cclxuICBsZXQgcmF3RGF0YTogbnVtYmVyO1xyXG4gIGxldCBkYXRhQnl0ZUxlbmd0aDogbnVtYmVyO1xyXG5cclxuICBpZiAoZGF0YVR5cGUgPT09ICdzdHJpbmcnICYmIChsb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInIHx8IGxvY2F0aW9uID09PSAnbWwtdGVuc29yJykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS4nKTtcclxuICB9XHJcblxyXG4gIGlmIChlbmFibGVHcmFwaENhcHR1cmUgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgRXh0ZXJuYWwgYnVmZmVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIGlucHV0L291dHB1dCBpbmRleCAke2luZGV4fSB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmAsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcclxuICAgIGNvbnN0IGdwdUJ1ZmZlciA9IHRlbnNvclsyXS5ncHVCdWZmZXI7XHJcbiAgICBkYXRhQnl0ZUxlbmd0aCA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcykhO1xyXG5cclxuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xyXG4gICAgICBjb25zdCByZWdpc3RlckJ1ZmZlciA9IHdhc20ud2ViZ3B1UmVnaXN0ZXJCdWZmZXI7XHJcbiAgICAgIGlmICghcmVnaXN0ZXJCdWZmZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByYXdEYXRhID0gcmVnaXN0ZXJCdWZmZXIoZ3B1QnVmZmVyLCBzZXNzaW9uSWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgcmVnaXN0ZXJCdWZmZXIgPSB3YXNtLmpzZXBSZWdpc3RlckJ1ZmZlcjtcclxuICAgICAgaWYgKCFyZWdpc3RlckJ1ZmZlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmF3RGF0YSA9IHJlZ2lzdGVyQnVmZmVyKHNlc3Npb25JZCwgaW5kZXgsIGdwdUJ1ZmZlciwgZGF0YUJ5dGVMZW5ndGgpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAobG9jYXRpb24gPT09ICdtbC10ZW5zb3InKSB7XHJcbiAgICBjb25zdCBtbFRlbnNvciA9IHRlbnNvclsyXS5tbFRlbnNvciBhcyBNTFRlbnNvcjtcclxuICAgIGRhdGFCeXRlTGVuZ3RoID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXModGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpLCBkaW1zKSE7XHJcblxyXG4gICAgY29uc3QgcmVnaXN0ZXJNTFRlbnNvciA9IHdhc20ud2Vibm5SZWdpc3Rlck1MVGVuc29yO1xyXG4gICAgaWYgKCFyZWdpc3Rlck1MVGVuc29yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO1xyXG4gICAgfVxyXG4gICAgcmF3RGF0YSA9IHJlZ2lzdGVyTUxUZW5zb3Ioc2Vzc2lvbklkLCBtbFRlbnNvciwgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpLCBkaW1zKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgZGF0YSA9IHRlbnNvclsyXTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAvLyBzdHJpbmcgdGVuc29yXHJcbiAgICAgIGRhdGFCeXRlTGVuZ3RoID0gcHRyU2l6ZSAqIGRhdGEubGVuZ3RoO1xyXG4gICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcclxuICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtpXSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7aX0gaXMgbm90IGEgc3RyaW5nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdhc20uc2V0VmFsdWUocmF3RGF0YSArIGkgKiBwdHJTaXplLCBhbGxvY1dhc21TdHJpbmcoZGF0YVtpXSwgYWxsb2NzKSwgJyonKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaXNHcmFwaElucHV0ID0gd2FzbS53ZWJubklzR3JhcGhJbnB1dDtcclxuICAgICAgY29uc3QgaXNHcmFwaE91dHB1dCA9IHdhc20ud2Vibm5Jc0dyYXBoT3V0cHV0O1xyXG4gICAgICBpZiAoZGF0YVR5cGUgIT09ICdzdHJpbmcnICYmIGlzR3JhcGhJbnB1dCAmJiBpc0dyYXBoT3V0cHV0KSB7XHJcbiAgICAgICAgY29uc3QgdGVuc29yTmFtZSA9IHdhc20uVVRGOFRvU3RyaW5nKHRlbnNvck5hbWVVVEY4RW5jb2RlZCk7XHJcbiAgICAgICAgLy8gUHJvbW90ZSB0aGUgdGVuc29yIHRvICdtbC10ZW5zb3InIGlmIGl0IGlzIGEgZ3JhcGggaW5wdXQuXHJcbiAgICAgICAgaWYgKGlzR3JhcGhJbnB1dChzZXNzaW9uSWQsIHRlbnNvck5hbWUpIHx8IGlzR3JhcGhPdXRwdXQoc2Vzc2lvbklkLCB0ZW5zb3JOYW1lKSkge1xyXG4gICAgICAgICAgY29uc3QgZGF0YVR5cGVFbnVtID0gdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpO1xyXG4gICAgICAgICAgZGF0YUJ5dGVMZW5ndGggPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyhkYXRhVHlwZUVudW0sIGRpbXMpITtcclxuICAgICAgICAgIGFjdHVhbExvY2F0aW9uID0gJ21sLXRlbnNvcic7XHJcbiAgICAgICAgICBjb25zdCBjcmVhdGVUZW1wb3JhcnlUZW5zb3IgPSB3YXNtLndlYm5uQ3JlYXRlVGVtcG9yYXJ5VGVuc29yO1xyXG4gICAgICAgICAgY29uc3QgdXBsb2FkVGVuc29yID0gd2FzbS53ZWJublVwbG9hZFRlbnNvcjtcclxuICAgICAgICAgIGlmICghY3JlYXRlVGVtcG9yYXJ5VGVuc29yIHx8ICF1cGxvYWRUZW5zb3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCB0ZW5zb3JJZCA9IGF3YWl0IGNyZWF0ZVRlbXBvcmFyeVRlbnNvcihzZXNzaW9uSWQsIGRhdGFUeXBlRW51bSwgZGltcyBhcyBudW1iZXJbXSk7XHJcbiAgICAgICAgICB1cGxvYWRUZW5zb3IodGVuc29ySWQsIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCkpO1xyXG4gICAgICAgICAgcmF3RGF0YSA9IHRlbnNvcklkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkYXRhQnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XHJcbiAgICAgICAgICB3YXNtLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YUJ5dGVMZW5ndGgpLCByYXdEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YUJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgcmF3RGF0YSA9IHdhc20uX21hbGxvYyhkYXRhQnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XHJcbiAgICAgICAgd2FzbS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGFCeXRlTGVuZ3RoKSwgcmF3RGF0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcclxuICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiBkaW1zLmxlbmd0aCk7XHJcbiAgdHJ5IHtcclxuICAgIGRpbXMuZm9yRWFjaCgoZCwgaW5kZXgpID0+IHdhc20uc2V0VmFsdWUoZGltc09mZnNldCArIGluZGV4ICogcHRyU2l6ZSwgZCwgcHRyU2l6ZSA9PT0gNCA/ICdpMzInIDogJ2k2NCcpKTtcclxuICAgIGNvbnN0IHRlbnNvciA9IHdhc20uX09ydENyZWF0ZVRlbnNvcihcclxuICAgICAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpLFxyXG4gICAgICByYXdEYXRhLFxyXG4gICAgICBkYXRhQnl0ZUxlbmd0aCxcclxuICAgICAgZGltc09mZnNldCxcclxuICAgICAgZGltcy5sZW5ndGgsXHJcbiAgICAgIGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bShhY3R1YWxMb2NhdGlvbiksXHJcbiAgICApO1xyXG4gICAgaWYgKHRlbnNvciA9PT0gMCkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7c2Vzc2lvbklkfSwgaW5kZXg9JHtpbmRleH0uYCk7XHJcbiAgICB9XHJcbiAgICB0ZW5zb3JIYW5kbGVzLnB1c2godGVuc29yKTtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBwZXJmb3JtIGluZmVyZW5jZSBydW5cclxuICovXHJcbmV4cG9ydCBjb25zdCBydW4gPSBhc3luYyAoXHJcbiAgc2Vzc2lvbklkOiBudW1iZXIsXHJcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcclxuICBpbnB1dFRlbnNvcnM6IFRlbnNvck1ldGFkYXRhW10sXHJcbiAgb3V0cHV0SW5kaWNlczogbnVtYmVyW10sXHJcbiAgb3V0cHV0VGVuc29yczogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcclxuICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXHJcbik6IFByb21pc2U8VGVuc29yTWV0YWRhdGFbXT4gPT4ge1xyXG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xyXG4gIGNvbnN0IHB0clNpemUgPSB3YXNtLlBUUl9TSVpFO1xyXG4gIGNvbnN0IHNlc3Npb24gPSBhY3RpdmVTZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcclxuICBpZiAoIXNlc3Npb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XHJcbiAgfVxyXG4gIGNvbnN0IHNlc3Npb25IYW5kbGUgPSBzZXNzaW9uWzBdO1xyXG4gIGNvbnN0IGlucHV0TmFtZXNVVEY4RW5jb2RlZCA9IHNlc3Npb25bMV07XHJcbiAgY29uc3Qgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IHNlc3Npb25bMl07XHJcbiAgY29uc3QgaW9CaW5kaW5nU3RhdGUgPSBzZXNzaW9uWzNdO1xyXG4gIGNvbnN0IGVuYWJsZUdyYXBoQ2FwdHVyZSA9IHNlc3Npb25bNF07XHJcbiAgY29uc3QgaW5wdXRPdXRwdXRCb3VuZCA9IHNlc3Npb25bNV07XHJcblxyXG4gIGNvbnN0IGlucHV0Q291bnQgPSBpbnB1dEluZGljZXMubGVuZ3RoO1xyXG4gIGNvbnN0IG91dHB1dENvdW50ID0gb3V0cHV0SW5kaWNlcy5sZW5ndGg7XHJcblxyXG4gIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcclxuICBsZXQgcnVuT3B0aW9uc0FsbG9jczogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgY29uc3QgaW5wdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xyXG4gIGNvbnN0IG91dHB1dFRlbnNvckhhbmRsZXM6IG51bWJlcltdID0gW107XHJcbiAgY29uc3QgaW5wdXRPdXRwdXRBbGxvY3M6IG51bWJlcltdID0gW107XHJcbiAgY29uc3QgcHJlQWxsb2NhdGVkT3V0cHV0czogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgY29uc3QgYmVmb3JlUnVuU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xyXG4gIGNvbnN0IGlucHV0VmFsdWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKGlucHV0Q291bnQgKiBwdHJTaXplKTtcclxuICBjb25zdCBpbnB1dE5hbWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKGlucHV0Q291bnQgKiBwdHJTaXplKTtcclxuICBjb25zdCBvdXRwdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiBwdHJTaXplKTtcclxuICBjb25zdCBvdXRwdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIHB0clNpemUpO1xyXG5cclxuICB0cnkge1xyXG4gICAgW3J1bk9wdGlvbnNIYW5kbGUsIHJ1bk9wdGlvbnNBbGxvY3NdID0gc2V0UnVuT3B0aW9ucyhvcHRpb25zKTtcclxuXHJcbiAgICBUUkFDRV9FVkVOVF9CRUdJTignd2FzbSBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3InKTtcclxuICAgIC8vIGNyZWF0ZSBpbnB1dCB0ZW5zb3JzXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xyXG4gICAgICBhd2FpdCBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3IoXHJcbiAgICAgICAgaW5wdXRUZW5zb3JzW2ldLFxyXG4gICAgICAgIGlucHV0VGVuc29ySGFuZGxlcyxcclxuICAgICAgICBpbnB1dE91dHB1dEFsbG9jcyxcclxuICAgICAgICBzZXNzaW9uSWQsXHJcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkW2lucHV0SW5kaWNlc1tpXV0sXHJcbiAgICAgICAgaW5wdXRJbmRpY2VzW2ldLFxyXG4gICAgICAgIGVuYWJsZUdyYXBoQ2FwdHVyZSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjcmVhdGUgb3V0cHV0IHRlbnNvcnNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xyXG4gICAgICBhd2FpdCBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3IoXHJcbiAgICAgICAgb3V0cHV0VGVuc29yc1tpXSxcclxuICAgICAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLFxyXG4gICAgICAgIGlucHV0T3V0cHV0QWxsb2NzLFxyXG4gICAgICAgIHNlc3Npb25JZCxcclxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkW291dHB1dEluZGljZXNbaV1dLFxyXG4gICAgICAgIGlucHV0Q291bnQgKyBvdXRwdXRJbmRpY2VzW2ldLFxyXG4gICAgICAgIGVuYWJsZUdyYXBoQ2FwdHVyZSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIFRSQUNFX0VWRU5UX0VORCgnd2FzbSBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3InKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xyXG4gICAgICB3YXNtLnNldFZhbHVlKGlucHV0VmFsdWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsIGlucHV0VGVuc29ySGFuZGxlc1tpXSwgJyonKTtcclxuICAgICAgd2FzbS5zZXRWYWx1ZShpbnB1dE5hbWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZFtpbnB1dEluZGljZXNbaV1dLCAnKicpO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XHJcbiAgICAgIHdhc20uc2V0VmFsdWUob3V0cHV0VmFsdWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsIG91dHB1dFRlbnNvckhhbmRsZXNbaV0sICcqJyk7XHJcbiAgICAgIHdhc20uc2V0VmFsdWUob3V0cHV0TmFtZXNPZmZzZXQgKyBpICogcHRyU2l6ZSwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtvdXRwdXRJbmRpY2VzW2ldXSwgJyonKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCB8fCAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkgJiYgaW9CaW5kaW5nU3RhdGUgJiYgIWlucHV0T3V0cHV0Qm91bmQpIHtcclxuICAgICAgY29uc3QgeyBoYW5kbGUsIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucywgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZCB9ID0gaW9CaW5kaW5nU3RhdGU7XHJcblxyXG4gICAgICBpZiAoaW5wdXROYW1lc1VURjhFbmNvZGVkLmxlbmd0aCAhPT0gaW5wdXRDb3VudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2lucHV0Q291bnR9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RofSkuYCxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBUUkFDRV9FVkVOVF9CRUdJTignd2FzbSBiaW5kSW5wdXRzT3V0cHV0cycpO1xyXG4gICAgICAvLyBwcm9jZXNzIGlucHV0c1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5wdXRJbmRpY2VzW2ldO1xyXG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydEJpbmRJbnB1dChoYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sIGlucHV0VGVuc29ySGFuZGxlc1tpXSk7XHJcbiAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xyXG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgaW5wdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcHJvY2VzcyBwcmUtYWxsb2NhdGVkIG91dHB1dHNcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBvdXRwdXRJbmRpY2VzW2ldO1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gb3V0cHV0VGVuc29yc1tpXT8uWzNdOyAvLyB1bmRlZmluZWQgbWVhbnMgb3V0cHV0IGlzIG5vdCBwcmUtYWxsb2NhdGVkLlxyXG5cclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgIC8vIG91dHB1dCBpcyBwcmUtYWxsb2NhdGVkLCBzdG9yZSBhbmQgYmluZCB0aGUgdGVuc29yLlxyXG4gICAgICAgICAgcHJlQWxsb2NhdGVkT3V0cHV0cy5wdXNoKG91dHB1dFRlbnNvckhhbmRsZXNbaV0pO1xyXG4gICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0QmluZE91dHB1dChoYW5kbGUsIG91dHB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLCBvdXRwdXRUZW5zb3JIYW5kbGVzW2ldLCAwKTtcclxuICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcclxuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuIHJlc2V0IHByZWZlcnJlZCBsb2NhdGlvbi5cclxuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEJpbmRPdXRwdXQoXHJcbiAgICAgICAgICAgIGhhbmRsZSxcclxuICAgICAgICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWRbaW5kZXhdLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcclxuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgb3V0cHV0WyR7aX1dIHRvICR7b3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW2ldfSBmb3Igc2Vzc2lvbj0ke3Nlc3Npb25JZH0uYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFRSQUNFX0VWRU5UX0VORCgnd2FzbSBiaW5kSW5wdXRzT3V0cHV0cycpO1xyXG4gICAgICBhY3RpdmVTZXNzaW9ucy5zZXQoc2Vzc2lvbklkLCBbXHJcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcclxuICAgICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQsXHJcbiAgICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCxcclxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcclxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgXSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2FzbS5qc2VwT25SdW5TdGFydD8uKHNlc3Npb25IYW5kbGUpO1xyXG4gICAgd2FzbS53ZWJubk9uUnVuU3RhcnQ/LihzZXNzaW9uSGFuZGxlKTtcclxuXHJcbiAgICBsZXQgZXJyb3JDb2RlOiBudW1iZXI7XHJcbiAgICBpZiAoKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCB8fCAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkgJiYgaW9CaW5kaW5nU3RhdGUpIHtcclxuICAgICAgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0UnVuV2l0aEJpbmRpbmcoXHJcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcclxuICAgICAgICBpb0JpbmRpbmdTdGF0ZS5oYW5kbGUsXHJcbiAgICAgICAgb3V0cHV0Q291bnQsXHJcbiAgICAgICAgb3V0cHV0VmFsdWVzT2Zmc2V0LFxyXG4gICAgICAgIHJ1bk9wdGlvbnNIYW5kbGUsXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRSdW4oXHJcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcclxuICAgICAgICBpbnB1dE5hbWVzT2Zmc2V0LFxyXG4gICAgICAgIGlucHV0VmFsdWVzT2Zmc2V0LFxyXG4gICAgICAgIGlucHV0Q291bnQsXHJcbiAgICAgICAgb3V0cHV0TmFtZXNPZmZzZXQsXHJcbiAgICAgICAgb3V0cHV0Q291bnQsXHJcbiAgICAgICAgb3V0cHV0VmFsdWVzT2Zmc2V0LFxyXG4gICAgICAgIHJ1bk9wdGlvbnNIYW5kbGUsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcignZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3V0cHV0OiBUZW5zb3JNZXRhZGF0YVtdID0gW107XHJcbiAgICBjb25zdCBvdXRwdXRQcm9taXNlczogQXJyYXk8UHJvbWlzZTxbbnVtYmVyLCBUZW5zb3IuRGF0YVR5cGVdPj4gPSBbXTtcclxuXHJcbiAgICBUUkFDRV9FVkVOVF9CRUdJTignd2FzbSBQcm9jZXNzT3V0cHV0VGVuc29yJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcclxuICAgICAgY29uc3QgdGVuc29yID0gTnVtYmVyKHdhc20uZ2V0VmFsdWUob3V0cHV0VmFsdWVzT2Zmc2V0ICsgaSAqIHB0clNpemUsICcqJykpO1xyXG4gICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgcGFydCB0byBlbnN1cmUgaXQgd29ya3MgZm9yIFdlYkdQVSB3aGVuIGJvdGggcHJlLWFsbG9jYXRlZCBvdXRwdXRzIGFuZFxyXG4gICAgICAvLyBwcmVmZXJyZWQgbG9jYXRpb24gYXJlIHNwZWNpZmllZC5cclxuICAgICAgLy8gQ2VydGFpbiBwcmUtYWxsb2NhdGVkIHRlbnNvcnMgbWF5IGFscmVhZHkgYmUgYm91bmQgaW4gdGhlIElPIGJpbmRpbmcuIGUuZy4gdGhlIFdlYk5OIGJhY2tlbmRcclxuICAgICAgLy8gYWx3YXlzIGJpbmRzIGl0cyB0ZW5zb3IgdG8gJ21sLXRlbnNvcicuIEluIHN1Y2ggY2FzZXMsIHRoZSB0ZW5zb3IgSUQgbWlnaHQgY2hhbmdlIGFmdGVyIGJpbmRpbmcsXHJcbiAgICAgIC8vIGJ1dCBjb3B5aW5nIGRhdGEgZm9yIHRoZXNlIHRlbnNvcnMgc2hvdWxkIHN0aWxsIGJlIGF2b2lkZWQuXHJcbiAgICAgIGlmICh0ZW5zb3IgPT09IG91dHB1dFRlbnNvckhhbmRsZXNbaV0gfHwgcHJlQWxsb2NhdGVkT3V0cHV0cy5pbmNsdWRlcyhvdXRwdXRUZW5zb3JIYW5kbGVzW2ldKSkge1xyXG4gICAgICAgIC8vIG91dHB1dCB0ZW5zb3IgaXMgcHJlLWFsbG9jYXRlZC4gbm8gbmVlZCB0byBjb3B5IGRhdGEuXHJcbiAgICAgICAgb3V0cHV0LnB1c2gob3V0cHV0VGVuc29yc1tpXSEpO1xyXG4gICAgICAgIGlmICh0ZW5zb3IgIT09IG91dHB1dFRlbnNvckhhbmRsZXNbaV0pIHtcclxuICAgICAgICAgIC8vIHJlbGVhc2UgcmVkdW5kYW50IHRlbnNvciBlYXJsaWVyLlxyXG4gICAgICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKSAhPT0gMCkge1xyXG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XHJcbiAgICAgIC8vIHN0YWNrIGFsbG9jYXRlIDQgcG9pbnRlciB2YWx1ZVxyXG4gICAgICBjb25zdCB0ZW5zb3JEYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiBwdHJTaXplKTtcclxuXHJcbiAgICAgIGxldCBrZWVwT3V0cHV0VGVuc29yID0gZmFsc2U7XHJcbiAgICAgIGxldCB0eXBlOiBUZW5zb3IuVHlwZSB8IHVuZGVmaW5lZCxcclxuICAgICAgICBkYXRhT2Zmc2V0ID0gMDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRHZXRUZW5zb3JEYXRhKFxyXG4gICAgICAgICAgdGVuc29yLFxyXG4gICAgICAgICAgdGVuc29yRGF0YU9mZnNldCxcclxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyBwdHJTaXplLFxyXG4gICAgICAgICAgdGVuc29yRGF0YU9mZnNldCArIDIgKiBwdHJTaXplLFxyXG5cclxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyAzICogcHRyU2l6ZSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcclxuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7aX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnO1xyXG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gTnVtYmVyKHdhc20uZ2V0VmFsdWUodGVuc29yRGF0YU9mZnNldCwgdmFsdWVUeXBlKSk7XHJcbiAgICAgICAgZGF0YU9mZnNldCA9IHdhc20uZ2V0VmFsdWUodGVuc29yRGF0YU9mZnNldCArIHB0clNpemUsICcqJyk7XHJcbiAgICAgICAgY29uc3QgZGltc09mZnNldCA9IHdhc20uZ2V0VmFsdWUodGVuc29yRGF0YU9mZnNldCArIHB0clNpemUgKiAyLCAnKicpO1xyXG4gICAgICAgIGNvbnN0IGRpbXNMZW5ndGggPSBOdW1iZXIod2FzbS5nZXRWYWx1ZSh0ZW5zb3JEYXRhT2Zmc2V0ICsgcHRyU2l6ZSAqIDMsIHZhbHVlVHlwZSkpO1xyXG4gICAgICAgIGNvbnN0IGRpbXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgZGltcy5wdXNoKE51bWJlcih3YXNtLmdldFZhbHVlKGRpbXNPZmZzZXQgKyBpICogcHRyU2l6ZSwgdmFsdWVUeXBlKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2FzbS5fT3J0RnJlZShkaW1zT2Zmc2V0KSAhPT0gMCkge1xyXG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBmcmVlIG1lbW9yeSBmb3IgdGVuc29yIGRpbXMuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzaXplID0gZGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKTtcclxuICAgICAgICB0eXBlID0gdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoZGF0YVR5cGUpO1xyXG5cclxuICAgICAgICBjb25zdCBwcmVmZXJyZWRMb2NhdGlvbiA9IGlvQmluZGluZ1N0YXRlPy5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbb3V0cHV0SW5kaWNlc1tpXV07XHJcblxyXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicgfHwgcHJlZmVycmVkTG9jYXRpb24gPT09ICdtbC10ZW5zb3InKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS4nKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IHN0cmluZ0RhdGE6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3YXNtLmdldFZhbHVlKGRhdGFPZmZzZXQgKyBpICogcHRyU2l6ZSwgJyonKTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dE9mZnNldCA9IHdhc20uZ2V0VmFsdWUoZGF0YU9mZnNldCArIChpICsgMSkgKiBwdHJTaXplLCAnKicpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhCeXRlc1RvUmVhZCA9IGkgPT09IHNpemUgLSAxID8gdW5kZWZpbmVkIDogbmV4dE9mZnNldCAtIG9mZnNldDtcclxuICAgICAgICAgICAgc3RyaW5nRGF0YS5wdXNoKHdhc20uVVRGOFRvU3RyaW5nKG9mZnNldCwgbWF4Qnl0ZXNUb1JlYWQpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBzdHJpbmdEYXRhLCAnY3B1J10pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBJZiBhIGNlcnRhaW4gb3V0cHV0J3MgcHJlZmVycmVkIGxvY2F0aW9uIGlzIEdQVSBidXQgdGhlIHRlbnNvciBpcyBlbXB0eSwgd2Ugc3RpbGwgbmVlZCB0byBjcmVhdGUgYSBDUFVcclxuICAgICAgICAgIC8vIHRlbnNvciBmb3IgaXQuIFRoZXJlIGlzIG5vIG1hcHBpbmcgR1BVIGJ1ZmZlciBmb3IgYW4gZW1wdHkgdGVuc29yLlxyXG4gICAgICAgICAgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicgJiYgc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZ2V0QnVmZmVyID0gIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUgPyB3YXNtLndlYmdwdUdldEJ1ZmZlciA6IHdhc20uanNlcEdldEJ1ZmZlcjtcclxuICAgICAgICAgICAgaWYgKCFnZXRCdWZmZXIpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZ3B1QnVmZmVyID0gZ2V0QnVmZmVyKGRhdGFPZmZzZXQpO1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyU2l6ZSA9PT0gdW5kZWZpbmVkIHx8ICFpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUodHlwZSkpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBkbyBub3QgcmVsZWFzZSB0aGUgdGVuc29yIHJpZ2h0IG5vdy4gaXQgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHVzZXIgY2FsbHMgdGVuc29yLmRpc3Bvc2UoKS5cclxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcclxuICAgICAgICAgICAgICB3YXNtLndlYmdwdVJlZ2lzdGVyQnVmZmVyIShncHVCdWZmZXIsIHNlc3Npb25JZCwgZGF0YU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWREYXRhRnVuY3Rpb24gPSB3YXNtLndlYmdwdUNyZWF0ZURvd25sb2FkZXIhKGdwdUJ1ZmZlciwgYnVmZmVyU2l6ZSwgc2Vzc2lvbklkKTtcclxuICAgICAgICAgICAgICBvdXRwdXQucHVzaChbXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgZGltcyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgZ3B1QnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICBkb3dubG9hZDogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZG93bmxvYWREYXRhRnVuY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3ICh0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSEpKShhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEgYXMgVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXNdO1xyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCByZWxlYXNlIHRlbnNvci5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICdncHUtYnVmZmVyJyxcclxuICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvdXRwdXQucHVzaChbXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgZGltcyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgZ3B1QnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICBkb3dubG9hZDogd2FzbS5qc2VwQ3JlYXRlRG93bmxvYWRlciEoZ3B1QnVmZmVyLCBidWZmZXJTaXplLCB0eXBlKSxcclxuICAgICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcikgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSB0ZW5zb3IuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnZ3B1LWJ1ZmZlcicsXHJcbiAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAocHJlZmVycmVkTG9jYXRpb24gPT09ICdtbC10ZW5zb3InICYmIHNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuc3VyZVRlbnNvciA9IHdhc20ud2Vibm5FbnN1cmVUZW5zb3I7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQgPSB3YXNtLndlYm5uSXNHcmFwaElucHV0T3V0cHV0VHlwZVN1cHBvcnRlZDtcclxuICAgICAgICAgICAgaWYgKCFlbnN1cmVUZW5zb3IgfHwgIWlzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbnNvclNpemUgPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyhkYXRhVHlwZSwgc2l6ZSk7XHJcbiAgICAgICAgICAgIGlmICh0ZW5zb3JTaXplID09PSB1bmRlZmluZWQgfHwgIWlzTUxUZW5zb3JTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQoc2Vzc2lvbklkLCB0eXBlLCBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBgcHJlZmVycmVkTG9jYXRpb24gXCJtbC10ZW5zb3JcIiBmb3IgJHt0eXBlfSBvdXRwdXQgaXMgbm90IHN1cHBvcnRlZCBieSBjdXJyZW50IFdlYk5OIENvbnRleHQuYCxcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZ3JhcGggaGFzIGJlZW4gcGFydGl0aW9uZWQsIHRoZSBvdXRwdXQgdGVuc29yIG1heSBoYXZlIG5vdCBiZWVuIGNyZWF0ZWQuIEZvciB0aGlzIHJlYXNvbiwgd2UgdXNlXHJcbiAgICAgICAgICAgIC8vIGVuc3VyZVRlbnNvciB0byBnZXQvY3JlYXRlIHRoZSBNTFRlbnNvci4gSW4gd2hpY2ggY2FzZSwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IHRoZSBkYXRhIGlmIGEgbmV3IHRlbnNvclxyXG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBjcmVhdGVkLlxyXG4gICAgICAgICAgICBjb25zdCBtbFRlbnNvciA9IGF3YWl0IGVuc3VyZVRlbnNvcihzZXNzaW9uSWQsIGRhdGFPZmZzZXQsIGRhdGFUeXBlLCBkaW1zLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBkbyBub3QgcmVsZWFzZSB0aGUgdGVuc29yIHJpZ2h0IG5vdy4gaXQgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHVzZXIgY2FsbHMgdGVuc29yLmRpc3Bvc2UoKS5cclxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChbXHJcbiAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICBkaW1zLFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1sVGVuc29yLFxyXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IHdhc20ud2Vibm5DcmVhdGVNTFRlbnNvckRvd25sb2FkZXIhKGRhdGFPZmZzZXQsIHR5cGUpLFxyXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICB3YXNtLndlYm5uUmVsZWFzZVRlbnNvcklkIShkYXRhT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICdtbC10ZW5zb3InLFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocHJlZmVycmVkTG9jYXRpb24gPT09ICdtbC10ZW5zb3ItY3B1LW91dHB1dCcgJiYgc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHdhc20ud2Vibm5DcmVhdGVNTFRlbnNvckRvd25sb2FkZXIhKGRhdGFPZmZzZXQsIHR5cGUgYXMgVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzKSgpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG91dHB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIC8vIERlbGF5IHRoZSBkYXRhIGRvd25sb2FkIGFuZCByZWxlYXNpbmcgdGhlIHRlbnNvciB1bnRpbCB3ZSBjYW4gd2FpdCBmb3IgYWxsIG91dHB1dCB0ZW5zb3JzIHRvIGJlIGRvd25sb2FkZWQuXHJcbiAgICAgICAgICAgIGtlZXBPdXRwdXRUZW5zb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICBvdXRwdXRQcm9taXNlcy5wdXNoKFxyXG4gICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQ6IFtudW1iZXIsIFRlbnNvci5EYXRhVHlwZV0gPSBbaW5kZXgsIGF3YWl0IGRhdGFdO1xyXG4gICAgICAgICAgICAgICAgd2FzbS53ZWJublJlbGVhc2VUZW5zb3JJZCEoZGF0YU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBbXSwgJ2NwdSddKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0eXBlKTtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyB0eXBlZEFycmF5Q29uc3RydWN0b3Ioc2l6ZSk7XHJcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCkuc2V0KFxyXG4gICAgICAgICAgICAgIHdhc20uSEVBUFU4LnN1YmFycmF5KGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGgpLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgZGF0YSwgJ2NwdSddKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgd2FzbS5zdGFja1Jlc3RvcmUoYmVmb3JlR2V0VGVuc29yRGF0YVN0YWNrKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgZGF0YU9mZnNldCkge1xyXG4gICAgICAgICAgd2FzbS5fZnJlZShkYXRhT2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFrZWVwT3V0cHV0VGVuc29yKSB7XHJcbiAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlvQmluZGluZ1N0YXRlICYmICFlbmFibGVHcmFwaENhcHR1cmUpIHtcclxuICAgICAgaWYgKHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSkgIT09IDApIHtcclxuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcclxuICAgICAgICBzZXNzaW9uSGFuZGxlLFxyXG4gICAgICAgIGlucHV0TmFtZXNVVEY4RW5jb2RlZCxcclxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxyXG4gICAgICAgIGlvQmluZGluZ1N0YXRlLFxyXG4gICAgICAgIGVuYWJsZUdyYXBoQ2FwdHVyZSxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICAvLyBXYWl0IGZvciBhbGwgb3V0cHV0IHRlbnNvciBkYXRhIHRvIGJlIGRvd25sb2FkZWQuXHJcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgZGF0YV0gb2YgYXdhaXQgUHJvbWlzZS5hbGwob3V0cHV0UHJvbWlzZXMpKSB7XHJcbiAgICAgIG91dHB1dFtpbmRleF1bMl0gPSBkYXRhO1xyXG4gICAgfVxyXG4gICAgVFJBQ0VfRVZFTlRfRU5EKCd3YXNtIFByb2Nlc3NPdXRwdXRUZW5zb3InKTtcclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHdhc20ud2Vibm5PblJ1bkVuZD8uKHNlc3Npb25IYW5kbGUpO1xyXG5cclxuICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZVJ1blN0YWNrKTtcclxuXHJcbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcclxuICAgICAgaW5wdXRUZW5zb3JzLmZvckVhY2goKHQpID0+IHtcclxuICAgICAgICBpZiAodCAmJiB0WzNdID09PSAnZ3B1LWJ1ZmZlcicpIHtcclxuICAgICAgICAgIHdhc20ud2ViZ3B1VW5yZWdpc3RlckJ1ZmZlciEodFsyXS5ncHVCdWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIG91dHB1dFRlbnNvcnMuZm9yRWFjaCgodCkgPT4ge1xyXG4gICAgICAgIGlmICh0ICYmIHRbM10gPT09ICdncHUtYnVmZmVyJykge1xyXG4gICAgICAgICAgd2FzbS53ZWJncHVVbnJlZ2lzdGVyQnVmZmVyISh0WzJdLmdwdUJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlucHV0VGVuc29ySGFuZGxlcy5mb3JFYWNoKCh2KSA9PiB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHYpKTtcclxuICAgIG91dHB1dFRlbnNvckhhbmRsZXMuZm9yRWFjaCgodikgPT4gd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih2KSk7XHJcbiAgICBpbnB1dE91dHB1dEFsbG9jcy5mb3JFYWNoKChwKSA9PiB3YXNtLl9mcmVlKHApKTtcclxuXHJcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xyXG4gICAgICB3YXNtLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhydW5PcHRpb25zSGFuZGxlKTtcclxuICAgIH1cclxuICAgIHJ1bk9wdGlvbnNBbGxvY3MuZm9yRWFjaCgocCkgPT4gd2FzbS5fZnJlZShwKSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGVuZCBwcm9maWxpbmdcclxuICovXHJcbmV4cG9ydCBjb25zdCBlbmRQcm9maWxpbmcgPSAoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XHJcbiAgaWYgKCFzZXNzaW9uKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2Vzc2lvbiBpZCcpO1xyXG4gIH1cclxuICBjb25zdCBzZXNzaW9uSGFuZGxlID0gc2Vzc2lvblswXTtcclxuXHJcbiAgLy8gcHJvZmlsZSBmaWxlIG5hbWUgaXMgbm90IHVzZWQgeWV0LCBidXQgaXQgbXVzdCBiZSBmcmVlZC5cclxuICBjb25zdCBwcm9maWxlRmlsZU5hbWUgPSB3YXNtLl9PcnRFbmRQcm9maWxpbmcoc2Vzc2lvbkhhbmRsZSk7XHJcbiAgaWYgKHByb2ZpbGVGaWxlTmFtZSA9PT0gMCkge1xyXG4gICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpO1xyXG4gIH1cclxuICB3YXNtLl9PcnRGcmVlKHByb2ZpbGVGaWxlTmFtZSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMgPSAodGVuc29yczogcmVhZG9ubHkgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSk6IEFycmF5QnVmZmVyTGlrZVtdID0+IHtcclxuICBjb25zdCBidWZmZXJzOiBBcnJheUJ1ZmZlckxpa2VbXSA9IFtdO1xyXG4gIGZvciAoY29uc3QgdGVuc29yIG9mIHRlbnNvcnMpIHtcclxuICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgJiYgJ2J1ZmZlcicgaW4gZGF0YSkge1xyXG4gICAgICBidWZmZXJzLnB1c2goZGF0YS5idWZmZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gYnVmZmVycztcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBlbnYsIEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHtcclxuICBPcnRXYXNtTWVzc2FnZSxcclxuICBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcixcclxuICBTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGEsXHJcbiAgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsXHJcbiAgVGVuc29yTWV0YWRhdGEsXHJcbn0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XHJcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSAnLi93YXNtLWNvcmUtaW1wbCc7XHJcbmltcG9ydCB7IGluaXRpYWxpemVXZWJBc3NlbWJseSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcclxuaW1wb3J0IHtcclxuICBpbXBvcnRQcm94eVdvcmtlcixcclxuICBpbmZlcldhc21QYXRoUHJlZml4RnJvbVNjcmlwdFNyYyxcclxuICBpc0VzbUltcG9ydE1ldGFVcmxIYXJkY29kZWRBc0ZpbGVVcmksXHJcbn0gZnJvbSAnLi93YXNtLXV0aWxzLWltcG9ydCc7XHJcblxyXG5jb25zdCBpc1Byb3h5ID0gKCk6IGJvb2xlYW4gPT4gISFlbnYud2FzbS5wcm94eSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xyXG5sZXQgcHJveHlXb3JrZXI6IFdvcmtlciB8IHVuZGVmaW5lZDtcclxubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xyXG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxubGV0IGFib3J0ZWQgPSBmYWxzZTtcclxubGV0IHRlbXBvcmFyeU9iamVjdFVybDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG5cclxudHlwZSBQcm9taXNlQ2FsbGJhY2tzPFQgPSB2b2lkPiA9IFtyZXNvbHZlOiAocmVzdWx0OiBUKSA9PiB2b2lkLCByZWplY3Q6IChyZWFzb246IHVua25vd24pID0+IHZvaWRdO1xyXG5sZXQgaW5pdFdhc21DYWxsYmFja3M6IFByb21pc2VDYWxsYmFja3M7XHJcbmNvbnN0IHF1ZXVlZENhbGxiYWNrczogTWFwPE9ydFdhc21NZXNzYWdlWyd0eXBlJ10sIEFycmF5PFByb21pc2VDYWxsYmFja3M8dW5rbm93bj4+PiA9IG5ldyBNYXAoKTtcclxuXHJcbmNvbnN0IGVucXVldWVDYWxsYmFja3MgPSAodHlwZTogT3J0V2FzbU1lc3NhZ2VbJ3R5cGUnXSwgY2FsbGJhY2tzOiBQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+KTogdm9pZCA9PiB7XHJcbiAgY29uc3QgcXVldWUgPSBxdWV1ZWRDYWxsYmFja3MuZ2V0KHR5cGUpO1xyXG4gIGlmIChxdWV1ZSkge1xyXG4gICAgcXVldWUucHVzaChjYWxsYmFja3MpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBxdWV1ZWRDYWxsYmFja3Muc2V0KHR5cGUsIFtjYWxsYmFja3NdKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBlbnN1cmVXb3JrZXIgPSAoKTogdm9pZCA9PiB7XHJcbiAgaWYgKGluaXRpYWxpemluZyB8fCAhaW5pdGlhbGl6ZWQgfHwgYWJvcnRlZCB8fCAhcHJveHlXb3JrZXIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignd29ya2VyIG5vdCByZWFkeScpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IG9uUHJveHlXb3JrZXJNZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8T3J0V2FzbU1lc3NhZ2U+KTogdm9pZCA9PiB7XHJcbiAgc3dpdGNoIChldi5kYXRhLnR5cGUpIHtcclxuICAgIGNhc2UgJ2luaXQtd2FzbSc6XHJcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgICBpZiAoZXYuZGF0YS5lcnIpIHtcclxuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcclxuICAgICAgICBpbml0V2FzbUNhbGxiYWNrc1sxXShldi5kYXRhLmVycik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzWzBdKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRlbXBvcmFyeU9iamVjdFVybCkge1xyXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGVtcG9yYXJ5T2JqZWN0VXJsKTtcclxuICAgICAgICB0ZW1wb3JhcnlPYmplY3RVcmwgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdpbml0LWVwJzpcclxuICAgIGNhc2UgJ2NvcHktZnJvbSc6XHJcbiAgICBjYXNlICdjcmVhdGUnOlxyXG4gICAgY2FzZSAncmVsZWFzZSc6XHJcbiAgICBjYXNlICdydW4nOlxyXG4gICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6IHtcclxuICAgICAgY29uc3QgY2FsbGJhY2tzID0gcXVldWVkQ2FsbGJhY2tzLmdldChldi5kYXRhLnR5cGUpITtcclxuICAgICAgaWYgKGV2LmRhdGEuZXJyKSB7XHJcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkhWzFdKGV2LmRhdGEuZXJyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYWxsYmFja3Muc2hpZnQoKSFbMF0oZXYuZGF0YS5vdXQhKTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGRlZmF1bHQ6XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgaWYgKGluaXRpYWxpemVkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChpbml0aWFsaXppbmcpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7XHJcbiAgfVxyXG4gIGlmIChhYm9ydGVkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO1xyXG4gIH1cclxuXHJcbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcclxuXHJcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHByb3h5V29ya2VyPy50ZXJtaW5hdGUoKTtcclxuXHJcbiAgICAgIHZvaWQgaW1wb3J0UHJveHlXb3JrZXIoKS50aGVuKChbb2JqZWN0VXJsLCB3b3JrZXJdKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHByb3h5V29ya2VyID0gd29ya2VyO1xyXG4gICAgICAgICAgcHJveHlXb3JrZXIub25lcnJvciA9IChldjogRXJyb3JFdmVudCkgPT4gcmVqZWN0KGV2KTtcclxuICAgICAgICAgIHByb3h5V29ya2VyLm9ubWVzc2FnZSA9IG9uUHJveHlXb3JrZXJNZXNzYWdlO1xyXG4gICAgICAgICAgaW5pdFdhc21DYWxsYmFja3MgPSBbcmVzb2x2ZSwgcmVqZWN0XTtcclxuICAgICAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnaW5pdC13YXNtJywgaW46IGVudiB9O1xyXG5cclxuICAgICAgICAgIC8vIGlmIHRoZSBwcm94eSB3b3JrZXIgaXMgbG9hZGVkIGZyb20gYSBibG9iIFVSTCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIHBhdGggaW5mb3JtYXRpb24gaXMgbm90IGxvc3QuXHJcbiAgICAgICAgICAvL1xyXG4gICAgICAgICAgLy8gd2hlbiBgZW52Lndhc20ud2FzbVBhdGhzYCBpcyBub3Qgc2V0LCB3ZSBuZWVkIHRvIHBhc3MgdGhlIHBhdGggaW5mb3JtYXRpb24gdG8gdGhlIHdvcmtlci5cclxuICAgICAgICAgIC8vXHJcbiAgICAgICAgICBpZiAoIUJVSUxEX0RFRlMuRU5BQkxFX0JVTkRMRV9XQVNNX0pTICYmICFtZXNzYWdlLmluIS53YXNtLndhc21QYXRocyAmJiBvYmplY3RVcmwpIHtcclxuICAgICAgICAgICAgLy8gZm9yIGEgYnVpbGQgbm90IGJ1bmRsZWQgdGhlIHdhc20gSlMsIHdlIG5lZWQgdG8gcGFzcyB0aGUgcGF0aCBwcmVmaXggdG8gdGhlIHdvcmtlci5cclxuICAgICAgICAgICAgLy8gdGhlIHBhdGggcHJlZml4IHdpbGwgYmUgdXNlZCB0byByZXNvbHZlIHRoZSBwYXRoIHRvIGJvdGggdGhlIHdhc20gSlMgYW5kIHRoZSB3YXNtIGZpbGUuXHJcbiAgICAgICAgICAgIGNvbnN0IGluZmVycmVkV2FzbVBhdGhQcmVmaXggPSBpbmZlcldhc21QYXRoUHJlZml4RnJvbVNjcmlwdFNyYygpO1xyXG4gICAgICAgICAgICBpZiAoaW5mZXJyZWRXYXNtUGF0aFByZWZpeCkge1xyXG4gICAgICAgICAgICAgIG1lc3NhZ2UuaW4hLndhc20ud2FzbVBhdGhzID0gaW5mZXJyZWRXYXNtUGF0aFByZWZpeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgQlVJTERfREVGUy5JU19FU00gJiZcclxuICAgICAgICAgICAgQlVJTERfREVGUy5FTkFCTEVfQlVORExFX1dBU01fSlMgJiZcclxuICAgICAgICAgICAgIW1lc3NhZ2UuaW4hLndhc20ud2FzbVBhdGhzICYmXHJcbiAgICAgICAgICAgIChvYmplY3RVcmwgfHwgaXNFc21JbXBvcnRNZXRhVXJsSGFyZGNvZGVkQXNGaWxlVXJpKVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIC8vIGZvciBhIGJ1aWxkIGJ1bmRsZWQgdGhlIHdhc20gSlMsIGlmIGVpdGhlciBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgaXMgbWV0OlxyXG4gICAgICAgICAgICAvLyAtIHRoZSBwcm94eSB3b3JrZXIgaXMgbG9hZGVkIGZyb20gYSBibG9iIFVSTFxyXG4gICAgICAgICAgICAvLyAtIGBpbXBvcnQubWV0YS51cmxgIGlzIGEgZmlsZSBVUkwsIGl0IG1lYW5zIGl0IGlzIG92ZXJ3cml0dGVuIGJ5IHRoZSBidW5kbGVyLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBpbiBlaXRoZXIgY2FzZSwgdGhlIHBhdGggaW5mb3JtYXRpb24gaXMgbG9zdCwgd2UgbmVlZCB0byBwYXNzIHRoZSBwYXRoIG9mIHRoZSAud2FzbSBmaWxlIHRvIHRoZSB3b3JrZXIuXHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIHRoZSBidW5kbGVyIHByZWZlcnJlZCBVUkwgZm9ybWF0OlxyXG4gICAgICAgICAgICAvLyBuZXcgVVJMKCdmaWxlbmFtZScsIGltcG9ydC5tZXRhLnVybClcclxuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgYnVuZGxlciBjYW4gaGFuZGxlIHRoZSBmaWxlIHVzaW5nIGNvcnJlc3BvbmRpbmcgbG9hZGVycy5cclxuICAgICAgICAgICAgbWVzc2FnZS5pbiEud2FzbS53YXNtUGF0aHMgPSB7XHJcbiAgICAgICAgICAgICAgd2FzbTogIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQXHJcbiAgICAgICAgICAgICAgICA/IG5ldyBVUkwoJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtJywgQlVJTERfREVGUy5FU01fSU1QT1JUX01FVEFfVVJMKS5ocmVmXHJcbiAgICAgICAgICAgICAgICA6ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVXHJcbiAgICAgICAgICAgICAgICAgID8gbmV3IFVSTCgnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5hc3luY2lmeS53YXNtJywgQlVJTERfREVGUy5FU01fSU1QT1JUX01FVEFfVVJMKS5ocmVmXHJcbiAgICAgICAgICAgICAgICAgIDogbmV3IFVSTCgnb3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtJywgQlVJTERfREVGUy5FU01fSU1QT1JUX01FVEFfVVJMKS5ocmVmLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcHJveHlXb3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICB0ZW1wb3JhcnlPYmplY3RVcmwgPSBvYmplY3RVcmw7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgcmVqZWN0KTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBpbml0aWFsaXplV2ViQXNzZW1ibHkoZW52Lndhc20pO1xyXG4gICAgICBhd2FpdCBjb3JlLmluaXRSdW50aW1lKGVudik7XHJcbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgYWJvcnRlZCA9IHRydWU7XHJcbiAgICAgIHRocm93IGU7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZU9ydEVwID0gYXN5bmMgKGVwTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcclxuICAgIGVuc3VyZVdvcmtlcigpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnaW5pdC1lcCcsIFtyZXNvbHZlLCByZWplY3RdKTtcclxuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdpbml0LWVwJywgaW46IHsgZXBOYW1lLCBlbnYgfSB9O1xyXG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgYXdhaXQgY29yZS5pbml0RXAoZW52LCBlcE5hbWUpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb3B5RnJvbUV4dGVybmFsQnVmZmVyID0gYXN5bmMgKGJ1ZmZlcjogVWludDhBcnJheSk6IFByb21pc2U8U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXI+ID0+IHtcclxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xyXG4gICAgZW5zdXJlV29ya2VyKCk7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXI+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnY29weS1mcm9tJywgW3Jlc29sdmUsIHJlamVjdF0pO1xyXG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2NvcHktZnJvbScsIGluOiB7IGJ1ZmZlciB9IH07XHJcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCBbYnVmZmVyLmJ1ZmZlcl0pO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBjb3JlLmNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIoYnVmZmVyKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlU2Vzc2lvbiA9IGFzeW5jIChcclxuICBtb2RlbDogU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIgfCBVaW50OEFycmF5LFxyXG4gIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxyXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xyXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XHJcbiAgICAvLyBjaGVjayB1bnN1cHBvcnRlZCBvcHRpb25zXHJcbiAgICBpZiAob3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG9wdGlvbiBcInByZWZlcnJlZE91dHB1dExvY2F0aW9uXCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7XHJcbiAgICB9XHJcbiAgICBlbnN1cmVXb3JrZXIoKTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnY3JlYXRlJywgW3Jlc29sdmUsIHJlamVjdF0pO1xyXG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2NyZWF0ZScsIGluOiB7IG1vZGVsLCBvcHRpb25zOiB7IC4uLm9wdGlvbnMgfSB9IH07XHJcbiAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZTogVHJhbnNmZXJhYmxlW10gPSBbXTtcclxuICAgICAgaWYgKG1vZGVsIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKG1vZGVsLmJ1ZmZlcik7XHJcbiAgICAgIH1cclxuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGNvcmUuY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gYXN5bmMgKHNlc3Npb25JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XHJcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcclxuICAgIGVuc3VyZVdvcmtlcigpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygncmVsZWFzZScsIFtyZXNvbHZlLCByZWplY3RdKTtcclxuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdyZWxlYXNlJywgaW46IHNlc3Npb25JZCB9O1xyXG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29yZS5yZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBydW4gPSBhc3luYyAoXHJcbiAgc2Vzc2lvbklkOiBudW1iZXIsXHJcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSxcclxuICBpbnB1dHM6IFRlbnNvck1ldGFkYXRhW10sXHJcbiAgb3V0cHV0SW5kaWNlczogbnVtYmVyW10sXHJcbiAgb3V0cHV0czogQXJyYXk8VGVuc29yTWV0YWRhdGEgfCBudWxsPixcclxuICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXHJcbik6IFByb21pc2U8VGVuc29yTWV0YWRhdGFbXT4gPT4ge1xyXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XHJcbiAgICAvLyBjaGVjayBpbnB1dHMgbG9jYXRpb25cclxuICAgIGlmIChpbnB1dHMuc29tZSgodCkgPT4gdFszXSAhPT0gJ2NwdScpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIG91dHB1dHMgbG9jYXRpb25cclxuICAgIGlmIChvdXRwdXRzLnNvbWUoKHQpID0+IHQpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xyXG4gICAgfVxyXG4gICAgZW5zdXJlV29ya2VyKCk7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdydW4nLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XHJcbiAgICAgIGNvbnN0IHNlcmlhbGl6YWJsZUlucHV0cyA9IGlucHV0cyBhcyBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdOyAvLyBldmVyeSBpbnB1dCBpcyBvbiBDUFUuXHJcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0ge1xyXG4gICAgICAgIHR5cGU6ICdydW4nLFxyXG4gICAgICAgIGluOiB7IHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHM6IHNlcmlhbGl6YWJsZUlucHV0cywgb3V0cHV0SW5kaWNlcywgb3B0aW9ucyB9LFxyXG4gICAgICB9O1xyXG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgY29yZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyhzZXJpYWxpemFibGVJbnB1dHMpKTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gY29yZS5ydW4oc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IGFzeW5jIChzZXNzaW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XHJcbiAgICBlbnN1cmVXb3JrZXIoKTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2VuZC1wcm9maWxpbmcnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnZW5kLXByb2ZpbGluZycsIGluOiBzZXNzaW9uSWQgfTtcclxuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvcmUuZW5kUHJvZmlsaW5nKHNlc3Npb25JZCk7XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7XHJcbiAgSW5mZXJlbmNlU2Vzc2lvbixcclxuICBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcixcclxuICBTZXNzaW9uSGFuZGxlcixcclxuICBUZW5zb3IsXHJcbiAgVFJBQ0VfRlVOQ19CRUdJTixcclxuICBUUkFDRV9GVU5DX0VORCxcclxufSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsIFRlbnNvck1ldGFkYXRhIH0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XHJcbmltcG9ydCB7IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIsIGNyZWF0ZVNlc3Npb24sIGVuZFByb2ZpbGluZywgcmVsZWFzZVNlc3Npb24sIHJ1biB9IGZyb20gJy4vcHJveHktd3JhcHBlcic7XHJcbmltcG9ydCB7IGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSwgaXNNTFRlbnNvclN1cHBvcnRlZFR5cGUgfSBmcm9tICcuL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XHJcbmltcG9ydCB7IGxvYWRGaWxlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWxvYWQtZmlsZSc7XHJcblxyXG5leHBvcnQgY29uc3QgZW5jb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3IsIGdldE5hbWU6ICgpID0+IHN0cmluZyk6IFRlbnNvck1ldGFkYXRhID0+IHtcclxuICBzd2l0Y2ggKHRlbnNvci5sb2NhdGlvbikge1xyXG4gICAgY2FzZSAnY3B1JzpcclxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHRlbnNvci5kYXRhLCAnY3B1J107XHJcbiAgICBjYXNlICdncHUtYnVmZmVyJzpcclxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHsgZ3B1QnVmZmVyOiB0ZW5zb3IuZ3B1QnVmZmVyIH0sICdncHUtYnVmZmVyJ107XHJcbiAgICBjYXNlICdtbC10ZW5zb3InOlxyXG4gICAgICByZXR1cm4gW3RlbnNvci50eXBlLCB0ZW5zb3IuZGltcywgeyBtbFRlbnNvcjogdGVuc29yLm1sVGVuc29yIH0sICdtbC10ZW5zb3InXTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke3RlbnNvci5sb2NhdGlvbn0gZm9yICR7Z2V0TmFtZSgpfWApO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkZWNvZGVUZW5zb3JNZXRhZGF0YSA9ICh0ZW5zb3I6IFRlbnNvck1ldGFkYXRhKTogVGVuc29yID0+IHtcclxuICBzd2l0Y2ggKHRlbnNvclszXSkge1xyXG4gICAgY2FzZSAnY3B1JzpcclxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGVuc29yWzBdLCB0ZW5zb3JbMl0sIHRlbnNvclsxXSk7XHJcbiAgICBjYXNlICdncHUtYnVmZmVyJzoge1xyXG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcclxuICAgICAgaWYgKCFpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUoZGF0YVR5cGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHsgZ3B1QnVmZmVyLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gdGVuc29yWzJdO1xyXG4gICAgICByZXR1cm4gVGVuc29yLmZyb21HcHVCdWZmZXIoZ3B1QnVmZmVyLCB7IGRhdGFUeXBlLCBkaW1zOiB0ZW5zb3JbMV0sIGRvd25sb2FkLCBkaXNwb3NlIH0pO1xyXG4gICAgfVxyXG4gICAgY2FzZSAnbWwtdGVuc29yJzoge1xyXG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcclxuICAgICAgaWYgKCFpc01MVGVuc29yU3VwcG9ydGVkVHlwZShkYXRhVHlwZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfSBmb3IgZGVzZXJpYWxpemluZyBNTFRlbnNvciB0ZW5zb3JgKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB7IG1sVGVuc29yLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gdGVuc29yWzJdO1xyXG4gICAgICByZXR1cm4gVGVuc29yLmZyb21NTFRlbnNvcihtbFRlbnNvciwgeyBkYXRhVHlwZSwgZGltczogdGVuc29yWzFdLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcclxuICAgIH1cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke3RlbnNvclszXX1gKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIge1xyXG4gIHByaXZhdGUgc2Vzc2lvbklkOiBudW1iZXI7XHJcblxyXG4gIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xyXG4gIG91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcclxuICBpbnB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcclxuICBvdXRwdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XHJcblxyXG4gIGFzeW5jIGZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHBhdGg6IHN0cmluZyk6IFByb21pc2U8U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXI+IHtcclxuICAgIC8vIGZldGNoIG1vZGVsIGZyb20gdXJsIGFuZCBtb3ZlIHRvIHdhc20gaGVhcC5cclxuICAgIHJldHVybiBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGF3YWl0IGxvYWRGaWxlKHBhdGgpKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGxvYWRNb2RlbChwYXRoT3JCdWZmZXI6IHN0cmluZyB8IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XHJcbiAgICBsZXQgbW9kZWw6IFBhcmFtZXRlcnM8dHlwZW9mIGNyZWF0ZVNlc3Npb24+WzBdO1xyXG5cclxuICAgIGlmICh0eXBlb2YgcGF0aE9yQnVmZmVyID09PSAnc3RyaW5nJykge1xyXG4gICAgICBpZiAoaXNOb2RlKSB7XHJcbiAgICAgICAgLy8gbm9kZVxyXG4gICAgICAgIG1vZGVsID0gYXdhaXQgbG9hZEZpbGUocGF0aE9yQnVmZmVyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBicm93c2VyXHJcbiAgICAgICAgLy8gZmV0Y2ggbW9kZWwgYW5kIGNvcHkgdG8gd2FzbSBoZWFwLlxyXG4gICAgICAgIG1vZGVsID0gYXdhaXQgdGhpcy5mZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoT3JCdWZmZXIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtb2RlbCA9IHBhdGhPckJ1ZmZlcjtcclxuICAgIH1cclxuXHJcbiAgICBbdGhpcy5zZXNzaW9uSWQsIHRoaXMuaW5wdXROYW1lcywgdGhpcy5vdXRwdXROYW1lcywgdGhpcy5pbnB1dE1ldGFkYXRhLCB0aGlzLm91dHB1dE1ldGFkYXRhXSA9IGF3YWl0IGNyZWF0ZVNlc3Npb24oXHJcbiAgICAgIG1vZGVsLFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgKTtcclxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIHJlbGVhc2VTZXNzaW9uKHRoaXMuc2Vzc2lvbklkKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJ1bihcclxuICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsXHJcbiAgICBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcclxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcclxuICApOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+IHtcclxuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcclxuICAgIGNvbnN0IGlucHV0QXJyYXk6IFRlbnNvcltdID0gW107XHJcbiAgICBjb25zdCBpbnB1dEluZGljZXM6IG51bWJlcltdID0gW107XHJcbiAgICBPYmplY3QuZW50cmllcyhmZWVkcykuZm9yRWFjaCgoa3ZwKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBrdnBbMF07XHJcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlucHV0TmFtZXMuaW5kZXhPZihuYW1lKTtcclxuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtuYW1lfSdgKTtcclxuICAgICAgfVxyXG4gICAgICBpbnB1dEFycmF5LnB1c2godGVuc29yKTtcclxuICAgICAgaW5wdXRJbmRpY2VzLnB1c2goaW5kZXgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgb3V0cHV0QXJyYXk6IEFycmF5PFRlbnNvciB8IG51bGw+ID0gW107XHJcbiAgICBjb25zdCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgT2JqZWN0LmVudHJpZXMoZmV0Y2hlcykuZm9yRWFjaCgoa3ZwKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBrdnBbMF07XHJcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSk7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke25hbWV9J2ApO1xyXG4gICAgICB9XHJcbiAgICAgIG91dHB1dEFycmF5LnB1c2godGVuc29yKTtcclxuICAgICAgb3V0cHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGlucHV0cyA9IGlucHV0QXJyYXkubWFwKCh0LCBpKSA9PlxyXG4gICAgICBlbmNvZGVUZW5zb3JNZXRhZGF0YSh0LCAoKSA9PiBgaW5wdXQgXCIke3RoaXMuaW5wdXROYW1lc1tpbnB1dEluZGljZXNbaV1dfVwiYCksXHJcbiAgICApO1xyXG4gICAgY29uc3Qgb3V0cHV0cyA9IG91dHB1dEFycmF5Lm1hcCgodCwgaSkgPT5cclxuICAgICAgdCA/IGVuY29kZVRlbnNvck1ldGFkYXRhKHQsICgpID0+IGBvdXRwdXQgXCIke3RoaXMub3V0cHV0TmFtZXNbb3V0cHV0SW5kaWNlc1tpXV19XCJgKSA6IG51bGwsXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBydW4odGhpcy5zZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvdXRwdXRzLCBvcHRpb25zKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHRNYXA6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUgPSB7fTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICByZXN1bHRNYXBbdGhpcy5vdXRwdXROYW1lc1tvdXRwdXRJbmRpY2VzW2ldXV0gPSBvdXRwdXRBcnJheVtpXSA/PyBkZWNvZGVUZW5zb3JNZXRhZGF0YShyZXN1bHRzW2ldKTtcclxuICAgIH1cclxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0TWFwO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XHJcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcHJvZmlsaW5nXHJcbiAgfVxyXG5cclxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XHJcbiAgICB2b2lkIGVuZFByb2ZpbGluZyh0aGlzLnNlc3Npb25JZCk7XHJcbiAgfVxyXG59XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgQmFja2VuZCwgZW52LCBJbmZlcmVuY2VTZXNzaW9uLCBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBpbml0aWFsaXplT3J0RXAsIGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUgfSBmcm9tICcuL3dhc20vcHJveHktd3JhcHBlcic7XHJcbmltcG9ydCB7IE9ubnhydW50aW1lV2ViQXNzZW1ibHlTZXNzaW9uSGFuZGxlciB9IGZyb20gJy4vd2FzbS9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIGFsbCBmbGFncyBmb3IgV2ViQXNzZW1ibHkuXHJcbiAqXHJcbiAqIFRob3NlIGZsYWdzIGFyZSBhY2Nlc3NpYmxlIGZyb20gYG9ydC5lbnYud2FzbWAuIFVzZXJzIGFyZSBhbGxvdyB0byBzZXQgdGhvc2UgZmxhZ3MgYmVmb3JlIHRoZSBmaXJzdCBpbmZlcmVuY2Ugc2Vzc2lvblxyXG4gKiBiZWluZyBjcmVhdGVkLCB0byBvdmVycmlkZSBkZWZhdWx0IHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVGbGFncyA9ICgpOiB2b2lkID0+IHtcclxuICBpZiAodHlwZW9mIGVudi53YXNtLmluaXRUaW1lb3V0ICE9PSAnbnVtYmVyJyB8fCBlbnYud2FzbS5pbml0VGltZW91dCA8IDApIHtcclxuICAgIGVudi53YXNtLmluaXRUaW1lb3V0ID0gMDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNpbWQgPSBlbnYud2FzbS5zaW1kO1xyXG4gIGlmICh0eXBlb2Ygc2ltZCAhPT0gJ2Jvb2xlYW4nICYmIHNpbWQgIT09IHVuZGVmaW5lZCAmJiBzaW1kICE9PSAnZml4ZWQnICYmIHNpbWQgIT09ICdyZWxheGVkJykge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgIGNvbnNvbGUud2FybihcclxuICAgICAgYFByb3BlcnR5IFwiZW52Lndhc20uc2ltZFwiIGlzIHNldCB0byB1bmtub3duIHZhbHVlIFwiJHtzaW1kfVwiLiBSZXNldCBpdCB0byBcXGBmYWxzZVxcYCBhbmQgaWdub3JlIFNJTUQgZmVhdHVyZSBjaGVja2luZy5gLFxyXG4gICAgKTtcclxuICAgIGVudi53YXNtLnNpbWQgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgZW52Lndhc20ucHJveHkgIT09ICdib29sZWFuJykge1xyXG4gICAgZW52Lndhc20ucHJveHkgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgZW52Lndhc20udHJhY2UgIT09ICdib29sZWFuJykge1xyXG4gICAgZW52Lndhc20udHJhY2UgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgZW52Lndhc20ubnVtVGhyZWFkcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIoZW52Lndhc20ubnVtVGhyZWFkcykgfHwgZW52Lndhc20ubnVtVGhyZWFkcyA8PSAwKSB7XHJcbiAgICAvLyBUaGUgZm9sbG93aW5nIGxvZ2ljIG9ubHkgYXBwbGllcyB3aGVuIGBvcnQuZW52Lndhc20ubnVtVGhyZWFkc2AgaXMgbm90IHNldCBieSB1c2VyLiBXZSB3aWxsIGFsd2F5cyBob25vciB1c2VyJ3NcclxuICAgIC8vIHNldHRpbmcgaWYgaXQgaXMgcHJvdmlkZWQuXHJcblxyXG4gICAgLy8gQnJvd3Nlcjogd2hlbiBjcm9zc09yaWdpbklzb2xhdGVkIGlzIGZhbHNlLCBTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYXZhaWxhYmxlIHNvIFdlYkFzc2VtYmx5IHRocmVhZHMgd2lsbCBub3RcclxuICAgIC8vIHdvcmsuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBzZXQgbnVtVGhyZWFkcyB0byAxLlxyXG4gICAgLy9cclxuICAgIC8vIFRoZXJlIGlzIGFuIGV4Y2VwdGlvbjogd2hlbiB0aGUgYnJvd3NlciBpcyBjb25maWd1cmVkIHRvIGZvcmNlLWVuYWJsZSBTaGFyZWRBcnJheUJ1ZmZlciAoZS5nLiBDaHJvbXVpbSB3aXRoXHJcbiAgICAvLyAtLWVuYWJsZS1mZWF0dXJlcz1TaGFyZWRBcnJheUJ1ZmZlciksIGl0IGlzIHBvc3NpYmxlIHRoYXQgYHNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZGAgaXMgZmFsc2UgYW5kXHJcbiAgICAvLyBTaGFyZWRBcnJheUJ1ZmZlciBpcyBhdmFpbGFibGUgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyB1c3VhbGx5IGZvciB0ZXN0aW5nLiBJbiB0aGlzIGNhc2UsICB3ZSB3aWxsIHN0aWxsIHNldFxyXG4gICAgLy8gbnVtVGhyZWFkcyB0byAxIGhlcmUuIElmIHdlIHdhbnQgdG8gZW5hYmxlIG11bHRpLXRocmVhZGluZyBpbiB0ZXN0LCB3ZSBzaG91bGQgc2V0IGBvcnQuZW52Lndhc20ubnVtVGhyZWFkc2AgdG8gYVxyXG4gICAgLy8gdmFsdWUgZ3JlYXRlciB0aGFuIDEuXHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpIHtcclxuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBudW1DcHVMb2dpY2FsQ29yZXMgPVxyXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gcmVxdWlyZSgnbm9kZTpvcycpLmNwdXMoKS5sZW5ndGggOiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtcclxuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IE1hdGgubWluKDQsIE1hdGguY2VpbCgobnVtQ3B1TG9naWNhbENvcmVzIHx8IDEpIC8gMikpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgdGhlIFdlYkFzc2VtYmx5IGJhY2tlbmQuXHJcbiAgICpcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBmb3IgZWFjaCBiYWNrZW5kIG5hbWUuIEl0IHdpbGwgYmUgY2FsbGVkIHRoZSBmaXJzdCB0aW1lIHdoZW5cclxuICAgKiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIGlzIGNhbGxlZCB3aXRoIGEgcmVnaXN0ZXJlZCBiYWNrZW5kIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYmFja2VuZE5hbWUgLSB0aGUgcmVnaXN0ZXJlZCBiYWNrZW5kIG5hbWUuXHJcbiAgICovXHJcbiAgYXN5bmMgaW5pdChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBwb3B1bGF0ZSB3YXNtIGZsYWdzXHJcbiAgICBpbml0aWFsaXplRmxhZ3MoKTtcclxuXHJcbiAgICAvLyBpbml0IHdhc21cclxuICAgIGF3YWl0IGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUoKTtcclxuXHJcbiAgICAvLyBwZXJmb3JtZSBFUCBzcGVjaWZpYyBpbml0aWFsaXphdGlvblxyXG4gICAgYXdhaXQgaW5pdGlhbGl6ZU9ydEVwKGJhY2tlbmROYW1lKTtcclxuICB9XHJcbiAgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoXHJcbiAgICBwYXRoOiBzdHJpbmcsXHJcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcclxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcclxuICBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihcclxuICAgIGJ1ZmZlcjogVWludDhBcnJheSxcclxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxyXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+O1xyXG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxyXG4gICAgcGF0aE9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxyXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj4ge1xyXG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIoKTtcclxuICAgIGF3YWl0IGhhbmRsZXIubG9hZE1vZGVsKHBhdGhPckJ1ZmZlciwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gaGFuZGxlcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB3YXNtQmFja2VuZCA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCgpO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cclxuXHJcbi8vIFdlIHVzZSBcInJlcXVpcmVcIiBpbnN0ZWFkIG9mIFwiaW1wb3J0XCIgaGVyZSBiZWNhdXNlIGltcG9ydCBzdGF0ZW1lbnQgbXVzdCBiZSBwdXQgaW4gdG9wIGxldmVsLiBPdXIgY3VycmVudCBjb2RlIGRvZXNcclxuLy8gbm90IGFsbG93IGJ1bmRsZXIgdG8gdHJlZS1zaGFraW5nIGNvZGUgYXMgZXhwZWN0ZWQgYmVjYXVzZSBzb21lIGNvZGVzIGFyZSB0cmVhdGVkIGFzIGhhdmluZyBzaWRlIGVmZmVjdHMuXHJcbi8vIFNvIHdlIGltcG9ydCBjb2RlIGluc2lkZSB0aGUgaWYtY2xhdXNlIHRvIGFsbG93IGJ1bmRsZXIgcmVtb3ZlIHRoZSBjb2RlIHNhZmVseS5cclxuXHJcbmV4cG9ydCAqIGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcbmltcG9ydCAqIGFzIG9ydCBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5leHBvcnQgZGVmYXVsdCBvcnQ7XHJcblxyXG5pbXBvcnQgeyByZWdpc3RlckJhY2tlbmQsIGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xyXG5cclxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR0wpIHtcclxuICBjb25zdCBvbm54anNCYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLW9ubnhqcycpLm9ubnhqc0JhY2tlbmQ7XHJcbiAgcmVnaXN0ZXJCYWNrZW5kKCd3ZWJnbCcsIG9ubnhqc0JhY2tlbmQsIC0xMCk7XHJcbn1cclxuXHJcbmlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAnVGhlIGN1cnJlbnQgYnVpbGQgaXMgc3BlY2lmaWVkIHRvIGVuYWJsZSBib3RoIEpTRVAgYW5kIFdlYkdQVSBFUC4gVGhpcyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uLiAnICtcclxuICAgICAgJ0pTRVAgYW5kIFdlYkdQVSBFUHMgY2Fubm90IGJlIGVuYWJsZWQgYXQgdGhlIHNhbWUgdGltZS4nLFxyXG4gICk7XHJcbn1cclxuXHJcbmlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQk5OICYmIEJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIEJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAnVGhlIGN1cnJlbnQgYnVpbGQgaXMgc3BlY2lmaWVkIHRvIGVuYWJsZSBXZWJOTiBFUCB3aXRob3V0IEpTRVAgb3IgV2ViR1BVIEVQLiBUaGlzIGlzIG5vdCBhIHZhbGlkIGNvbmZpZ3VyYXRpb24uICcgK1xyXG4gICAgICAnV2ViTk4gRVAgcmVxdWlyZXMgZWl0aGVyIEpTRVAgb3IgV2ViR1BVIEVQIHRvIGJlIGVuYWJsZWQuJyxcclxuICApO1xyXG59XHJcblxyXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNKSB7XHJcbiAgY29uc3Qgd2FzbUJhY2tlbmQgPSByZXF1aXJlKCcuL2JhY2tlbmQtd2FzbScpLndhc21CYWNrZW5kO1xyXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcclxuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ3B1Jywgd2FzbUJhY2tlbmQsIDUpO1xyXG4gIH1cclxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJOTikge1xyXG4gICAgcmVnaXN0ZXJCYWNrZW5kKCd3ZWJubicsIHdhc21CYWNrZW5kLCA1KTtcclxuICB9XHJcbiAgcmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCB3YXNtQmFja2VuZCwgMTApO1xyXG4gIHJlZ2lzdGVyQmFja2VuZCgnd2FzbScsIHdhc21CYWNrZW5kLCAxMCk7XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbnYudmVyc2lvbnMsICd3ZWInLCB7IHZhbHVlOiB2ZXJzaW9uLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgL2pzL3NjcmlwdHMvdXBkYXRlLXZlcnNpb24udHNcclxuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXHJcblxyXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcxLjIzLjAnO1xyXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BZ0JNLFVBQ0EsMEJBWU8saUJBd0NQLGdDQXdDTztBQTdHYjs7O0FBZ0JBLE1B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cUM7QUFDekQsZ0JBQU0sUUFBUSxVQUFVLGNBQWMsT0FBTztBQUM3QyxpQkFBTztBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBRU8sTUFBTSxjQUFjLElBQUksOEJBQThCO0FBQUE7QUFBQTs7O0FDL0Y3RDtBQUFBO0FBQUEsNEJBQUFDO0FBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBQUFDO0FBQUEsSUFBQTtBQUFBLGVBQUFDO0FBQUEsSUFBQTtBQUFBO0FBU0E7QUFDQTtBQUdBOzs7QUNQTyxNQUFNQyxXQUFVOzs7QURLdkIsTUFBTyxnQkFBUTtBQUtmLE1BQUksT0FBMkI7QUFDN0IsVUFBTSxnQkFBZ0IsS0FBNEI7QUFDbEQsb0JBQWdCLFNBQVMsZUFBZSxHQUFHO0FBQUEsRUFDN0M7QUFFQSxNQUFnQyxPQUE0QjtBQUMxRCxVQUFNLElBQUk7QUFBQSxNQUNSO0FBQUEsSUFFRjtBQUFBLEVBQ0Y7QUFFQSxNQUFpQyxPQUFzRDtBQUNyRixVQUFNLElBQUk7QUFBQSxNQUNSO0FBQUEsSUFFRjtBQUFBLEVBQ0Y7QUFFQSxNQUFJLE1BQTBCO0FBQzVCLFVBQU1DLGVBQWMsMERBQTBCO0FBQzlDLFFBQUksTUFBd0Q7QUFDMUQsc0JBQWdCLFVBQVVBLGNBQWEsQ0FBQztBQUFBLElBQzFDO0FBQ0EsUUFBSSxNQUEyQjtBQUM3QixzQkFBZ0IsU0FBU0EsY0FBYSxDQUFDO0FBQUEsSUFDekM7QUFDQSxvQkFBZ0IsT0FBT0EsY0FBYSxFQUFFO0FBQ3RDLG9CQUFnQixRQUFRQSxjQUFhLEVBQUU7QUFBQSxFQUN6QztBQUVBLFNBQU8sZUFBZUMsS0FBSSxVQUFVLE9BQU8sRUFBRSxPQUFPQyxVQUFTLFlBQVksS0FBSyxDQUFDOyIsCiAgIm5hbWVzIjogWyJpIiwgImVudiIsICJGbG9hdDE2QXJyYXkiLCAiVGVuc29yIiwgIlRlbnNvciIsICJJbmZlcmVuY2VTZXNzaW9uIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgImVudiIsICJlbnYiLCAid2FzbSIsICJ3YXNtIiwgIndhc20iLCAibG9jYXRpb24iLCAicGFkIiwgInRlbnNvciIsICJlbnYiLCAibWxDb250ZXh0SW5kZXgiLCAid2FzbSIsICJpbml0IiwgIm9mZnNldHMiLCAiaW5kaWNlcyIsICJpbXBsIiwgInZhbGlkYXRlSW5wdXRzIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiYSIsICJiIiwgInZhbGlkYXRlSW5wdXRzIiwgImkiLCAiaW5wdXRWYXJpYWJsZSIsICJ0cmFuc3Bvc2UiLCAib3V0cHV0VmFyaWFibGUiLCAiaW5uZXJFbGVtZW50U2l6ZSIsICJwYWQiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29udklucHV0cyIsICJ0cmFuc3Bvc2VkV2VpZ2h0IiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInBlcm1GdW5jdGlvbkJvZHkiLCAic3ltYm9sIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJjYWxjdWxhdGVPdXRwdXRTaGFwZSIsICJmYXN0R2VsdSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJpbnB1dHMiLCAib3V0cHV0U2l6ZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAid2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImRhdGFUeXBlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImVudiIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29tcG9uZW50cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJnZXRPdXRwdXRTaGFwZSIsICJhIiwgImIiLCAiYyIsICJmYXN0R2VsdSIsICJlbnYiLCAiaSIsICJlbnYiLCAiZW52IiwgIndhc20iLCAibG9jYXRpb24iLCAiaW5kZXgiLCAidGVuc29yIiwgImVycm9yQ29kZSIsICJpIiwgImluaXRpYWxpemluZyIsICJpbml0aWFsaXplZCIsICJhYm9ydGVkIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJUZW5zb3IiLCAiY29weUZyb21FeHRlcm5hbEJ1ZmZlciIsICJjcmVhdGVTZXNzaW9uIiwgInJlbGVhc2VTZXNzaW9uIiwgInJ1biIsICJlbmRQcm9maWxpbmciLCAiZW52IiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgImVudiIsICJ2ZXJzaW9uIiwgIndhc21CYWNrZW5kIiwgImVudiIsICJ2ZXJzaW9uIl0KfQo=
