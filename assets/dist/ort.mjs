/*!
 * ONNX Runtime Web v1.23.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// common/dist/esm/backend-impl.js
var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
var init_backend_impl = __esm({
  "common/dist/esm/backend-impl.js"() {
    "use strict";
    backends = /* @__PURE__ */ new Map();
    backendsSortedByPriority = [];
    registerBackend = (name, backend, priority) => {
      if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
        const currentBackend = backends.get(name);
        if (currentBackend === void 0) {
          backends.set(name, { backend, priority });
        } else if (currentBackend.priority > priority) {
          return;
        } else if (currentBackend.priority === priority) {
          if (currentBackend.backend !== backend) {
            throw new Error(`cannot register backend "${name}" using priority ${priority}`);
          }
        }
        if (priority >= 0) {
          const i = backendsSortedByPriority.indexOf(name);
          if (i !== -1) {
            backendsSortedByPriority.splice(i, 1);
          }
          for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
            if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
              backendsSortedByPriority.splice(i2, 0, name);
              return;
            }
          }
          backendsSortedByPriority.push(name);
        }
        return;
      }
      throw new TypeError("not a valid backend");
    };
    tryResolveAndInitializeBackend = async (backendName) => {
      const backendInfo = backends.get(backendName);
      if (!backendInfo) {
        return "backend not found.";
      }
      if (backendInfo.initialized) {
        return backendInfo.backend;
      } else if (backendInfo.aborted) {
        return backendInfo.error;
      } else {
        const isInitializing = !!backendInfo.initPromise;
        try {
          if (!isInitializing) {
            backendInfo.initPromise = backendInfo.backend.init(backendName);
          }
          await backendInfo.initPromise;
          backendInfo.initialized = true;
          return backendInfo.backend;
        } catch (e) {
          if (!isInitializing) {
            backendInfo.error = `${e}`;
            backendInfo.aborted = true;
          }
          return backendInfo.error;
        } finally {
          delete backendInfo.initPromise;
        }
      }
    };
    resolveBackendAndExecutionProviders = async (options) => {
      const eps = options.executionProviders || [];
      const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
      const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
      let backend;
      const errors = [];
      const availableBackendNames = /* @__PURE__ */ new Set();
      for (const backendName of backendNames) {
        const resolveResult = await tryResolveAndInitializeBackend(backendName);
        if (typeof resolveResult === "string") {
          errors.push({ name: backendName, err: resolveResult });
        } else {
          if (!backend) {
            backend = resolveResult;
          }
          if (backend === resolveResult) {
            availableBackendNames.add(backendName);
          }
        }
      }
      if (!backend) {
        throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
      }
      for (const { name, err } of errors) {
        if (backendHints.includes(name)) {
          console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
        }
      }
      const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
      return [
        backend,
        new Proxy(options, {
          get: (target, prop) => {
            if (prop === "executionProviders") {
              return filteredEps;
            }
            return Reflect.get(target, prop);
          }
        })
      ];
    };
  }
});

// common/dist/esm/backend.js
var init_backend = __esm({
  "common/dist/esm/backend.js"() {
    "use strict";
    init_backend_impl();
  }
});

// common/dist/esm/version.js
var version;
var init_version = __esm({
  "common/dist/esm/version.js"() {
    "use strict";
    version = "1.23.0";
  }
});

// common/dist/esm/env-impl.js
var logLevelValue, env;
var init_env_impl = __esm({
  "common/dist/esm/env-impl.js"() {
    "use strict";
    init_version();
    logLevelValue = "warning";
    env = {
      wasm: {},
      webgl: {},
      webgpu: {},
      versions: { common: version },
      set logLevel(value) {
        if (value === void 0) {
          return;
        }
        if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
          throw new Error(`Unsupported logging level: ${value}`);
        }
        logLevelValue = value;
      },
      get logLevel() {
        return logLevelValue;
      }
    };
    Object.defineProperty(env, "logLevel", { enumerable: true });
  }
});

// common/dist/esm/env.js
var env2;
var init_env = __esm({
  "common/dist/esm/env.js"() {
    "use strict";
    init_env_impl();
    env2 = env;
  }
});

// common/dist/esm/tensor-conversion-impl.js
var tensorToDataURL, tensorToImageData;
var init_tensor_conversion_impl = __esm({
  "common/dist/esm/tensor-conversion-impl.js"() {
    "use strict";
    tensorToDataURL = (tensor, options) => {
      const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
      canvas.width = tensor.dims[3];
      canvas.height = tensor.dims[2];
      const pixels2DContext = canvas.getContext("2d");
      if (pixels2DContext != null) {
        let width;
        let height;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
        }
        const inputformat = options?.format !== void 0 ? options.format : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
            pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
            pixels2DContext.fillRect(j, i, 1, 1);
          }
        }
        if ("toDataURL" in canvas) {
          return canvas.toDataURL();
        } else {
          throw new Error("toDataURL is not supported");
        }
      } else {
        throw new Error("Can not access image data");
      }
    };
    tensorToImageData = (tensor, options) => {
      const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
      let image;
      if (pixels2DContext != null) {
        let width;
        let height;
        let channels;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[1];
          channels = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
          channels = tensor.dims[1];
        }
        const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        if (options !== void 0) {
          if (options.format !== void 0 && channels === 4 && options.format !== "RGBA" || channels === 3 && options.format !== "RGB" && options.format !== "BGR") {
            throw new Error("Tensor format doesn't match input tensor dims");
          }
        }
        const step = 4;
        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        image = pixels2DContext.createImageData(width, height);
        for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
          image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
          image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
          image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
          image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
        }
      } else {
        throw new Error("Can not access image data");
      }
      return image;
    };
  }
});

// common/dist/esm/tensor-factory-impl.js
var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromMLTensor, tensorFromPinnedBuffer;
var init_tensor_factory_impl = __esm({
  "common/dist/esm/tensor-factory-impl.js"() {
    "use strict";
    init_tensor_impl();
    bufferToTensor = (buffer, options) => {
      if (buffer === void 0) {
        throw new Error("Image buffer must be defined");
      }
      if (options.height === void 0 || options.width === void 0) {
        throw new Error("Image height and width must be defined");
      }
      if (options.tensorLayout === "NHWC") {
        throw new Error("NHWC Tensor layout is not supported yet");
      }
      const { height, width } = options;
      const norm = options.norm ?? { mean: 255, bias: 0 };
      let normMean;
      let normBias;
      if (typeof norm.mean === "number") {
        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
      } else {
        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
      }
      if (typeof norm.bias === "number") {
        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
      } else {
        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
      }
      const inputformat = options.format !== void 0 ? options.format : "RGBA";
      const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
      const stride = height * width;
      const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
      let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
      if (inputformat === "RGB") {
        step = 3;
        rImagePointer = 0;
        gImagePointer = 1;
        bImagePointer = 2;
        aImagePointer = -1;
      }
      if (outputformat === "RGBA") {
        aTensorPointer = stride * 3;
      } else if (outputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
      } else if (outputformat === "BGR") {
        bTensorPointer = 0;
        gTensorPointer = stride;
        rTensorPointer = stride * 2;
      }
      for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
        if (aTensorPointer !== -1 && aImagePointer !== -1) {
          float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
        }
      }
      const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
      return outputTensor;
    };
    tensorFromImage = async (image, options) => {
      const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
      const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
      const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
      const isString = typeof image === "string";
      let data;
      let bufferToTensorOptions = options ?? {};
      const createCanvas = () => {
        if (typeof document !== "undefined") {
          return document.createElement("canvas");
        } else if (typeof OffscreenCanvas !== "undefined") {
          return new OffscreenCanvas(1, 1);
        } else {
          throw new Error("Canvas is not supported");
        }
      };
      const createCanvasContext = (canvas) => {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          return canvas.getContext("2d");
        } else if (canvas instanceof OffscreenCanvas) {
          return canvas.getContext("2d");
        } else {
          return null;
        }
      };
      if (isHTMLImageEle) {
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          let height = image.height;
          let width = image.width;
          if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
            if (options.tensorFormat !== void 0) {
              throw new Error("Image input config format must be RGBA for HTMLImageElement");
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
            }
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          } else {
            bufferToTensorOptions.tensorFormat = "RGBA";
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          }
          pixels2DContext.drawImage(image, 0, 0);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isImageDataEle) {
        let height;
        let width;
        if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
          height = options.resizedHeight;
          width = options.resizedWidth;
        } else {
          height = image.height;
          width = image.width;
        }
        if (options !== void 0) {
          bufferToTensorOptions = options;
        }
        bufferToTensorOptions.format = "RGBA";
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
        if (options !== void 0) {
          const tempCanvas = createCanvas();
          tempCanvas.width = width;
          tempCanvas.height = height;
          const pixels2DContext = createCanvasContext(tempCanvas);
          if (pixels2DContext != null) {
            pixels2DContext.putImageData(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else {
          data = image.data;
        }
      } else if (isImageBitmap) {
        if (options === void 0) {
          throw new Error("Please provide image config with format for Imagebitmap");
        }
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          const height = image.height;
          const width = image.width;
          pixels2DContext.drawImage(image, 0, 0, width, height);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isString) {
        return new Promise((resolve, reject) => {
          const canvas = createCanvas();
          const context = createCanvasContext(canvas);
          if (!image || !context) {
            return reject();
          }
          const newImage = new Image();
          newImage.crossOrigin = "Anonymous";
          newImage.src = image;
          newImage.onload = () => {
            canvas.width = newImage.width;
            canvas.height = newImage.height;
            context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
            const img = context.getImageData(0, 0, canvas.width, canvas.height);
            bufferToTensorOptions.height = canvas.height;
            bufferToTensorOptions.width = canvas.width;
            resolve(bufferToTensor(img.data, bufferToTensorOptions));
          };
        });
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
      if (data !== void 0) {
        return bufferToTensor(data, bufferToTensorOptions);
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
    };
    tensorFromTexture = (texture, options) => {
      const { width, height, download, dispose } = options;
      const dims = [1, height, width, 4];
      return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
    };
    tensorFromGpuBuffer = (gpuBuffer, options) => {
      const { dataType, dims, download, dispose } = options;
      return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
    };
    tensorFromMLTensor = (mlTensor, options) => {
      const { dataType, dims, download, dispose } = options;
      return new Tensor({ location: "ml-tensor", type: dataType ?? "float32", mlTensor, dims, download, dispose });
    };
    tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
  }
});

// common/dist/esm/tensor-impl-type-mapping.js
var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
var init_tensor_impl_type_mapping = __esm({
  "common/dist/esm/tensor-impl-type-mapping.js"() {
    "use strict";
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
      ["float32", Float32Array],
      ["uint8", Uint8Array],
      ["int8", Int8Array],
      ["uint16", Uint16Array],
      ["int16", Int16Array],
      ["int32", Int32Array],
      ["bool", Uint8Array],
      ["float64", Float64Array],
      ["uint32", Uint32Array],
      ["int4", Uint8Array],
      ["uint4", Uint8Array]
    ]);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
      [Float32Array, "float32"],
      [Uint8Array, "uint8"],
      [Int8Array, "int8"],
      [Uint16Array, "uint16"],
      [Int16Array, "int16"],
      [Int32Array, "int32"],
      [Float64Array, "float64"],
      [Uint32Array, "uint32"]
    ]);
    isTypedArrayChecked = false;
    checkTypedArray = () => {
      if (!isTypedArrayChecked) {
        isTypedArrayChecked = true;
        const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
        const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
        const Float16Array2 = globalThis.Float16Array;
        const isFloat16ArrayAvailable = typeof Float16Array2 !== "undefined" && Float16Array2.from;
        if (isBigInt64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
        }
        if (isBigUint64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
        }
        if (isFloat16ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array2);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array2, "float16");
        } else {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
        }
      }
    };
  }
});

// common/dist/esm/tensor-utils-impl.js
var calculateSize, tensorReshape;
var init_tensor_utils_impl = __esm({
  "common/dist/esm/tensor-utils-impl.js"() {
    "use strict";
    init_tensor_impl();
    calculateSize = (dims) => {
      let size = 1;
      for (let i = 0; i < dims.length; i++) {
        const dim = dims[i];
        if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
          throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
          throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
      }
      return size;
    };
    tensorReshape = (tensor, dims) => {
      switch (tensor.location) {
        case "cpu":
          return new Tensor(tensor.type, tensor.data, dims);
        case "cpu-pinned":
          return new Tensor({
            location: "cpu-pinned",
            data: tensor.data,
            type: tensor.type,
            dims
          });
        case "texture":
          return new Tensor({
            location: "texture",
            texture: tensor.texture,
            type: tensor.type,
            dims
          });
        case "gpu-buffer":
          return new Tensor({
            location: "gpu-buffer",
            gpuBuffer: tensor.gpuBuffer,
            type: tensor.type,
            dims
          });
        case "ml-tensor":
          return new Tensor({
            location: "ml-tensor",
            mlTensor: tensor.mlTensor,
            type: tensor.type,
            dims
          });
        default:
          throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
      }
    };
  }
});

// common/dist/esm/tensor-impl.js
var Tensor;
var init_tensor_impl = __esm({
  "common/dist/esm/tensor-impl.js"() {
    "use strict";
    init_tensor_conversion_impl();
    init_tensor_factory_impl();
    init_tensor_impl_type_mapping();
    init_tensor_utils_impl();
    Tensor = class {
      /**
       * implementation.
       */
      constructor(arg0, arg1, arg2) {
        checkTypedArray();
        let type;
        let dims;
        if (typeof arg0 === "object" && "location" in arg0) {
          this.dataLocation = arg0.location;
          type = arg0.type;
          dims = arg0.dims;
          switch (arg0.location) {
            case "cpu-pinned": {
              const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
              if (!expectedTypedArrayConstructor) {
                throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
              }
              if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
              }
              this.cpuData = arg0.data;
              break;
            }
            case "texture": {
              if (type !== "float32") {
                throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
              }
              this.gpuTextureData = arg0.texture;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            case "gpu-buffer": {
              if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
              }
              this.gpuBufferData = arg0.gpuBuffer;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            case "ml-tensor": {
              if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint64" && type !== "int8" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                throw new TypeError(`unsupported type "${type}" to create tensor from MLTensor`);
              }
              this.mlTensorData = arg0.mlTensor;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            default:
              throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
          }
        } else {
          let data;
          let maybeDims;
          if (typeof arg0 === "string") {
            type = arg0;
            maybeDims = arg2;
            if (arg0 === "string") {
              if (!Array.isArray(arg1)) {
                throw new TypeError("A string tensor's data must be a string array.");
              }
              data = arg1;
            } else {
              const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
              if (typedArrayConstructor === void 0) {
                throw new TypeError(`Unsupported tensor type: ${arg0}.`);
              }
              if (Array.isArray(arg1)) {
                if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
                  throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
                } else if (arg0 === "uint64" || arg0 === "int64") {
                  data = typedArrayConstructor.from(arg1, BigInt);
                } else {
                  data = typedArrayConstructor.from(arg1);
                }
              } else if (arg1 instanceof typedArrayConstructor) {
                data = arg1;
              } else if (arg1 instanceof Uint8ClampedArray) {
                if (arg0 === "uint8") {
                  data = Uint8Array.from(arg1);
                } else {
                  throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
                }
              } else if (arg0 === "float16" && arg1 instanceof Uint16Array && typedArrayConstructor !== Uint16Array) {
                data = new globalThis.Float16Array(arg1.buffer, arg1.byteOffset, arg1.length);
              } else {
                throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
              }
            }
          } else {
            maybeDims = arg1;
            if (Array.isArray(arg0)) {
              if (arg0.length === 0) {
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              }
              const firstElementType = typeof arg0[0];
              if (firstElementType === "string") {
                type = "string";
                data = arg0;
              } else if (firstElementType === "boolean") {
                type = "bool";
                data = Uint8Array.from(arg0);
              } else {
                throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
              }
            } else if (arg0 instanceof Uint8ClampedArray) {
              type = "uint8";
              data = Uint8Array.from(arg0);
            } else {
              const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
              if (mappedType === void 0) {
                throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
              }
              type = mappedType;
              data = arg0;
            }
          }
          if (maybeDims === void 0) {
            maybeDims = [data.length];
          } else if (!Array.isArray(maybeDims)) {
            throw new TypeError("A tensor's dims must be a number array");
          }
          dims = maybeDims;
          this.cpuData = data;
          this.dataLocation = "cpu";
        }
        const size = calculateSize(dims);
        if (this.cpuData && size !== this.cpuData.length) {
          if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {
          } else {
            throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
          }
        }
        this.type = type;
        this.dims = dims;
        this.size = size;
      }
      // #endregion
      // #region factory
      static async fromImage(image, options) {
        return tensorFromImage(image, options);
      }
      static fromTexture(texture, options) {
        return tensorFromTexture(texture, options);
      }
      static fromGpuBuffer(gpuBuffer, options) {
        return tensorFromGpuBuffer(gpuBuffer, options);
      }
      static fromMLTensor(mlTensor, options) {
        return tensorFromMLTensor(mlTensor, options);
      }
      static fromPinnedBuffer(type, buffer, dims) {
        return tensorFromPinnedBuffer(type, buffer, dims);
      }
      // #endregion
      // #region conversions
      toDataURL(options) {
        return tensorToDataURL(this, options);
      }
      toImageData(options) {
        return tensorToImageData(this, options);
      }
      // #endregion
      // #region properties
      get data() {
        this.ensureValid();
        if (!this.cpuData) {
          throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
        }
        return this.cpuData;
      }
      get location() {
        return this.dataLocation;
      }
      get texture() {
        this.ensureValid();
        if (!this.gpuTextureData) {
          throw new Error("The data is not stored as a WebGL texture.");
        }
        return this.gpuTextureData;
      }
      get gpuBuffer() {
        this.ensureValid();
        if (!this.gpuBufferData) {
          throw new Error("The data is not stored as a WebGPU buffer.");
        }
        return this.gpuBufferData;
      }
      get mlTensor() {
        this.ensureValid();
        if (!this.mlTensorData) {
          throw new Error("The data is not stored as a WebNN MLTensor.");
        }
        return this.mlTensorData;
      }
      // #endregion
      // #region methods
      async getData(releaseData) {
        this.ensureValid();
        switch (this.dataLocation) {
          case "cpu":
          case "cpu-pinned":
            return this.data;
          case "texture":
          case "gpu-buffer":
          case "ml-tensor": {
            if (!this.downloader) {
              throw new Error("The current tensor is not created with a specified data downloader.");
            }
            if (this.isDownloading) {
              throw new Error("The current tensor is being downloaded.");
            }
            try {
              this.isDownloading = true;
              const data = await this.downloader();
              this.downloader = void 0;
              this.dataLocation = "cpu";
              this.cpuData = data;
              if (releaseData && this.disposer) {
                this.disposer();
                this.disposer = void 0;
              }
              return data;
            } finally {
              this.isDownloading = false;
            }
          }
          default:
            throw new Error(`cannot get data from location: ${this.dataLocation}`);
        }
      }
      dispose() {
        if (this.isDownloading) {
          throw new Error("The current tensor is being downloaded.");
        }
        if (this.disposer) {
          this.disposer();
          this.disposer = void 0;
        }
        this.cpuData = void 0;
        this.gpuTextureData = void 0;
        this.gpuBufferData = void 0;
        this.mlTensorData = void 0;
        this.downloader = void 0;
        this.isDownloading = void 0;
        this.dataLocation = "none";
      }
      // #endregion
      // #region tensor utilities
      ensureValid() {
        if (this.dataLocation === "none") {
          throw new Error("The tensor is disposed.");
        }
      }
      reshape(dims) {
        this.ensureValid();
        if (this.downloader || this.disposer) {
          throw new Error("Cannot reshape a tensor that owns GPU resource.");
        }
        return tensorReshape(this, dims);
      }
    };
  }
});

// common/dist/esm/tensor.js
var Tensor2;
var init_tensor = __esm({
  "common/dist/esm/tensor.js"() {
    "use strict";
    init_tensor_impl();
    Tensor2 = Tensor;
  }
});

// common/dist/esm/trace.js
var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END, TRACE_EVENT_BEGIN, TRACE_EVENT_END;
var init_trace = __esm({
  "common/dist/esm/trace.js"() {
    "use strict";
    init_env_impl();
    TRACE = (deviceType, label) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.timeStamp(`${deviceType}::ORT::${label}`);
    };
    TRACE_FUNC = (msg, extraMsg) => {
      const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
      let hasTraceFunc = false;
      for (let i = 0; i < stack.length; i++) {
        if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
          let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
          if (extraMsg) {
            label += `::${extraMsg}`;
          }
          TRACE("CPU", label);
          return;
        }
        if (stack[i].includes("TRACE_FUNC")) {
          hasTraceFunc = true;
        }
      }
    };
    TRACE_FUNC_BEGIN = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("BEGIN", extraMsg);
    };
    TRACE_FUNC_END = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("END", extraMsg);
    };
    TRACE_EVENT_BEGIN = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.time(`ORT::${extraMsg}`);
    };
    TRACE_EVENT_END = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.timeEnd(`ORT::${extraMsg}`);
    };
  }
});

// common/dist/esm/inference-session-impl.js
var InferenceSession;
var init_inference_session_impl = __esm({
  "common/dist/esm/inference-session-impl.js"() {
    "use strict";
    init_backend_impl();
    init_tensor();
    init_trace();
    InferenceSession = class _InferenceSession {
      constructor(handler) {
        this.handler = handler;
      }
      async run(feeds, arg1, arg2) {
        TRACE_FUNC_BEGIN();
        TRACE_EVENT_BEGIN("InferenceSession.run");
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name of arg1) {
              if (typeof name !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (this.outputNames.indexOf(name) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
              }
              fetches[name] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name of this.outputNames) {
              if (arg1Keys.indexOf(name) !== -1) {
                const v = arg1[name];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name of this.inputNames) {
          if (typeof feeds[name] === "undefined") {
            throw new Error(`input '${name}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name of this.outputNames) {
            fetches[name] = null;
          }
        }
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        TRACE_EVENT_END("InferenceSession.run");
        TRACE_FUNC_END();
        return returnValue;
      }
      async release() {
        return this.handler.dispose();
      }
      static async create(arg0, arg1, arg2, arg3) {
        TRACE_FUNC_BEGIN();
        TRACE_EVENT_BEGIN("InferenceSession.create");
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === "string") {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof Uint8Array) {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
          const buffer = arg0;
          let byteOffset = 0;
          let byteLength = arg0.byteLength;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 === "number") {
            byteOffset = arg1;
            if (!Number.isSafeInteger(byteOffset)) {
              throw new RangeError("'byteOffset' must be an integer.");
            }
            if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
              throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
            }
            byteLength = arg0.byteLength - byteOffset;
            if (typeof arg2 === "number") {
              byteLength = arg2;
              if (!Number.isSafeInteger(byteLength)) {
                throw new RangeError("'byteLength' must be an integer.");
              }
              if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
              }
              if (typeof arg3 === "object" && arg3 !== null) {
                options = arg3;
              } else if (typeof arg3 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'byteLength' must be a number.");
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
          filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
          throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
        }
        const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
        TRACE_EVENT_END("InferenceSession.create");
        TRACE_FUNC_END();
        return new _InferenceSession(handler);
      }
      startProfiling() {
        this.handler.startProfiling();
      }
      endProfiling() {
        this.handler.endProfiling();
      }
      get inputNames() {
        return this.handler.inputNames;
      }
      get outputNames() {
        return this.handler.outputNames;
      }
      get inputMetadata() {
        return this.handler.inputMetadata;
      }
      get outputMetadata() {
        return this.handler.outputMetadata;
      }
    };
  }
});

// common/dist/esm/inference-session.js
var InferenceSession2;
var init_inference_session = __esm({
  "common/dist/esm/inference-session.js"() {
    "use strict";
    init_inference_session_impl();
    InferenceSession2 = InferenceSession;
  }
});

// common/dist/esm/tensor-conversion.js
var init_tensor_conversion = __esm({
  "common/dist/esm/tensor-conversion.js"() {
    "use strict";
  }
});

// common/dist/esm/tensor-factory.js
var init_tensor_factory = __esm({
  "common/dist/esm/tensor-factory.js"() {
    "use strict";
  }
});

// common/dist/esm/onnx-model.js
var init_onnx_model = __esm({
  "common/dist/esm/onnx-model.js"() {
    "use strict";
  }
});

// common/dist/esm/onnx-value.js
var init_onnx_value = __esm({
  "common/dist/esm/onnx-value.js"() {
    "use strict";
  }
});

// common/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  InferenceSession: () => InferenceSession2,
  TRACE: () => TRACE,
  TRACE_EVENT_BEGIN: () => TRACE_EVENT_BEGIN,
  TRACE_EVENT_END: () => TRACE_EVENT_END,
  TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
  TRACE_FUNC_END: () => TRACE_FUNC_END,
  Tensor: () => Tensor2,
  env: () => env2,
  registerBackend: () => registerBackend
});
var init_esm = __esm({
  "common/dist/esm/index.js"() {
    "use strict";
    init_backend();
    init_env();
    init_inference_session();
    init_tensor();
    init_tensor_conversion();
    init_tensor_factory();
    init_trace();
    init_onnx_model();
    init_onnx_value();
  }
});

// web/lib/wasm/wasm-utils-env.ts
var isNode;
var init_wasm_utils_env = __esm({
  "web/lib/wasm/wasm-utils-env.ts"() {
    "use strict";
    isNode = false;
  }
});

// web/lib/wasm/proxy-worker/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
var WORKER_NAME, isProxyWorker, main_default;
var init_main = __esm({
  "web/lib/wasm/proxy-worker/main.ts"() {
    "use strict";
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    WORKER_NAME = "ort-wasm-proxy-worker";
    isProxyWorker = globalThis.self?.name === WORKER_NAME;
    if (isProxyWorker) {
      self.onmessage = (ev) => {
        const { type, in: message } = ev.data;
        try {
          switch (type) {
            case "init-wasm":
              initializeWebAssembly(message.wasm).then(
                () => {
                  initRuntime(message).then(
                    () => {
                      postMessage({ type });
                    },
                    (err) => {
                      postMessage({ type, err });
                    }
                  );
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            case "init-ep": {
              const { epName, env: env3 } = message;
              initEp(env3, epName).then(
                () => {
                  postMessage({ type });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "copy-from": {
              const { buffer } = message;
              const bufferData = copyFromExternalBuffer(buffer);
              postMessage({ type, out: bufferData });
              break;
            }
            case "create": {
              const { model, options } = message;
              createSession(model, options).then(
                (sessionMetadata) => {
                  postMessage({ type, out: sessionMetadata });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "release":
              releaseSession(message);
              postMessage({ type });
              break;
            case "run": {
              const { sessionId, inputIndices, inputs, outputIndices, options } = message;
              run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                (outputs) => {
                  if (outputs.some((o) => o[3] !== "cpu")) {
                    postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                  } else {
                    postMessage(
                      { type, out: outputs },
                      extractTransferableBuffers([...inputs, ...outputs])
                    );
                  }
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "end-profiling":
              endProfiling(message);
              postMessage({ type });
              break;
            default:
          }
        } catch (err) {
          postMessage({ type, err });
        }
      };
    }
    main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: true ? "module" : "classic", name: WORKER_NAME });
  }
});

// web/lib/wasm/wasm-utils-import.ts
var origin, isEsmImportMetaUrlHardcodedAsFileUri, getScriptSrc, scriptSrc, inferWasmPathPrefixFromScriptSrc, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, embeddedWasmModule, importWasmModule;
var init_wasm_utils_import = __esm({
  "web/lib/wasm/wasm-utils-import.ts"() {
    "use strict";
    init_wasm_utils_env();
    origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
    isEsmImportMetaUrlHardcodedAsFileUri = import.meta.url > "file:" && import.meta.url < "file;";
    getScriptSrc = () => {
      if (isNode) {
        return void 0;
      }
      if (true) {
        if (isEsmImportMetaUrlHardcodedAsFileUri) {
          const URL2 = URL;
          return new URL(new URL2("ort.mjs", import.meta.url).href, origin).href;
        }
        return import.meta.url;
      }
      return typeof document !== "undefined" ? document.currentScript?.src : (
        // use `self.location.href` if available
        typeof self !== "undefined" ? self.location?.href : void 0
      );
    };
    scriptSrc = getScriptSrc();
    inferWasmPathPrefixFromScriptSrc = () => {
      if (scriptSrc && !scriptSrc.startsWith("blob:")) {
        return scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
      }
      return void 0;
    };
    isSameOrigin = (filename, prefixOverride) => {
      try {
        const baseUrl = prefixOverride ?? scriptSrc;
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.origin === origin;
      } catch {
        return false;
      }
    };
    normalizeUrl = (filename, prefixOverride) => {
      const baseUrl = prefixOverride ?? scriptSrc;
      try {
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.href;
      } catch {
        return void 0;
      }
    };
    fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
    preload = async (absoluteUrl) => {
      const response = await fetch(absoluteUrl, { credentials: "same-origin" });
      const blob = await response.blob();
      return URL.createObjectURL(blob);
    };
    dynamicImportDefault = async (url) => (await import(
      /* webpackIgnore: true */
      url
    )).default;
    createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
    false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
    importProxyWorker = async () => {
      if (!scriptSrc) {
        throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
      }
      if (isSameOrigin(scriptSrc)) {
        return [void 0, createProxyWorker()];
      }
      const url = await preload(scriptSrc);
      return [url, createProxyWorker(url)];
    };
    embeddedWasmModule = false ? (
      // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      (true ? null : false ? null : null).default
    ) : void 0;
    importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded, isWasmOverridden) => {
      let useEmbeddedModule = embeddedWasmModule && !(urlOverride || prefixOverride);
      if (useEmbeddedModule) {
        if (!scriptSrc) {
          if (isWasmOverridden && !isMultiThreaded) {
            useEmbeddedModule = true;
          } else {
            throw new Error("cannot determine the script source URL.");
          }
        } else {
          useEmbeddedModule = isSameOrigin(scriptSrc);
        }
      }
      if (useEmbeddedModule) {
        return [void 0, embeddedWasmModule];
      } else {
        const wasmModuleFilename = true ? "ort-wasm-simd-threaded.jsep.mjs" : false ? "ort-wasm-simd-threaded.asyncify.mjs" : "ort-wasm-simd-threaded.mjs";
        const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
        const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
        const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
        return [needPreload ? url : void 0, await dynamicImportDefault(url)];
      }
    };
  }
});

// web/lib/wasm/wasm-factory.ts
var wasm, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, isRelaxedSimdSupported, initializeWebAssembly, getInstance;
var init_wasm_factory = __esm({
  "web/lib/wasm/wasm-factory.ts"() {
    "use strict";
    init_wasm_utils_import();
    initialized = false;
    initializing = false;
    aborted = false;
    isMultiThreadSupported = () => {
      if (typeof SharedArrayBuffer === "undefined") {
        return false;
      }
      try {
        if (typeof MessageChannel !== "undefined") {
          new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
        }
        return WebAssembly.validate(
          new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            4,
            1,
            96,
            0,
            0,
            3,
            2,
            1,
            0,
            5,
            4,
            1,
            3,
            1,
            1,
            10,
            11,
            1,
            9,
            0,
            65,
            0,
            254,
            16,
            2,
            0,
            26,
            11
          ])
        );
      } catch (e) {
        return false;
      }
    };
    isSimdSupported = () => {
      try {
        return WebAssembly.validate(
          new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            4,
            1,
            96,
            0,
            0,
            3,
            2,
            1,
            0,
            10,
            30,
            1,
            28,
            0,
            65,
            0,
            253,
            15,
            253,
            12,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            253,
            186,
            1,
            26,
            11
          ])
        );
      } catch (e) {
        return false;
      }
    };
    isRelaxedSimdSupported = () => {
      try {
        return WebAssembly.validate(
          new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            5,
            1,
            96,
            0,
            1,
            123,
            3,
            2,
            1,
            0,
            10,
            19,
            1,
            17,
            0,
            65,
            1,
            253,
            15,
            65,
            2,
            253,
            15,
            65,
            3,
            253,
            15,
            253,
            147,
            2,
            11
          ])
        );
      } catch (e) {
        return false;
      }
    };
    initializeWebAssembly = async (flags) => {
      if (initialized) {
        return Promise.resolve();
      }
      if (initializing) {
        throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
      }
      if (aborted) {
        throw new Error("previous call to 'initializeWebAssembly()' failed.");
      }
      initializing = true;
      const timeout = flags.initTimeout;
      let numThreads = flags.numThreads;
      if (flags.simd === false) {
      } else if (flags.simd === "relaxed") {
        if (!isRelaxedSimdSupported()) {
          throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.");
        }
      } else if (!isSimdSupported()) {
        throw new Error("WebAssembly SIMD is not supported in the current environment.");
      }
      const multiThreadSupported = isMultiThreadSupported();
      if (numThreads > 1 && !multiThreadSupported) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          console.warn(
            "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
          );
        }
        console.warn(
          "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
        );
        flags.numThreads = numThreads = 1;
      }
      const wasmPaths = flags.wasmPaths;
      const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
      const mjsPathOverrideFlag = wasmPaths?.mjs;
      const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
      const wasmPathOverrideFlag = wasmPaths?.wasm;
      const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
      const wasmBinaryOverride = flags.wasmBinary;
      const [objectUrl, ortWasmFactory] = await importWasmModule(
        mjsPathOverride,
        wasmPrefixOverride,
        numThreads > 1,
        !!wasmBinaryOverride || !!wasmPathOverride
      );
      let isTimeout = false;
      const tasks = [];
      if (timeout > 0) {
        tasks.push(
          new Promise((resolve) => {
            setTimeout(() => {
              isTimeout = true;
              resolve();
            }, timeout);
          })
        );
      }
      tasks.push(
        new Promise((resolve, reject) => {
          const config = {
            /**
             * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
             * created.
             */
            numThreads
          };
          if (wasmBinaryOverride) {
            config.wasmBinary = wasmBinaryOverride;
          } else if (wasmPathOverride || wasmPrefixOverride) {
            config.locateFile = (fileName) => wasmPathOverride ?? wasmPrefixOverride + fileName;
          } else if (mjsPathOverride && mjsPathOverride.indexOf("blob:") !== 0) {
            config.locateFile = (fileName) => new URL(fileName, mjsPathOverride).href;
          } else if (objectUrl) {
            const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();
            if (inferredWasmPathPrefix) {
              config.locateFile = (fileName) => inferredWasmPathPrefix + fileName;
            }
          }
          ortWasmFactory(config).then(
            // wasm module initialized successfully
            (module) => {
              initializing = false;
              initialized = true;
              wasm = module;
              resolve();
              if (objectUrl) {
                URL.revokeObjectURL(objectUrl);
              }
            },
            // wasm module failed to initialize
            (what) => {
              initializing = false;
              aborted = true;
              reject(what);
            }
          );
        })
      );
      await Promise.race(tasks);
      if (isTimeout) {
        throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
      }
    };
    getInstance = () => {
      if (initialized && wasm) {
        return wasm;
      }
      throw new Error("WebAssembly is not initialized yet.");
    };
  }
});

// web/lib/wasm/wasm-utils.ts
var allocWasmString, iterateExtraOptions, checkLastError;
var init_wasm_utils = __esm({
  "web/lib/wasm/wasm-utils.ts"() {
    "use strict";
    init_wasm_factory();
    allocWasmString = (data, allocs) => {
      const wasm2 = getInstance();
      const dataLength = wasm2.lengthBytesUTF8(data) + 1;
      const dataOffset = wasm2._malloc(dataLength);
      wasm2.stringToUTF8(data, dataOffset, dataLength);
      allocs.push(dataOffset);
      return dataOffset;
    };
    iterateExtraOptions = (options, prefix, seen, handler) => {
      if (typeof options == "object" && options !== null) {
        if (seen.has(options)) {
          throw new Error("Circular reference in options");
        } else {
          seen.add(options);
        }
      }
      Object.entries(options).forEach(([key, value]) => {
        const name = prefix ? prefix + key : key;
        if (typeof value === "object") {
          iterateExtraOptions(value, name + ".", seen, handler);
        } else if (typeof value === "string" || typeof value === "number") {
          handler(name, value.toString());
        } else if (typeof value === "boolean") {
          handler(name, value ? "1" : "0");
        } else {
          throw new Error(`Can't handle extra config type: ${typeof value}`);
        }
      });
    };
    checkLastError = (message) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      try {
        const ptrSize = wasm2.PTR_SIZE;
        const paramsOffset = wasm2.stackAlloc(2 * ptrSize);
        wasm2._OrtGetLastError(paramsOffset, paramsOffset + ptrSize);
        const errorCode = Number(wasm2.getValue(paramsOffset, ptrSize === 4 ? "i32" : "i64"));
        const errorMessagePointer = wasm2.getValue(paramsOffset + ptrSize, "*");
        const errorMessage = errorMessagePointer ? wasm2.UTF8ToString(errorMessagePointer) : "";
        throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
      } finally {
        wasm2.stackRestore(stack);
      }
    };
  }
});

// web/lib/wasm/run-options.ts
var setRunOptions;
var init_run_options = __esm({
  "web/lib/wasm/run-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    setRunOptions = (options) => {
      const wasm2 = getInstance();
      let runOptionsHandle = 0;
      const allocs = [];
      const runOptions = options || {};
      try {
        if (options?.logSeverityLevel === void 0) {
          runOptions.logSeverityLevel = 2;
        } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
          throw new Error(`log severity level is not valid: ${options.logSeverityLevel}`);
        }
        if (options?.logVerbosityLevel === void 0) {
          runOptions.logVerbosityLevel = 0;
        } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
          throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
        }
        if (options?.terminate === void 0) {
          runOptions.terminate = false;
        }
        let tagDataOffset = 0;
        if (options?.tag !== void 0) {
          tagDataOffset = allocWasmString(options.tag, allocs);
        }
        runOptionsHandle = wasm2._OrtCreateRunOptions(
          runOptions.logSeverityLevel,
          runOptions.logVerbosityLevel,
          !!runOptions.terminate,
          tagDataOffset
        );
        if (runOptionsHandle === 0) {
          checkLastError("Can't create run options.");
        }
        if (options?.extra !== void 0) {
          iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            const keyDataOffset = allocWasmString(key, allocs);
            const valueDataOffset = allocWasmString(value, allocs);
            if (wasm2._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
            }
          });
        }
        return [runOptionsHandle, allocs];
      } catch (e) {
        if (runOptionsHandle !== 0) {
          wasm2._OrtReleaseRunOptions(runOptionsHandle);
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/session-options.ts
var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, appendSessionConfig, setExecutionProviders, setSessionOptions;
var init_session_options = __esm({
  "web/lib/wasm/session-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    getGraphOptimzationLevel = (graphOptimizationLevel) => {
      switch (graphOptimizationLevel) {
        case "disabled":
          return 0;
        case "basic":
          return 1;
        case "extended":
          return 2;
        case "layout":
          return 3;
        case "all":
          return 99;
        default:
          throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
      }
    };
    getExecutionMode = (executionMode) => {
      switch (executionMode) {
        case "sequential":
          return 0;
        case "parallel":
          return 1;
        default:
          throw new Error(`unsupported execution mode: ${executionMode}`);
      }
    };
    appendDefaultOptions = (options) => {
      if (!options.extra) {
        options.extra = {};
      }
      if (!options.extra.session) {
        options.extra.session = {};
      }
      const session = options.extra.session;
      if (!session.use_ort_model_bytes_directly) {
        session.use_ort_model_bytes_directly = "1";
      }
      if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
        options.enableMemPattern = false;
      }
    };
    appendSessionConfig = (sessionOptionsHandle, key, value, allocs) => {
      const keyDataOffset = allocWasmString(key, allocs);
      const valueDataOffset = allocWasmString(value, allocs);
      if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
        checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
      }
    };
    setExecutionProviders = async (sessionOptionsHandle, executionProviders, allocs) => {
      for (const ep of executionProviders) {
        let epName = typeof ep === "string" ? ep : ep.name;
        const epOptions = [];
        switch (epName) {
          case "webnn":
            epName = "WEBNN";
            if (typeof ep !== "string") {
              const webnnOptions = ep;
              const deviceType = webnnOptions?.deviceType;
              if (deviceType) {
                appendSessionConfig(sessionOptionsHandle, "deviceType", deviceType, allocs);
              }
            }
            break;
          case "webgpu":
            if (false) {
              epName = "WebGPU";
              let customDevice;
              if (typeof ep !== "string") {
                const customOptions = ep;
                if (customOptions.device) {
                  if (typeof GPUDevice !== "undefined" && customOptions.device instanceof GPUDevice) {
                    customDevice = customOptions.device;
                  } else {
                    throw new Error("Invalid GPU device set in WebGPU EP options.");
                  }
                }
              }
              const info = getInstance().webgpuRegisterDevice(customDevice);
              if (info) {
                const [deviceId, instanceHandle, deviceHandle] = info;
                appendEpOption(epOptions, "deviceId", deviceId.toString(), allocs);
                appendEpOption(epOptions, "webgpuInstance", instanceHandle.toString(), allocs);
                appendEpOption(epOptions, "webgpuDevice", deviceHandle.toString(), allocs);
              }
            } else {
              epName = "JS";
              if (typeof ep !== "string") {
                const webgpuOptions = ep;
                if (webgpuOptions?.preferredLayout) {
                  if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                    throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                  }
                  appendSessionConfig(sessionOptionsHandle, "preferredLayout", webgpuOptions.preferredLayout, allocs);
                }
              }
            }
            break;
          case "wasm":
          case "cpu":
            continue;
          default:
            throw new Error(`not supported execution provider: ${epName}`);
        }
        const epNameDataOffset = allocWasmString(epName, allocs);
        const epOptionsCount = epOptions.length;
        let keysOffset = 0;
        let valuesOffset = 0;
        if (epOptionsCount > 0) {
          keysOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);
          allocs.push(keysOffset);
          valuesOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);
          allocs.push(valuesOffset);
          for (let i = 0; i < epOptionsCount; i++) {
            getInstance().setValue(keysOffset + i * getInstance().PTR_SIZE, epOptions[i][0], "*");
            getInstance().setValue(valuesOffset + i * getInstance().PTR_SIZE, epOptions[i][1], "*");
          }
        }
        if (await getInstance()._OrtAppendExecutionProvider(
          sessionOptionsHandle,
          epNameDataOffset,
          keysOffset,
          valuesOffset,
          epOptionsCount
        ) !== 0) {
          checkLastError(`Can't append execution provider: ${epName}.`);
        }
      }
    };
    setSessionOptions = async (options) => {
      const wasm2 = getInstance();
      let sessionOptionsHandle = 0;
      const allocs = [];
      const sessionOptions = options || {};
      appendDefaultOptions(sessionOptions);
      try {
        const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
        const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
        const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
        const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
        if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
          throw new Error(`log severity level is not valid: ${logSeverityLevel}`);
        }
        const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
        if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
          throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
        }
        const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
        sessionOptionsHandle = wasm2._OrtCreateSessionOptions(
          graphOptimizationLevel,
          !!sessionOptions.enableCpuMemArena,
          !!sessionOptions.enableMemPattern,
          executionMode,
          !!sessionOptions.enableProfiling,
          0,
          logIdDataOffset,
          logSeverityLevel,
          logVerbosityLevel,
          optimizedModelFilePathOffset
        );
        if (sessionOptionsHandle === 0) {
          checkLastError("Can't create session options.");
        }
        if (sessionOptions.executionProviders) {
          await setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
        }
        if (sessionOptions.enableGraphCapture !== void 0) {
          if (typeof sessionOptions.enableGraphCapture !== "boolean") {
            throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
          }
          appendSessionConfig(
            sessionOptionsHandle,
            "enableGraphCapture",
            sessionOptions.enableGraphCapture.toString(),
            allocs
          );
        }
        if (sessionOptions.freeDimensionOverrides) {
          for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
            if (typeof name !== "string") {
              throw new Error(`free dimension override name must be a string: ${name}`);
            }
            if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
              throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
            }
            const nameOffset = allocWasmString(name, allocs);
            if (wasm2._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
              checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);
            }
          }
        }
        if (sessionOptions.extra !== void 0) {
          iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            appendSessionConfig(sessionOptionsHandle, key, value, allocs);
          });
        }
        return [sessionOptionsHandle, allocs];
      } catch (e) {
        if (sessionOptionsHandle !== 0) {
          if (wasm2._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {
            checkLastError("Can't release session options.");
          }
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/wasm-common.ts
var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, calculateTensorSizeInBytes, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, isMLTensorSupportedType, dataLocationStringToEnum;
var init_wasm_common = __esm({
  "web/lib/wasm/wasm-common.ts"() {
    "use strict";
    tensorDataTypeStringToEnum = (type) => {
      switch (type) {
        case "int8":
          return 3 /* int8 */;
        case "uint8":
          return 2 /* uint8 */;
        case "bool":
          return 9 /* bool */;
        case "int16":
          return 5 /* int16 */;
        case "uint16":
          return 4 /* uint16 */;
        case "int32":
          return 6 /* int32 */;
        case "uint32":
          return 12 /* uint32 */;
        case "float16":
          return 10 /* float16 */;
        case "float32":
          return 1 /* float */;
        case "float64":
          return 11 /* double */;
        case "string":
          return 8 /* string */;
        case "int64":
          return 7 /* int64 */;
        case "uint64":
          return 13 /* uint64 */;
        case "int4":
          return 22 /* int4 */;
        case "uint4":
          return 21 /* uint4 */;
        default:
          throw new Error(`unsupported data type: ${type}`);
      }
    };
    tensorDataTypeEnumToString = (typeProto) => {
      switch (typeProto) {
        case 3 /* int8 */:
          return "int8";
        case 2 /* uint8 */:
          return "uint8";
        case 9 /* bool */:
          return "bool";
        case 5 /* int16 */:
          return "int16";
        case 4 /* uint16 */:
          return "uint16";
        case 6 /* int32 */:
          return "int32";
        case 12 /* uint32 */:
          return "uint32";
        case 10 /* float16 */:
          return "float16";
        case 1 /* float */:
          return "float32";
        case 11 /* double */:
          return "float64";
        case 8 /* string */:
          return "string";
        case 7 /* int64 */:
          return "int64";
        case 13 /* uint64 */:
          return "uint64";
        case 22 /* int4 */:
          return "int4";
        case 21 /* uint4 */:
          return "uint4";
        default:
          throw new Error(`unsupported data type: ${typeProto}`);
      }
    };
    calculateTensorSizeInBytes = (dateType, dimsOrSize) => {
      const elementSize = [
        -1,
        // undefined = 0
        4,
        // float = 1
        1,
        // uint8 = 2
        1,
        // int8 = 3
        2,
        // uint16 = 4
        2,
        // int16 = 5
        4,
        // int32 = 6
        8,
        // int64 = 7
        -1,
        // string = 8
        1,
        // bool = 9
        2,
        // float16 = 10
        8,
        // double = 11
        4,
        // uint32 = 12
        8,
        // uint64 = 13
        -1,
        // complex64 = 14
        -1,
        // complex128 = 15
        -1,
        // bfloat16 = 16
        -1,
        // FLOAT8E4M3FN = 17
        -1,
        // FLOAT8E4M3FNUZ = 18
        -1,
        // FLOAT8E5M2 = 19
        -1,
        // FLOAT8E5M2FNUZ = 20
        0.5,
        // uint4 = 21
        0.5
        // int4 = 22
      ][dateType];
      const size = typeof dimsOrSize === "number" ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);
      return elementSize > 0 ? Math.ceil(size * elementSize) : void 0;
    };
    tensorTypeToTypedArrayConstructor = (type) => {
      switch (type) {
        case "float16":
          return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
        case "float32":
          return Float32Array;
        case "uint8":
          return Uint8Array;
        case "int8":
          return Int8Array;
        case "uint16":
          return Uint16Array;
        case "int16":
          return Int16Array;
        case "int32":
          return Int32Array;
        case "bool":
          return Uint8Array;
        case "float64":
          return Float64Array;
        case "uint32":
          return Uint32Array;
        case "int64":
          return BigInt64Array;
        case "uint64":
          return BigUint64Array;
        default:
          throw new Error(`unsupported type: ${type}`);
      }
    };
    logLevelStringToEnum = (logLevel) => {
      switch (logLevel) {
        case "verbose":
          return 0;
        case "info":
          return 1;
        case "warning":
          return 2;
        case "error":
          return 3;
        case "fatal":
          return 4;
        default:
          throw new Error(`unsupported logging level: ${logLevel}`);
      }
    };
    isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
    isMLTensorSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint64" || type === "int8" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
    dataLocationStringToEnum = (location2) => {
      switch (location2) {
        case "none":
          return 0;
        case "cpu":
          return 1;
        case "cpu-pinned":
          return 2;
        case "texture":
          return 3;
        case "gpu-buffer":
          return 4;
        case "ml-tensor":
          return 5;
        default:
          throw new Error(`unsupported data location: ${location2}`);
      }
    };
  }
});

// web/lib/wasm/wasm-utils-load-file.ts
var loadFile;
var init_wasm_utils_load_file = __esm({
  "web/lib/wasm/wasm-utils-load-file.ts"() {
    "use strict";
    init_wasm_utils_env();
    loadFile = async (file) => {
      if (typeof file === "string") {
        if (isNode) {
          try {
            const { readFile } = __require("node:fs/promises");
            return new Uint8Array(await readFile(file));
          } catch (e) {
            if (e.code === "ERR_FS_FILE_TOO_LARGE") {
              const { createReadStream } = __require("node:fs");
              const stream = createReadStream(file);
              const chunks = [];
              for await (const chunk of stream) {
                chunks.push(chunk);
              }
              return new Uint8Array(Buffer.concat(chunks));
            }
            throw e;
          }
        } else {
          const response = await fetch(file);
          if (!response.ok) {
            throw new Error(`failed to load external data file: ${file}`);
          }
          const contentLengthHeader = response.headers.get("Content-Length");
          const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
          if (fileSize < 1073741824) {
            return new Uint8Array(await response.arrayBuffer());
          } else {
            if (!response.body) {
              throw new Error(`failed to load external data file: ${file}, no response body.`);
            }
            const reader = response.body.getReader();
            let buffer;
            try {
              buffer = new ArrayBuffer(fileSize);
            } catch (e) {
              if (e instanceof RangeError) {
                const pages = Math.ceil(fileSize / 65536);
                buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
              } else {
                throw e;
              }
            }
            let offset = 0;
            while (true) {
              const { done, value } = await reader.read();
              if (done) {
                break;
              }
              const chunkSize = value.byteLength;
              const chunk = new Uint8Array(buffer, offset, chunkSize);
              chunk.set(value);
              offset += chunkSize;
            }
            return new Uint8Array(buffer, 0, fileSize);
          }
        }
      } else if (file instanceof Blob) {
        return new Uint8Array(await file.arrayBuffer());
      } else if (file instanceof Uint8Array) {
        return file;
      } else {
        return new Uint8Array(file);
      }
    };
  }
});

// web/lib/wasm/jsep/log.ts
var logLevelPrefix, doLog, configLogLevel, debug, configureLogger, LOG, LOG_DEBUG;
var init_log = __esm({
  "web/lib/wasm/jsep/log.ts"() {
    "use strict";
    init_wasm_common();
    logLevelPrefix = ["V", "I", "W", "E", "F"];
    doLog = (level, message) => {
      console.log(`[${logLevelPrefix[level]},${(/* @__PURE__ */ new Date()).toISOString()}]${message}`);
    };
    configureLogger = ($configLogLevel, $debug) => {
      configLogLevel = $configLogLevel;
      debug = $debug;
    };
    LOG = (logLevel, msg) => {
      const messageLevel = logLevelStringToEnum(logLevel);
      const configLevel = logLevelStringToEnum(configLogLevel);
      if (messageLevel >= configLevel) {
        doLog(messageLevel, typeof msg === "function" ? msg() : msg);
      }
    };
    LOG_DEBUG = (...args) => {
      if (debug) {
        LOG(...args);
      }
    };
  }
});

// web/lib/wasm/jsep/util.ts
var MatMulUtil, BroadcastUtil, ShapeUtil, PoolConvUtil, GemmUtil, MIN_CLIP, MAX_CLIP;
var init_util = __esm({
  "web/lib/wasm/jsep/util.ts"() {
    "use strict";
    MatMulUtil = class {
      /**
       * Calculate the expected shape when matrix multiplication
       * @param a The shape of tensor A. Should be a tuple of 2 positive integers
       * @param b The shape of tensor B. Should be a tuple of 2 positive integers
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcMatMulShape(a, b) {
        return a[1] !== b[0] ? void 0 : [a[0], b[1]];
      }
    };
    BroadcastUtil = class {
      /**
       * Calculate the expected shape when broadcasting 2 tensors
       * @param a The shape of tensor A. Should be an array of positive integers
       * @param b The shape of tensor B. Should be an array of positive integers
       * @param isMatMul Whether the operation is MatMul
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcShape(adims, bdims, isMatMul = false) {
        const arank = adims.length;
        const brank = bdims.length;
        if (arank === 0) {
          return bdims;
        }
        if (brank === 0) {
          return adims;
        }
        const crank = Math.max(adims.length, bdims.length);
        const cdims = new Array(crank);
        if (isMatMul) {
          if (arank < 2 || brank < 2) {
            return void 0;
          }
          const cShapeMatMul = MatMulUtil.calcMatMulShape(
            [adims[arank - 2], adims[arank - 1]],
            [bdims[brank - 2], bdims[brank - 1]]
          );
          if (cShapeMatMul === void 0) {
            return void 0;
          }
          [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
        }
        for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
          const aLen = arank - i < 0 ? 1 : adims[arank - i];
          const bLen = brank - i < 0 ? 1 : bdims[brank - i];
          if (aLen !== bLen && aLen > 1 && bLen > 1) {
            return void 0;
          }
          const max = Math.max(aLen, bLen);
          if (aLen && bLen) {
            cdims[crank - i] = Math.max(aLen, bLen);
          } else {
            if (max > 1) {
              return void 0;
            }
            cdims[crank - i] = 0;
          }
        }
        return cdims;
      }
      /**
       * Determine if a shape is unidirectional broadcastable to another shape
       * @param shape The input shape
       * @param finalShape The desired shape after broadcasting
       */
      static isValidBroadcast(shape, finalShape) {
        const inputRank = shape.length;
        const finalRank = finalShape.length;
        if (inputRank > finalRank) {
          return false;
        }
        for (let i = 1; i <= inputRank; i++) {
          if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
            return false;
          }
        }
        return true;
      }
    };
    ShapeUtil = class _ShapeUtil {
      /**
       * calculate the size (number of elements)
       */
      static size(dims) {
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
      }
      /**
       * convert dims corresponding to type change to pack. ex. uint8 data to uint32
       */
      static convertShape(dims, size = 4) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        }
        const newDims = new Array(rank);
        let i = rank - 1;
        while (i >= 0) {
          if (dims[i] % size === 0) {
            newDims[i] = dims[i] / size;
            break;
          }
          if (size % dims[i] !== 0) {
            throw new Error("cannot convert shape");
          }
          newDims[i] = 1;
          size /= dims[i];
          i--;
        }
        for (i--; i >= 0; i--) {
          newDims[i] = dims[i];
        }
        return newDims;
      }
      /**
       * calculate the size (number of elements) from the given axis (inclusive)
       */
      static sizeFromDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
      }
      /**
       * calculate the size (number of elements) to the given axis (exclusive)
       */
      static sizeToDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
      }
      /**
       * calculate the size (number of elements) from and to the given axis [start, end)
       */
      static getSizeFromDimensionRange(dims, start, end) {
        let size = 1;
        for (let i = start; i < end; i++) {
          if (dims[i] < 0) {
            throw new Error(
              // eslint-disable-next-line max-len
              "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."
            );
          }
          size *= Number(dims[i]);
        }
        return size;
      }
      static computeStrides(dims) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        } else if (rank === 1) {
          return [1];
        }
        const strides = new Array(rank);
        strides[rank - 1] = 1;
        strides[rank - 2] = dims[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * dims[i + 1];
        }
        return strides;
      }
      /**
       * normalize axis of range [-r, r) into [0, r).
       */
      static normalizeAxis(axis, tensorRank) {
        if (axis < -tensorRank && axis >= tensorRank) {
          throw new Error("unsupported axis for this operation.");
        }
        return axis < 0 ? axis + tensorRank : axis;
      }
      static normalizeAxes(axes, tensorRank) {
        return axes.map((x) => this.normalizeAxis(x, tensorRank ?? axes.length));
      }
      /**
       * Sorts a given array based on the indices in the Perm array
       * Used in Transpose
       * @param a Array to be sorted such as dims or strides
       * @param perm Perm given; if null a will be reversed
       */
      static sortBasedOnPerm(a, perm) {
        if (perm) {
          return perm.map((v) => a[v]);
        } else {
          return a.slice().reverse();
        }
      }
      /**
       * Pads a given shape according to the padding values
       * @param dims shape of the Tensor to be padded
       * @param pad pad values
       */
      static padShape(dims, pad2) {
        const rank = dims.length;
        return dims.map((v, i) => v + pad2[i] + pad2[i + rank]);
      }
      /**
       * Determines if the two shapes are identical
       * @param shape1
       * @param shape2
       */
      static areEqual(shape1, shape2) {
        if (shape1.length !== shape2.length) {
          return false;
        }
        return shape1.every((v, i) => v === shape2[i]);
      }
    };
    PoolConvUtil = class _PoolConvUtil {
      /**
       * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension.
       * @param kernelShape The size of the kernel along each axis.
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       */
      static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
        if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
        }
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            if (dim >= kernelShape.length) {
              kernelShape.push(inputDims[dim + 2]);
            } else {
              kernelShape[dim] = inputDims[dim + 2];
            }
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < strides.length) {
            if (strides[dim] < 0) {
              throw new Error("strides should be greater than or equal to 1");
            }
          } else {
            strides.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < dilations.length) {
            if (dilations[dim] < 0) {
              throw new Error("dilations should be greater than or equal to 1");
            }
          } else {
            dilations.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length * 2; dim++) {
          if (dim < pads.length) {
            if (pads[dim] < 0) {
              throw new Error("pad should be greater than or equal to 1");
            }
          } else {
            pads.push(0);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (kernelShape[dim] <= 0) {
            throw new Error("kernel shapes need to be greater than 0");
          }
          if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
            throw new Error("pads should be smaller than kernel");
          }
        }
      }
      // adjust pad values based on 'autoPad' attribute
      static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, isChannelLast, autoPad) {
        if (!autoPad) {
          return;
        }
        if (pads.length !== 2 * (inputDims.length - 2)) {
          throw new Error("length of pads should be twice the length of data dimensions");
        }
        if (strides.length !== inputDims.length - 2) {
          throw new Error("length of strides should be the length of data dimensions");
        }
        if (kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of kernel shapes should be the length of data dimensions");
        }
        for (let dim = 0; dim < inputDims.length - 2; dim++) {
          _PoolConvUtil.adjustPadAndReturnShape(
            inputDims[dim + (isChannelLast ? 1 : 2)],
            strides[dim],
            dilations[dim],
            kernelShape[dim],
            pads,
            dim,
            dim + inputDims.length - 2,
            autoPad
          );
        }
      }
      /**
       * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0) {
          throw new Error("input shape must be of size greater than 0");
        }
        const outputDims = [inputDims[0], inputDims[1]];
        _PoolConvUtil.computeShapeHelper(
          isGlobalOperator,
          inputDims,
          outputDims,
          strides,
          dilations,
          kernelShape,
          pads,
          autoPad
        );
        return outputDims;
      }
      /**
       * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param filterDims The filter tensor dimension. (inputs[1].dims)
       * @param strides Stride along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0 || filterDims.length <= 0) {
          throw new Error("invalid input tensor dims or invalid filter tensor dims");
        }
        const outputDims = [inputDims[0], filterDims[0]];
        _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
      }
      // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
      // called by computePoolOutputShape() and computeConvOutputShape()
      // adjust pads based on 'autoPad' attribute prior to shape computation
      static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(1);
          }
        } else {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(
              _PoolConvUtil.adjustPadAndReturnShape(
                inputDims[dim + 2],
                strides[dim],
                dilations[dim],
                kernelShape[dim],
                pads,
                dim,
                dim + inputDims.length - 2,
                autoPad
              )
            );
          }
        }
      }
      // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
      // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
      static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
        const dkernel = dilation * (kernel - 1) + 1;
        if (autoPad && autoPad !== "NOTSET") {
          switch (autoPad) {
            case "VALID":
              pads[padHeadIndex] = 0;
              pads[padTailIndex] = 0;
              return Math.floor((inSize - dkernel) / stride + 1);
            case "SAME_LOWER":
            case "SAME_UPPER":
              if (dilation !== 1) {
                throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
              } else {
                const legacyTargetSize = (inSize + stride - 1) / stride;
                const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                return Math.floor((inSize + padNeeded - kernel) / stride + 1);
              }
            default:
              throw new Error("Unsupported AutoPad type");
          }
        } else {
          return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
        }
      }
    };
    GemmUtil = class {
      // will make sure input shapes are compatible for this op
      // and return back the shape of the output in the form of a tuple
      // will throw exception if the input shapes are not compatible
      static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
        if (leftShape.length !== 2 || rightShape.length !== 2) {
          throw new Error("shape need to be of size 2");
        }
        let M;
        let K;
        let N;
        if (transLeft) {
          M = leftShape[1];
          K = leftShape[0];
        } else {
          M = leftShape[0];
          K = leftShape[1];
        }
        let kDim = -1;
        if (transRight) {
          N = rightShape[0];
          kDim = 1;
        } else {
          N = rightShape[1];
          kDim = 0;
        }
        if (rightShape[kDim] !== K) {
          throw new Error("dimension mismatch");
        }
        if (M <= 0 || N <= 0 || K <= 0) {
          throw new Error("invalid shape specified");
        }
        if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
          throw new Error("gemm: invalid bias shape for broadcast");
        }
        return [M, N, K];
      }
    };
    MIN_CLIP = -34028234663852886e22;
    MAX_CLIP = 34028234663852886e22;
  }
});

// web/lib/wasm/jsep/tensor-view.ts
var createView;
var init_tensor_view = __esm({
  "web/lib/wasm/jsep/tensor-view.ts"() {
    "use strict";
    init_wasm_common();
    createView = (dataBuffer, type) => new (tensorTypeToTypedArrayConstructor(type))(dataBuffer);
  }
});

// web/lib/wasm/jsep/webnn/tensor-manager.ts
var webnnDataTypeToSize, convertDataToInt32, convertInt32ToData, tensorGuid, createNewTensorId, webnnDataTypeToFallback, calculateByteLength, TensorWrapper, TensorIdTracker, TensorManagerImpl, createTensorManager;
var init_tensor_manager = __esm({
  "web/lib/wasm/jsep/webnn/tensor-manager.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    webnnDataTypeToSize = /* @__PURE__ */ new Map([
      ["float32", 32],
      ["float16", 16],
      ["int32", 32],
      ["uint32", 32],
      ["int64", 64],
      ["uint64", 64],
      ["int8", 8],
      ["uint8", 8],
      ["int4", 4],
      ["uint4", 4]
    ]);
    convertDataToInt32 = (data, dataType) => {
      if (dataType === "int32") {
        return data;
      }
      const dataTypeSize = webnnDataTypeToSize.get(dataType);
      if (!dataTypeSize) {
        throw new Error(`WebNN backend does not support data type: ${dataType}`);
      }
      const bytesPerElement = dataTypeSize / 8;
      if (data.byteLength % bytesPerElement !== 0) {
        throw new Error(`Invalid Uint8Array length - must be a multiple of ${bytesPerElement}.`);
      }
      const numElements = data.byteLength / bytesPerElement;
      const originalArray = new (tensorTypeToTypedArrayConstructor(dataType))(data.buffer, data.byteOffset, numElements);
      switch (dataType) {
        case "int64":
        case "uint64": {
          const int32Array = new Int32Array(numElements);
          for (let i = 0; i < numElements; i++) {
            const value = originalArray[i];
            if (value > 2147483647n || value < -2147483648n) {
              throw new Error(`Can not convert int64 data to int32 - value out of range.`);
            }
            int32Array[i] = Number(value);
          }
          return new Uint8Array(int32Array.buffer);
        }
        case "int8":
        case "uint8":
        case "uint32": {
          if (dataType === "uint32") {
            if (originalArray.some((value) => value > 2147483647)) {
              throw new Error(`Can not convert uint32 data to int32 - value out of range.`);
            }
          }
          const int32Array = Int32Array.from(originalArray, Number);
          return new Uint8Array(int32Array.buffer);
        }
        default:
          throw new Error(`Unsupported data conversion from ${dataType} to 'int32'`);
      }
    };
    convertInt32ToData = (data, dataType) => {
      if (dataType === "int32") {
        return data;
      }
      if (data.byteLength % 4 !== 0) {
        throw new Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");
      }
      const numElements = data.byteLength / 4;
      const int32Array = new Int32Array(data.buffer, data.byteOffset, numElements);
      switch (dataType) {
        case "int64": {
          const bigInt64Array = BigInt64Array.from(int32Array, BigInt);
          return new Uint8Array(bigInt64Array.buffer);
        }
        case "uint64": {
          if (int32Array.some((value) => value < 0)) {
            throw new Error("Can not convert int32 data to uin64 - negative value found.");
          }
          const bigUint64Array = BigUint64Array.from(int32Array, BigInt);
          return new Uint8Array(bigUint64Array.buffer);
        }
        case "int8": {
          if (int32Array.some((value) => value < -128 || value > 127)) {
            throw new Error("Can not convert int32 data to int8 - value out of range.");
          }
          const int8Array = Int8Array.from(int32Array, Number);
          return new Uint8Array(int8Array.buffer);
        }
        case "uint8": {
          if (int32Array.some((value) => value < 0 || value > 255)) {
            throw new Error("Can not convert int32 data to uint8 - value out of range.");
          }
          return Uint8Array.from(int32Array, Number);
        }
        case "uint32": {
          if (int32Array.some((value) => value < 0)) {
            throw new Error("Can not convert int32 data to uint32 - negative value found.");
          }
          const uint32Array = Uint32Array.from(int32Array, Number);
          return new Uint8Array(uint32Array.buffer);
        }
        default:
          throw new Error(`Unsupported data conversion from 'int32' to ${dataType}`);
      }
    };
    tensorGuid = 1;
    createNewTensorId = () => tensorGuid++;
    webnnDataTypeToFallback = /* @__PURE__ */ new Map([
      ["int8", "int32"],
      ["uint8", "int32"],
      ["uint32", "int32"],
      ["int64", "int32"]
    ]);
    calculateByteLength = (dataType, shape) => {
      const dataTypeSize = webnnDataTypeToSize.get(dataType);
      if (!dataTypeSize) {
        throw new Error(`WebNN backend does not support data type: ${dataType}`);
      }
      return shape.length > 0 ? Math.ceil(shape.reduce((a, b) => a * b) * dataTypeSize / 8) : 0;
    };
    TensorWrapper = class {
      constructor(descriptor) {
        // This flag is used to indicate whether the data has been converted to fallback data type.
        this.isDataConverted = false;
        const { sessionId, context, tensor, dataType, shape, fallbackDataType } = descriptor;
        this.sessionId = sessionId;
        this.mlContext = context;
        this.mlTensor = tensor;
        this.dataType = dataType;
        this.tensorShape = shape;
        this.fallbackDataType = fallbackDataType;
      }
      get tensor() {
        return this.mlTensor;
      }
      get type() {
        return this.dataType;
      }
      get fallbackType() {
        return this.fallbackDataType;
      }
      get shape() {
        return this.tensorShape;
      }
      get byteLength() {
        return calculateByteLength(this.dataType, this.tensorShape);
      }
      destroy() {
        LOG_DEBUG("verbose", () => "[WebNN] TensorWrapper.destroy");
        this.mlTensor.destroy();
      }
      write(data) {
        this.mlContext.writeTensor(this.mlTensor, data);
      }
      async read(dstBuffer) {
        if (this.fallbackDataType) {
          const data = await this.mlContext.readTensor(this.mlTensor);
          const originalData = convertInt32ToData(new Uint8Array(data), this.dataType);
          if (dstBuffer) {
            const targetBuffer = dstBuffer instanceof ArrayBuffer ? new Uint8Array(dstBuffer) : new Uint8Array(dstBuffer.buffer, dstBuffer.byteOffset, dstBuffer.byteLength);
            targetBuffer.set(originalData);
            return void 0;
          } else {
            return originalData.buffer;
          }
        } else {
          return dstBuffer ? this.mlContext.readTensor(this.mlTensor, dstBuffer) : this.mlContext.readTensor(this.mlTensor);
        }
      }
      canReuseTensor(context, dataType, shape) {
        return this.mlContext === context && this.dataType === dataType && this.tensorShape.length === shape.length && this.tensorShape.every((v, i) => v === shape[i]);
      }
      setIsDataConverted(isConverted) {
        this.isDataConverted = isConverted;
      }
    };
    TensorIdTracker = class {
      constructor(tensorManager, wrapper) {
        this.tensorManager = tensorManager;
        this.wrapper = wrapper;
      }
      get tensorWrapper() {
        return this.wrapper;
      }
      releaseTensor() {
        if (this.tensorWrapper) {
          this.tensorManager.releaseTensor(this.tensorWrapper);
          this.wrapper = void 0;
        }
      }
      async ensureTensor(sessionId, dataType, shape, copyOld) {
        const context = this.tensorManager.getMLContext(sessionId);
        let fallbackDataType;
        if (!context.opSupportLimits().input.dataTypes.includes(dataType)) {
          fallbackDataType = webnnDataTypeToFallback.get(dataType);
          if (!fallbackDataType || !context.opSupportLimits().input.dataTypes.includes(fallbackDataType)) {
            throw new Error(`WebNN backend does not support data type: ${dataType}`);
          }
          LOG_DEBUG(
            "verbose",
            () => `[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${dataType} to ${fallbackDataType}`
          );
        }
        if (this.wrapper) {
          if (this.wrapper.canReuseTensor(context, dataType, shape)) {
            return this.wrapper.tensor;
          } else {
            if (copyOld) {
              if (this.wrapper.byteLength !== calculateByteLength(dataType, shape)) {
                throw new Error("Unable to copy data to tensor with different size.");
              }
              this.activeUpload = new Uint8Array(await this.wrapper.read());
            }
            this.tensorManager.releaseTensor(this.wrapper);
          }
        }
        const usage = typeof MLTensorUsage == "undefined" ? void 0 : MLTensorUsage.READ | MLTensorUsage.WRITE;
        this.wrapper = await this.tensorManager.getCachedTensor(
          sessionId,
          dataType,
          shape,
          usage,
          true,
          true,
          fallbackDataType
        );
        if (copyOld && this.activeUpload) {
          this.wrapper.write(this.activeUpload);
          this.activeUpload = void 0;
        }
        return this.wrapper.tensor;
      }
      upload(data) {
        let newData = data;
        if (this.wrapper) {
          if (this.wrapper.fallbackType) {
            if (this.wrapper.fallbackType === "int32") {
              newData = convertDataToInt32(data, this.wrapper.type);
              this.wrapper.setIsDataConverted(true);
            } else {
              throw new Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);
            }
          }
          if (data.byteLength === this.wrapper.byteLength) {
            this.wrapper.write(newData);
            return;
          } else {
            LOG_DEBUG("verbose", () => "Data size does not match tensor size. Releasing tensor.");
            this.releaseTensor();
          }
        }
        if (this.activeUpload) {
          this.activeUpload.set(newData);
        } else {
          this.activeUpload = new Uint8Array(newData);
        }
      }
      async download(dstBuffer) {
        if (this.activeUpload) {
          const dstData = this.wrapper?.isDataConverted ? convertInt32ToData(this.activeUpload, this.wrapper?.type) : this.activeUpload;
          if (dstBuffer) {
            if (dstBuffer instanceof ArrayBuffer) {
              new Uint8Array(dstBuffer).set(dstData);
            } else {
              new Uint8Array(dstBuffer.buffer, dstBuffer.byteOffset, dstBuffer.byteLength).set(dstData);
            }
            return;
          } else {
            return dstData.buffer;
          }
        }
        if (!this.wrapper) {
          throw new Error("Tensor has not been created.");
        }
        if (!dstBuffer) {
          return this.wrapper.read();
        }
        return this.wrapper.read(dstBuffer);
      }
    };
    TensorManagerImpl = class {
      constructor(backend) {
        this.backend = backend;
        this.tensorTrackersById = /* @__PURE__ */ new Map();
        this.freeTensors = [];
        this.externalTensors = /* @__PURE__ */ new Set();
      }
      getMLContext(sessionId) {
        const context = this.backend.getMLContext(sessionId);
        if (!context) {
          throw new Error("MLContext not found for session.");
        }
        return context;
      }
      reserveTensorId() {
        const tensorId = createNewTensorId();
        this.tensorTrackersById.set(tensorId, new TensorIdTracker(this));
        return tensorId;
      }
      releaseTensorId(tensorId) {
        const tensorTracker = this.tensorTrackersById.get(tensorId);
        if (!tensorTracker) {
          return;
        }
        this.tensorTrackersById.delete(tensorId);
        if (tensorTracker.tensorWrapper) {
          this.releaseTensor(tensorTracker.tensorWrapper);
        }
      }
      async ensureTensor(sessionId, tensorId, dataType, shape, copyOld) {
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] TensorManager.ensureTensor {tensorId: ${tensorId}, dataType: ${dataType}, shape: ${shape}, copyOld: ${copyOld}}`
        );
        const tensor = this.tensorTrackersById.get(tensorId);
        if (!tensor) {
          throw new Error("Tensor not found.");
        }
        return tensor.ensureTensor(sessionId, dataType, shape, copyOld);
      }
      upload(tensorId, data) {
        const tensor = this.tensorTrackersById.get(tensorId);
        if (!tensor) {
          throw new Error("Tensor not found.");
        }
        tensor.upload(data);
      }
      async download(tensorId, dstBuffer) {
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] TensorManager.download {tensorId: ${tensorId}, dstBuffer: ${dstBuffer?.byteLength}}`
        );
        const tensorTracker = this.tensorTrackersById.get(tensorId);
        if (!tensorTracker) {
          throw new Error("Tensor not found.");
        }
        return tensorTracker.download(dstBuffer);
      }
      releaseTensorsForSession(sessionId) {
        for (const tensor of this.freeTensors) {
          if (tensor.sessionId === sessionId) {
            tensor.destroy();
          }
        }
        this.freeTensors = this.freeTensors.filter((tensor) => tensor.sessionId !== sessionId);
      }
      registerTensor(sessionId, mlTensor, dataType, shape) {
        const context = this.getMLContext(sessionId);
        const tensorId = createNewTensorId();
        const wrapper = new TensorWrapper({
          sessionId,
          context,
          tensor: mlTensor,
          dataType,
          shape
        });
        this.tensorTrackersById.set(tensorId, new TensorIdTracker(this, wrapper));
        this.externalTensors.add(wrapper);
        return tensorId;
      }
      /**
       * Get or create an MLTensor with the given data type and shape.
       */
      async getCachedTensor(sessionId, dataType, shape, usage, writable, readable, fallbackDataType) {
        const context = this.getMLContext(sessionId);
        for (const [index, tensor2] of this.freeTensors.entries()) {
          if (tensor2.canReuseTensor(context, dataType, shape)) {
            LOG_DEBUG(
              "verbose",
              () => `[WebNN] Reusing tensor {dataType: ${dataType}, ${fallbackDataType ? `fallbackDataType: ${fallbackDataType},` : ""} shape: ${shape}`
            );
            const wrapper = this.freeTensors.splice(index, 1)[0];
            wrapper.sessionId = sessionId;
            return wrapper;
          }
        }
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] MLContext.createTensor {dataType: ${dataType}, ${fallbackDataType ? `fallbackDataType: ${fallbackDataType},` : ""} shape: ${shape}}`
        );
        const tensor = await context.createTensor({
          dataType: fallbackDataType ?? dataType,
          // If fallback data type is provided, use it.
          shape,
          dimensions: shape,
          usage,
          writable,
          readable
        });
        return new TensorWrapper({ sessionId, context, tensor, dataType, shape, fallbackDataType });
      }
      /**
       * Release tensor for reuse unless external.
       */
      releaseTensor(tensorWrapper) {
        if (this.externalTensors.has(tensorWrapper)) {
          this.externalTensors.delete(tensorWrapper);
        }
        this.freeTensors.push(tensorWrapper);
      }
    };
    createTensorManager = (...args) => new TensorManagerImpl(...args);
  }
});

// web/lib/wasm/jsep/backend-webnn.ts
var onnxDataTypeToWebnnDataType, compareMLContextOptions, WebNNBackend;
var init_backend_webnn = __esm({
  "web/lib/wasm/jsep/backend-webnn.ts"() {
    "use strict";
    init_wasm_common();
    init_wasm_factory();
    init_tensor_view();
    init_tensor_manager();
    init_log();
    onnxDataTypeToWebnnDataType = /* @__PURE__ */ new Map([
      [1 /* float */, "float32"],
      [10 /* float16 */, "float16"],
      [6 /* int32 */, "int32"],
      [12 /* uint32 */, "uint32"],
      [7 /* int64 */, "int64"],
      [13 /* uint64 */, "uint64"],
      [22 /* int4 */, "int4"],
      [21 /* uint4 */, "uint4"],
      [3 /* int8 */, "int8"],
      [2 /* uint8 */, "uint8"],
      [9 /* bool */, "uint8"]
    ]);
    compareMLContextOptions = (a, b) => {
      if (a === b) {
        return true;
      }
      if (a === void 0 || b === void 0) {
        return false;
      }
      const aKeys = Object.keys(a).sort();
      const bKeys = Object.keys(b).sort();
      return aKeys.length === bKeys.length && aKeys.every((key, index) => key === bKeys[index] && a[key] === b[key]);
    };
    WebNNBackend = class {
      constructor(env3) {
        /**
         * Tensor managers for each session.
         */
        this.tensorManager = createTensorManager(this);
        /**
         * Maps from session id to MLContexts.
         */
        this.mlContextBySessionId = /* @__PURE__ */ new Map();
        /**
         * Maps from MLContext to session ids.
         */
        this.sessionIdsByMLContext = /* @__PURE__ */ new Map();
        /**
         * Cache of MLContexts.
         */
        this.mlContextCache = [];
        /**
         * Maps from session id to list of graph inputs.
         */
        this.sessionGraphInputs = /* @__PURE__ */ new Map();
        /**
         * Maps from session id to list of graph outputs.
         */
        this.sessionGraphOutputs = /* @__PURE__ */ new Map();
        /**
         * Temporary graph inputs for the current session.
         * These inputs will be registered when the session is created.
         */
        this.temporaryGraphInputs = [];
        /**
         * Temporary graph outputs for the current session.
         * These outputs will be registered when the session is created.
         */
        this.temporaryGraphOutputs = [];
        /**
         * Temporary tensors for the current session.
         */
        this.temporarySessionTensorIds = /* @__PURE__ */ new Map();
        configureLogger(env3.logLevel, !!env3.debug);
      }
      get currentSessionId() {
        if (this.activeSessionId === void 0) {
          throw new Error("No active session");
        }
        return this.activeSessionId;
      }
      onRunStart(sessionId) {
        LOG_DEBUG("verbose", () => `[WebNN] onRunStart {sessionId: ${sessionId}}`);
        this.activeSessionId = sessionId;
      }
      onRunEnd(sessionId) {
        LOG_DEBUG("verbose", () => `[WebNN] onRunEnd {sessionId: ${sessionId}}`);
        const tensorIds = this.temporarySessionTensorIds.get(sessionId);
        if (!tensorIds) {
          return;
        }
        for (const tensorId of tensorIds) {
          LOG_DEBUG("verbose", () => `[WebNN] releasing temporary tensor {tensorId: ${tensorId}}`);
          this.tensorManager.releaseTensorId(tensorId);
        }
        this.temporarySessionTensorIds.delete(sessionId);
        this.activeSessionId = void 0;
      }
      async createMLContext(optionsOrDevice) {
        if (optionsOrDevice instanceof GPUDevice) {
          const mlContextIndex2 = this.mlContextCache.findIndex((entry) => entry.gpuDevice === optionsOrDevice);
          if (mlContextIndex2 !== -1) {
            return this.mlContextCache[mlContextIndex2].mlContext;
          } else {
            const mlContext = await navigator.ml.createContext(optionsOrDevice);
            this.mlContextCache.push({ gpuDevice: optionsOrDevice, mlContext });
            return mlContext;
          }
        } else if (optionsOrDevice === void 0) {
          const mlContextIndex2 = this.mlContextCache.findIndex(
            (entry) => entry.options === void 0 && entry.gpuDevice === void 0
          );
          if (mlContextIndex2 !== -1) {
            return this.mlContextCache[mlContextIndex2].mlContext;
          } else {
            const mlContext = await navigator.ml.createContext();
            this.mlContextCache.push({ mlContext });
            return mlContext;
          }
        }
        const mlContextIndex = this.mlContextCache.findIndex(
          (entry) => compareMLContextOptions(entry.options, optionsOrDevice)
        );
        if (mlContextIndex !== -1) {
          return this.mlContextCache[mlContextIndex].mlContext;
        } else {
          const mlContext = await navigator.ml.createContext(optionsOrDevice);
          this.mlContextCache.push({ options: optionsOrDevice, mlContext });
          return mlContext;
        }
      }
      registerMLContext(sessionId, mlContext) {
        this.mlContextBySessionId.set(sessionId, mlContext);
        let sessionIds = this.sessionIdsByMLContext.get(mlContext);
        if (!sessionIds) {
          sessionIds = /* @__PURE__ */ new Set();
          this.sessionIdsByMLContext.set(mlContext, sessionIds);
        }
        sessionIds.add(sessionId);
        if (this.temporaryGraphInputs.length > 0) {
          this.sessionGraphInputs.set(sessionId, this.temporaryGraphInputs);
          this.temporaryGraphInputs = [];
        }
        if (this.temporaryGraphOutputs.length > 0) {
          this.sessionGraphOutputs.set(sessionId, this.temporaryGraphOutputs);
          this.temporaryGraphOutputs = [];
        }
      }
      onReleaseSession(sessionId) {
        this.sessionGraphInputs.delete(sessionId);
        this.sessionGraphOutputs.delete(sessionId);
        const mlContext = this.mlContextBySessionId.get(sessionId);
        if (!mlContext) {
          return;
        }
        this.tensorManager.releaseTensorsForSession(sessionId);
        this.mlContextBySessionId.delete(sessionId);
        const sessionIds = this.sessionIdsByMLContext.get(mlContext);
        sessionIds.delete(sessionId);
        if (sessionIds.size === 0) {
          this.sessionIdsByMLContext.delete(mlContext);
          const mlContextIndex = this.mlContextCache.findIndex((entry) => entry.mlContext === mlContext);
          if (mlContextIndex !== -1) {
            this.mlContextCache.splice(mlContextIndex, 1);
          }
        }
      }
      getMLContext(sessionId) {
        return this.mlContextBySessionId.get(sessionId);
      }
      reserveTensorId() {
        return this.tensorManager.reserveTensorId();
      }
      releaseTensorId(tensorId) {
        LOG_DEBUG("verbose", () => `[WebNN] releaseTensorId {tensorId: ${tensorId}}`);
        this.tensorManager.releaseTensorId(tensorId);
      }
      async ensureTensor(sessionId, tensorId, onnxDataType, dimensions, copyOld) {
        const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
        if (!webnnDataType) {
          throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
        }
        return this.tensorManager.ensureTensor(
          sessionId ?? this.currentSessionId,
          tensorId,
          webnnDataType,
          dimensions,
          copyOld
        );
      }
      async createTemporaryTensor(sessionId, onnxDataType, shape) {
        LOG_DEBUG("verbose", () => `[WebNN] createTemporaryTensor {onnxDataType: ${onnxDataType}, shape: ${shape}}`);
        const dataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
        if (!dataType) {
          throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
        }
        const tensorId = this.tensorManager.reserveTensorId();
        await this.tensorManager.ensureTensor(sessionId, tensorId, dataType, shape, false);
        const tensorIds = this.temporarySessionTensorIds.get(sessionId);
        if (!tensorIds) {
          this.temporarySessionTensorIds.set(sessionId, [tensorId]);
        } else {
          tensorIds.push(tensorId);
        }
        return tensorId;
      }
      uploadTensor(tensorId, data) {
        const wasm2 = getInstance();
        if (!wasm2.shouldTransferToMLTensor) {
          throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");
        }
        LOG_DEBUG("verbose", () => `[WebNN] uploadTensor {tensorId: ${tensorId}, data: ${data.byteLength}}`);
        this.tensorManager.upload(tensorId, data);
      }
      async downloadTensor(tensorId, dstBuffer) {
        return this.tensorManager.download(tensorId, dstBuffer);
      }
      createMLTensorDownloader(tensorId, type) {
        return async () => {
          const data = await this.tensorManager.download(tensorId);
          return createView(data, type);
        };
      }
      registerMLTensor(sessionId, tensor, onnxDataType, dimensions) {
        const webnnDataType = onnxDataTypeToWebnnDataType.get(onnxDataType);
        if (!webnnDataType) {
          throw new Error(`Unsupported ONNX data type: ${onnxDataType}`);
        }
        const id = this.tensorManager.registerTensor(sessionId, tensor, webnnDataType, dimensions);
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] registerMLTensor {tensor: ${tensor}, dataType: ${webnnDataType}, dimensions: ${dimensions}} -> {tensorId: ${id}}`
        );
        return id;
      }
      // Register a WebNN Constant operand from external data.
      registerMLConstant(externalFilePath, dataOffset, dataLength, builder, desc, mountedFiles, shouldConvertInt64ToInt32 = false) {
        if (!mountedFiles) {
          throw new Error("External mounted files are not available.");
        }
        let filePath = externalFilePath;
        if (externalFilePath.startsWith("./")) {
          filePath = externalFilePath.substring(2);
        }
        const fileData = mountedFiles.get(filePath);
        if (!fileData) {
          throw new Error(`File with name ${filePath} not found in preloaded files.`);
        }
        if (dataOffset + dataLength > fileData.byteLength) {
          throw new Error("Out of bounds: data offset and length exceed the external file data size.");
        }
        const buffer = fileData.slice(dataOffset, dataOffset + dataLength).buffer;
        let bufferView;
        switch (desc.dataType) {
          case "float32":
            bufferView = new Float32Array(buffer);
            break;
          case "float16":
            bufferView = typeof Float16Array !== "undefined" && Float16Array.from ? new Float16Array(buffer) : new Uint16Array(buffer);
            break;
          case "int32":
            bufferView = new Int32Array(buffer);
            break;
          case "uint32":
            bufferView = new Uint32Array(buffer);
            break;
          case "int64":
            if (shouldConvertInt64ToInt32) {
              const int32Buffer = convertDataToInt32(new Uint8Array(buffer), "int64");
              bufferView = new Int32Array(int32Buffer.buffer);
              desc.dataType = "int32";
            } else {
              bufferView = new BigInt64Array(buffer);
            }
            break;
          case "uint64":
            bufferView = new BigUint64Array(buffer);
            break;
          case "int8":
            bufferView = new Int8Array(buffer);
            break;
          case "int4":
          case "uint4":
          case "uint8":
            bufferView = new Uint8Array(buffer);
            break;
          default:
            throw new Error(`Unsupported data type: ${desc.dataType} in creating WebNN Constant from external data.`);
        }
        LOG_DEBUG(
          "verbose",
          () => `[WebNN] registerMLConstant {dataType: ${desc.dataType}, shape: ${desc.shape}}} ${shouldConvertInt64ToInt32 ? "(Note: it was int64 data type and registered to int32 as workaround)" : ""}`
        );
        return builder.constant(desc, bufferView);
      }
      registerGraphInput(inputName) {
        this.temporaryGraphInputs.push(inputName);
      }
      registerGraphOutput(outputName) {
        this.temporaryGraphOutputs.push(outputName);
      }
      isGraphInput(sessionId, inputName) {
        const inputNames = this.sessionGraphInputs.get(sessionId);
        if (!inputNames) {
          return false;
        }
        return inputNames.includes(inputName);
      }
      isGraphOutput(sessionId, outputName) {
        const outputNames = this.sessionGraphOutputs.get(sessionId);
        if (!outputNames) {
          return false;
        }
        return outputNames.includes(outputName);
      }
      isGraphInputOutputTypeSupported(sessionId, type, isInput = true) {
        const context = this.mlContextBySessionId.get(sessionId);
        const dataType = onnxDataTypeToWebnnDataType.get(tensorDataTypeStringToEnum(type));
        if (typeof dataType === "undefined") {
          return false;
        }
        if (isInput) {
          return !!context?.opSupportLimits().input.dataTypes.includes(dataType);
        } else {
          return !!context?.opSupportLimits().output.dataTypes.includes(dataType);
        }
      }
      flush() {
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/types.ts
var init_types = __esm({
  "web/lib/wasm/jsep/webgpu/types.ts"() {
    "use strict";
  }
});

// web/lib/wasm/jsep/webgpu/gpu-data-manager.ts
var bucketFreelist, bucketArr, calcNormalizedBufferSize, calcBucketBufferSize, guid, createNewGpuDataId, downloadGpuData, GpuDataManagerImpl, createGpuDataManager;
var init_gpu_data_manager = __esm({
  "web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"() {
    "use strict";
    init_log();
    init_types();
    bucketFreelist = /* @__PURE__ */ new Map([
      [64, 250],
      [128, 200],
      [256, 200],
      [512, 200],
      [2048, 230],
      [4096, 200],
      [8192, 50],
      [16384, 50],
      [32768, 50],
      [65536, 50],
      [131072, 50],
      [262144, 50],
      [524288, 50],
      [1048576, 50],
      [2097152, 30],
      [4194304, 20],
      [8388608, 10],
      [12582912, 10],
      [16777216, 10],
      [26214400, 15],
      [33554432, 22],
      [44236800, 2],
      [58982400, 6],
      // we don't want to cache the bucket sizes below but not caching them
      // results in some major performance hits for models like sd-turbo.
      [67108864, 6],
      [134217728, 6],
      [167772160, 6]
    ]);
    bucketArr = [];
    calcNormalizedBufferSize = (size) => Math.ceil(Number(size) / 16) * 16;
    calcBucketBufferSize = (size) => {
      for (let idx = 0; idx < bucketArr.length; idx++) {
        const sizeForBucket = bucketArr[idx];
        if (size <= sizeForBucket) {
          return sizeForBucket;
        }
      }
      return Math.ceil(size / 16) * 16;
    };
    guid = 1;
    createNewGpuDataId = () => guid++;
    downloadGpuData = async (backend, gpuBuffer, originalSize, getTargetBuffer) => {
      const bufferSize = calcNormalizedBufferSize(originalSize);
      const gpuReadBuffer = backend.device.createBuffer(
        // eslint-disable-next-line no-bitwise
        { size: bufferSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }
      );
      try {
        const commandEncoder = backend.getCommandEncoder();
        backend.endComputePass();
        commandEncoder.copyBufferToBuffer(
          gpuBuffer,
          0,
          gpuReadBuffer,
          0,
          bufferSize
        );
        backend.flush();
        await gpuReadBuffer.mapAsync(GPUMapMode.READ);
        const arrayBuffer = gpuReadBuffer.getMappedRange();
        if (getTargetBuffer) {
          const targetBuffer = getTargetBuffer();
          targetBuffer.set(new Uint8Array(arrayBuffer, 0, originalSize));
          return targetBuffer;
        } else {
          return new Uint8Array(arrayBuffer.slice(0, originalSize));
        }
      } finally {
        gpuReadBuffer.destroy();
      }
    };
    GpuDataManagerImpl = class {
      constructor(backend) {
        this.backend = backend;
        this.storageCache = /* @__PURE__ */ new Map();
        this.freeBuffers = /* @__PURE__ */ new Map();
        this.freeUniformBuffers = /* @__PURE__ */ new Map();
        this.buffersPending = [];
        this.capturedPendingBuffers = /* @__PURE__ */ new Map();
        for (const [key] of bucketFreelist) {
          bucketArr.push(key);
          this.freeBuffers.set(key, []);
          this.freeUniformBuffers.set(key, []);
        }
        this.sessionCount = 0;
      }
      upload(id, data) {
        const srcArrayBuffer = data.buffer;
        const srcOffset = data.byteOffset;
        const srcLength = data.byteLength;
        const size = calcNormalizedBufferSize(srcLength);
        const gpuDataCache = this.storageCache.get(id);
        if (!gpuDataCache) {
          throw new Error("gpu data for uploading does not exist");
        }
        if (Number(gpuDataCache.originalSize) !== srcLength) {
          throw new Error(`inconsistent data size. gpu data size=${gpuDataCache.originalSize}, data size=${srcLength}`);
        }
        const gpuBufferForUploading = this.backend.device.createBuffer(
          // eslint-disable-next-line no-bitwise
          { mappedAtCreation: true, size, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }
        );
        const arrayBuffer = gpuBufferForUploading.getMappedRange();
        new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer, srcOffset, srcLength));
        gpuBufferForUploading.unmap();
        const commandEncoder = this.backend.device.createCommandEncoder();
        commandEncoder.copyBufferToBuffer(gpuBufferForUploading, 0, gpuDataCache.gpuData.buffer, 0, size);
        this.backend.device.queue.submit([commandEncoder.finish()]);
        gpuBufferForUploading.destroy();
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.upload(id=${id})`);
      }
      memcpy(sourceId, destinationId) {
        const sourceGpuDataCache = this.storageCache.get(sourceId);
        if (!sourceGpuDataCache) {
          throw new Error("source gpu data for memcpy does not exist");
        }
        const destinationGpuDataCache = this.storageCache.get(destinationId);
        if (!destinationGpuDataCache) {
          throw new Error("destination gpu data for memcpy does not exist");
        }
        if (sourceGpuDataCache.originalSize !== destinationGpuDataCache.originalSize) {
          throw new Error("inconsistent source and destination gpu data size");
        }
        const size = calcNormalizedBufferSize(sourceGpuDataCache.originalSize);
        const commandEncoder = this.backend.getCommandEncoder();
        this.backend.endComputePass();
        commandEncoder.copyBufferToBuffer(
          sourceGpuDataCache.gpuData.buffer,
          0,
          destinationGpuDataCache.gpuData.buffer,
          0,
          size
        );
      }
      registerExternalBuffer(buffer, originalSize, previous) {
        let id;
        if (previous) {
          id = previous[0];
          if (buffer === previous[1]) {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, buffer is the same, skip.`
            );
            return id;
          } else if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) {
            throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
          }
        } else {
          id = createNewGpuDataId();
        }
        this.storageCache.set(id, { gpuData: { id, type: 0 /* default */, buffer }, originalSize });
        LOG_DEBUG(
          "verbose",
          () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, registered.`
        );
        return id;
      }
      unregisterExternalBuffer(id) {
        if (id !== void 0) {
          this.storageCache.delete(id);
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${id}`);
        }
      }
      // eslint-disable-next-line no-bitwise
      create(size, usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
        const bufferSize = calcBucketBufferSize(size);
        let gpuBuffer;
        const isStorage = (usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE;
        const isUniform = (usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
        if (isStorage || isUniform) {
          const freeBuffers = isStorage ? this.freeBuffers : this.freeUniformBuffers;
          const buffers = freeBuffers.get(bufferSize);
          if (!buffers) {
            gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
          } else {
            if (buffers.length > 0) {
              gpuBuffer = buffers.pop();
            } else {
              gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
            }
          }
        } else {
          gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
        }
        const gpuData = { id: createNewGpuDataId(), type: 0 /* default */, buffer: gpuBuffer };
        this.storageCache.set(gpuData.id, { gpuData, originalSize: Number(size) });
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.create(size=${size}) => id=${gpuData.id}`);
        return gpuData;
      }
      get(id) {
        return this.storageCache.get(id)?.gpuData;
      }
      release(idInput) {
        const id = typeof idInput === "bigint" ? Number(idInput) : idInput;
        const cachedData = this.storageCache.get(id);
        if (!cachedData) {
          if (this.storageCache.size === 0) {
            return 0;
          } else {
            throw new Error("releasing data does not exist");
          }
        }
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.release(id=${id}), gpuDataId=${cachedData.gpuData.id}`);
        this.storageCache.delete(id);
        this.buffersPending.push(cachedData.gpuData.buffer);
        return cachedData.originalSize;
      }
      async download(id, getTargetBuffer) {
        const cachedData = this.storageCache.get(Number(id));
        if (!cachedData) {
          throw new Error("data does not exist");
        }
        await downloadGpuData(this.backend, cachedData.gpuData.buffer, cachedData.originalSize, getTargetBuffer);
      }
      refreshPendingBuffers() {
        if (this.buffersPending.length === 0) {
          return;
        }
        if (this.backend.sessionStatus === "default") {
          for (const buffer of this.buffersPending) {
            const maxInFreeList = bucketFreelist.get(buffer.size);
            if ((buffer.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
              const freelist = this.freeBuffers.get(buffer.size) || [];
              if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                buffer.destroy();
              } else {
                freelist.push(buffer);
              }
            } else if ((buffer.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
              const freelist = this.freeUniformBuffers.get(buffer.size) || [];
              if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                buffer.destroy();
              } else {
                freelist.push(buffer);
              }
            } else {
              buffer.destroy();
            }
          }
          this.buffersPending = [];
        } else {
          let capturedBuffers = this.capturedPendingBuffers.get(this.backend.currentSessionId);
          if (!capturedBuffers) {
            capturedBuffers = [];
            this.capturedPendingBuffers.set(this.backend.currentSessionId, capturedBuffers);
          }
          for (const buffer of this.buffersPending) {
            capturedBuffers.push(buffer);
          }
          this.buffersPending = [];
        }
      }
      dispose() {
        this.freeBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.freeUniformBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.storageCache.forEach((storage) => {
          storage.gpuData.buffer.destroy();
        });
        this.capturedPendingBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.storageCache = /* @__PURE__ */ new Map();
        this.freeBuffers = /* @__PURE__ */ new Map();
        this.freeUniformBuffers = /* @__PURE__ */ new Map();
        this.capturedPendingBuffers = /* @__PURE__ */ new Map();
      }
      onCreateSession() {
        this.sessionCount += 1;
      }
      onReleaseSession(sessionId) {
        const pendingBuffers = this.capturedPendingBuffers.get(sessionId);
        if (pendingBuffers) {
          pendingBuffers.forEach((buffer) => {
            buffer.destroy();
          });
          this.capturedPendingBuffers.delete(sessionId);
        }
        this.sessionCount -= 1;
        if (this.sessionCount === 0) {
          LOG_DEBUG("warning", () => "[WebGPU] Clearing webgpu buffer cache");
          this.storageCache.forEach((storage) => {
            storage.gpuData.buffer.destroy();
          });
          this.storageCache = /* @__PURE__ */ new Map();
        }
      }
    };
    createGpuDataManager = (...args) => new GpuDataManagerImpl(...args);
  }
});

// web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts
var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
var init_attribute_with_cache_key = __esm({
  "web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"() {
    "use strict";
    AttributeWithCacheKeyImpl = class {
      constructor(attribute) {
        Object.assign(this, attribute);
      }
      get cacheKey() {
        if (!this.key) {
          this.key = Object.getOwnPropertyNames(this).sort().map((name) => `${this[name]}`).join(";");
        }
        return this.key;
      }
    };
    createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
  }
});

// web/lib/wasm/jsep/webgpu/ops/common.ts
var WORKGROUP_SIZE, getWgslMappedType, tensorTypeToWsglStorageType, tensorTypeToWsglValueType, createTensorShapeVariables, getMaxComponents, fillVector, castToF32, sumVector, getElementAt, createIndicesHelper, inputVariable, outputVariable, atomicOutputVariable, internalVariable, ShaderHelperImpl, createShaderHelper;
var init_common = __esm({
  "web/lib/wasm/jsep/webgpu/ops/common.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    WORKGROUP_SIZE = 64;
    getWgslMappedType = (type, components) => {
      if (components === 3) {
        throw new Error("vec3 has same alignment as vec4, use vec4 instead");
      }
      switch (Number(type)) {
        case 10 /* float16 */:
          return components > 1 ? `vec${components}<f16>` : "f16";
        case 1 /* float */:
          return components > 1 ? `vec${components}<f32>` : "f32";
        case 6 /* int32 */:
          return components > 1 ? `vec${components}<i32>` : "i32";
        case 12 /* uint32 */:
          return components > 1 ? `vec${components}<u32>` : "u32";
        case 7 /* int64 */:
          if (components > 1) {
            throw new Error("currently not supported vecX of uint64 yet");
          }
          return ["vec2<u32>", "i32"];
        case 13 /* uint64 */:
          if (components > 1) {
            throw new Error("currently not supported vecX of uint64 yet");
          }
          return ["vec2<u32>", "u32"];
        case 9 /* bool */:
          if (components !== 4) {
            throw new Error("bool must be vec4");
          }
          return ["u32", "vec4<bool>"];
        case 22 /* int4 */:
          return "i32";
        case 21 /* uint4 */:
          return "u32";
        default:
          throw new Error(`Unknown data type: ${type}`);
      }
    };
    tensorTypeToWsglStorageType = (type, components = 1) => {
      const mappedType = getWgslMappedType(type, components);
      return typeof mappedType === "string" ? mappedType : mappedType[0];
    };
    tensorTypeToWsglValueType = (type, components = 1) => {
      const mappedType = getWgslMappedType(type, components);
      return typeof mappedType === "string" ? mappedType : mappedType[1];
    };
    createTensorShapeVariables = (...dims) => {
      const programUniforms = [];
      dims.forEach((dim) => {
        if (dim.length !== 0) {
          programUniforms.push(
            { type: 12 /* uint32 */, data: dim },
            { type: 12 /* uint32 */, data: ShapeUtil.computeStrides(dim) }
          );
        }
      });
      return programUniforms;
    };
    getMaxComponents = (size) => {
      if (size % 4 === 0) {
        return 4;
      } else if (size % 2 === 0) {
        return 2;
      }
      return 1;
    };
    fillVector = (dataType = "f32", components, value = "0") => {
      if (!components || components === 1) {
        return `${dataType}(${value})`;
      }
      return `vec${components}<${dataType}>(${value})`;
    };
    castToF32 = (dataType, components, value) => {
      if (dataType === "f32") {
        return value;
      }
      if (components === 1) {
        return `f32(${value})`;
      }
      return `vec${components}<f32>(${value})`;
    };
    sumVector = (name, components) => {
      if (components === 4) {
        return `(${name}.x + ${name}.y + ${name}.z + ${name}.w)`;
      } else if (components === 2) {
        return `(${name}.x + ${name}.y)`;
      } else if (components === 3) {
        return `(${name}.x + ${name}.y + ${name}.z)`;
      }
      return name;
    };
    getElementAt = (name, index, length, type) => {
      if (name.startsWith("uniforms.") && length > 4) {
        if (typeof index === "string") {
          if (type === "f16") {
            return `${name}[(${index}) / 8][(${index}) % 8 / 4][(${index}) % 8 % 4]`;
          } else {
            return `${name}[(${index}) / 4][(${index}) % 4]`;
          }
        } else {
          if (type === "f16") {
            return `${name}[${Math.floor(index / 8)}][${Math.floor(index % 8 / 4)}][${index % 8 % 4}]`;
          } else {
            return `${name}[${Math.floor(index / 4)}][${index % 4}]`;
          }
        }
      } else {
        return length > 1 ? `${name}[${index}]` : name;
      }
    };
    createIndicesHelper = (name, tensorType, shapeOrRank, usage, components) => {
      const useUniform = typeof shapeOrRank === "number";
      const rank = useUniform ? shapeOrRank : shapeOrRank.length;
      const rankIdentity = [...new Array(rank).keys()];
      const indicesType = rank < 2 ? "u32" : rank <= 4 ? `vec${rank}<u32>` : `array<u32, ${rank}>`;
      const mappedType = getWgslMappedType(tensorType, components);
      const valueType = typeof mappedType === "string" ? mappedType : mappedType[1];
      const storageType = typeof mappedType === "string" ? mappedType : mappedType[0];
      const type = { indices: indicesType, value: valueType, storage: storageType, tensor: tensorType };
      const normalizeDim = (dim) => typeof dim === "string" ? dim : `${dim}u`;
      const implementationUsed = {
        offsetToIndices: false,
        indicesToOffset: false,
        broadcastedIndicesToOffset: false,
        set: false,
        setByIndices: false,
        get: false,
        getByIndices: false
      };
      const uniformPrefix = useUniform ? "uniforms." : "";
      const shape = `${uniformPrefix}${name}_shape`;
      const strides = `${uniformPrefix}${name}_strides`;
      let o2iSnippet = "";
      for (let i = 0; i < rank - 1; i++) {
        o2iSnippet += `
    let dim${i} = current / ${getElementAt(strides, i, rank)};
    let rest${i} = current % ${getElementAt(strides, i, rank)};
    indices[${i}] = dim${i};
    current = rest${i};
    `;
      }
      o2iSnippet += `indices[${rank - 1}] = current;`;
      const offsetToIndicesImplementation = rank < 2 ? "" : `
  fn o2i_${name}(offset: u32) -> ${type.indices} {
    var indices: ${type.indices};
    var current = offset;
    ${o2iSnippet}
    return indices;
  }`;
      const offsetToIndices = (varOffset) => {
        implementationUsed.offsetToIndices = true;
        return rank < 2 ? varOffset : `o2i_${name}(${varOffset})`;
      };
      const offsets = [];
      if (rank >= 2) {
        for (let i = rank - 1; i >= 0; i--) {
          offsets.push(`${getElementAt(strides, i, rank)} * (indices[${i}])`);
        }
      }
      const indicesToOffsetImplementation = rank < 2 ? "" : `
  fn i2o_${name}(indices: ${type.indices}) -> u32 {
    return ${offsets.join("+")};
  }`;
      const indicesToOffset = (varIndices) => {
        implementationUsed.indicesToOffset = true;
        return rank < 2 ? varIndices : `i2o_${name}(${varIndices})`;
      };
      const indices = (...init2) => rank === 0 ? "0u" : `${type.indices}(${init2.map(normalizeDim).join(",")})`;
      const indicesGet = (varIndices, idx) => {
        if (rank < 2) {
          return `${varIndices}`;
        } else {
          return `${getElementAt(varIndices, idx, rank)}`;
        }
      };
      const indicesSet = (varIndices, idx, value) => {
        if (rank < 2) {
          return `${varIndices}=${value};`;
        } else {
          return `${getElementAt(varIndices, idx, rank)}=${value};`;
        }
      };
      const broadcastedIndicesToOffsetImplementation = {};
      const broadcastedIndicesToOffset = (varIndices, output) => {
        implementationUsed.broadcastedIndicesToOffset = true;
        const implKey = `${output.name}broadcastedIndicesTo${name}Offset`;
        if (implKey in broadcastedIndicesToOffsetImplementation) {
          return `${implKey}(${varIndices})`;
        }
        const offsets2 = [];
        for (let i = rank - 1; i >= 0; i--) {
          const idx = output.indicesGet("outputIndices", i + output.rank - rank);
          offsets2.push(`${indicesGet(strides, i)} * (${idx} % ${indicesGet(shape, i)})`);
        }
        broadcastedIndicesToOffsetImplementation[implKey] = `fn ${implKey}(outputIndices: ${output.type.indices}) -> u32 {
             return ${offsets2.length > 0 ? offsets2.join("+") : "0u"};
           }`;
        return `${implKey}(${varIndices})`;
      };
      const setByOffset = (offset, value) => (() => {
        if (type.storage === type.value) {
          return `${name}[${offset}]=${value};`;
        } else if (type.storage === "vec2<u32>" && type.value === "i32") {
          return `${name}[${offset}]=vec2<u32>(u32(${value}), select(0u, 0xFFFFFFFFu, ${value} < 0));`;
        } else if (type.storage === "vec2<u32>" && type.value === "u32") {
          return `${name}[${offset}]=vec2<u32>(u32(${value}), 0u);`;
        } else if (type.storage === "u32" && type.value === "vec4<bool>") {
          return `${name}[${offset}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${value}));`;
        } else {
          throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
        }
      })();
      const getByOffset = (offset) => (() => {
        if (type.storage === type.value) {
          return `${name}[${offset}]`;
        } else if (type.storage === "vec2<u32>" && type.value === "i32") {
          return `i32(${name}[${offset}].x)`;
        } else if (type.storage === "vec2<u32>" && type.value === "u32") {
          return `u32(${name}[${offset}].x)`;
        } else if (type.storage === "u32" && type.value === "vec4<bool>") {
          return `vec4<bool>(bool(${name}[${offset}] & 0xFFu), bool(${name}[${offset}] & 0xFF00u), bool(${name}[${offset}] & 0xFF0000u), bool(${name}[${offset}] & 0xFF000000u))`;
        } else {
          throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
        }
      })();
      const getByIndicesImplementation = rank < 2 ? "" : `
  fn get_${name}ByIndices(indices: ${type.indices}) -> ${valueType} {
    return ${getByOffset(`i2o_${name}(indices)`)};
  }`;
      const getImplementation = rank < 2 ? "" : (() => {
        const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
        const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
        return `
  fn get_${name}(${functionParams}) -> ${valueType} {
    return get_${name}ByIndices(${indices(dimsParams)});
  }`;
      })();
      const get = (...indices2) => {
        if (indices2.length !== rank) {
          throw new Error(`indices length must be ${rank}`);
        }
        const normalizedIndices = indices2.map(normalizeDim).join(",");
        if (rank === 0) {
          return getByOffset("0u");
        } else if (rank === 1) {
          return getByOffset(normalizedIndices[0]);
        } else {
          implementationUsed.get = true;
          implementationUsed.getByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `get_${name}(${normalizedIndices})`;
        }
      };
      const getByIndices = (varIndices) => {
        if (rank < 2) {
          return getByOffset(varIndices);
        } else {
          implementationUsed.getByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `get_${name}ByIndices(${varIndices})`;
        }
      };
      const setByIndicesImplementation = rank < 2 ? "" : `
  fn set_${name}ByIndices(indices: ${type.indices}, value: ${valueType}) {
    ${setByOffset(`i2o_${name}(indices)`, "value")}
  }`;
      const setImplementation = rank < 2 ? "" : (() => {
        const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
        const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
        return `
  fn set_${name}(${functionParams}, value: ${valueType}) {
    set_${name}ByIndices(${indices(dimsParams)}, value);
  }`;
      })();
      const set = (...indicesAndValue) => {
        if (indicesAndValue.length !== rank + 1) {
          throw new Error(`indices length must be ${rank}`);
        }
        const value = indicesAndValue[rank];
        if (typeof value !== "string") {
          throw new Error("value must be string");
        }
        const normalizedIndices = indicesAndValue.slice(0, rank).map(normalizeDim).join(",");
        if (rank === 0) {
          return setByOffset("0u", value);
        } else if (rank === 1) {
          return setByOffset(normalizedIndices[0], value);
        } else {
          implementationUsed.set = true;
          implementationUsed.setByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `set_${name}(${normalizedIndices}, ${value})`;
        }
      };
      const setByIndices = (varIndices, value) => {
        if (rank < 2) {
          return setByOffset(varIndices, value);
        } else {
          implementationUsed.setByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `set_${name}ByIndices(${varIndices}, ${value});`;
        }
      };
      const impl = () => {
        const impls = [];
        let needShapeStrides = false;
        if (implementationUsed.offsetToIndices) {
          impls.push(offsetToIndicesImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.indicesToOffset) {
          impls.push(indicesToOffsetImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.broadcastedIndicesToOffset) {
          Object.values(broadcastedIndicesToOffsetImplementation).forEach((impl2) => impls.push(impl2));
          needShapeStrides = true;
        }
        if (implementationUsed.set) {
          impls.push(setImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.setByIndices) {
          impls.push(setByIndicesImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.get) {
          impls.push(getImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.getByIndices) {
          impls.push(getByIndicesImplementation);
          needShapeStrides = true;
        }
        if (!useUniform && needShapeStrides) {
          impls.unshift(
            `const ${shape} = ${type.indices}(${shapeOrRank.join(",")});`,
            `const ${strides} = ${type.indices}(${ShapeUtil.computeStrides(shapeOrRank).join(",")});`
          );
        }
        return impls.join("\n");
      };
      return {
        impl,
        type,
        offsetToIndices,
        indicesToOffset,
        broadcastedIndicesToOffset,
        indices,
        indicesGet,
        indicesSet,
        set,
        setByOffset,
        setByIndices,
        get,
        getByOffset,
        getByIndices,
        // isVec4,
        usage,
        name,
        strides,
        shape,
        rank
      };
    };
    inputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "input", components);
    outputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "output", components);
    atomicOutputVariable = (name, type, shapeOrRank) => createIndicesHelper(name, type, shapeOrRank, "atomicOutput", 1);
    internalVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "internal", components);
    ShaderHelperImpl = class {
      constructor(normalizedDispatchGroup, limits) {
        this.normalizedDispatchGroup = normalizedDispatchGroup;
        this.limits = limits;
        this.internalVariables = [];
        this.variables = [];
        this.uniforms = [];
        this.variableIndex = 0;
      }
      guardAgainstOutOfBoundsWorkgroupSizes(size) {
        const sizeInCode = typeof size === "number" ? `${size}u` : size;
        return `if (global_idx >= ${sizeInCode}) { return; }`;
      }
      mainStart(workgroupSize = WORKGROUP_SIZE) {
        const workgroupSizeX = typeof workgroupSize === "number" ? workgroupSize : workgroupSize[0];
        const workgroupSizeY = typeof workgroupSize === "number" ? 1 : workgroupSize[1];
        const workgroupSizeZ = typeof workgroupSize === "number" ? 1 : workgroupSize[2];
        if (workgroupSizeX > this.limits.maxComputeWorkgroupSizeX || workgroupSizeY > this.limits.maxComputeWorkgroupSizeY || workgroupSizeZ > this.limits.maxComputeWorkgroupSizeZ) {
          throw new Error(
            `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`
          );
        }
        if (workgroupSizeX * workgroupSizeY * workgroupSizeZ > this.limits.maxComputeInvocationsPerWorkgroup) {
          throw new Error(
            `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`
          );
        }
        const is1DimensionDispatch = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;
        const paramList = is1DimensionDispatch ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`;
        const globalIdxDefinition = is1DimensionDispatch ? `let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;` : `let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${workgroupSizeX * workgroupSizeY * workgroupSizeZ}u + local_idx;`;
        return `@compute @workgroup_size(${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ})
  fn main(${paramList}) {
    ${globalIdxDefinition}
  `;
      }
      appendVariableUniforms(variable) {
        if (variable.rank !== 0) {
          if (variable.shape.startsWith("uniforms.")) {
            this.uniforms.push({ name: variable.shape.replace("uniforms.", ""), type: "u32", length: variable.rank });
          }
          if (variable.strides.startsWith("uniforms.")) {
            this.uniforms.push({ name: variable.strides.replace("uniforms.", ""), type: "u32", length: variable.rank });
          }
        }
      }
      declareVariable(variable, bindingIndex) {
        if (variable.usage === "internal") {
          throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
        }
        this.variables.push(variable);
        this.appendVariableUniforms(variable);
        const access = variable.usage === "input" ? "read" : "read_write";
        const storageType = variable.usage === "atomicOutput" ? `atomic<i32>` : variable.type.storage;
        return `@group(0) @binding(${bindingIndex}) var<storage, ${access}> ${variable.name}: array<${storageType}>;`;
      }
      declareVariables(...variables) {
        return variables.map((v) => this.declareVariable(v, this.variableIndex++)).join("\n");
      }
      registerInternalVariable(variable) {
        if (variable.usage !== "internal") {
          throw new Error(
            "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."
          );
        }
        this.internalVariables.push(variable);
        this.appendVariableUniforms(variable);
      }
      registerInternalVariables(...variables) {
        variables.forEach((v) => this.registerInternalVariable(v));
        return this;
      }
      registerUniform(name, type, length = 1) {
        this.uniforms.push({ name, type, length });
        return this;
      }
      registerUniforms(additionalUniforms) {
        this.uniforms = this.uniforms.concat(additionalUniforms);
        return this;
      }
      uniformDeclaration() {
        if (this.uniforms.length === 0) {
          return "";
        }
        const uniformSnippets = [];
        for (const { name, type, length } of this.uniforms) {
          if (length && length > 4) {
            if (type === "f16") {
              uniformSnippets.push(`@align(16) ${name}:array<mat2x4<${type}>, ${Math.ceil(length / 8)}>`);
            } else {
              uniformSnippets.push(`${name}:array<vec4<${type}>, ${Math.ceil(length / 4)}>`);
            }
          } else {
            const typeTemp = length == null || length === 1 ? type : `vec${length}<${type}>`;
            uniformSnippets.push(`${name}:${typeTemp}`);
          }
        }
        return `
      struct Uniforms { ${uniformSnippets.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
      }
      /**
       * Get additional implementation that needs to be added to the shader source.
       */
      get additionalImplementations() {
        return this.uniformDeclaration() + this.variables.map((i) => i.impl()).join("\n") + this.internalVariables.map((i) => i.impl()).join("\n");
      }
      /**
       * Get the variable info of the shader program.
       */
      get variablesInfo() {
        if (this.uniforms.length === 0) {
          return void 0;
        }
        const uniformWgslTypeToDataType = (type) => [12 /* uint32 */, 10 /* float16 */, 1 /* float */, 6 /* int32 */][["u32", "f16", "f32", "i32"].indexOf(type)];
        return this.uniforms.map((u) => [uniformWgslTypeToDataType(u.type), u.length ?? 1]);
      }
    };
    createShaderHelper = (dispatchGroup, limits) => new ShaderHelperImpl(dispatchGroup, limits);
  }
});

// web/lib/wasm/jsep/webgpu/ops/transpose.ts
var validateInputs, getAdjustedPerm, getOutputShape, permFunctionBody, squeezeShape, isTransposeReshape, createTransposeProgramInfo, transpose, parseTransposeAttributes;
var init_transpose = __esm({
  "web/lib/wasm/jsep/webgpu/ops/transpose.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs = (inputs, perm) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Transpose requires 1 input.");
      }
      if (perm.length !== 0 && perm.length !== inputs[0].dims.length) {
        throw new Error(`perm size ${perm.length} does not match input rank ${inputs[0].dims.length}`);
      }
    };
    getAdjustedPerm = (inputRank, perm) => perm.length !== 0 ? perm : [...new Array(inputRank).keys()].reverse();
    getOutputShape = (inputShape, perm) => ShapeUtil.sortBasedOnPerm(inputShape, getAdjustedPerm(inputShape.length, perm));
    permFunctionBody = (perm, rank, input, output) => {
      let reverseFunc = `fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`;
      for (let i = 0; i < rank; ++i) {
        reverseFunc += `a[${perm[i]}]=i[${i}];`;
      }
      return reverseFunc += "return a;}";
    };
    squeezeShape = (shape, adjustedPerm) => {
      const newShape = [];
      const newPerm = [];
      for (let i = 0; i < shape.length; ++i) {
        if (shape[i] !== 1) {
          newShape.push(shape[i]);
        }
        if (shape[adjustedPerm[i]] !== 1) {
          newPerm.push(adjustedPerm[i]);
        }
      }
      return { newShape, newPerm };
    };
    isTransposeReshape = (perm, shape) => {
      let lastPermutedAxis = 0;
      for (let i = 0; i < perm.length; ++i) {
        if (shape[perm[i]] === 1) {
          continue;
        }
        if (perm[i] < lastPermutedAxis) {
          return false;
        }
        lastPermutedAxis = perm[i];
      }
      return true;
    };
    createTransposeProgramInfo = (inputTensor, permAttr) => {
      const inputDataType = inputTensor.dataType;
      const inputRank = inputTensor.dims.length;
      const perm = getAdjustedPerm(inputRank, permAttr);
      const outputShape = getOutputShape(inputTensor.dims, perm);
      let newInputShape = inputTensor.dims;
      let newOutputShape = outputShape;
      const transposeAsReshape = inputRank < 2 || isTransposeReshape(perm, inputTensor.dims);
      let getShaderSource;
      if (transposeAsReshape) {
        getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", inputDataType, newInputShape, 4);
          const output = outputVariable("output", inputDataType, newOutputShape, 4);
          return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`;
        };
        return {
          name: "TransposeCopy",
          shaderCache: { inputDependencies: ["type"] },
          getRunData: () => {
            const outputSize = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64 / 4
                /* components */
              ) },
              programUniforms: [{ type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) }]
            };
          },
          getShaderSource
        };
      }
      const { newShape, newPerm } = squeezeShape(inputTensor.dims, perm);
      const channelsLast = ShapeUtil.areEqual(newPerm, [2, 3, 1]);
      const channelsFirst = ShapeUtil.areEqual(newPerm, [3, 1, 2]);
      const useShared = newShape.length === 2 || channelsLast || channelsFirst;
      if (useShared) {
        newInputShape = channelsLast ? [newShape[0], newShape[1] * newShape[2]] : channelsFirst ? [newShape[0] * newShape[1], newShape[2]] : newShape;
        newOutputShape = [newInputShape[1], newInputShape[0]];
        const tileSize = 16;
        getShaderSource = (shaderHelper) => {
          const input = inputVariable("a", inputDataType, newInputShape.length);
          const output = outputVariable("output", inputDataType, newOutputShape.length);
          return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  var<workgroup> tile : array<array<${output.type.value}, ${tileSize + 1}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let stride = (uniforms.output_shape[1] - 1) / ${tileSize} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${tileSize}u + local_id.x;
    let input_row = workgroup_id_x * ${tileSize}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${input.getByIndices(`${input.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${tileSize}u + local_id.x;
    let output_row = workgroup_id_y * ${tileSize}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${output.setByIndices(`${output.type.indices}(output_row, output_col)`, "tile[local_id.x][local_id.y]")}
    }
  }`;
        };
        return {
          name: "TransposeShared",
          shaderCache: { inputDependencies: ["type"] },
          getRunData: () => {
            const outputSize = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
              dispatchGroup: { x: Math.ceil(newOutputShape[1] / tileSize), y: Math.ceil(newOutputShape[0] / tileSize) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(newInputShape, newOutputShape)
              ]
            };
          },
          getShaderSource
        };
      }
      getShaderSource = (shaderHelper) => {
        const input = inputVariable("a", inputDataType, newInputShape.length);
        const output = outputVariable("output", inputDataType, newOutputShape.length);
        return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

  ${permFunctionBody(perm, inputRank, input, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${output.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${output.setByOffset("global_idx", input.getByIndices("aIndices"))}
  }`;
      };
      return {
        name: "Transpose",
        shaderCache: { hint: `${permAttr}`, inputDependencies: ["rank"] },
        getRunData: () => {
          const outputSize = ShapeUtil.size(outputShape);
          return {
            outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(newInputShape, newOutputShape)
            ]
          };
        },
        getShaderSource
      };
    };
    transpose = (context, attributes) => {
      validateInputs(context.inputs, attributes.perm);
      context.compute(createTransposeProgramInfo(context.inputs[0], attributes.perm));
    };
    parseTransposeAttributes = (attributes) => createAttributeWithCacheKey({ perm: attributes.perm });
  }
});

// web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts
var reduceOps, reduceSharedOps, reduceInitValues, reduceOutputValues, getInnerMostAxes, computeOutAndReduceShapes, expandShapeToKeepDim, areAxesInnerMostDims, getAxesPermutation, createReduceSharedProgramInfo, reduceCommon, reduceMeanShared, reduceL1Shared, reduceL2Shared, reduceLogSumExpShared, reduceMaxShared, reduceMinShared, reduceProdShared, reduceSumShared, reduceSumSquareShared, reduceLogSumShared;
var init_reduce_shared = __esm({
  "web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_reduce();
    init_transpose();
    reduceOps = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate * candidate",
      logSumExp: "bestValue + exp(candidate)",
      l1: "bestValue + abs(candidate)",
      l2: "bestValue + candidate * candidate",
      logSum: "bestValue + candidate"
    };
    reduceSharedOps = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate",
      logSumExp: "bestValue + candidate",
      l1: "bestValue + candidate",
      l2: "bestValue + candidate",
      logSum: "bestValue + candidate"
    };
    reduceInitValues = {
      max: "_A[offset]",
      min: "_A[offset]",
      mean: "0",
      sum: "0",
      prod: "1",
      sumSquare: "0",
      logSumExp: "0",
      l1: "0",
      l2: "0",
      logSum: "0"
    };
    reduceOutputValues = {
      max: "bestValue",
      min: "bestValue",
      sum: "bestValue",
      prod: "bestValue",
      sumSquare: "bestValue",
      logSumExp: "log(bestValue)",
      l1: "bestValue",
      l2: "sqrt(bestValue)",
      logSum: "log(bestValue)"
    };
    getInnerMostAxes = (numInnerAxes, rank) => {
      const res = [];
      for (let i = rank - numInnerAxes; i < rank; ++i) {
        res.push(i);
      }
      return res;
    };
    computeOutAndReduceShapes = (shape, axes) => {
      const outputShape = [];
      const rank = shape.length;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          outputShape.push(shape[dim]);
        }
      }
      const reduceShape = axes.map((dim) => shape[dim]);
      return [outputShape, reduceShape];
    };
    expandShapeToKeepDim = (shape, axes) => {
      const rank = shape.length + axes.length;
      const expandShape = [];
      let shapeIdx = 0;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          expandShape.push(shape[shapeIdx++]);
        } else {
          expandShape.push(1);
        }
      }
      return expandShape;
    };
    areAxesInnerMostDims = (axes, rank) => {
      for (let i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
          return false;
        }
      }
      return true;
    };
    getAxesPermutation = (axes, rank) => {
      const res = [];
      if (!areAxesInnerMostDims(axes, rank)) {
        for (let i = 0; i < rank; ++i) {
          if (axes.indexOf(i) === -1) {
            res.push(i);
          }
        }
        axes.forEach((axis) => res.push(axis));
      }
      return res;
    };
    createReduceSharedProgramInfo = (name, cacheKey, inputs, reduceType, outputDataType, outputShape, reduceShape) => {
      const inputShape = inputs[0].dims;
      const outputSize = ShapeUtil.size(outputShape);
      const reduceSize = ShapeUtil.size(reduceShape);
      const input = inputVariable("_A", inputs[0].dataType, inputShape);
      const output = outputVariable("output", outputDataType, outputShape);
      let workgroupSize = 64;
      if (outputSize === 1) {
        workgroupSize = 256;
      }
      const sharedMemorySnippet = `
          var<workgroup> aBestValues : array<f32, ${workgroupSize}>;
       `;
      const getShaderSource = (shaderHelper) => `
        ${shaderHelper.registerUniform("reduceSize", "u32").declareVariables(input, output)}
        ${sharedMemorySnippet}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${shaderHelper.mainStart(workgroupSize)}

          let outputIndex = global_idx / ${workgroupSize};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${reduceInitValues[reduceType]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${workgroupSize}) {
           let candidate = f32(${input.getByOffset("offset + k")});
           bestValue = ${reduceOps[reduceType]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${workgroupSize}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${reduceSharedOps[reduceType]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${output.setByOffset(
        "outputIndex",
        `${reduceType === "mean" ? `${output.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${output.type.storage}(${reduceOutputValues[reduceType]})`}`
      )};
         }
        }`;
      return {
        name,
        // Note that in JSEP, WG size is not included in cache by default, but WebGPU EP it is.
        shaderCache: { hint: `${cacheKey};${workgroupSize}`, inputDependencies: ["type"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: outputSize },
          programUniforms: [{ type: 12 /* uint32 */, data: reduceSize }]
        })
      };
    };
    reduceCommon = (context, name, attributes, reduceType) => {
      const updatedAttributes = context.inputs.length === 1 ? attributes : createReduceAttributesFromInputs(context.inputs, attributes);
      let updatedAxes = updatedAttributes.axes;
      if (updatedAxes.length === 0 && !updatedAttributes.noopWithEmptyAxes) {
        updatedAxes = context.inputs[0].dims.map((_dim, i) => i);
      }
      const normalizeAxes = ShapeUtil.normalizeAxes(updatedAxes, context.inputs[0].dims.length);
      let axes = normalizeAxes;
      let input = context.inputs[0];
      const permutedAxes = getAxesPermutation(axes, context.inputs[0].dims.length);
      if (permutedAxes.length > 0) {
        input = context.compute(createTransposeProgramInfo(context.inputs[0], permutedAxes), {
          inputs: [0],
          outputs: [-1]
        })[0];
        axes = getInnerMostAxes(axes.length, input.dims.length);
      }
      const [outputShape, reduceShape] = computeOutAndReduceShapes(input.dims, axes);
      let finalOutputShape = outputShape;
      if (updatedAttributes.keepDims) {
        finalOutputShape = expandShapeToKeepDim(outputShape, normalizeAxes);
      }
      context.compute(
        createReduceSharedProgramInfo(
          name,
          updatedAttributes.cacheKey,
          [input],
          reduceType,
          context.inputs[0].dataType,
          finalOutputShape,
          reduceShape
        ),
        { inputs: [input] }
      );
    };
    reduceMeanShared = (context, attributes) => {
      reduceCommon(context, "ReduceMeanShared", attributes, "mean");
    };
    reduceL1Shared = (context, attributes) => {
      reduceCommon(context, "ReduceL1Shared", attributes, "l1");
    };
    reduceL2Shared = (context, attributes) => {
      reduceCommon(context, "ReduceL2Shared", attributes, "l2");
    };
    reduceLogSumExpShared = (context, attributes) => {
      reduceCommon(context, "ReduceLogSumExpShared", attributes, "logSumExp");
    };
    reduceMaxShared = (context, attributes) => {
      reduceCommon(context, "ReduceMaxShared", attributes, "max");
    };
    reduceMinShared = (context, attributes) => {
      reduceCommon(context, "ReduceMinShared", attributes, "min");
    };
    reduceProdShared = (context, attributes) => {
      reduceCommon(context, "ReduceProdShared", attributes, "prod");
    };
    reduceSumShared = (context, attributes) => {
      reduceCommon(context, "ReduceSumShared", attributes, "sum");
    };
    reduceSumSquareShared = (context, attributes) => {
      reduceCommon(context, "ReduceSumSquareShared", attributes, "sumSquare");
    };
    reduceLogSumShared = (context, attributes) => {
      reduceCommon(context, "ReduceLogSumShared", attributes, "logSum");
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/reduce.ts
var validateInputs2, noOp, createReduceProgramInfo, createReduceAttributesFromInputs, runReduceProgram, reduceLogSumNaive, reduceL1Naive, reduceL2Naive, reduceLogSumExpNaive, reduceMaxNaive, reduceMeanNaive, reduceMinNaive, reduceProdNaive, reduceSumNaive, reduceSumSquareNaive, useNaiveReduceMethod, reduceMean, reduceL1, reduceL2, reduceLogSumExp, reduceMax, reduceMin, reduceProd, reduceSum, reduceSumSquare, reduceLogSum;
var init_reduce = __esm({
  "web/lib/wasm/jsep/webgpu/ops/reduce.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    init_reduce_shared();
    validateInputs2 = (inputs) => {
      if (!inputs || inputs.length === 0 || inputs.length > 2) {
        throw new Error("Reduce op requires 1 or 2 inputs.");
      }
      if (inputs.length === 2 && inputs[1].dims.length !== 1) {
        throw new Error("Invalid axes input dims.");
      }
    };
    noOp = (input) => ["", "", `var value = ${input.getByIndices("input_indices")};`, ""];
    createReduceProgramInfo = (name, shaderCache, inputs, reduceOp, axesInput, outputDataType, keepDims = false, noopWithEmptyAxes = false) => {
      const outputShape = [];
      const inputShape = inputs[0].dims;
      const inputRank = inputShape.length;
      const axes = ShapeUtil.normalizeAxes(axesInput, inputRank);
      const reduceOnAllAxes = !noopWithEmptyAxes && axes.length === 0;
      inputShape.forEach((d, i) => {
        if (reduceOnAllAxes || axes.indexOf(i) >= 0) {
          if (keepDims) {
            outputShape.push(1);
          }
        } else {
          outputShape.push(d);
        }
      });
      const outputRank = outputShape.length;
      const outputSize = ShapeUtil.size(outputShape);
      const getShaderSource = (shaderHelper) => {
        const idxCopy = [];
        const input = inputVariable("_A", inputs[0].dataType, inputRank);
        const output = outputVariable("output", outputDataType, outputRank);
        const ops = reduceOp(input, output, axes);
        let reduceOps2 = ops[2];
        for (let k = 0, l = 0; k < inputRank; k++) {
          if (reduceOnAllAxes || axes.indexOf(k) >= 0) {
            if (keepDims) {
              l++;
            }
            reduceOps2 = `for(var j${k}: u32 = 0; j${k} < ${inputShape[k]}; j${k}++) {
                  ${ops[2].includes("last_index") ? `let last_index = j${k};` : ""}
                  ${input.indicesSet("input_indices", k, `j${k}`)}
                  ${reduceOps2}
                }`;
          } else {
            idxCopy.push(`${input.indicesSet("input_indices", k, output.indicesGet("output_indices", l))};`);
            l++;
          }
        }
        return `

        ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${input.type.indices};
          let output_indices = ${output.offsetToIndices("global_idx")};

          ${idxCopy.join("\n")}
          ${ops[0]}       // init ops for reduce max/min
          ${ops[1]}
          ${reduceOps2}
          ${ops[3]}
          ${ops.length === 4 ? output.setByOffset("global_idx", "value") : ops.slice(4).join("\n")}
        }`;
      };
      return {
        name,
        shaderCache,
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            ...createTensorShapeVariables(inputShape, outputShape)
          ]
        })
      };
    };
    createReduceAttributesFromInputs = (inputs, attributes) => {
      const axes = [];
      if (inputs[1].dims[0] > 0) {
        inputs[1].getBigInt64Array().forEach((v) => axes.push(Number(v)));
      }
      return createAttributeWithCacheKey({
        axes,
        keepDims: attributes.keepDims,
        noopWithEmptyAxes: attributes.noopWithEmptyAxes
      });
    };
    runReduceProgram = (context, name, attributes, reduceOp) => {
      const inputs = context.inputs;
      const updatedAttributes = inputs.length === 1 ? attributes : createReduceAttributesFromInputs(inputs, attributes);
      context.compute(
        createReduceProgramInfo(
          name,
          { hint: updatedAttributes.cacheKey, inputDependencies: ["rank"] },
          [inputs[0]],
          updatedAttributes.noopWithEmptyAxes && updatedAttributes.axes.length === 0 ? noOp : reduceOp,
          updatedAttributes.axes,
          inputs[0].dataType,
          updatedAttributes.keepDims,
          updatedAttributes.noopWithEmptyAxes
        ),
        { inputs: [0] }
      );
    };
    reduceLogSumNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += ${input.getByIndices("input_indices")};`,
        "value = log(value);"
      ];
      runReduceProgram(context, "ReduceLogSum", attributes, reduceOp);
    };
    reduceL1Naive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += abs(${input.getByIndices("input_indices")});`,
        ""
      ];
      runReduceProgram(context, "ReduceL1", attributes, reduceOp);
    };
    reduceL2Naive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
        "",
        `t = ${input.getByIndices("input_indices")}; value += (t * t);`,
        "value = sqrt(value);"
      ];
      runReduceProgram(context, "ReduceL2", attributes, reduceOp);
    };
    reduceLogSumExpNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += exp(${input.getByIndices("input_indices")});`,
        "value = log(value);"
      ];
      runReduceProgram(context, "ReduceLogSumExp", attributes, reduceOp);
    };
    reduceMaxNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, _output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(input.indicesSet("input_indices", k, 0));
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};`,
          `value = max(value, ${input.getByIndices("input_indices")});`,
          ""
        ];
      };
      runReduceProgram(context, "ReduceMax", attributes, reduceOp);
    };
    reduceMeanNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output, axes) => {
        let size = 1;
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            size *= context.inputs[0].dims[k];
          }
        }
        return [
          "var sum = f32(0);",
          "",
          `sum += f32(${input.getByIndices("input_indices")});`,
          `let value = ${output.type.value}(sum / ${size});`
        ];
      };
      runReduceProgram(context, "ReduceMean", attributes, reduceOp);
    };
    reduceMinNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, _output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};`,
          `value = min(value, ${input.getByIndices("input_indices")});`,
          ""
        ];
      };
      runReduceProgram(context, "ReduceMin", attributes, reduceOp);
    };
    reduceProdNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(1);`,
        "",
        `value *= ${input.getByIndices("input_indices")};`,
        ""
      ];
      runReduceProgram(context, "ReduceProd", attributes, reduceOp);
    };
    reduceSumNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += ${input.getByIndices("input_indices")};`,
        ""
      ];
      runReduceProgram(context, "ReduceSum", attributes, reduceOp);
    };
    reduceSumSquareNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
        "",
        `t = ${input.getByIndices("input_indices")}; value += t * t;`,
        ""
      ];
      runReduceProgram(context, "ReduceSumSquare", attributes, reduceOp);
    };
    useNaiveReduceMethod = (shape, axes, noopWithEmptyAxes) => {
      if (axes.length === 0) {
        return noopWithEmptyAxes;
      }
      let outputSize = 1;
      let reduceSize = 1;
      for (let dim = 0; dim < axes.length; dim++) {
        if (axes.indexOf(dim) === -1) {
          outputSize *= shape[dim];
        } else {
          reduceSize *= shape[dim];
        }
      }
      return reduceSize < 32 && outputSize > 1024;
    };
    reduceMean = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMeanNaive(context, attributes);
      } else {
        reduceMeanShared(context, attributes);
      }
    };
    reduceL1 = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceL1Naive(context, attributes);
      } else {
        reduceL1Shared(context, attributes);
      }
    };
    reduceL2 = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceL2Naive(context, attributes);
      } else {
        reduceL2Shared(context, attributes);
      }
    };
    reduceLogSumExp = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceLogSumExpNaive(context, attributes);
      } else {
        reduceLogSumExpShared(context, attributes);
      }
    };
    reduceMax = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMaxNaive(context, attributes);
      } else {
        reduceMaxShared(context, attributes);
      }
    };
    reduceMin = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMinNaive(context, attributes);
      } else {
        reduceMinShared(context, attributes);
      }
    };
    reduceProd = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceProdNaive(context, attributes);
      } else {
        reduceProdShared(context, attributes);
      }
    };
    reduceSum = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceSumNaive(context, attributes);
      } else {
        reduceSumShared(context, attributes);
      }
    };
    reduceSumSquare = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceSumSquareNaive(context, attributes);
      } else {
        reduceSumSquareShared(context, attributes);
      }
    };
    reduceLogSum = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceLogSumNaive(context, attributes);
      } else {
        reduceLogSumShared(context, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/argminmax.ts
var validateInputs3, argMin, argMax, parseArgMinMaxAttributes;
var init_argminmax = __esm({
  "web/lib/wasm/jsep/webgpu/ops/argminmax.ts"() {
    "use strict";
    init_wasm_common();
    init_attribute_with_cache_key();
    init_reduce();
    validateInputs3 = (inputs) => {
      if (!inputs || inputs.length === 0 || inputs.length > 2) {
        throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
      }
      if (inputs[0].dataType !== 1 /* float */) {
        throw new Error("Invalid input type.");
      }
    };
    argMin = (context, attributes) => {
      validateInputs3(context.inputs);
      const argMinMaxOp = (input, output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          output.setByOffset("global_idx", "best_index")
        ];
      };
      context.compute(
        createReduceProgramInfo(
          "ArgMin",
          { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          [context.inputs[0]],
          argMinMaxOp,
          [attributes.axis],
          7 /* int64 */,
          attributes.keepDims
        ),
        { inputs: [0] }
      );
    };
    argMax = (context, attributes) => {
      validateInputs3(context.inputs);
      const argMinMaxOp = (input, output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          output.setByOffset("global_idx", "best_index")
        ];
      };
      context.compute(
        createReduceProgramInfo(
          "argMax",
          { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          [context.inputs[0]],
          argMinMaxOp,
          [attributes.axis],
          7 /* int64 */,
          attributes.keepDims
        ),
        { inputs: [0] }
      );
    };
    parseArgMinMaxAttributes = (attributes) => createAttributeWithCacheKey(attributes);
  }
});

// web/lib/wasm/jsep/webgpu/ops/attention.ts
var validateAttentionInputs, initVarStub, createInPlaceSoftmaxProgramInfo, createAttentionProbsProgramInfo, createVxAttentionScoreProgramInfo, applyAttention, prepare, attention;
var init_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/attention.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_types();
    init_common();
    validateAttentionInputs = (inputs, attributes) => {
      const input = inputs[0];
      const weights = inputs[1];
      const bias = inputs[2];
      const maskIndex = inputs[3];
      const past = inputs[4];
      const attentionBias = inputs[5];
      if (past && attentionBias) {
        throw new Error("Attention cannot have both past and attention_bias");
      }
      if (input.dims.length !== 3) {
        throw new Error('Input "input" must have 3 dimensions');
      }
      const batchSize = input.dims[0];
      const sequenceLength = input.dims[1];
      const inputHiddenSize = input.dims[2];
      if (bias.dims.length !== 1) {
        throw new Error('Input "bias" is expected to have 1 dimensions');
      }
      if (weights.dims.length !== 2) {
        throw new Error('Input "weights" is expected to have 2 dimensions');
      }
      if (weights.dims[0] !== inputHiddenSize) {
        throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
      }
      if (bias.dims[0] !== weights.dims[1]) {
        throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
      }
      let qHiddenSize = bias.dims[0] / 3;
      let kHiddenSize = qHiddenSize;
      let vHiddenSize = kHiddenSize;
      if (attributes.qkvHiddenSizes.length > 0) {
        if (attributes.qkvHiddenSizes.length !== 3) {
          throw new Error("qkv_hidden_sizes attribute should have 3 elements");
        }
        for (const sz of attributes.qkvHiddenSizes) {
          if (sz % attributes.numHeads !== 0) {
            throw new Error("qkv_hidden_sizes should be divisible by num_heads");
          }
        }
        qHiddenSize = attributes.qkvHiddenSizes[0];
        kHiddenSize = attributes.qkvHiddenSizes[1];
        vHiddenSize = attributes.qkvHiddenSizes[2];
      }
      const kvSequenceLength = sequenceLength;
      if (qHiddenSize !== kHiddenSize) {
        throw new Error("qkv_hidden_sizes first element should be same as the second");
      }
      if (bias.dims[0] !== qHiddenSize + kHiddenSize + vHiddenSize) {
        throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
      }
      let pastSequenceLength = 0;
      if (past) {
        if (kHiddenSize !== vHiddenSize) {
          throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
        }
        if (past.dims.length !== 5) {
          throw new Error('Input "past" must have 5 dimensions');
        }
        if (past.dims[0] !== 2) {
          throw new Error('Input "past" first dimension must be 2');
        }
        if (past.dims[1] !== batchSize) {
          throw new Error('Input "past" second dimension must be batch_size');
        }
        if (past.dims[2] !== attributes.numHeads) {
          throw new Error('Input "past" third dimension must be num_heads');
        }
        if (past.dims[4] !== kHiddenSize / attributes.numHeads) {
          throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
        }
        if (!attributes.pastPresentShareBuffer) {
          pastSequenceLength = past.dims[3];
        }
      }
      const totalSequenceLength = kvSequenceLength + pastSequenceLength;
      const maxSequenceLength = -1;
      const maskType = 0 /* none */;
      if (maskIndex) {
        throw new Error("Mask not supported");
      }
      if (past) {
        throw new Error("past is not supported");
      }
      if (attentionBias) {
        if (attentionBias.dims.length !== 4) {
          throw new Error('Input "attention_bias" must have 4 dimensions');
        }
        if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
          throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
        }
      }
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize,
        hiddenSize: qHiddenSize,
        vHiddenSize,
        headSize: Math.floor(qHiddenSize / attributes.numHeads),
        vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
        numHeads: attributes.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: attributes.maskFilterValue,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias: false,
        passPastInKv: false,
        qkvFormat: 1 /* qkvBNSH */
      };
    };
    initVarStub = (seqLensInput, totalSequenceLengthInput, initPastSequenceLength) => {
      if (totalSequenceLengthInput && seqLensInput) {
        return `
      let total_sequence_length_input = u32(${totalSequenceLengthInput.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${seqLensInput?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `;
      } else {
        return `
    ${initPastSequenceLength ? "let past_sequence_length = uniforms.past_sequence_length" : ""};
    let present_sequence_length = total_sequence_length;
    `;
      }
    };
    createInPlaceSoftmaxProgramInfo = (input, batchSize, numHeads, pastSequenceLength, sequenceLength, totalSequenceLength, seqLens, totalSequenceLengthInput) => {
      const components = getMaxComponents(seqLens ? 1 : totalSequenceLength);
      let WG = 64;
      const totalSequenceLengthComp = totalSequenceLength / components;
      if (totalSequenceLengthComp < WG) {
        WG = 32;
      }
      const elementsPerThread = Math.ceil(totalSequenceLength / components / WG);
      const programUniforms = [
        { type: 12 /* uint32 */, data: batchSize },
        { type: 12 /* uint32 */, data: numHeads },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: sequenceLength },
        { type: 12 /* uint32 */, data: totalSequenceLengthComp },
        { type: 12 /* uint32 */, data: elementsPerThread }
      ];
      const dataType = tensorTypeToWsglStorageType(input.dataType, components);
      const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
      const inputDependencies = ["type"];
      if (seqLens) {
        inputDependencies.push("type");
      }
      if (totalSequenceLengthInput) {
        inputDependencies.push("type");
      }
      const getShaderSource = (shaderHelper) => {
        const inputHelper = outputVariable("x", input.dataType, input.dims, components);
        const inputHelpers = [inputHelper];
        const seqLensInputHelper = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
        if (seqLensInputHelper) {
          inputHelpers.push(seqLensInputHelper);
        }
        const totalSequenceLengthInputHelper = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
        if (totalSequenceLengthInputHelper) {
          inputHelpers.push(totalSequenceLengthInputHelper);
        }
        const elemValueType = tensorTypeToWsglValueType(input.dataType);
        const uniforms = [
          { name: "batch_size", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "sequence_length", type: "u32" },
          { name: "total_sequence_length", type: "u32" },
          { name: "elements_per_thread", type: "u32" }
        ];
        return `
  var<workgroup> thread_max: array<f32, ${WG}>;
  var<workgroup> thread_sum: array<f32, ${WG}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputHelpers)}
  ${shaderHelper.mainStart([WG, 1, 1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${initVarStub(seqLensInputHelper, totalSequenceLengthInputHelper, false)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${WG}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${seqLens ? "u32(past_sequence_length + workgroup_id.y + 1)" : "total_sequence_length"};
    var thread_max_vector = ${f32Type}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${f32Type}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
          switch (components) {
            case 1:
              return "thread_max_vector";
            case 2:
              return "max(thread_max_vector.x, thread_max_vector.y)";
            case 4:
              return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${WG}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f32Type}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${f32Type}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
          switch (components) {
            case 1:
              return "sum_vector";
            case 2:
              return "sum_vector.x + sum_vector.y";
            case 4:
              return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${WG}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${inputHelper.type.value}(${elemValueType}(1.0) / ${elemValueType}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${f32Type}(x[offset + i]);
        x[offset + i] = ${inputHelper.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${seqLens ? `
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${inputHelper.type.value}(${elemValueType}(0));
        }` : ""};
  }`;
      };
      return {
        name: "AttentionProbsSoftmax",
        shaderCache: { hint: `${WG};${dataType};${components}`, inputDependencies },
        getShaderSource,
        getRunData: () => ({
          outputs: [],
          dispatchGroup: { x: 1, y: sequenceLength, z: batchSize * numHeads },
          programUniforms
        })
      };
    };
    createAttentionProbsProgramInfo = (outputCount, q, key, pastKey, attentionBias, parameters, pastSequenceLength, seqLens, totalSequenceLengthInput) => {
      const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
      const probsShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, totalSequenceLength];
      const presentKey = outputCount > 1 && pastKey;
      const kvNumHeads = parameters.kvNumHeads ? parameters.kvNumHeads : parameters.numHeads;
      const presentKeyShape = presentKey ? [parameters.batchSize, kvNumHeads, totalSequenceLength, parameters.headSize] : void 0;
      const nReps = parameters.nReps ? parameters.nReps : 1;
      const alpha = parameters.scale === 0 ? 1 / Math.sqrt(parameters.headSize) : parameters.scale;
      const components = getMaxComponents(parameters.headSize);
      const vectorizedHeadSize = parameters.headSize / components;
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(totalSequenceLength / TILE_SIZE),
        y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
        z: parameters.batchSize * parameters.numHeads
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: parameters.sequenceLength },
        { type: 12 /* uint32 */, data: vectorizedHeadSize },
        { type: 12 /* uint32 */, data: totalSequenceLength },
        { type: 12 /* uint32 */, data: parameters.numHeads },
        { type: 12 /* uint32 */, data: parameters.headSize },
        { type: 1 /* float */, data: alpha },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: parameters.kvSequenceLength },
        { type: 12 /* uint32 */, data: nReps }
      ];
      const feedPastKey = presentKey && pastKey && ShapeUtil.size(pastKey.dims) > 0;
      const inputDependencies = ["type", "type"];
      if (feedPastKey) {
        inputDependencies.push("type");
      }
      if (attentionBias) {
        inputDependencies.push("type");
      }
      if (seqLens) {
        inputDependencies.push("type");
      }
      if (totalSequenceLengthInput) {
        inputDependencies.push("type");
      }
      const outputs = [{ dims: probsShape, dataType: q.dataType, gpuDataType: 0 /* default */ }];
      if (presentKey) {
        outputs.push({ dims: presentKeyShape, dataType: q.dataType, gpuDataType: 0 /* default */ });
      }
      const getShaderSource = (shaderHelper) => {
        const qInput = inputVariable("q", q.dataType, q.dims, components);
        const kInput = inputVariable("key", key.dataType, key.dims, components);
        const inputVars = [qInput, kInput];
        if (feedPastKey) {
          const pastKeyInput = inputVariable("past_key", pastKey.dataType, pastKey.dims, components);
          inputVars.push(pastKeyInput);
        }
        if (attentionBias) {
          inputVars.push(inputVariable("attention_bias", attentionBias.dataType, attentionBias.dims));
        }
        const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
        if (seqLensInputVariable) {
          inputVars.push(seqLensInputVariable);
        }
        const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
        if (totalSequenceLengthInputVariable) {
          inputVars.push(totalSequenceLengthInputVariable);
        }
        const output = outputVariable("output", q.dataType, probsShape);
        const outputVars = [output];
        if (presentKey) {
          outputVars.push(outputVariable("present_key", q.dataType, presentKeyShape, components));
        }
        const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "kv_sequence_length", type: "u32" },
          { name: "n_reps", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;

  var<workgroup> tileQ: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
    let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${feedPastKey && presentKey ? "let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;" : ""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${presentKey ? "let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${f32Type}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${(() => {
          if (feedPastKey && presentKey) {
            return `
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`;
          } else {
            return `
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`;
          }
        })()}
      ${presentKey ? `if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }` : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${f32Type}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
          switch (components) {
            case 1:
              return "value";
            case 2:
              return "value.x + value.y";
            case 4:
              return "value.x + value.y + value.z + value.w";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
        output[outputIdx] = ${output.type.value} (sum * uniforms.alpha) + ${attentionBias ? "attention_bias[outputIdx]" : "0.0"};
    }
  }`;
      };
      return {
        name: "AttentionProbs",
        shaderCache: {
          hint: `${components};${attentionBias !== void 0};${pastKey !== void 0};${outputCount}`,
          inputDependencies
        },
        getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
        getShaderSource
      };
    };
    createVxAttentionScoreProgramInfo = (outputCount, probs, v, pastValue, params, pastSequenceLength, seqLens = void 0, totalSequenceLengthInput = void 0) => {
      const totalSequenceLength = pastSequenceLength + params.kvSequenceLength;
      const nReps = params.nReps ? params.nReps : 1;
      const repeatedVHiddenSize = params.vHiddenSize * nReps;
      const presentValue = outputCount > 1 && pastValue;
      const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
      const presentValueShape = presentValue ? [params.batchSize, kvNumHeads, totalSequenceLength, params.headSize] : void 0;
      const outputShape = [params.batchSize, params.sequenceLength, repeatedVHiddenSize];
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(params.vHeadSize / TILE_SIZE),
        y: Math.ceil(params.sequenceLength / TILE_SIZE),
        z: params.batchSize * params.numHeads
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: params.sequenceLength },
        { type: 12 /* uint32 */, data: totalSequenceLength },
        { type: 12 /* uint32 */, data: params.vHeadSize },
        { type: 12 /* uint32 */, data: params.numHeads },
        { type: 12 /* uint32 */, data: params.headSize },
        { type: 12 /* uint32 */, data: repeatedVHiddenSize },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: params.kvSequenceLength },
        { type: 12 /* uint32 */, data: nReps }
      ];
      const feedPastValue = presentValue && pastValue && ShapeUtil.size(pastValue.dims) > 0;
      const inputDependencies = ["type", "type"];
      if (feedPastValue) {
        inputDependencies.push("type");
      }
      if (seqLens) {
        inputDependencies.push("type");
      }
      if (totalSequenceLengthInput) {
        inputDependencies.push("type");
      }
      const outputs = [{ dims: outputShape, dataType: probs.dataType, gpuDataType: 0 /* default */ }];
      if (presentValue) {
        outputs.push({ dims: presentValueShape, dataType: probs.dataType, gpuDataType: 0 /* default */ });
      }
      const getShaderSource = (shaderHelper) => {
        const probsHelper = inputVariable("probs", probs.dataType, probs.dims);
        const vHelper = inputVariable("v", v.dataType, v.dims);
        const inputVars = [probsHelper, vHelper];
        if (feedPastValue) {
          inputVars.push(inputVariable("past_value", pastValue.dataType, pastValue.dims));
        }
        const seqLensInputVariable = seqLens ? inputVariable("seq_lens", seqLens.dataType, seqLens.dims) : void 0;
        if (seqLens) {
          inputVars.push(seqLensInputVariable);
        }
        const totalSequenceLengthInputVariable = totalSequenceLengthInput ? inputVariable("total_sequence_length_input", totalSequenceLengthInput.dataType, totalSequenceLengthInput.dims) : void 0;
        if (totalSequenceLengthInput) {
          inputVars.push(totalSequenceLengthInputVariable);
        }
        const output = outputVariable("output", probs.dataType, outputShape);
        const outputVars = [output];
        if (presentValue) {
          outputVars.push(outputVariable("present_value", probs.dataType, presentValueShape));
        }
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "v_hidden_size", type: "u32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "kv_sequence_length", type: "u32" },
          { name: "n_reps", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileQ: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileV: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${nReps === 1 ? "headIdx" : "headIdx / uniforms.n_reps"};
   let kv_num_heads = ${nReps === 1 ? "uniforms.num_heads" : "uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${initVarStub(seqLensInputVariable, totalSequenceLengthInputVariable, true)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${feedPastValue && presentValue ? "let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;" : ""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${presentValue ? "let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${probsHelper.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${(() => {
          if (feedPastValue && presentValue) {
            return `
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `;
          } else {
            return `
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`;
          }
        })()}
        ${presentValue ? `
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }` : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
      };
      return {
        name: "AttentionScore",
        shaderCache: { hint: `${pastValue !== void 0};${outputCount}`, inputDependencies },
        getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
        getShaderSource
      };
    };
    applyAttention = (context, q, k, v, _maskIndex, _past, pastKey, pastValue, attentionBiasInput, parameters, seqLens = void 0, totalSequenceLengthInput = void 0) => {
      const outputCount = Math.min(context.outputCount, 1 + (pastKey ? 1 : 0) + (pastValue ? 1 : 0));
      const pastSequenceLength = outputCount > 1 ? parameters.pastSequenceLength : 0;
      const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
      const attentionBias = attentionBiasInput && ShapeUtil.size(attentionBiasInput.dims) > 0 ? attentionBiasInput : void 0;
      const inputsK = [q, k];
      if (outputCount > 1 && pastKey && ShapeUtil.size(pastKey.dims) > 0) {
        inputsK.push(pastKey);
      }
      if (attentionBias) {
        inputsK.push(attentionBias);
      }
      if (seqLens) {
        inputsK.push(seqLens);
      }
      if (totalSequenceLengthInput) {
        inputsK.push(totalSequenceLengthInput);
      }
      const probs = context.compute(
        createAttentionProbsProgramInfo(
          outputCount,
          q,
          k,
          pastKey,
          attentionBias,
          parameters,
          pastSequenceLength,
          seqLens,
          totalSequenceLengthInput
        ),
        { inputs: inputsK, outputs: outputCount > 1 ? [-1, 1] : [-1] }
      )[0];
      context.compute(
        createInPlaceSoftmaxProgramInfo(
          probs,
          parameters.batchSize,
          parameters.numHeads,
          pastSequenceLength,
          parameters.sequenceLength,
          totalSequenceLength,
          seqLens,
          totalSequenceLengthInput
        ),
        { inputs: seqLens && totalSequenceLengthInput ? [probs, seqLens, totalSequenceLengthInput] : [probs], outputs: [] }
      );
      const inputsV = [probs, v];
      if (outputCount > 1 && pastValue && ShapeUtil.size(pastValue.dims) > 0) {
        inputsV.push(pastValue);
      }
      if (seqLens) {
        inputsV.push(seqLens);
      }
      if (totalSequenceLengthInput) {
        inputsV.push(totalSequenceLengthInput);
      }
      context.compute(
        createVxAttentionScoreProgramInfo(
          outputCount,
          probs,
          v,
          pastValue,
          parameters,
          pastSequenceLength,
          seqLens,
          totalSequenceLengthInput
        ),
        {
          inputs: inputsV,
          outputs: outputCount > 1 ? [0, 2] : [0]
        }
      );
    };
    prepare = (context, parameters) => {
      const outputShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, parameters.headSize];
      const M = parameters.sequenceLength;
      const K = parameters.inputHiddenSize;
      const N = parameters.headSize;
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(parameters.headSize / TILE_SIZE),
        y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
        z: parameters.batchSize * parameters.numHeads
      };
      const inputs = [context.inputs[0], context.inputs[1], context.inputs[2]];
      const programUniforms = [
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: K },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: parameters.numHeads },
        { type: 12 /* uint32 */, data: parameters.headSize },
        { type: 12 /* uint32 */, data: parameters.hiddenSize },
        { type: 12 /* uint32 */, data: parameters.hiddenSize + parameters.hiddenSize + parameters.vHiddenSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const outputQ = outputVariable("output_q", inputs[0].dataType, outputShape);
        const outputK = outputVariable("output_k", inputs[0].dataType, outputShape);
        const outputV = outputVariable("output_v", inputs[0].dataType, outputShape);
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims);
        const weight = inputVariable("weight", inputs[1].dataType, inputs[1].dims);
        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
        const dataType = input.type.storage;
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "hidden_size", type: "u32" },
          { name: "ldb", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileInput: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightQ: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightK: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightV: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(input, weight, bias, outputQ, outputK, outputV)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${dataType}(0);
    var valueK = ${dataType}(0);
    var valueV = ${dataType}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
      };
      return context.compute(
        {
          name: "AttentionPrepare",
          shaderCache: { inputDependencies: ["type", "type", "type"] },
          getRunData: () => ({
            outputs: [
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ }
            ],
            dispatchGroup: dispatch,
            programUniforms
          }),
          getShaderSource
        },
        { inputs, outputs: [-1, -1, -1] }
      );
    };
    attention = (context, attributes) => {
      const params = validateAttentionInputs(context.inputs, attributes);
      const [q, k, v] = prepare(context, params);
      return applyAttention(
        context,
        q,
        k,
        v,
        context.inputs[4],
        void 0,
        void 0,
        void 0,
        context.inputs[5],
        params
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/batch-norm.ts
var validateInputs4, createBatchNormInferenceProgramInfo, parseBatchNormAttributes, batchNorm;
var init_batch_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs4 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 5) {
        throw new Error("BatchNormalization requires 5 inputs");
      }
      const checkShapeEqual = (actual, expected, message) => {
        const r = expected.length;
        if (r !== actual.length) {
          throw new Error(`${message}: num dimensions != ${r}`);
        }
        expected.forEach((v, i) => {
          if (v !== actual[i]) {
            throw new Error(`${message}: dim[${i}] do not match`);
          }
        });
      };
      if (inputs[0].dims.length > 1) {
        const shape = attributes.format === "NHWC" ? attributes.spatial ? inputs[0].dims.slice(-1) : inputs[0].dims.slice(-1).concat(inputs[0].dims.slice(1, inputs[0].dims.length - 1)) : inputs[0].dims.slice(1, attributes.spatial ? 2 : void 0);
        checkShapeEqual(inputs[1].dims, shape, "Invalid input scale");
        checkShapeEqual(inputs[2].dims, shape, "Invalid input B");
        checkShapeEqual(inputs[3].dims, shape, "Invalid input mean");
        checkShapeEqual(inputs[4].dims, shape, "Invalid input var");
      } else {
        checkShapeEqual(inputs[1].dims, [1], "Invalid input scale");
        checkShapeEqual(inputs[2].dims, [1], "Invalid input B");
        checkShapeEqual(inputs[3].dims, [1], "Invalid input mean");
        checkShapeEqual(inputs[4].dims, [1], "Invalid input var");
      }
    };
    createBatchNormInferenceProgramInfo = (inputs, attributes) => {
      const { epsilon, spatial, format } = attributes;
      const yShape = inputs[0].dims;
      const components = spatial ? getMaxComponents(yShape[yShape.length - 1]) : 1;
      const cComponents = format === "NHWC" && yShape.length > 1 ? components : 1;
      const outputSize = ShapeUtil.size(yShape) / components;
      const useShapesUniforms = spatial;
      const shapeOrRank = useShapesUniforms ? yShape.length : yShape;
      const x = inputVariable("x", inputs[0].dataType, inputs[0].dims, components);
      const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims, cComponents);
      const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims, cComponents);
      const inputMean = inputVariable("inputMean", inputs[3].dataType, inputs[3].dims, cComponents);
      const inputVar = inputVariable("inputVar", inputs[4].dataType, inputs[4].dims, cComponents);
      const y = outputVariable("y", inputs[0].dataType, shapeOrRank, components);
      const calcCOffset = () => {
        let cOffset = "";
        if (spatial) {
          cOffset = `let cOffset = ${yShape.length === 1 ? "0u" : format === "NHWC" ? `outputIndices[${yShape.length - 1}] / ${components}` : "outputIndices[1]"};`;
        } else {
          if (format === "NCHW") {
            cOffset = `
            ${y.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${y.indicesToOffset("outputIndices")};`;
          } else {
            cOffset = `var cIndices = ${scale.type.indices}(0);
                       cIndices[0] = outputIndices[${yShape.length - 1}];`;
            for (let i = 1; i < scale.rank; i++) {
              cOffset += `cIndices[${i}] = outputIndices[${i}];`;
            }
            cOffset += `let cOffset = ${scale.indicesToOffset("cIndices")};`;
          }
        }
        return cOffset;
      };
      const getInferenceModeShaderSource = (helper) => `
  const epsilon = ${epsilon};
  ${helper.registerUniform("outputSize", "u32").declareVariables(x, scale, bias, inputMean, inputVar, y)}
  ${helper.mainStart()}
  ${helper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${y.offsetToIndices(`global_idx * ${components}`)};
    ${calcCOffset()}
    let scale = ${scale.getByOffset("cOffset")};
    let bias = ${bias.getByOffset("cOffset")};
    let inputMean = ${inputMean.getByOffset("cOffset")};
    let inputVar = ${inputVar.getByOffset("cOffset")};
    let x = ${x.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${y.setByOffset("global_idx", "value")}
  }`;
      return {
        name: "BatchNormalization",
        shaderCache: {
          hint: `${attributes.epsilon}_${attributes.format}_${spatial}_${components}`,
          inputDependencies: useShapesUniforms ? ["rank", "type", "type", "type", "type"] : void 0
        },
        getShaderSource: getInferenceModeShaderSource,
        getRunData: () => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: useShapesUniforms ? [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(yShape)] : [{ type: 12 /* uint32 */, data: outputSize }]
        })
      };
    };
    parseBatchNormAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    batchNorm = (context, attributes) => {
      const { inputs, outputCount } = context;
      const updatedAttributes = parseBatchNormAttributes({ ...attributes, outputCount });
      if (env2.webgpu.validateInputContent) {
        validateInputs4(inputs, updatedAttributes);
      }
      if (attributes.trainingMode) {
        throw new Error("BatchNormalization trainingMode is not supported yet.");
      } else {
        context.compute(createBatchNormInferenceProgramInfo(inputs, updatedAttributes));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/bias-add.ts
var validateInputs5, createBiasAddProgramInfo, biasAdd;
var init_bias_add = __esm({
  "web/lib/wasm/jsep/webgpu/ops/bias-add.ts"() {
    "use strict";
    init_util();
    init_common();
    validateInputs5 = (inputs) => {
      if (inputs[0].dims.length !== 3) {
        throw new Error("input should have 3 dimensions");
      }
      if (![320, 640, 1280].includes(inputs[0].dims[2])) {
        throw new Error("number of channels should be 320, 640 or 1280");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("bias is expected to have 1 dimensions");
      }
      if (inputs[0].dims[2] !== inputs[1].dims[0]) {
        throw new Error("last dimension of input and bias are not the same");
      }
    };
    createBiasAddProgramInfo = (inputs) => {
      const outputShape = inputs[0].dims;
      const channels = inputs[0].dims[2];
      const outputSize = ShapeUtil.size(outputShape) / 4;
      const dataType = inputs[0].dataType;
      const input = inputVariable("input", dataType, outputShape, 4);
      const bias = inputVariable("bias", dataType, [channels], 4);
      const residual = inputVariable("residual", dataType, outputShape, 4);
      const output = outputVariable("output", dataType, outputShape, 4);
      const getShaderSource = (shaderHelper) => `
  const channels = ${channels}u / 4;
  ${shaderHelper.declareVariables(input, bias, residual, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let value = ${input.getByOffset("global_idx")}
      + ${bias.getByOffset("global_idx % channels")} + ${residual.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", "value")}
  }`;
      return {
        name: "BiasAdd",
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) }
        }),
        getShaderSource
      };
    };
    biasAdd = (context) => {
      validateInputs5(context.inputs);
      context.compute(createBiasAddProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/unary-op.ts
var createElementwiseProgramShader, createElementwiseProgramInfo, abs, acos, acosh, asin, asinh, atan, atanh, parseCastAttributes, cast, generateClipAttributesFromInputs, clip, ceil, cos, cosh, parseAlphaAttributes, elu, erfImpl, erf, exp, floor, gelu, leakyRelu, not, neg, reciprocal, relu, sigmoid, parseHardSigmoidAttributes, hardSigmoid, sin, sinh, sqrt, tan, tanhExpression, tanh, fastGeluImpl, fastGeluExpression, fastGelu, thresholdedRelu, log, quickGeluImpl, quickGeluExpression, quickgelu;
var init_unary_op = __esm({
  "web/lib/wasm/jsep/webgpu/ops/unary-op.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    createElementwiseProgramShader = (shaderHelper, datasize, inputDataType, outputDataType, funcCall, additionalImplementation, additionalUniformsType) => {
      const vecSize = Math.ceil(datasize / 4);
      let expression = "";
      if (typeof funcCall === "string") {
        expression = `${funcCall}(a)`;
      } else {
        expression = funcCall("a");
      }
      const input = inputVariable("inputData", inputDataType, [vecSize], 4);
      const output = outputVariable("outputData", outputDataType, [vecSize], 4);
      const uniforms = [{ name: "vec_size", type: "u32" }];
      if (additionalUniformsType) {
        uniforms.push(...additionalUniformsType);
      }
      return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}

  ${additionalImplementation ?? ""}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${input.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", expression)}
  }`;
    };
    createElementwiseProgramInfo = (input, name, funcCall, additionalImplementation, cacheKey, outputDataType = input.dataType, additionalUniforms, additionalUniformsType) => {
      const programUniforms = [
        { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(input.dims) / 4) }
      ];
      if (additionalUniforms) {
        programUniforms.push(...additionalUniforms);
      }
      return {
        name,
        shaderCache: { hint: cacheKey, inputDependencies: ["type"] },
        getShaderSource: (shaderHelper) => createElementwiseProgramShader(
          shaderHelper,
          ShapeUtil.size(input.dims),
          input.dataType,
          outputDataType,
          funcCall,
          additionalImplementation,
          additionalUniformsType
        ),
        getRunData: (inputTensors) => ({
          outputs: [{ dims: input.dims, dataType: outputDataType }],
          dispatchGroup: {
            x: Math.ceil(
              ShapeUtil.size(inputTensors[0].dims) / 64 / 4
              /* vec size */
            )
          },
          programUniforms
        })
      };
    };
    abs = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Abs", "abs"));
    };
    acos = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Acos", "acos"));
    };
    acosh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Acosh", "acosh"));
    };
    asin = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Asin", "asin"));
    };
    asinh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Asinh", "asinh"));
    };
    atan = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Atan", "atan"));
    };
    atanh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Atanh", "atanh"));
    };
    parseCastAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    cast = (context, attributes) => {
      let func;
      switch (attributes.to) {
        case 10 /* float16 */:
          func = "vec4<f16>";
          break;
        case 1 /* float */:
          func = "vec4<f32>";
          break;
        case 12 /* uint32 */:
          func = "vec4<u32>";
          break;
        case 6 /* int32 */:
          func = "vec4<i32>";
          break;
        case 9 /* bool */:
          func = "vec4<bool>";
          break;
        default:
          throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${attributes.to}`);
      }
      context.compute(
        createElementwiseProgramInfo(context.inputs[0], "Cast", func, void 0, attributes.cacheKey, attributes.to)
      );
    };
    generateClipAttributesFromInputs = (inputs) => {
      let min;
      let max;
      const hasMin = inputs.length >= 2 && inputs[1].data !== 0;
      const hasMax = inputs.length >= 3 && inputs[2].data !== 0;
      switch (inputs[0].dataType) {
        case 1 /* float */:
          min = hasMin ? inputs[1].getFloat32Array()[0] : -34028234663852886e22;
          max = hasMax ? inputs[2].getFloat32Array()[0] : 34028234663852886e22;
          break;
        case 10 /* float16 */:
          min = hasMin ? inputs[1].getUint16Array()[0] : 64511;
          max = hasMax ? inputs[2].getUint16Array()[0] : 31743;
          break;
        default:
          throw new Error("Unsupport data type");
      }
      return createAttributeWithCacheKey({ min, max });
    };
    clip = (context, clipAttributes) => {
      const attributes = clipAttributes ? clipAttributes : generateClipAttributesFromInputs(context.inputs);
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Clip",
          (a) => `clamp(${a}, vec4<${dataType}>(uniforms.min), vec4<${dataType}>(uniforms.max))`,
          void 0,
          attributes.cacheKey,
          void 0,
          [
            { type: context.inputs[0].dataType, data: attributes.min },
            { type: context.inputs[0].dataType, data: attributes.max }
          ],
          [
            { name: "min", type: dataType },
            { name: "max", type: dataType }
          ]
        ),
        { inputs: [0] }
      );
    };
    ceil = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Ceil", "ceil"));
    };
    cos = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Cos", "cos"));
    };
    cosh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Cosh", "cosh"));
    };
    parseAlphaAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    elu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Elu",
          (a) => `elu_vf32(${a})`,
          `
  const elu_alpha_ = ${dataType}(${attributes.alpha});

  fn elu_f32(a: ${dataType}) -> ${dataType} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${dataType}>) -> vec4<${dataType}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,
          attributes.cacheKey
        )
      );
    };
    erfImpl = (varType = "f32") => `
const r0: ${varType} = 0.3275911;
const r1: ${varType} = 0.254829592;
const r2: ${varType} = -0.284496736;
const r3: ${varType} = 1.421413741;
const r4: ${varType} = -1.453152027;
const r5: ${varType} = 1.061405429;

fn erf_vf32(v: vec4<${varType}>) -> vec4<${varType}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`;
    erf = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Erf", (a) => `erf_vf32(${a})`, erfImpl(dataType)));
    };
    exp = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Exp", "exp"));
    };
    floor = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Floor", "floor"));
    };
    gelu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Gelu",
          (a) => `0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,
          erfImpl(dataType)
        )
      );
    };
    leakyRelu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "LeakyRelu",
          (a) => `select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${dataType}>(0.0))`,
          `const leaky_relu_alpha_ = ${dataType}(${attributes.alpha});`,
          attributes.cacheKey
        )
      );
    };
    not = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Not", (a) => `!${a}`));
    };
    neg = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Neg", (a) => `-${a}`));
    };
    reciprocal = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Reciprocal", (a) => `1.0/${a}`));
    };
    relu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Relu",
          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > vec4<${dataType}>(0.0))`
        )
      );
    };
    sigmoid = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sigmoid", (a) => `(1.0 / (1.0 + exp(-${a})))`));
    };
    parseHardSigmoidAttributes = (attributes) => createAttributeWithCacheKey(
      attributes
    );
    hardSigmoid = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "HardSigmoid",
          (a) => `max(vec4<${dataType}>(0.0), min(vec4<${dataType}>(1.0), ${attributes.alpha} * ${a} + vec4<${dataType}>(${attributes.beta})))`,
          void 0,
          attributes.cacheKey
        )
      );
    };
    sin = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sin", "sin"));
    };
    sinh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sinh", "sinh"));
    };
    sqrt = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sqrt", "sqrt"));
    };
    tan = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Tan", "tan"));
    };
    tanhExpression = (a) => `sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`;
    tanh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Tanh", tanhExpression));
    };
    fastGeluImpl = (varType = "f32") => `
const fast_gelu_a: ${varType} = 0.5;
const fast_gelu_b: ${varType} = 0.7978845608028654;
const fast_gelu_c: ${varType} = 0.035677408136300125;

fn tanh_v(v: vec4<${varType}>) -> vec4<${varType}> {
  return ${tanhExpression("v")};
}
`;
    fastGeluExpression = (x) => `(fast_gelu_a + fast_gelu_a * tanh_v(${x} * (fast_gelu_c * ${x} * ${x} + fast_gelu_b))) * ${x}`;
    fastGelu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "FastGelu",
          fastGeluExpression,
          fastGeluImpl(dataType),
          void 0,
          context.inputs[0].dataType
        )
      );
    };
    thresholdedRelu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "ThresholdedRelu",
          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,
          `const thresholded_relu_alpha_ = vec4<${dataType}>(${attributes.alpha});`,
          attributes.cacheKey
        )
      );
      return 0;
    };
    log = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Log", "log"));
    };
    quickGeluImpl = (varType, alpha) => `
const alpha = vec4<${varType}>(${alpha});
const one = ${varType}(1.0);
const zero = ${varType}(0.0);

fn quick_gelu_impl(x: vec4<${varType}>) -> vec4<${varType}> {
  let v = x *alpha;
  var x1 : vec4<${varType}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`;
    quickGeluExpression = (x) => `quick_gelu_impl(${x})`;
    quickgelu = (context, attributes) => {
      const dType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "QuickGelu",
          quickGeluExpression,
          quickGeluImpl(dType, attributes.alpha),
          attributes.cacheKey,
          context.inputs[0].dataType
        )
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts
var validateInputs6, createBiasSplitGeluProgramInfo, biasSplitGelu;
var init_bias_split_gelu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"() {
    "use strict";
    init_util();
    init_common();
    init_unary_op();
    validateInputs6 = (inputs) => {
      if (inputs[0].dims.length !== 3) {
        throw new Error("input should have 3 dimensions");
      }
      if (![2560, 5120, 10240].includes(inputs[0].dims[2])) {
        throw new Error("hidden state should be 2560, 5120 or 10240");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("bias is expected to have 1 dimensions");
      }
      if (inputs[0].dims[2] !== inputs[1].dims[0]) {
        throw new Error("last dimension of input and bias are not the same");
      }
    };
    createBiasSplitGeluProgramInfo = (inputs) => {
      const outputShape = inputs[0].dims.slice();
      outputShape[2] = outputShape[2] / 2;
      const input = inputVariable("input", inputs[0].dataType, inputs[0].dims, 4);
      const bias = inputVariable("bias", inputs[0].dataType, [inputs[0].dims[2]], 4);
      const output = outputVariable("output", inputs[0].dataType, outputShape, 4);
      const outputSize = ShapeUtil.size(outputShape) / 4;
      const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
      const getShaderSource = (shaderHelper) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${inputs[0].dims[2] / 4 / 2}u;

  ${shaderHelper.declareVariables(input, bias, output)}

  ${erfImpl(dataType)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${output.setByOffset("global_idx", "valueLeft * geluRight")}
  }`;
      return {
        name: "BiasSplitGelu",
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) }
        }),
        getShaderSource
      };
    };
    biasSplitGelu = (context) => {
      validateInputs6(context.inputs);
      context.compute(createBiasSplitGeluProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/binary-op.ts
var createBinaryOpProgramShader, createBinaryOpProgramInfo, runBinaryOp, add, div, equal, mul, pow, sub, greater, less, greaterOrEqual, lessOrEqual;
var init_binary_op = __esm({
  "web/lib/wasm/jsep/webgpu/ops/binary-op.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    createBinaryOpProgramShader = (shaderHelper, dimsA, dimsB, dimsOutput, vectorize, doBroadcast, sharedDimensionDivisibleBy4, funcCall, typeA, typeB, typeOutput, additionalImplementation) => {
      let expressionScalar;
      let expressionVector;
      if (typeof funcCall === "string") {
        expressionScalar = expressionVector = (a2, b2) => `${funcCall}((${a2}),(${b2}))`;
      } else if (typeof funcCall === "function") {
        expressionScalar = expressionVector = funcCall;
      } else {
        expressionScalar = funcCall.scalar;
        expressionVector = funcCall.vector;
      }
      const output = outputVariable("outputData", typeOutput, dimsOutput.length, 4);
      const a = inputVariable("aData", typeA, dimsA.length, 4);
      const b = inputVariable("bData", typeB, dimsB.length, 4);
      let assignment;
      if (vectorize) {
        if (doBroadcast) {
          const isAOneElement = ShapeUtil.size(dimsA) === 1;
          const isBOneElement = ShapeUtil.size(dimsB) === 1;
          const aLastDimDivisibleBy4 = dimsA.length > 0 && dimsA[dimsA.length - 1] % 4 === 0;
          const bLastDimDivisibleBy4 = dimsB.length > 0 && dimsB[dimsB.length - 1] % 4 === 0;
          if (isAOneElement || isBOneElement) {
            assignment = output.setByOffset(
              "global_idx",
              expressionVector(
                isAOneElement ? `${a.type.value}(${a.getByOffset("0")}.x)` : a.getByOffset("global_idx"),
                isBOneElement ? `${b.type.value}(${b.getByOffset("0")}.x)` : b.getByOffset("global_idx")
              )
            );
          } else {
            assignment = `
            let outputIndices = ${output.offsetToIndices("global_idx * 4u")};
            let offsetA = ${a.broadcastedIndicesToOffset("outputIndices", output)};
            let offsetB = ${b.broadcastedIndicesToOffset("outputIndices", output)};
            ${output.setByOffset(
              "global_idx",
              expressionVector(
                sharedDimensionDivisibleBy4 || aLastDimDivisibleBy4 ? a.getByOffset("offsetA / 4u") : `${a.type.value}(${a.getByOffset("offsetA / 4u")}[offsetA % 4u])`,
                sharedDimensionDivisibleBy4 || bLastDimDivisibleBy4 ? b.getByOffset("offsetB / 4u") : `${b.type.value}(${b.getByOffset("offsetB / 4u")}[offsetB % 4u])`
              )
            )}
          `;
          }
        } else {
          assignment = output.setByOffset(
            "global_idx",
            expressionVector(a.getByOffset("global_idx"), b.getByOffset("global_idx"))
          );
        }
      } else {
        if (!doBroadcast) {
          throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
        }
        const singleAssignment = (resStr, x, typeCast = "") => {
          const expressionA = `aData[indexA${x}][componentA${x}]`;
          const expressionB = `bData[indexB${x}][componentB${x}]`;
          return `
            let outputIndices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${a.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let offsetB${x} = ${b.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expressionScalar(expressionA, expressionB)});
          `;
        };
        if (typeOutput === 9 /* bool */) {
          assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
        } else {
          assignment = `
            ${singleAssignment("outputData[global_idx]", 0)}
            ${singleAssignment("outputData[global_idx]", 1)}
            ${singleAssignment("outputData[global_idx]", 2)}
            ${singleAssignment("outputData[global_idx]", 3)}
          `;
        }
      }
      return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(a, b, output)}

        ${additionalImplementation ?? ""}

        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
    };
    createBinaryOpProgramInfo = (name, cacheKey, a, b, funcCall, additionalImplementation, outputDataType = a.dataType) => {
      const aDims = a.dims.map((x) => Number(x) ?? 1);
      const bDims = b.dims.map((x) => Number(x) ?? 1);
      const isBroadcast = !ShapeUtil.areEqual(aDims, bDims);
      let outputShape = aDims;
      let outputSize = ShapeUtil.size(aDims);
      let vectorize = false;
      let sharedDimensionDivisibleBy4 = false;
      const cacheKeyAux = [isBroadcast];
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(aDims, bDims, false);
        if (!calculatedShape) {
          throw new Error("Can't perform binary op on the given tensors");
        }
        outputShape = calculatedShape.slice();
        outputSize = ShapeUtil.size(outputShape);
        const isAOneElement = ShapeUtil.size(aDims) === 1;
        const isBOneElement = ShapeUtil.size(bDims) === 1;
        const aLastDimDivisibleBy4 = aDims.length > 0 && aDims[aDims.length - 1] % 4 === 0;
        const bLastDimDivisibleBy4 = bDims.length > 0 && bDims[bDims.length - 1] % 4 === 0;
        cacheKeyAux.push(isAOneElement);
        cacheKeyAux.push(isBOneElement);
        cacheKeyAux.push(aLastDimDivisibleBy4);
        cacheKeyAux.push(bLastDimDivisibleBy4);
        let sharedDimension = 1;
        for (let i = 1; i < outputShape.length; i++) {
          const dimA = aDims[aDims.length - i];
          const dimB = bDims[bDims.length - i];
          if (dimA === dimB) {
            sharedDimension *= dimA;
          } else {
            break;
          }
        }
        if (sharedDimension % 4 === 0) {
          sharedDimensionDivisibleBy4 = true;
          vectorize = true;
        } else if (isAOneElement || isBOneElement || aLastDimDivisibleBy4 || bLastDimDivisibleBy4) {
          vectorize = true;
        }
      } else {
        vectorize = true;
      }
      cacheKeyAux.push(vectorize);
      return {
        name,
        shaderCache: {
          hint: cacheKey + cacheKeyAux.map((x) => x.toString()).join("_"),
          inputDependencies: ["rank", "rank"]
        },
        getShaderSource: (shaderHelper) => createBinaryOpProgramShader(
          shaderHelper,
          aDims,
          bDims,
          outputShape,
          vectorize,
          isBroadcast,
          sharedDimensionDivisibleBy4,
          funcCall,
          a.dataType,
          b.dataType,
          outputDataType,
          additionalImplementation
        ),
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64 / 4
            /* component size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(outputShape) / 4) },
            ...createTensorShapeVariables(aDims, bDims, outputShape)
          ]
        })
      };
    };
    runBinaryOp = (context, name, funcCall, additionalImplementation, cacheKey, outputDataType) => {
      context.compute(
        createBinaryOpProgramInfo(
          name,
          cacheKey ?? "",
          context.inputs[0],
          context.inputs[1],
          funcCall,
          additionalImplementation,
          outputDataType
        )
      );
    };
    add = (context) => {
      runBinaryOp(context, "Add", (a, b) => `${a}+${b}`);
    };
    div = (context) => {
      runBinaryOp(context, "Div", (a, b) => `${a}/${b}`);
    };
    equal = (context) => {
      runBinaryOp(
        context,
        "Equal",
        { scalar: (a, b) => `u32(${a}==${b})`, vector: (a, b) => `vec4<u32>(${a}==${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    mul = (context) => {
      runBinaryOp(context, "Mul", (a, b) => `${a}*${b}`);
    };
    pow = (context) => {
      const type = inputVariable("input", context.inputs[0].dataType, context.inputs[0].dims).type.value;
      const roundStr = type === "i32" ? "round" : "";
      runBinaryOp(
        context,
        "Pow",
        { scalar: (a, b) => `pow_custom(${a},${b})`, vector: (a, b) => `pow_vector_custom(${a},${b})` },
        `
    fn pow_custom(a : ${type}, b : ${type}) -> ${type} {
      if (b == ${type}(0.0)) {
        return ${type}(1.0);
      } else if (a < ${type}(0.0) && f32(b) != floor(f32(b))) {
        return ${type}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${type}(1.0), round(f32(abs(b) % ${type}(2.0))) != 1.0) * ${type}(${roundStr}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${type}>, b : vec4<${type}>) -> vec4<${type}> {
      // TODO: implement vectorized pow
      return vec4<${type}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `
      );
    };
    sub = (context) => {
      runBinaryOp(context, "Sub", (a, b) => `${a}-${b}`);
    };
    greater = (context) => {
      runBinaryOp(
        context,
        "Greater",
        { scalar: (a, b) => `u32(${a}>${b})`, vector: (a, b) => `vec4<u32>(${a}>${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    less = (context) => {
      runBinaryOp(
        context,
        "Less",
        { scalar: (a, b) => `u32(${a}<${b})`, vector: (a, b) => `vec4<u32>(${a}<${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    greaterOrEqual = (context) => {
      runBinaryOp(
        context,
        "GreaterOrEqual",
        { scalar: (a, b) => `u32(${a}>=${b})`, vector: (a, b) => `vec4<u32>(${a}>=${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    lessOrEqual = (context) => {
      runBinaryOp(
        context,
        "LessOrEqual",
        { scalar: (a, b) => `u32(${a}<=${b})`, vector: (a, b) => `vec4<u32>(${a}<=${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/concat.ts
var validateInputs7, calculateInputIndexImpl, assignOutputData, createConcatProgramInfo, concat, parseConcatAttributes;
var init_concat = __esm({
  "web/lib/wasm/jsep/webgpu/ops/concat.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs7 = (inputs, axis) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      const referenceIndex = 0;
      const referenceInput = inputs[referenceIndex];
      const inputType = referenceInput.dataType;
      const inputRank = referenceInput.dims.length;
      inputs.forEach((input, i) => {
        if (i === referenceIndex) {
          return;
        }
        if (input.dataType !== inputType) {
          throw new Error("input tensors should be one type");
        }
        if (input.dims.length !== inputRank) {
          throw new Error("input tensors should have the same shape");
        }
        input.dims.forEach((dim, i2) => {
          if (i2 !== axis && dim !== referenceInput.dims[i2]) {
            throw new Error("non concat dimensions must match");
          }
        });
      });
    };
    calculateInputIndexImpl = (numberOfTensors, sizeInConcatAxisStr) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${numberOfTensors}u>(${sizeInConcatAxisStr});
    for (var i: u32 = 0u; i < ${numberOfTensors}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${numberOfTensors}u;
  }`;
    assignOutputData = (inputs, output) => {
      const numberOfTensors = inputs.length;
      const codeLines = [];
      for (let i = 0; i < numberOfTensors; ++i) {
        const returnSnippet = output.setByOffset("global_idx", inputs[i].getByIndices("indices"));
        if (numberOfTensors === 1) {
          codeLines.push(returnSnippet);
        } else if (i === 0) {
          codeLines.push(`if (inputIndex == ${i}u) { ${returnSnippet} }`);
        } else if (i === numberOfTensors - 1) {
          codeLines.push(`else { ${returnSnippet} }`);
        } else {
          codeLines.push(`else if (inputIndex == ${i}) { ${returnSnippet} }`);
        }
      }
      return codeLines.join("\n");
    };
    createConcatProgramInfo = (inputs, adjustedAxis, outputShape, dataType) => {
      const outputSize = ShapeUtil.size(outputShape);
      const sizeInConcatAxis = new Array(inputs.length);
      const inputVars = new Array(inputs.length);
      let previousSum = 0;
      const inputDependencies = [];
      const inputRanks = [];
      const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }];
      for (let i = 0; i < inputs.length; ++i) {
        previousSum += inputs[i].dims[adjustedAxis];
        sizeInConcatAxis[i] = previousSum;
        inputRanks.push(inputs[i].dims.length);
        inputVars[i] = inputVariable(`input${i}`, dataType, inputRanks[i]);
        inputDependencies.push("rank");
        programUniforms.push({ type: 12 /* uint32 */, data: sizeInConcatAxis[i] });
      }
      for (let i = 0; i < inputs.length; ++i) {
        programUniforms.push(...createTensorShapeVariables(inputs[i].dims));
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const output = outputVariable("output", dataType, outputShape.length);
      const indicesAxis = output.indicesGet("indices", adjustedAxis);
      const sizeInConcatAxisStr = Array.from(Array(sizeInConcatAxis.length).keys()).map((i) => `uniforms.sizeInConcatAxis${i}`).join(",");
      const getShaderSource = (shaderHelper) => `

  ${(() => {
        shaderHelper.registerUniform("outputSize", "u32");
        for (let i = 0; i < inputs.length; i++) {
          shaderHelper.registerUniform(`sizeInConcatAxis${i}`, "u32");
        }
        return shaderHelper.declareVariables(...inputVars, output);
      })()}

  ${calculateInputIndexImpl(sizeInConcatAxis.length, sizeInConcatAxisStr)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${output.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${indicesAxis});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${sizeInConcatAxis.length}u>(${sizeInConcatAxisStr});
      ${indicesAxis} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${assignOutputData(inputVars, output)}
  }`;
      return {
        name: "Concat",
        shaderCache: { hint: `${adjustedAxis}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    concat = (context, attributes) => {
      const inputs = context.inputs;
      const inputShape = inputs[0].dims;
      const adjustedAxis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      validateInputs7(inputs, adjustedAxis);
      const outputShape = inputShape.slice();
      outputShape[adjustedAxis] = inputs.reduce(
        (sum, input) => sum + (input.dims.length > adjustedAxis ? input.dims[adjustedAxis] : 0),
        0
      );
      const nonEmptyInputs = inputs.filter((input) => ShapeUtil.size(input.dims) > 0);
      context.compute(createConcatProgramInfo(nonEmptyInputs, adjustedAxis, outputShape, inputs[0].dataType), {
        inputs: nonEmptyInputs
      });
    };
    parseConcatAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
  }
});

// web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts
var getActivationSnippet, appendActivationUniformsData, appendActivationUniforms, parseInternalActivationAttributes;
var init_fuse_utils = __esm({
  "web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    getActivationSnippet = (attributes, valueType, baseType = "f32") => {
      switch (attributes.activation) {
        case "Relu":
          return `value = max(value, ${valueType}(0.0));`;
        case "Sigmoid":
          return `value = (${valueType}(1.0) / (${valueType}(1.0) + exp(-value)));`;
        case "Clip":
          return `value = clamp(value, ${valueType}(${baseType}(uniforms.clip_min)), ${valueType}(${baseType}(uniforms.clip_max)));`;
        case "HardSigmoid":
          return `value = max(${valueType}(0.0), min(${valueType}(1.0), ${baseType}(uniforms.alpha) * value + ${baseType}(uniforms.beta)));`;
        case "LeakyRelu":
          return `value = select(${baseType}(uniforms.alpha) * value, value, value >= ${valueType}(0.0));`;
        case "Tanh":
          return `let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;
        case "":
          return "";
        // TODO: adding other activations that can be fused.
        default:
          throw new Error(`Unsupported activation ${attributes.activation}`);
      }
    };
    appendActivationUniformsData = (attributes, programUniform) => {
      if (attributes.activation === "Clip") {
        programUniform.push(
          { type: 1 /* float */, data: attributes.clipMax },
          { type: 1 /* float */, data: attributes.clipMin }
        );
      } else if (attributes.activation === "HardSigmoid") {
        programUniform.push(
          { type: 1 /* float */, data: attributes.alpha },
          { type: 1 /* float */, data: attributes.beta }
        );
      } else if (attributes.activation === "LeakyRelu") {
        programUniform.push({ type: 1 /* float */, data: attributes.alpha });
      }
    };
    appendActivationUniforms = (attributes, uniforms) => {
      if (attributes.activation === "Clip") {
        uniforms.push({ name: "clip_max", type: "f32" }, { name: "clip_min", type: "f32" });
      } else if (attributes.activation === "HardSigmoid") {
        uniforms.push({ name: "alpha", type: "f32" }, { name: "beta", type: "f32" });
      } else if (attributes.activation === "LeakyRelu") {
        uniforms.push({ name: "alpha", type: "f32" });
      }
    };
    parseInternalActivationAttributes = (attributes) => {
      const activation = attributes?.activation || "";
      if (activation === "HardSigmoid") {
        const [alpha, beta] = attributes?.activation_params || [0.2, 0.5];
        return { activation, alpha, beta };
      } else if (activation === "Clip") {
        const [clipMin, clipMax] = attributes?.activation_params || [MIN_CLIP, MAX_CLIP];
        return { activation, clipMax, clipMin };
      } else if (activation === "LeakyRelu") {
        const [alpha] = attributes?.activation_params || [0.01];
        return { activation, alpha };
      }
      return { activation };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts
var typeSnippet, biasSnippet;
var init_activation_util = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"() {
    "use strict";
    typeSnippet = (component, dataType) => {
      switch (component) {
        case 1:
          return dataType;
        case 2:
          return `vec2<${dataType}>`;
        case 3:
          return `vec3<${dataType}>`;
        case 4:
          return `vec4<${dataType}>`;
        default:
          throw new Error(`${component}-component is not supported.`);
      }
    };
    biasSnippet = (hasBias) => `
      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts
var utilFunctions;
var init_conv_util = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"() {
    "use strict";
    utilFunctions = (strideStr) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${strideStr}.x), i32(${strideStr}.y), i32(${strideStr}.z), 1));
}
`;
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmul-shaders.ts
var convertOutputBatchIndicesToInputBatchIndices, createNaiveMatmulProgramInfo;
var init_matmul_shaders = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmul-shaders.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_fuse_utils();
    convertOutputBatchIndicesToInputBatchIndices = (targetIndicesName, inputVariable2, inputBatchRank, outputBatchRank, batchIndicesName) => {
      const extendingInputRank = outputBatchRank - inputBatchRank;
      return `
      ${Array.from({ length: inputBatchRank }).map(
        (_, i) => `
      if (${getElementAt(inputVariable2.shape, i, inputVariable2.rank)} != 1) {
        ${inputVariable2.indicesSet(targetIndicesName, i, getElementAt(batchIndicesName, i + extendingInputRank, outputBatchRank))}
      } else {
        ${inputVariable2.indicesSet(targetIndicesName, i, 0)}
      }`
      ).join("")}
`;
    };
    createNaiveMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const M = aShape[aShape.length - 2];
      const N = bShape[bShape.length - 1];
      const K = aShape[aShape.length - 1];
      const components = getMaxComponents(N);
      const aComponents = getMaxComponents(K);
      const outputNumber = getMaxComponents(M);
      const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const hasBias = inputs.length > 2;
      const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
      const batchSize = ShapeUtil.size(outerDims);
      const outputShapeInShader = [batchSize, M, N];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: K }
      ];
      appendActivationUniformsData(activationAttributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(outerDims, aShape, bShape));
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      }
      programUniforms.push(...createTensorShapeVariables(outputShapeInShader));
      const getShaderSource = (shaderHelper) => {
        const batchDims = internalVariable("batch_dims", inputs[0].dataType, outerDims.length);
        const a = inputVariable("a", inputs[0].dataType, aShape.length, aComponents);
        const b = inputVariable("b", inputs[1].dataType, bShape.length, components);
        const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
        const inputVariables = [a, b];
        let processBias = "";
        if (hasBias) {
          const biasComponents = isChannelsLast ? components : 1;
          inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
          processBias = `${isChannelsLast ? `value += bias[col / ${biasComponents}];` : `value += ${output.type.value}(bias[row + i]);`}`;
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" }
        ];
        appendActivationUniforms(activationAttributes, uniforms);
        const calcResult = () => {
          let calcStr = `var a_data: ${a.type.value};`;
          for (let i = 0; i < aComponents; i++) {
            calcStr += `
              let b_data${i} = b[(b_offset + (k + ${i}) * uniforms.N + col) / ${components}];`;
          }
          for (let i = 0; i < outputNumber; i++) {
            calcStr += `a_data = a[(a_offset + (row + ${i}) * uniforms.K + k) / ${aComponents}];`;
            for (let j = 0; j < aComponents; j++) {
              calcStr += `
            values[${i}] = fma(${b.type.value}(a_data${aComponents === 1 ? "" : `[${j}]`}), b_data${j}, values[${i}]);
`;
            }
          }
          return calcStr;
        };
        return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${components})) * ${components};
    var index1 = global_idx / (uniforms.N / ${components});
    let stride1 = uniforms.M / ${outputNumber};
    let row = (index1 % stride1) * ${outputNumber};
    let batch = index1 / stride1;

    ${outputShape.length === 2 ? "" : `let batch_indices = ${batchDims.offsetToIndices("batch")};`}

    var a_indices: ${a.type.indices};
    ${convertOutputBatchIndicesToInputBatchIndices("a_indices", a, a.rank - 2, batchDims.rank, "batch_indices")}
    ${a.indicesSet("a_indices", a.rank - 2, 0)}
    ${a.indicesSet("a_indices", a.rank - 1, 0)}
    let a_offset = ${a.indicesToOffset("a_indices")};

    var b_indices: ${b.type.indices};
    ${convertOutputBatchIndicesToInputBatchIndices("b_indices", b, b.rank - 2, batchDims.rank, "batch_indices")}
    ${b.indicesSet("b_indices", b.rank - 2, 0)}
    ${b.indicesSet("b_indices", b.rank - 1, 0)}
    let b_offset = ${b.indicesToOffset("b_indices")};
    var values: array<${output.type.value}, ${outputNumber}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${aComponents}) {
      ${calcResult()}
    }
    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      let cur_indices = ${output.type.indices}(batch, row + i, col);
      let offset = ${output.indicesToOffset("cur_indices")};
      ${output.setByOffset(`offset / ${components}`, "value")};
    }
  }
  `;
      };
      return {
        name: "MatMulNaive",
        shaderCache: {
          hint: `${activationAttributes.activation};${components};${aComponents};${outputNumber};${isChannelsLast}`,
          inputDependencies: hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts
var writeDataToSubAVec4Snippet, calculateResultSnippet, makeMatMulPackedVec4Source, writeDataToSubASnippet, readDataFromSubASnippet, makeMatMulPackedSource, matMulReadWriteFnSource, createMatmulProgramInfo;
var init_matmul_packed_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_fuse_utils();
    init_matmul_shaders();
    init_activation_util();
    writeDataToSubAVec4Snippet = (transpose2, batchDims) => {
      if (transpose2) {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
      } else {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
      }
    };
    calculateResultSnippet = (transposeA, innerElementSize) => {
      if (transposeA) {
        return `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${innerElementSize === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`;
      } else {
        return `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;
      }
    };
    makeMatMulPackedVec4Source = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32) => {
      const tileAOuter = workgroupSize[1] * workPerThread[1];
      const tileBOuter = workgroupSize[0] * workPerThread[0];
      const tileAWidth = transposeA ? tileAOuter : tileInner;
      const tileAHight = transposeA ? tileInner : tileAOuter;
      const innerElementSize = tileAWidth / workgroupSize[0];
      const rowPerThreadB = tileInner / workgroupSize[1];
      if (!((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4)) {
        throw new Error(`If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
      Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
  tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);
      }
      return `
var<workgroup> mm_Asub: array<array<vec${innerElementSize}<${type}>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
var<workgroup> mm_Bsub: array<array<vec4<${type}>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

const rowPerThread = ${workPerThread[1]};
const colPerThread = ${workPerThread[0]};
const innerElementSize = ${innerElementSize};
const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${splitK ? "0" : "i32(globalId.z)"};
  ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

  var acc: array<vec4<${type}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${rowPerThreadB};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${writeDataToSubAVec4Snippet(transposeA, batchDims)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${batchDims ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${innerElementSize === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${calculateResultSnippet(transposeA, innerElementSize)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
    };
    writeDataToSubASnippet = (transpose2, batchDims) => {
      if (transpose2) {
        return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
      } else {
        return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
      }
    };
    readDataFromSubASnippet = (transposeA) => transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
    makeMatMulPackedSource = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) => {
      const tileAOuter = workPerThread[1] * workgroupSize[1];
      const tileBOuter = workPerThread[0] * workgroupSize[0];
      const tileAWidth = transposeA ? tileAOuter : tileInner;
      const tileAHight = transposeA ? tileInner : tileAOuter;
      if (!(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0)) {
        throw new Error(
          `tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`
        );
      }
      const rowPerThreadA = tileAHight / workgroupSize[1];
      const colPerThreadA = tileAWidth / workgroupSize[0];
      const rowPerThreadB = tileInner / workgroupSize[1];
      const matmulSnippet = sequentialAccessByThreads ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
    let globalColStart = i32(workgroupId.x) * ${tileBOuter};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {
        for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {
          ${writeDataToSubASnippet(transposeA, batchDims)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {
            for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${batchDims ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${type}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

let tileRowA = i32(localId.y) * ${rowPerThreadA};
let tileColA = i32(localId.x) * ${colPerThreadA};
let tileRowB = i32(localId.y) * ${rowPerThreadB};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${writeDataToSubASnippet(transposeA, batchDims)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${batchDims ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${type}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${readDataFromSubASnippet(transposeA)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
      return `
  var<workgroup> mm_Asub : array<array<${type}, ${tileAWidth}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<${type}, ${tileBOuter}>, ${tileInner}>;
  const rowPerThread = ${workPerThread[1]};
  const colPerThread = ${workPerThread[0]};
  const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${splitK ? "0" : "i32(globalId.z)"};
    ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

    var acc : array<array<${type}, colPerThread>, rowPerThread>;
    ${matmulSnippet}
  }
`;
    };
    matMulReadWriteFnSource = (component, hasBias, applyActivation, variables, isChannelsLast = false) => {
      const [batchVariable, aVariable, bVariable, outputVariable2] = variables;
      const dataType = tensorTypeToWsglStorageType(variables[0].type.tensor);
      const source = `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
        component,
        dataType
      )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${aVariable.type.indices};
        ${convertOutputBatchIndicesToInputBatchIndices(
        "aIndices",
        aVariable,
        aVariable.rank - 2,
        batchVariable.rank,
        "batchIndices"
      )}
        ${aVariable.indicesSet("aIndices", aVariable.rank - 2, "u32(row)")}
        ${aVariable.indicesSet("aIndices", aVariable.rank - 1, "u32(colIn)")}
        value = ${aVariable.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
        component,
        dataType
      )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${bVariable.type.indices};
        ${convertOutputBatchIndicesToInputBatchIndices(
        "bIndices",
        bVariable,
        bVariable.rank - 2,
        batchVariable.rank,
        "batchIndices"
      )}
        ${bVariable.indicesSet("bIndices", bVariable.rank - 2, "u32(row)")}
        ${bVariable.indicesSet("bIndices", bVariable.rank - 1, "u32(colIn)")}
        value = ${bVariable.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component, dataType)}) {
      let col = colIn * ${component};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${hasBias ? `value = value + ${isChannelsLast ? "bias[colIn]" : `${typeSnippet(component, dataType)}(bias[row])`};` : ""}
        ${applyActivation}
        ${outputVariable2.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
      return source;
    };
    createMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const outerDimsA = aShape.slice(0, -2);
      const outerDimsB = bShape.slice(0, -2);
      const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
      const batchSize = ShapeUtil.size(outerDims);
      const dimAOuter = aShape[aShape.length - 2];
      const dimInner = aShape[aShape.length - 1];
      const dimBOuter = bShape[bShape.length - 1];
      const isVec4 = dimInner % 4 === 0 && dimBOuter % 4 === 0;
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const workgroupSize = [8, 8, 1];
      const dispatch = [
        Math.ceil(dimBOuter / workgroupSize[0] / elementsPerThread[0]),
        Math.ceil(dimAOuter / workgroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workgroupSize[2] / elementsPerThread[2])
      ];
      const components = isVec4 ? 4 : 1;
      const aShapeTemp = [...outerDimsA, dimAOuter, dimInner / components];
      const aRank = aShapeTemp.length;
      const bShapeTemp = [...outerDimsB, dimInner, dimBOuter / components];
      const bRank = bShapeTemp.length;
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner }
      ];
      appendActivationUniformsData(activationAttributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(outerDims, aShapeTemp, bShapeTemp));
      const inputDependencies = ["rank", "rank"];
      const hasBias = inputs.length > 2;
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const batchRank = outerDims.length;
        const batchDims = internalVariable("batchDims", inputs[0].dataType, batchRank, 1);
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const A = inputVariable("a", inputs[0].dataType, aRank, components);
        const B = inputVariable("b", inputs[1].dataType, bRank, components);
        const output = outputVariable("result", inputs[0].dataType, outputShapeTemp.length, components);
        const inputVariables = [A, B];
        if (hasBias) {
          const biasComponents = isChannelsLast ? components : 1;
          inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
        }
        const uniforms = [
          { name: "dim_a_outer", type: "i32" },
          { name: "dim_b_outer", type: "i32" },
          { name: "dim_inner", type: "i32" }
        ];
        appendActivationUniforms(activationAttributes, uniforms);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
        const declareFunctions = matMulReadWriteFnSource(
          components,
          hasBias,
          applyActivation,
          [batchDims, A, B, output],
          isChannelsLast
        );
        return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${declareFunctions}
  ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workgroupSize, dataType, batchDims) : makeMatMulPackedSource(elementsPerThread, workgroupSize, dataType, batchDims)}
                   `;
      };
      return {
        name: "MatMul",
        shaderCache: {
          hint: `${elementsPerThread};${activationAttributes.activation};${isVec4};${isChannelsLast}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts
var conv2dCommonSnippet, createConv2DMatMulProgramInfo;
var init_conv2d_mm_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_common();
    init_fuse_utils();
    init_activation_util();
    init_conv_util();
    init_matmul_packed_webgpu();
    conv2dCommonSnippet = (isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, attributes, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4, dataType = "f32") => {
      const getXSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "resData = x[xIndex];";
          case 3:
            return `resData = vec3<${dataType}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
          case 4:
            return "resData = x[xIndex / 4];";
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const getWSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
          case 4:
            return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const coordASnippet = isChannelsLast ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `;
      const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
      const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
      const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
      const row = isChannelsLast ? "row" : "col";
      const col = isChannelsLast ? "col" : "row";
      const readXSnippet = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${row} / outWidth;
    let outCol = ${row} % outWidth;

    let WRow = ${col} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${col} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${col} % inChannels;
    var resData = ${typeSnippet(innerElementSizeX, dataType)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${xHeight} && xCol >= 0 && xCol < ${xWidth}) {
      ${coordASnippet}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${getXSnippet(innerElementSizeX)}
    }
    return resData;`;
      const sampleX = isChannelsLast ? fitAOuter && fitInner ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);` : fitInner && fitBOuter ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);`;
      const sampleW = isChannelsLast ? fitInner && fitBOuter ? getWSnippet(innerElementSizeW) : `
    let col = colIn * ${innerElementSizeW};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${getWSnippet(innerElementSizeW)}
    }
    return ${typeSnippet(innerElementSizeW, dataType)}(0.0);` : `
    let col = colIn * ${innerElementSizeW};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${getWSnippet(innerElementSizeW)}
    }
    return ${typeSnippet(innerElementSizeW, dataType)}(0.0);`;
      const resType = typeSnippet(innerElementSize, dataType);
      const aType = isChannelsLast ? typeSnippet(innerElementSizeX, dataType) : typeSnippet(innerElementSizeW, dataType);
      const bType = isChannelsLast ? typeSnippet(innerElementSizeW, dataType) : typeSnippet(innerElementSizeX, dataType);
      const applyActivation = getActivationSnippet(attributes, resType, dataType);
      const userCode = `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${aType} {
      ${isChannelsLast ? sampleX : sampleW}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${bType} {
      ${isChannelsLast ? sampleW : sampleX}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${resType}) {
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
      return userCode;
    };
    createConv2DMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads, squeezeOutputShapeFunction) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
      const batchSize = outputShape[0];
      const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
      const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
      const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
      const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
      const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
      const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
      const workGroupSize = [8, 8, 1];
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const dispatch = [
        Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
        Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
      ];
      LOG_DEBUG("verbose", () => `[conv2d_mm_webgpu] dispatch = ${dispatch}`);
      const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
      const tileAOuter = workGroupSize[1] * elementsPerThread[1];
      const tileBOuter = workGroupSize[0] * elementsPerThread[0];
      const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
      const fitAOuter = dimAOuter % tileAOuter === 0;
      const fitBOuter = dimBOuter % tileBOuter === 0;
      const fitInner = dimInner % tileInner === 0;
      const elementsSize = isVec4 ? [innerElementSize, 4, 4] : [1, 1, 1];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner },
        { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] },
        { type: 6 /* int32 */, data: attributes.strides },
        { type: 6 /* int32 */, data: attributes.dilations }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
      const inputDependencies = ["rank", "rank"];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "dim_a_outer", type: "i32" },
          { name: "dim_b_outer", type: "i32" },
          { name: "dim_inner", type: "i32" },
          { name: "pad", type: "i32", length: 2 },
          { name: "stride", type: "i32", length: 2 },
          { name: "dilation", type: "i32", length: 2 }
        ];
        appendActivationUniforms(attributes, uniforms);
        const components = isVec4 ? 4 : 1;
        const t = tensorTypeToWsglStorageType(inputs[0].dataType);
        let declareFunctions = `
      fn setOutputAtIndex(flatIndex : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        result[flatIndex] = ${isVec4 ? `vec4<${t}>` : t}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${isVec4 ? "/ 4" : ""}, value);
      }`;
        const x = inputVariable(
          "x",
          inputs[0].dataType,
          inputs[0].dims.length,
          innerElementSize === 3 ? 1 : innerElementSize
        );
        const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, components);
        const inputVariables = [x, w];
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        if (hasBias) {
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
          inputVariables.push(bias);
          declareFunctions += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
        }`;
        }
        return `
        ${utilFunctions("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${declareFunctions}
        ${conv2dCommonSnippet(
          isChannelsLast,
          fitAOuter,
          fitBOuter,
          fitInner,
          hasBias,
          attributes,
          elementsSize[0],
          elementsSize[1],
          elementsSize[2],
          t
        )}
        ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workGroupSize, t, void 0, !isChannelsLast, tileInner) : makeMatMulPackedSource(
          elementsPerThread,
          workGroupSize,
          t,
          void 0,
          !isChannelsLast,
          tileInner,
          false,
          void 0,
          sequentialAccessByThreads
        )}`;
      };
      return {
        name: "Conv2DMatMul",
        shaderCache: {
          hint: `${attributes.cacheKey};${innerElementSize};${isVec4};${fitAOuter};${fitBOuter};${fitInner};${tileAOuter};${tileBOuter};${tileInner}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
var arrayProduct, parse3TupleParam, getEffectiveFilterSize, computeDefaultPad, computeOutputShape4D, get3DPadAndOutInfo, computeConv3DInfo, createConv3DNaiveProgramInfo;
var init_conv3d_naive_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_util();
    init_common();
    init_fuse_utils();
    init_activation_util();
    arrayProduct = (arr) => {
      let product = 1;
      for (let i = 0; i < arr.length; i++) {
        product *= arr[i];
      }
      return product;
    };
    parse3TupleParam = (param) => typeof param === "number" ? [param, param, param] : param;
    getEffectiveFilterSize = (filterSize, dilation) => {
      if (dilation <= 1) {
        return filterSize;
      }
      return filterSize + (filterSize - 1) * (dilation - 1);
    };
    computeDefaultPad = (inputShape, fieldSize, stride, dilation = 1) => {
      const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
      return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
    };
    computeOutputShape4D = (inShape, filterShape, outChannels, strides, zeroPad) => {
      if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
      }
      const outShape = [0, 0, 0, outChannels];
      for (let index = 0; index < 3; index++) {
        if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
          outShape[index] = Math.trunc((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1);
        }
      }
      return outShape;
    };
    get3DPadAndOutInfo = (pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth) => {
      let padInfo;
      let outDepth;
      let outHeight;
      let outWidth;
      if (pad2 === "VALID") {
        pad2 = 0;
      }
      if (typeof pad2 === "number") {
        padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, front: pad2, back: pad2 };
        const outShape = computeOutputShape4D(
          [inDepth, inHeight, inWidth, 1],
          [filterDepth, filterHeight, filterWidth],
          1,
          [strideDepth, strideHeight, strideWidth],
          pad2
        );
        outDepth = outShape[0];
        outHeight = outShape[1];
        outWidth = outShape[2];
      } else if (Array.isArray(pad2)) {
        if (!pad2.every((val, _, arr) => val === arr[0])) {
          throw Error(`Unsupported padding parameter: ${pad2}`);
        }
        padInfo = { top: pad2[0], bottom: pad2[1], left: pad2[2], right: pad2[3], front: pad2[4], back: pad2[5] };
        const outShape = computeOutputShape4D(
          [inDepth, inHeight, inWidth, 1],
          [filterDepth, filterHeight, filterWidth],
          1,
          [strideDepth, strideHeight, strideWidth],
          pad2[0]
        );
        outDepth = outShape[0];
        outHeight = outShape[1];
        outWidth = outShape[2];
      } else if (pad2 === "SAME_UPPER") {
        outDepth = Math.ceil(inDepth / strideDepth);
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
        const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        const front = Math.floor(padAlongDepth / 2);
        const back = padAlongDepth - front;
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = { top, bottom, left, right, front, back };
      } else {
        throw Error(`Unknown padding parameter: ${pad2}`);
      }
      return { padInfo, outDepth, outHeight, outWidth };
    };
    computeConv3DInfo = (inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast") => {
      let batchSize, inDepth, inHeight, inWidth, inChannels;
      if (dataFormat === "channelsLast") {
        [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
      } else if (dataFormat === "channelsFirst") {
        [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      const [filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
      const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
      const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
      const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
      const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
      const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
      const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(
        pad2,
        inDepth,
        inHeight,
        inWidth,
        strideDepth,
        strideHeight,
        strideWidth,
        effectiveFilterDepth,
        effectiveFilterHeight,
        effectiveFilterWidth
      );
      const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
      let outShape = [0, 0, 0, 0, 0];
      if (dataFormat === "channelsFirst") {
        outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
      } else if (dataFormat === "channelsLast") {
        outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
      }
      return {
        batchSize,
        dataFormat,
        inDepth,
        inHeight,
        inWidth,
        inChannels,
        outDepth,
        outHeight,
        outWidth,
        outChannels,
        padInfo,
        strideDepth,
        strideHeight,
        strideWidth,
        filterDepth,
        filterHeight,
        filterWidth,
        effectiveFilterDepth,
        effectiveFilterHeight,
        effectiveFilterWidth,
        dilationDepth,
        dilationHeight,
        dilationWidth,
        inShape,
        outShape,
        filterShape
      };
    };
    createConv3DNaiveProgramInfo = (inputs, attributes, outputShape, filterDims, pads, dataFormat) => {
      const isChannelLast = dataFormat === "channelsLast";
      const inChannels = isChannelLast ? inputs[0].dims[3] : inputs[0].dims[1];
      const isVec4 = false;
      const workGroupSize = [64, 1, 1];
      const dispatchLayout = { x: outputShape.map((_, i) => i) };
      const dispatch = [Math.ceil(arrayProduct(dispatchLayout.x.map((d) => outputShape[d])) / workGroupSize[0]), 1, 1];
      LOG_DEBUG("verbose", () => `[conv3d_naive_webgpu] dispatch = ${dispatch}`);
      const innerElementSize = isVec4 ? isChannelLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: filterDims },
        { type: 12 /* uint32 */, data: pads },
        { type: 12 /* uint32 */, data: attributes.strides },
        { type: 12 /* uint32 */, data: attributes.dilations }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
      const inputDependencies = ["rank", "rank"];
      const hasBias = inputs.length === 3;
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "filter_dims", type: "u32", length: filterDims.length },
          { name: "pads", type: "u32", length: pads.length },
          { name: "strides", type: "u32", length: attributes.strides.length },
          { name: "dilations", type: "u32", length: attributes.dilations.length }
        ];
        appendActivationUniforms(attributes, uniforms);
        const components = isVec4 ? 4 : 1;
        const t = tensorTypeToWsglStorageType(inputs[0].dataType);
        const x = inputVariable(
          "x",
          inputs[0].dataType,
          inputs[0].dims.length,
          innerElementSize === 3 ? 1 : innerElementSize
        );
        const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
        const inputVariables = [x, w];
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        let declareFunctions = "";
        if (hasBias) {
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
          inputVariables.push(bias);
          declareFunctions += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[${isChannelLast ? getElementAt("coords", 4, 5) : getElementAt("coords", 1, 5)}${isVec4 ? "/ 4" : ""}];
        }`;
        }
        const resType = typeSnippet(innerElementSize, t);
        const applyActivation = getActivationSnippet(attributes, resType, t);
        return `
            ${declareFunctions}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
          ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
          ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${output.offsetToIndices("global_idx")};
              let batch = ${getElementAt("coords", 0, x.rank)};
              let d2 = ${isChannelLast ? getElementAt("coords", x.rank - 1, x.rank) : getElementAt("coords", 1, x.rank)};
              let xFRCCorner = vec3<u32>(${isChannelLast ? getElementAt("coords", 1, x.rank) : getElementAt("coords", 2, x.rank)},
              ${isChannelLast ? getElementAt("coords", 2, x.rank) : getElementAt("coords", 3, x.rank)},
              ${isChannelLast ? getElementAt("coords", 3, x.rank) : getElementAt("coords", 4, x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${isChannelLast ? getElementAt("uniforms.x_shape", 1, x.rank) : getElementAt("uniforms.x_shape", 2, x.rank)};
              let xShapeZ = ${isChannelLast ? getElementAt("uniforms.x_shape", 2, x.rank) : getElementAt("uniforms.x_shape", 3, x.rank)};
              let xShapeW = ${isChannelLast ? getElementAt("uniforms.x_shape", 3, x.rank) : getElementAt("uniforms.x_shape", 4, x.rank)};
              let xShapeU = ${isChannelLast ? getElementAt("uniforms.x_shape", 4, x.rank) : getElementAt("uniforms.x_shape", 1, x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${isChannelLast ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            ` : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${isChannelLast ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${isChannelLast ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      ` : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${isChannelLast ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      ` : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${hasBias ? "value = value + getBiasByOutputCoords(coords)" : ""};
              ${applyActivation}
              result[global_idx] = f32(value);
          }`;
      };
      return {
        name: "Conv3DNaive",
        shaderCache: { hint: `${attributes.cacheKey};${isChannelLast};${innerElementSize};${hasBias}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts
var createGroupedConvProgramInfo, createGroupedConvVectorizeProgramInfo;
var init_conv_grouped = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_fuse_utils();
    createGroupedConvProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const processBias = hasBias ? "value += b[output_channel];" : "";
      const xShape = inputs[0].dims;
      const wShape = inputs[1].dims;
      const isChannelLast = attributes.format === "NHWC";
      const outputChannels = isChannelLast ? outputShape[3] : outputShape[1];
      const outputChannelsPerGroup = outputChannels / attributes.group;
      const components = isChannelLast && outputChannelsPerGroup >= 4 ? getMaxComponents(outputChannels) : 1;
      const outputSize = ShapeUtil.size(outputShape) / components;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: attributes.dilations },
        { type: 12 /* uint32 */, data: [attributes.strides[0], attributes.strides[1]] },
        { type: 12 /* uint32 */, data: [attributes.pads[0], attributes.pads[1]] },
        { type: 12 /* uint32 */, data: outputChannelsPerGroup }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(
        ...createTensorShapeVariables(xShape, [wShape[0], wShape[1], wShape[2], wShape[3] / components])
      );
      const inputDependencies = hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"];
      programUniforms.push(
        ...createTensorShapeVariables([outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components])
      );
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
        const x = inputVariable("x", inputs[0].dataType, xShape.length);
        const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
        const inputVars = [x, w];
        if (hasBias) {
          inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "dilations", type: "u32", length: attributes.dilations.length },
          { name: "strides", type: "u32", length: 2 },
          { name: "pads", type: "u32", length: 2 },
          { name: "output_channels_per_group", type: "u32" }
        ];
        appendActivationUniforms(attributes, uniforms);
        const calculateResult = isChannelLast ? `
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${x.get("batch", "xHeight", "xWidth", "input_channel")};
            let wVal = ${w.get("wHeight", "wWidth", "wInChannel", "output_channel")};
            value += xVal * wVal;
          }
        }
      }
      ` : `
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${x.get("batch", "input_channel", "xHeight", "xWidth")};
            let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${output.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${isChannelLast ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${isChannelLast ? 1 : 2}], outputIndices[${isChannelLast ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${components} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${isChannelLast ? 2 : 1}];

    var value: ${output.type.value} = ${output.type.value}(0);
    ${calculateResult}
    ${processBias}
    ${applyActivation}
    ${output.setByOffset("global_idx", "value")}
  }`;
      };
      return {
        name: "GroupedConv",
        shaderCache: { hint: `${attributes.cacheKey}_${components}`, inputDependencies },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    createGroupedConvVectorizeProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const components = getMaxComponents(outputShape[3]);
      const outputNumber = getMaxComponents(outputShape[2]);
      const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const xShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[0].dims[2], inputs[0].dims[3] / components];
      const wShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[1].dims[3] / components];
      const outputShapeInShader = [outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: [attributes.strides[0], attributes.strides[1]] },
        { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(xShape, wShape, outputShapeInShader));
      const xNumber = (outputNumber - 1) * attributes.strides[1] + wShape[1];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
        const x = inputVariable("x", inputs[0].dataType, xShape.length, components);
        const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
        const inputVars = [x, w];
        if (hasBias) {
          inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
        }
        const processBias = hasBias ? "value += b[output_channel];" : "";
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "strides", type: "i32", length: 2 },
          { name: "pads", type: "i32", length: 2 }
        ];
        appendActivationUniforms(attributes, uniforms);
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${outputNumber}u;
    let col = (index1 % width1) * ${outputNumber}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${xNumber}>;
    var values: array<${output.type.value}, ${outputNumber}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${wShape[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${xNumber}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${wShape[1]}; w_width++) {
          let w_val = ${w.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${outputNumber}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      ${output.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
      };
      return {
        name: "GroupedConv-Vectorize",
        shaderCache: {
          hint: `${attributes.cacheKey};${components};${outputNumber};${xNumber};${wShape[0]};${wShape[1]}`,
          inputDependencies: hasBias ? ["rank", "rank", "type"] : ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv.ts
var calculateOutputShape, weightTransposeAttribute, validateInputs8, getAdjustedConvAttributes, parseConvAttributes, conv2d, conv1d, conv3d, conv;
var init_conv = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv.ts"() {
    "use strict";
    init_util();
    init_conv2d_mm_webgpu();
    init_conv3d_naive_webgpu();
    init_matmul_packed_webgpu();
    init_conv_grouped();
    init_fuse_utils();
    init_matmul_shaders();
    init_transpose();
    calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides, isChannelLast) => {
      const batchSize = inputShape[0];
      const inputSpatialShape = inputShape.slice(isChannelLast ? 1 : 2, isChannelLast ? 3 : 4);
      const spatialRank = inputSpatialShape.length;
      const outChannels = kernelShape[0];
      const kernelSpatialShape = kernelShape.slice(2);
      const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
      const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
      const outputShape = inputSpatialShapeWithPad.map(
        (v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i])
      );
      outputShape.splice(0, 0, batchSize);
      outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
      return outputShape;
    };
    weightTransposeAttribute = [2, 3, 1, 0];
    validateInputs8 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length > 5) {
        throw new Error("greater than 5D is not supported");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("filter does not have same dimension as input");
      }
      const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
      const filterInChannel = inputs[1].dims[1] * attributes.group;
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      if (attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      if (attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      if (attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
    };
    getAdjustedConvAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (kernelShape.length < inputs[1].dims.length - 2) {
        kernelShape.push(...Array(inputs[1].dims.length - 2 - kernelShape.length).fill(0));
      }
      for (let i = 2; i < inputs[1].dims.length; ++i) {
        if (kernelShape[i - 2] === 0) {
          kernelShape[i - 2] = inputs[1].dims[i];
        }
      }
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPadsBasedOnAutoPad(
        inputs[0].dims,
        attributes.strides,
        attributes.dilations,
        kernelShape,
        pads,
        attributes.format === "NHWC",
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads });
      return newAttributes;
    };
    parseConvAttributes = (attributes) => {
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const format = attributes.format;
      const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad];
      const dilations = attributes.dilations;
      const group = attributes.group;
      const kernelShape = attributes.kernel_shape;
      const pads = attributes.pads;
      const strides = attributes.strides;
      const wIsConst = attributes.w_is_const();
      return {
        autoPad,
        format,
        dilations,
        group,
        kernelShape,
        pads,
        strides,
        wIsConst,
        ...activationAttributes,
        cacheKey: `${attributes.format};${activationAttributes.activation};`
      };
    };
    conv2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
      const isChannelsLast = attributes.format === "NHWC";
      const outputShape = calculateOutputShape(
        inputs[0].dims,
        inputs[1].dims,
        attributes.dilations,
        attributes.pads,
        attributes.strides,
        isChannelsLast
      );
      if (attributes.group !== 1) {
        const convInputs2 = [inputs[0]];
        if (isChannelsLast) {
          const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
            inputs: [1],
            outputs: [attributes.wIsConst ? -2 : -1]
          })[0];
          if (attributes.wIsConst && !context.kernelCustomData.wT) {
            context.kernelCustomData.wT = transposedWeight2;
          }
          convInputs2.push(transposedWeight2);
        } else {
          convInputs2.push(inputs[1]);
        }
        if (inputs.length === 3) {
          convInputs2.push(inputs[2]);
        }
        const enableGroupedConvVectorize = !context.adapterInfo.isArchitecture("ampere");
        if (enableGroupedConvVectorize && isChannelsLast && inputs[1].dims[0] === attributes.group && inputs[1].dims[1] === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1) {
          context.compute(
            createGroupedConvVectorizeProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction),
            { inputs: convInputs2 }
          );
        } else {
          context.compute(createGroupedConvProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction), {
            inputs: convInputs2
          });
        }
        return;
      }
      const hasBias = inputs.length === 3;
      const inputHeight = inputs[0].dims[isChannelsLast ? 1 : 2];
      const inputWidth = inputs[0].dims[isChannelsLast ? 2 : 3];
      const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
      const weightHeight = inputs[1].dims[2];
      const weightWidth = inputs[1].dims[3];
      const outHeight = outputShape[isChannelsLast ? 1 : 2];
      const outWidth = outputShape[isChannelsLast ? 2 : 3];
      const outChannels = outputShape[isChannelsLast ? 3 : 1];
      const sameSize = isChannelsLast && weightHeight === inputHeight && weightWidth === inputWidth && attributes.pads[0] === 0 && attributes.pads[1] === 0;
      if (sameSize || weightHeight === 1 && weightWidth === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1 && attributes.strides[0] === 1 && attributes.strides[1] === 1 && attributes.pads[0] === 0 && attributes.pads[1] === 0) {
        const batch = outputShape[0];
        let xReshaped, wReshaped, matmulOutputShape;
        const matmulInputs = [];
        if (isChannelsLast) {
          const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
            inputs: [1],
            outputs: [attributes.wIsConst ? -2 : -1]
          })[0];
          if (attributes.wIsConst && !context.kernelCustomData.wT) {
            context.kernelCustomData.wT = transposedWeight2;
          }
          if (sameSize) {
            const sharedDim = inputHeight * inputWidth * inputChannels;
            xReshaped = inputs[0].reshape([1, batch, sharedDim]);
            wReshaped = transposedWeight2.reshape([1, sharedDim, outChannels]);
            matmulOutputShape = [1, batch, outChannels];
          } else {
            xReshaped = inputs[0].reshape([batch, inputHeight * inputWidth, inputChannels]);
            wReshaped = transposedWeight2.reshape([1, inputChannels, outChannels]);
            matmulOutputShape = [batch, outHeight * outWidth, outChannels];
          }
          matmulInputs.push(xReshaped);
          matmulInputs.push(wReshaped);
        } else {
          xReshaped = inputs[0].reshape([batch, inputChannels, inputHeight * inputWidth]);
          wReshaped = inputs[1].reshape([1, outChannels, inputChannels]);
          matmulOutputShape = [batch, outChannels, outHeight * outWidth];
          matmulInputs.push(wReshaped);
          matmulInputs.push(xReshaped);
        }
        if (hasBias) {
          matmulInputs.push(inputs[2]);
        }
        const N = matmulOutputShape[2];
        const K = matmulInputs[0].dims[matmulInputs[0].dims.length - 1];
        if (N < 8 && K < 8) {
          context.compute(
            createNaiveMatmulProgramInfo(
              matmulInputs,
              attributes,
              outputShape,
              matmulOutputShape,
              isChannelsLast,
              squeezeOutputShapeFunction
            ),
            { inputs: matmulInputs }
          );
        } else {
          context.compute(
            createMatmulProgramInfo(
              matmulInputs,
              attributes,
              outputShape,
              matmulOutputShape,
              isChannelsLast,
              squeezeOutputShapeFunction
            ),
            { inputs: matmulInputs }
          );
        }
        return;
      }
      const sequentialAccessByThreads = (
        /* backend.adapterInfo.isIntel() */
        true
      );
      const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
        inputs: [1],
        outputs: [attributes.wIsConst ? -2 : -1]
      })[0];
      if (attributes.wIsConst && !context.kernelCustomData.wT) {
        context.kernelCustomData.wT = transposedWeight;
      }
      const convInputs = [inputs[0], transposedWeight];
      if (hasBias) {
        convInputs.push(inputs[2]);
      }
      const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
      const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
      const dimInner = weightHeight * weightWidth * inputChannels;
      context.compute(
        createConv2DMatMulProgramInfo(
          convInputs,
          attributes,
          outputShape,
          dimAOuter,
          dimBOuter,
          dimInner,
          hasBias,
          sequentialAccessByThreads,
          squeezeOutputShapeFunction
        ),
        { inputs: convInputs }
      );
    };
    conv1d = (context, attributes) => {
      const isChannelLast = attributes.format === "NHWC";
      const inputs = [
        context.inputs[0].reshape(
          isChannelLast ? (
            // [N, W, C] -> [N, H=1, W, C]
            [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
          ) : (
            // [N, C, W] -> [N, C, H=1, W]
            [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
          )
        ),
        //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
        context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
      ];
      if (context.inputs.length === 3) {
        inputs.push(context.inputs[2]);
      }
      const pads = [0, attributes.pads[0], 0, attributes.pads[1]];
      const strides = [1].concat(attributes.strides);
      const dilations = [1].concat(attributes.dilations);
      const kernelShape = [1].concat(attributes.kernelShape);
      const adjustedAttributes = getAdjustedConvAttributes(
        { ...attributes, pads, strides, dilations, kernelShape },
        inputs
      );
      conv2d(
        context,
        inputs,
        adjustedAttributes,
        (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
      );
    };
    conv3d = (context, inputs, attributes) => {
      const format = attributes.format === "NHWC" ? "channelsLast" : "channelsFirst";
      const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
      const pads = attributes.autoPad === "NOTSET" ? attributes.pads : attributes.autoPad;
      const convInfo = computeConv3DInfo(
        inputs[0].dims,
        inputs[1].dims,
        attributes.strides,
        attributes.dilations,
        pads,
        false,
        format
      );
      context.compute(
        createConv3DNaiveProgramInfo(
          inputs,
          adjustedAttributes,
          convInfo.outShape,
          [convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth],
          [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left],
          format
        )
      );
    };
    conv = (context, attributes) => {
      validateInputs8(context.inputs, attributes);
      if (context.inputs[0].dims.length === 3) {
        conv1d(context, attributes);
      } else if (context.inputs[0].dims.length === 5) {
        conv3d(context, context.inputs, attributes);
      } else {
        const adjustedAttributes = getAdjustedConvAttributes(attributes, context.inputs);
        conv2d(context, context.inputs, adjustedAttributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts
var createConvTranspose2DProgramInfo;
var init_conv_backprop_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_util();
    init_common();
    createConvTranspose2DProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const outputShape = attributes.outputShape;
      const isChannelsLast = attributes.format === "NHWC";
      const group = attributes.group;
      const wShape = inputs[1].dims;
      const inputChannelsPerGroup = wShape[2] / group;
      const outputChannelsPerGroup = wShape[3];
      const aComponents = isChannelsLast ? getMaxComponents(inputChannelsPerGroup) : 1;
      const packInputAs4 = isChannelsLast && outputChannelsPerGroup === 1 && inputChannelsPerGroup >= 4;
      const inputChannelsPerGroupInt = packInputAs4 ? Math.floor(inputChannelsPerGroup / 4) * 4 : Math.floor(inputChannelsPerGroup / aComponents) * aComponents;
      const inputChannelsRemainder = inputChannelsPerGroup - inputChannelsPerGroupInt;
      const components = isChannelsLast ? getMaxComponents(outputChannelsPerGroup) : 1;
      const bComponents = isChannelsLast ? outputChannelsPerGroup === 1 ? aComponents : components : 1;
      const outputSize = ShapeUtil.size(outputShape) / components;
      const dispatch = [Math.ceil(outputSize / 64), 1, 1];
      LOG_DEBUG("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${dispatch}`);
      const inputDependencies = ["rank", "rank"];
      const strides = [attributes.strides[0], attributes.strides[1]];
      const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
      const dilations = [attributes.dilations[0], attributes.dilations[1]];
      const effectiveFilterDims = [
        filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)),
        filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1))
      ];
      const pads = [
        effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
        effectiveFilterDims[1] - 1 - Math.floor((attributes.pads[1] + attributes.pads[3]) / 2)
      ];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: strides },
        { type: 12 /* uint32 */, data: filterDims },
        { type: 12 /* uint32 */, data: dilations },
        { type: 12 /* uint32 */, data: effectiveFilterDims },
        { type: 6 /* int32 */, data: pads },
        { type: 12 /* uint32 */, data: inputChannelsPerGroupInt },
        { type: 12 /* uint32 */, data: inputChannelsPerGroup },
        { type: 12 /* uint32 */, data: outputChannelsPerGroup },
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims)
      ];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "strides", type: "u32", length: strides.length },
          { name: "filter_dims", type: "u32", length: filterDims.length },
          { name: "dilations", type: "u32", length: filterDims.length },
          { name: "effective_filter_dims", type: "u32", length: effectiveFilterDims.length },
          { name: "pads", type: "i32", length: pads.length },
          { name: "input_channels_per_group_int", type: "u32" },
          { name: "input_channels_per_group", type: "u32" },
          { name: "output_channels_per_group", type: "u32" }
        ];
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, bComponents);
        const dy = inputVariable("Dy", inputs[0].dataType, inputs[0].dims.length, aComponents);
        const inputVariables = [dy, w];
        if (hasBias) {
          inputVariables.push(inputVariable("bias", inputs[2].dataType, [outputShape[channelDim]].length, components));
        }
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        const calculateResult = () => {
          let calcStr = "";
          if (packInputAs4) {
            if (aComponents === 4) {
              calcStr += `
        let xValue = ${dy.getByOffset("x_offset")};
        let wValue = ${w.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`;
            } else if (aComponents === 2) {
              calcStr += `
          dotProd = dotProd + dot(vec4<${dataType}>(${dy.getByOffset("x_offset")}, ${dy.getByOffset("x_offset + 1u")}), vec4<${dataType}>(${w.getByOffset("w_offset")}, ${w.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`;
            } else if (aComponents === 1) {
              calcStr += `
          dotProd = dotProd + dot(vec4<${dataType}>(${dy.getByOffset("x_offset")}, ${dy.getByOffset("x_offset + 1u")}, ${dy.getByOffset("x_offset + 2u")}, ${dy.getByOffset("x_offset + 3u")}), vec4<${dataType}>(${w.getByOffset("w_offset")}, ${w.getByOffset("w_offset + 1u")}, ${w.getByOffset("w_offset + 2u")}, ${w.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`;
            }
          } else {
            calcStr += `
                  let xValue = ${isChannelsLast ? dy.getByOffset(
              `${dy.indicesToOffset(`${dy.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${aComponents}`
            ) : dy.get("batch", "inputChannel", "idyR", "idyC")};
        `;
            if (aComponents === 1) {
              calcStr += `
          let w_offset = ${w.indicesToOffset(`${w.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${w.getByOffset(`w_offset / ${bComponents}`)};
          dotProd = dotProd + xValue * wValue;`;
            } else {
              for (let c = 0; c < aComponents; c++) {
                calcStr += `
            let wValue${c} = ${w.getByOffset(`${w.indicesToOffset(`${w.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${c}, wOutChannel)`)} / ${bComponents}`)};
            dotProd = dotProd + xValue[${c}] * wValue${c};`;
              }
            }
          }
          return calcStr;
        };
        const calculateRemainder = () => {
          if (inputChannelsRemainder === 0) {
            return "";
          }
          if (!packInputAs4) {
            throw new Error(`packInputAs4 ${packInputAs4} is not true.`);
          }
          let calcStr = "";
          if (aComponents === 1) {
            calcStr += "dotProd = dotProd";
            for (let i = 0; i < inputChannelsRemainder; i++) {
              calcStr += `
            + ${dy.getByOffset(`x_offset + ${i}`)} * ${w.getByOffset(`w_offset + ${i}`)}`;
            }
            calcStr += ";";
          } else if (aComponents === 2) {
            if (inputChannelsRemainder !== 2) {
              throw new Error(`Invalid inputChannelsRemainder ${inputChannelsRemainder}.`);
            }
            calcStr += `
          let xValue = ${dy.getByOffset("x_offset")};
          let wValue = ${w.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`;
          }
          return calcStr;
        };
        const codeSnippet = `
            let outputIndices = ${output.offsetToIndices(`global_idx * ${components}`)};
            let batch = ${output.indicesGet("outputIndices", 0)};
            let d1 = ${output.indicesGet("outputIndices", channelDim)};
            let r = ${output.indicesGet("outputIndices", rowDim)};
            let c = ${output.indicesGet("outputIndices", colDim)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${output.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${dataType}(dyRCorner) + ${dataType}(wR)) / ${dataType}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[${rowDim}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${dataType}(dyCCorner) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[${colDim}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${packInputAs4 ? `
                var x_offset = ${dy.indicesToOffset(`${dy.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${aComponents};
                var w_offset = ${w.indicesToOffset(`${w.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${bComponents};
                  ` : ""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${packInputAs4 ? 4 : aComponents}) {
                  ${calculateResult()}
                  inputChannel = inputChannel + ${packInputAs4 ? 4 : aComponents};
                }
                ${calculateRemainder()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${hasBias ? ` + bias[d1 / ${components}]` : ""};
            ${output.setByOffset("global_idx", "value")};
          `;
        return `
    ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${codeSnippet}}`;
      };
      return {
        name: "ConvTranspose2D",
        shaderCache: {
          hint: `${attributes.cacheKey};${aComponents}${bComponents}${components}${packInputAs4}${inputChannelsRemainder}`,
          inputDependencies
        },
        getRunData: () => ({
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          outputs: [
            {
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }
          ],
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts
var computeTotalPad, distributePadding, calculateOutputShapeAndPads, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs9, convTranspose2d, convTranspose1d, convTranspose;
var init_conv_transpose = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"() {
    "use strict";
    init_conv_backprop_webgpu();
    init_fuse_utils();
    init_transpose();
    computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
    distributePadding = (totalPad, autoPad, pads, head, tail) => {
      const smallPad = Math.floor(totalPad / 2);
      if (autoPad === "SAME_UPPER") {
        pads[head] = smallPad;
        pads[tail] = totalPad - smallPad;
      } else if (autoPad === "SAME_LOWER") {
        pads[head] = totalPad - smallPad;
        pads[tail] = smallPad;
      }
    };
    calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, group, pads, strides, isChannelLast, outputPadding, outputShape) => {
      const spatialRank = inputShape.length - 2;
      const updateOutputShape = outputShape.length === 0;
      if (outputPadding.length < spatialRank) {
        outputPadding.push(...Array(spatialRank - outputPadding.length).fill(0));
      }
      const batchSize = inputShape[0];
      const outChannels = kernelShape[isChannelLast ? 3 : 1] * group;
      for (let i = 0, j = inputShape.length - spatialRank - (isChannelLast ? 1 : 0); i < spatialRank; ++i, ++j) {
        const inSize = inputShape[j];
        const outSize = updateOutputShape ? inSize * strides[i] : outputShape[i];
        const totalPad = computeTotalPad(inSize, strides[i], pads[i], kernelShape[j], dilations[i], outSize);
        distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
        if (updateOutputShape) {
          outputShape.push(
            strides[i] * (inSize - 1) + outputPadding[i] + (kernelShape[j] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
          );
        }
      }
      outputShape.splice(0, 0, batchSize);
      outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
    };
    getAdjustedConvTransposeAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (attributes.kernelShape.length === 0 || attributes.kernelShape.reduce((a, b) => a * b, 1) === 0) {
        kernelShape.length = 0;
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          kernelShape.push(inputs[1].dims[i]);
        }
      }
      const isChannelsLast = attributes.format === "NHWC";
      kernelShape.splice(0, 0, inputs[1].dims[0]);
      kernelShape.splice(isChannelsLast ? 3 : 1, 0, inputs[1].dims[1]);
      const pads = attributes.pads.slice();
      const outputShape = attributes.outputShape.slice();
      const outputPadding = attributes.outputPadding.slice();
      const inputShape = inputs[0].dims;
      let dilations = attributes.dilations.slice();
      if (dilations.reduce((a, b) => a + b, 0) === 0) {
        const spatialRank = inputs[0].dims.length - 2;
        dilations = new Array(spatialRank).fill(1);
      }
      let strides = attributes.strides.slice();
      if (strides.reduce((a, b) => a + b, 0) === 0) {
        const spatialRank = inputs[0].dims.length - 2;
        strides = new Array(spatialRank).fill(1);
      }
      calculateOutputShapeAndPads(
        inputShape,
        kernelShape,
        dilations,
        attributes.autoPad,
        attributes.group,
        pads,
        strides,
        isChannelsLast,
        outputPadding,
        outputShape
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads, outputPadding, outputShape, dilations, strides });
      return newAttributes;
    };
    parseConvTransposeAttributes = (attributes) => {
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const format = attributes.format;
      const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][typeof attributes.autoPad == "undefined" ? 0 : attributes.autoPad];
      const dilations = attributes.dilations;
      const group = attributes.group;
      const kernelShape = attributes.kernelShape;
      const pads = attributes.pads;
      const strides = attributes.strides;
      const wIsConst = attributes.wIsConst();
      const outputPadding = attributes.outputPadding;
      const outputShape = attributes.outputShape;
      return {
        autoPad,
        format,
        dilations,
        group,
        kernelShape,
        outputPadding,
        outputShape,
        pads,
        strides,
        wIsConst,
        ...activationAttributes,
        cacheKey: `${attributes.format};${activationAttributes.activation};`
      };
    };
    validateInputs9 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {
        throw new Error("currently only support 2-dimensional conv");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("filter does not have same dimension as input");
      }
      const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
      const filterInChannel = inputs[1].dims[0];
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      const featureMaps = inputs[1].dims[1] * attributes.group;
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      const dilationsSet = attributes.dilations.reduce((a, b) => a + b, 0) > 0;
      if (dilationsSet && attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      const stridesSet = attributes.strides.reduce((a, b) => a + b, 0) > 0;
      if (stridesSet && attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      const padsSet = attributes.pads.reduce((a, b) => a + b, 0) > 0;
      if (padsSet && attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.outputPadding.length !== spatialRank && attributes.outputPadding.length !== 0) {
        throw new Error(`output_padding should be ${spatialRank}D`);
      }
      const kernelShapeSet = attributes.kernelShape.reduce((a, b) => a + b, 0) > 0;
      if (kernelShapeSet && attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
      if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
        throw new Error("invalid output shape");
      }
    };
    convTranspose2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
      const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], [2, 3, 0, 1]), {
        inputs: [1],
        outputs: [attributes.wIsConst ? -2 : -1]
      })[0];
      if (attributes.wIsConst && !context.kernelCustomData.wT) {
        context.kernelCustomData.wT = transposedWeight;
      }
      const convTransposeInputs = [inputs[0], transposedWeight];
      if (inputs.length === 3) {
        convTransposeInputs.push(inputs[2]);
      }
      context.compute(createConvTranspose2DProgramInfo(convTransposeInputs, attributes, squeezeOutputShapeFunction), {
        inputs: convTransposeInputs
      });
    };
    convTranspose1d = (context, attributes) => {
      const isChannelLast = attributes.format === "NHWC";
      const inputs = [
        context.inputs[0].reshape(
          isChannelLast ? (
            // [N, W, C] -> [N, H=1, W, C]
            [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
          ) : (
            // [N, C, W] -> [N, C, H=1, W]
            [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
          )
        ),
        //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
        context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
      ];
      if (context.inputs.length === 3) {
        inputs.push(context.inputs[2]);
      }
      let kernelShape = attributes.kernelShape;
      if (kernelShape.length === 0 || kernelShape[0] === 0) {
        kernelShape = [context.inputs[1].dims[2]];
      }
      let dilations = attributes.dilations;
      if (dilations.length === 0 || dilations[0] === 0) {
        dilations = [1];
      }
      let strides = attributes.strides;
      if (strides.length === 0 || strides[0] === 0) {
        strides = [1];
      }
      let pads = attributes.pads;
      if (pads.length === 0) {
        pads = [0, 0];
      }
      pads = [0, pads[0], 0, pads[1]];
      strides = [1].concat(strides);
      dilations = [1].concat(dilations);
      kernelShape = [1].concat(kernelShape);
      let outputPadding = attributes.outputPadding;
      outputPadding = [0].concat(outputPadding);
      const adjustedAttributes = getAdjustedConvTransposeAttributes(
        { ...attributes, pads, strides, dilations, kernelShape, outputPadding },
        inputs
      );
      convTranspose2d(
        context,
        inputs,
        adjustedAttributes,
        (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
      );
    };
    convTranspose = (context, attributes) => {
      validateInputs9(context.inputs, attributes);
      if (context.inputs[0].dims.length === 3) {
        convTranspose1d(context, attributes);
      } else {
        const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, context.inputs);
        convTranspose2d(context, context.inputs, adjustedAttributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/cumsum.ts
var createCumsumProgramInfo, cumsum, parseCumSumAttributes;
var init_cumsum = __esm({
  "web/lib/wasm/jsep/webgpu/ops/cumsum.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    createCumsumProgramInfo = (inputType, inputShape, axisInput, attributes) => {
      const outputSize = ShapeUtil.size(inputShape);
      const rank = inputShape.length;
      const input = inputVariable("input", inputType, rank);
      const output = outputVariable("output", inputType, rank);
      const axisValue = axisInput.dataType === 6 /* int32 */ ? axisInput.getInt32Array()[0] : Number(axisInput.getBigInt64Array()[0]);
      const axis = ShapeUtil.normalizeAxis(axisValue, rank);
      const getShaderSource = (shaderHelper) => {
        const index = ` i32(${input.indicesGet("inputIndices", "uniforms.axis")}) `;
        const max = getElementAt("uniforms.input_shape", "uniforms.axis", rank);
        const lowerLimit = attributes.reverse ? index + (attributes.exclusive ? " + 1" : "") : "0";
        const upperLimit = attributes.reverse ? max : index + (attributes.exclusive ? "" : " + 1");
        return `
                ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(input, output)}
                ${shaderHelper.mainStart()}
                  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${output.offsetToIndices("global_idx")};
                  var sum = ${output.type.value}(0);
                  let first : i32 = ${lowerLimit};
                  let last : i32 = ${upperLimit};
                  for (var i : i32 = first; i < last; i++) {
                    ${input.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${input.getByIndices("inputIndices")};
                  }
                  ${output.setByOffset("global_idx", "sum")};
                }`;
      };
      return {
        name: "CumSum",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
        getRunData: () => ({
          outputs: [{ dims: inputShape, dataType: inputType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            { type: 12 /* uint32 */, data: axis },
            ...createTensorShapeVariables(inputShape, inputShape)
          ]
        }),
        getShaderSource
      };
    };
    cumsum = (context, attributes) => {
      const inputShape = context.inputs[0].dims;
      const inputType = context.inputs[0].dataType;
      const axis = context.inputs[1];
      context.compute(createCumsumProgramInfo(inputType, inputShape, axis, attributes), { inputs: [0] });
    };
    parseCumSumAttributes = (attributes) => {
      const exclusive = attributes.exclusive === 1;
      const reverse = attributes.reverse === 1;
      return createAttributeWithCacheKey({ exclusive, reverse });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts
var validateInputs10, permFunctionBody2, createDepthToSpaceProgramInfo, depthToSpace, parseDepthToSpaceAttributes;
var init_depth_to_space = __esm({
  "web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs10 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("DepthToSpace requires 1 input.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error("DepthToSpace requires 4D input.");
      }
    };
    permFunctionBody2 = (perm, rank, input, output) => {
      const reverseFunc = [];
      reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
      for (let i = 0; i < rank; ++i) {
        reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
      }
      reverseFunc.push("return a;}");
      return reverseFunc.join("\n");
    };
    createDepthToSpaceProgramInfo = (inputTensor, attributes) => {
      let n, h, w, c;
      let shape;
      let perm;
      const isChannelLast = attributes.format === "NHWC";
      const blocksize = attributes.blocksize;
      const isDCRmode = attributes.mode === "DCR";
      if (isChannelLast) {
        [n, h, w, c] = inputTensor.dims;
        shape = isDCRmode ? [n, h, w, blocksize, blocksize, c / blocksize ** 2] : [n, h, w, c / blocksize ** 2, blocksize, blocksize];
        perm = isDCRmode ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3];
      } else {
        [n, h, w, c] = [inputTensor.dims[0], inputTensor.dims[2], inputTensor.dims[3], inputTensor.dims[1]];
        shape = isDCRmode ? [n, blocksize, blocksize, c / blocksize ** 2, h, w] : [n, c / blocksize ** 2, blocksize, blocksize, h, w];
        perm = isDCRmode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
      }
      const reshapedInputTensor = inputTensor.reshape(shape);
      const reshapedInputRank = reshapedInputTensor.dims.length;
      const inputDataType = inputTensor.dataType;
      const reshapedInput = inputVariable("a", inputDataType, reshapedInputRank);
      const permedOutput = outputVariable("output", inputDataType, reshapedInputRank);
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(reshapedInput, permedOutput)}

  ${permFunctionBody2(perm, reshapedInputRank, reshapedInput, permedOutput)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${permedOutput.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${permedOutput.setByOffset("global_idx", reshapedInput.getByIndices("aIndices"))}
  }`;
      return {
        name: "DepthToSpace",
        shaderCache: {
          hint: `${inputTensor.dims};${attributes.blocksize};${attributes.mode}`,
          inputDependencies: ["rank"]
        },
        getRunData: (inputs) => {
          const outputShape = isChannelLast ? [n, h * blocksize, w * blocksize, c / blocksize ** 2] : [n, c / blocksize ** 2, h * blocksize, w * blocksize];
          const outputSize = ShapeUtil.size(outputShape);
          const shapeBeforePerm = reshapedInputTensor.dims;
          const shapeAfterPerm = ShapeUtil.sortBasedOnPerm(shapeBeforePerm, perm);
          return {
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(shapeBeforePerm, shapeAfterPerm)
            ]
          };
        },
        getShaderSource
      };
    };
    depthToSpace = (context, attributes) => {
      validateInputs10(context.inputs);
      context.compute(createDepthToSpaceProgramInfo(context.inputs[0], attributes));
    };
    parseDepthToSpaceAttributes = (attributes) => createAttributeWithCacheKey({
      blocksize: attributes.blocksize,
      mode: attributes.mode,
      format: attributes.format
    });
  }
});

// web/lib/wasm/jsep/webgpu/ops/einsum.ts
var symbolPattern, termPattern, termPatternOnly, lhsPattern, lhsPatternOnly, EinsumTerm, EinsumEquation, appendMax, createEinsumProgramInfo, einsum, parseEinsumAttributes;
var init_einsum = __esm({
  "web/lib/wasm/jsep/webgpu/ops/einsum.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    symbolPattern = "[a-zA-Z]|\\.\\.\\.";
    termPattern = "(" + symbolPattern + ")+";
    termPatternOnly = "^" + termPattern + "$";
    lhsPattern = "(" + termPattern + ",)*" + termPattern;
    lhsPatternOnly = "^" + lhsPattern + "$";
    EinsumTerm = class {
      constructor(inputIndex = -1) {
        this.symbolToIndices = /* @__PURE__ */ new Map();
        this.inputIndex = inputIndex;
      }
      // Add a symbol to the term
      addSymbol(symbol, index) {
        let value = this.symbolToIndices.get(symbol);
        if (value === void 0) {
          value = [index];
        } else {
          value.push(index);
        }
        this.symbolToIndices.set(symbol, value);
      }
      // -1 for output and 0, 1, 2, ... for inputs
    };
    EinsumEquation = class {
      constructor(inputs, equation) {
        this.equation = equation;
        this.hasEllipsis = false;
        this.symbolToInfo = /* @__PURE__ */ new Map();
        this.lhs = new Array();
        this.outputDims = [];
        let [lhs, rhs] = equation.includes("->") ? equation.split("->", 2) : [equation, ""];
        if (!lhs.match(RegExp(lhsPatternOnly))) {
          throw new Error("Invalid LHS term");
        }
        const inputTerms = lhs.split(",");
        inputTerms.forEach((inputTerm, index) => {
          const dims = inputs[index].dims.slice();
          if (!inputTerm.match(RegExp(termPatternOnly))) {
            throw new Error("Invalid LHS term");
          }
          const einsumTerm = this.processTerm(inputTerm, true, dims, index);
          this.lhs.push(einsumTerm);
        });
        if (rhs === "") {
          rhs += [...this.symbolToInfo.entries()].filter(([sym, info]) => info.count === 1 || sym === "...").map(([sym]) => sym).join("");
        } else {
          if (!rhs.match(RegExp(termPattern))) {
            throw new Error("Invalid RHS");
          }
        }
        const rhsSymbols = rhs.match(RegExp(symbolPattern, "g"));
        rhsSymbols?.forEach((symbol) => {
          if (symbol === "...") {
            this.outputDims = this.outputDims.concat(this.ellipsisDims);
          } else {
            const info = this.symbolToInfo.get(symbol);
            if (info === void 0) {
              throw new Error("Invalid RHS symbol");
            }
            this.outputDims.push(info.dimValue);
          }
        });
        this.rhs = this.processTerm(rhs, false, this.outputDims);
      }
      // End of EinsumEqation constructor
      // Add a symbol to the equation
      addSymbol(symbol, dimValue, inputIndex) {
        let info = this.symbolToInfo.get(symbol);
        if (info !== void 0) {
          if (info.dimValue !== dimValue && info.count !== 1) {
            throw new Error("Dimension mismatch");
          } else {
            info.count++;
            info.inputIndices.push(inputIndex);
          }
        } else {
          info = { count: 1, dimValue, inputIndices: [inputIndex] };
        }
        this.symbolToInfo.set(symbol, info);
      }
      // Process one input/output term
      processTerm(term, isInput, dims, index = -1) {
        const rank = dims.length;
        let ellipsis = false;
        let ellipsisDims = [];
        let nextDim = 0;
        if (!term.match(RegExp(termPatternOnly)) && !isInput && term !== "") {
          throw new Error("Invalid LHS term");
        }
        const indexSymbols = term.match(RegExp(symbolPattern, "g"));
        const einsumTerm = new EinsumTerm(index);
        indexSymbols?.forEach((symbol, i) => {
          if (symbol === "...") {
            if (ellipsis) {
              throw new Error("Only one ellipsis is allowed per input term");
            }
            ellipsis = true;
            const ellipsisDimLength = rank - indexSymbols.length + 1;
            if (ellipsisDimLength < 0) {
              throw new Error("Ellipsis out of bounds");
            }
            ellipsisDims = dims.slice(nextDim, nextDim + ellipsisDimLength);
            if (this.hasEllipsis) {
              if (this.ellipsisDims.length !== ellipsisDims.length || this.ellipsisDims.toString() !== ellipsisDims.toString()) {
                throw new Error("Ellipsis dimensions mismatch");
              }
            } else if (isInput) {
              this.hasEllipsis = true;
              this.ellipsisDims = ellipsisDims;
            } else {
              throw new Error("Ellipsis must be specified in the LHS");
            }
            for (let j = 0; j < ellipsisDims.length; j++) {
              const symbol2 = String.fromCharCode("0".charCodeAt(0) + j);
              einsumTerm.addSymbol(symbol2, i + j);
              this.addSymbol(symbol2, dims[nextDim++], index);
            }
          } else {
            einsumTerm.addSymbol(symbol, i + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0));
            this.addSymbol(symbol, dims[nextDim++], index);
          }
        });
        return einsumTerm;
      }
      // Output dimensions of the equation
    };
    appendMax = (name) => name + "_max";
    createEinsumProgramInfo = (inputShapes, dataType, einsumEquation, outputShape) => {
      const ranks = inputShapes.map((dims) => dims.length);
      const inputVars = ranks.map((rank, index) => inputVariable(`input${index}`, dataType, rank));
      const outputSize = ShapeUtil.size(outputShape);
      const output = outputVariable("output", dataType, outputShape.length);
      const uniformsSymbols = [...einsumEquation.symbolToInfo.keys()].filter(
        (symbol) => !einsumEquation.rhs.symbolToIndices.has(symbol)
      );
      const getShaderSource = (shaderHelper) => {
        const idxCopy = [];
        const initProd = "var prod = 1.0;";
        const initSum = "var sum = 0.0;";
        const updateSum = "sum += prod;";
        const reduceOpsSetIndices = [];
        const reduceOpsLoopHeaders = [];
        const reduceOpsLoopFooters = [];
        const reduceOpCompute = [];
        const isReduceOpsWithoutLoop = einsumEquation.symbolToInfo.size === einsumEquation.rhs.symbolToIndices.size;
        einsumEquation.symbolToInfo.forEach((info, symbol) => {
          if (einsumEquation.rhs.symbolToIndices.has(symbol)) {
            const outputIndex = einsumEquation.rhs.symbolToIndices.get(symbol)?.[0];
            if (outputIndex !== void 0) {
              einsumEquation.lhs.forEach((term, i) => {
                if (info.inputIndices.includes(i)) {
                  const indices = term.symbolToIndices.get(symbol);
                  if (indices === void 0) {
                    throw new Error("Invalid symbol error");
                  }
                  indices.forEach((index) => {
                    idxCopy.push(
                      `${inputVars[i].indicesSet(
                        `input${i}Indices`,
                        index,
                        output.indicesGet("outputIndices", outputIndex)
                      )}`
                    );
                  });
                }
              });
            }
          } else {
            einsumEquation.lhs.forEach((term, i) => {
              if (info.inputIndices.includes(i)) {
                const indices = term.symbolToIndices.get(symbol);
                if (indices === void 0) {
                  throw new Error("Invalid symbol error");
                }
                indices.forEach((index) => {
                  reduceOpsSetIndices.push(`${inputVars[i].indicesSet(`input${i}Indices`, index, `${symbol}`)}`);
                });
                reduceOpCompute.push(`prod *= ${inputVars[i].getByIndices(`input${i}Indices`)};`);
              }
            });
            reduceOpsLoopHeaders.push(
              `for(var ${symbol}: u32 = 0; ${symbol} < uniforms.${appendMax(symbol)}; ${symbol}++) {`
            );
            reduceOpsLoopFooters.push("}");
          }
        });
        const reduceOps2 = isReduceOpsWithoutLoop ? [
          ...idxCopy,
          `let sum = ${inputVars.map((inputVar, i) => inputVar.getByIndices(`input${i}Indices`)).join(" * ")};`
        ] : [
          ...idxCopy,
          initSum,
          ...reduceOpsLoopHeaders,
          ...reduceOpsSetIndices,
          initProd,
          ...reduceOpCompute,
          updateSum,
          ...reduceOpsLoopFooters
        ];
        return `
            ${shaderHelper.registerUniforms(uniformsSymbols.map((symbol) => ({ name: `${appendMax(symbol)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...inputVars, output)}

            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${output.offsetToIndices("global_idx")};
            ${inputVars.map((_var, i) => `var input${i}Indices: ${inputVars[i].type.indices};`).join("\n")}
            ${reduceOps2.join("\n")};
            ${output.setByOffset("global_idx", "sum")};
          }`;
      };
      return {
        name: "Einsum",
        shaderCache: { hint: einsumEquation.equation, inputDependencies: inputShapes.map(() => "rank") },
        getRunData: () => {
          const programUniformsInit = uniformsSymbols.filter((symbol) => einsumEquation.symbolToInfo.has(symbol)).map((symbol) => ({ type: 12 /* uint32 */, data: einsumEquation.symbolToInfo.get(symbol)?.dimValue || 0 }));
          programUniformsInit.push({ type: 12 /* uint32 */, data: outputSize });
          const programUniforms = inputShapes.map((dims, _) => [...createTensorShapeVariables(dims)]).reduce((acc, inputProgramUniforms) => acc.concat(inputProgramUniforms), programUniformsInit);
          programUniforms.push(...createTensorShapeVariables(outputShape));
          return {
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          };
        },
        getShaderSource
      };
    };
    einsum = (context, attributes) => {
      const einsumEquation = new EinsumEquation(context.inputs, attributes.equation);
      const outputShape = einsumEquation.outputDims;
      const inputShapes = context.inputs.map((input, _) => input.dims);
      context.compute(createEinsumProgramInfo(inputShapes, context.inputs[0].dataType, einsumEquation, outputShape));
    };
    parseEinsumAttributes = (attributes) => {
      const equation = attributes.equation.replace(/\s+/g, "");
      return createAttributeWithCacheKey({ equation });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/expand.ts
var validateInputs11, getAdjustedShape, calculateOutputShape2, createExpandProgramInfo, expand;
var init_expand = __esm({
  "web/lib/wasm/jsep/webgpu/ops/expand.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs11 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Expand requires 2 input.");
      }
      const inputShape = inputs[0].dims;
      const shape = Array.from(inputs[1].getBigInt64Array(), Number);
      let shapeIndex = shape.length < inputShape.length ? 0 : shape.length - inputShape.length;
      let inputShapeIndex = inputShape.length < shape.length ? 0 : inputShape.length - shape.length;
      for (; shapeIndex < shape.length && inputShapeIndex < inputShape.length; ++shapeIndex, ++inputShapeIndex) {
        if (shape[shapeIndex] !== inputShape[inputShapeIndex] && shape[shapeIndex] !== 1 && inputShape[inputShapeIndex] !== 1) {
          throw new Error("Expand requires shape to be broadcastable to input");
        }
      }
    };
    getAdjustedShape = (shape1, shape2) => {
      const diff = shape1.length - shape2.length;
      const shape = [];
      for (let i = 0; i < diff; ++i) {
        shape.push(shape1[i]);
      }
      for (let i = 0; i < shape2.length; ++i) {
        shape.push(shape2[i] === 1 ? shape1[i + diff] : shape2[i]);
      }
      return shape;
    };
    calculateOutputShape2 = (inputShape, shape) => inputShape.length > shape.length ? getAdjustedShape(inputShape, shape) : getAdjustedShape(shape, inputShape);
    createExpandProgramInfo = (inputs) => {
      const inputShape = inputs[0].dims;
      const shape = Array.from(inputs[1].getBigInt64Array(), Number);
      const outputShape = calculateOutputShape2(inputShape, shape);
      const dataType = inputs[0].dataType;
      const isBoolOrScalar = dataType === 9 /* bool */ || ShapeUtil.size(inputShape) === 1;
      const iComponents = dataType === 9 /* bool */ ? 4 : inputShape.length > 0 && inputShape[inputShape.length - 1] % 4 === 0 ? 4 : 1;
      const components = isBoolOrScalar ? 4 : outputShape.length > 0 && outputShape[outputShape.length - 1] % 4 === 0 ? 4 : 1;
      const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("input", dataType, inputShape.length, iComponents);
        const output = outputVariable("output", dataType, outputShape.length, components);
        let assignment;
        if (dataType === 9 /* bool */) {
          const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          let offset${x} = ${input.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${input.getByOffset(`index${x}`)}[component${x}]);
        `;
          assignment = `
        let outputOffset = global_idx * ${components};
        var data = vec4<u32>(0);
        ${singleAssignment("data", 0, "u32")}
        ${singleAssignment("data", 1, "u32")}
        ${singleAssignment("data", 2, "u32")}
        ${singleAssignment("data", 3, "u32")}
        ${output.setByOffset("global_idx", "data")}
      }`;
        } else {
          assignment = `
        let outputIndices = ${output.offsetToIndices(`global_idx * ${components}`)};
        let inputOffset = ${input.broadcastedIndicesToOffset("outputIndices", output)};
        let data = ${output.type.value}(${input.getByOffset(`inputOffset / ${iComponents}`)});
        ${output.setByOffset("global_idx", "data")}
      }`;
        }
        return `
    ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}
    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${assignment}`;
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        ...createTensorShapeVariables(inputShape, outputShape)
      ];
      return {
        name: "Expand",
        shaderCache: { hint: `${outputShape.length};${iComponents}${components}`, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    expand = (context) => {
      validateInputs11(context.inputs);
      context.compute(createExpandProgramInfo(context.inputs), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts
var createFastGeluProgramInfo, fastGelu2;
var init_fast_gelu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_unary_op();
    createFastGeluProgramInfo = (inputTensors) => {
      const dataType = inputTensors[0].dataType;
      const outputSize = ShapeUtil.size(inputTensors[0].dims);
      const biasLength = ShapeUtil.size(inputTensors[1].dims);
      const useVec4 = biasLength % 4 === 0;
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", dataType, [1], 4);
        const bias = inputVariable("bias", dataType, [1], 4);
        const y = outputVariable("y", dataType, [1], 4);
        const uniforms = [
          { name: "output_vec_size", type: "u32" },
          { name: "bias_size", type: "u32" }
        ];
        const singleElementBias = (i) => `
      let bias${i}_offset: u32 = (global_idx * 4 + ${i}) % uniforms.bias_size;
      let bias${i} = ${bias.getByOffset(`bias${i}_offset / 4`)}[bias${i}_offset % 4];`;
        const biasGetExpression = useVec4 ? `
      let bias = ${bias.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${singleElementBias(0)}${singleElementBias(1)}${singleElementBias(2)}${singleElementBias(3)}
      let bias = ${x.type.value}(bias0, bias1, bias2, bias3);`;
        return `${shaderHelper.registerUniforms(uniforms).declareVariables(x, bias, y)}

    ${fastGeluImpl(tensorTypeToWsglValueType(dataType))}

    ${shaderHelper.mainStart(WORKGROUP_SIZE)}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${x.getByOffset("global_idx")};
      ${biasGetExpression}
      let x_in = x + bias;
      ${y.setByOffset("global_idx", fastGeluExpression("x_in"))}
    }`;
      };
      return {
        name: "FastGeluWithBias",
        shaderCache: { hint: `${useVec4}`, inputDependencies: ["type", "type"] },
        getShaderSource,
        getRunData: (inputs) => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          programUniforms: [
            { type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) },
            { type: 12 /* uint32 */, data: biasLength }
          ],
          dispatchGroup: { x: Math.ceil(outputSize / WORKGROUP_SIZE / 4) }
        })
      };
    };
    fastGelu2 = (context) => {
      if (context.inputs.length < 2 || ShapeUtil.size(context.inputs[1].dims) === 0) {
        fastGelu(context);
      } else {
        context.compute(createFastGeluProgramInfo(context.inputs));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather.ts
var validateInputs12, createGatherProgramInfo, parseGatherAttributes, gather;
var init_gather = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs12 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Gather requires 2 inputs.");
      }
    };
    createGatherProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const indicesShape = inputs[1].dims;
      const inputRank = inputShape.length;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const outputShape = inputShape.slice(0);
      outputShape.splice(axis, 1, ...indicesShape);
      const axisDimLimit = inputShape[axis];
      const components = inputs[0].dataType === 9 /* bool */ ? 4 : 1;
      const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: axisDimLimit },
        { type: 12 /* uint32 */, data: axis },
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length, components);
        const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
        const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
        const calcDataIndices = (x) => {
          const indicesRank = indicesShape.length;
          let calcStr = `var indicesIndices${x}  = ${indices.type.indices}(0);`;
          for (let i = 0; i < indicesRank; i++) {
            calcStr += `${indicesRank > 1 ? `indicesIndices${x}[${i}]` : `indicesIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[uniforms.axis + ${i}]` : `outputIndices${x}`};`;
          }
          calcStr += `
          var idx${x} = ${indices.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${data.type.indices};
        `;
          for (let i = 0, j = 0; i < inputRank; i++) {
            if (i === axis) {
              calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = u32(idx${x});`;
              j += indicesRank;
            } else {
              calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[${j}]` : `outputIndices${x}`};`;
              j++;
            }
          }
          return calcStr;
        };
        let assignment;
        if (inputs[0].dataType === 9 /* bool */) {
          const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          ${calcDataIndices(x)};
          let offset${x} = ${data.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${data.getByOffset(`index${x}`)}[component${x}]);
        `;
          assignment = `
        let outputOffset = global_idx * ${components};
        var value = vec4<u32>(0);
        ${singleAssignment("value", 0, "u32")}
        ${singleAssignment("value", 1, "u32")}
        ${singleAssignment("value", 2, "u32")}
        ${singleAssignment("value", 3, "u32")}
        ${output.setByOffset("global_idx", "value")}
      `;
        } else {
          assignment = `
      let outputIndices = ${output.offsetToIndices("global_idx")};
      ${calcDataIndices("")};
      let value = ${data.getByIndices("dataIndices")};
      ${output.setByOffset("global_idx", "value")};
      `;
        }
        return `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(data, indices, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${assignment}
      }`;
      };
      return {
        name: "Gather",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGatherAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    gather = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs12(inputs);
      context.compute(createGatherProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather-nd.ts
var computeSliceOffsets, gatherND, parseGatherNDAttributes;
var init_gather_nd = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather-nd.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    computeSliceOffsets = (context, indicesData, sizesFromSliceDimsData, batchDims, inputDims, numSlices, numSlicesPerBatch, inputBatchStride, numSliceDims) => {
      const programUniforms = [
        { type: 12 /* uint32 */, data: numSlices },
        { type: 12 /* uint32 */, data: batchDims },
        { type: 12 /* uint32 */, data: inputDims },
        { type: 12 /* uint32 */, data: sizesFromSliceDimsData },
        { type: 12 /* uint32 */, data: numSlicesPerBatch },
        { type: 12 /* uint32 */, data: inputBatchStride },
        { type: 12 /* uint32 */, data: numSliceDims }
      ];
      const outputShape = [numSlices];
      programUniforms.push(...createTensorShapeVariables(indicesData.dims, outputShape));
      const getShaderSource = (shaderHelper) => {
        const indices = inputVariable("indices_data", indicesData.dataType, indicesData.dims.length);
        const output = outputVariable("input_slice_offsets_data", 12 /* uint32 */, 1, 1);
        const variables = [indices, output];
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "batch_dims", type: "u32" },
          { name: "input_dims", type: "u32", length: inputDims.length },
          { name: "sizes_from_slice_dims_data", type: "u32", length: sizesFromSliceDimsData.length },
          { name: "num_slices_per_batch", type: "u32" },
          { name: "input_batch_stride", type: "u32" },
          { name: "num_slice_dims", type: "u32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${inputDims.length === 1 ? "index += i32(uniforms.input_dims);" : "index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${sizesFromSliceDimsData.length === 1 ? "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);" : "relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`;
      };
      return context.compute(
        {
          name: "computeSliceOffsets",
          shaderCache: { hint: `${inputDims.length}_${sizesFromSliceDimsData.length}`, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: context.inputs[1].dataType }],
            dispatchGroup: { x: Math.ceil(numSlices / 64) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [indicesData], outputs: [-1] }
      )[0];
    };
    gatherND = (context, attributes) => {
      const inputs = context.inputs;
      const inputShape = inputs[0].dims;
      const inputType = inputs[0].dataType;
      const indicesShape = inputs[1].dims;
      const numSliceDims = indicesShape[indicesShape.length - 1];
      const numSlices = ShapeUtil.sizeToDimension(indicesShape, indicesShape.length - 1);
      const sliceSize = ShapeUtil.sizeFromDimension(inputShape, attributes.batchDims + numSliceDims);
      const numBatches = ShapeUtil.sizeToDimension(inputShape, attributes.batchDims);
      const inputBatchStride = ShapeUtil.sizeFromDimension(inputShape, attributes.batchDims);
      const numSlicesPerBatch = numSlices / numBatches;
      const sizesFromSliceDims = new Array(numSliceDims);
      let runningProduct = sliceSize;
      for (let i = 0; i < numSliceDims; ++i) {
        sizesFromSliceDims[numSliceDims - 1 - i] = runningProduct;
        runningProduct *= inputShape[attributes.batchDims + numSliceDims - 1 - i];
      }
      const inputSliceOffsets = computeSliceOffsets(
        context,
        inputs[1],
        sizesFromSliceDims,
        attributes.batchDims,
        inputShape,
        numSlices,
        numSlicesPerBatch,
        inputBatchStride,
        numSliceDims
      );
      const lastIndicesDimension = attributes.batchDims + numSliceDims;
      if (lastIndicesDimension > inputShape.length) {
        throw new Error("last dimension of indices must not be larger than rank of input tensor");
      }
      const outputShape = indicesShape.slice(0, -1).concat(inputShape.slice(lastIndicesDimension));
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: sliceSize },
        ...createTensorShapeVariables(inputs[0].dims, inputSliceOffsets.dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
        const indices = inputVariable("slice_offsets", 12 /* uint32 */, inputSliceOffsets.dims.length);
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        return `
          ${shaderHelper.registerUniform("output_size", "u32").registerUniform("slice_size", "u32").declareVariables(input, indices, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`;
      };
      context.compute(
        {
          name: "GatherND",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [inputs[0], inputSliceOffsets] }
      );
    };
    parseGatherNDAttributes = (attributes) => {
      const batchDims = attributes.batch_dims;
      return {
        batchDims,
        cacheKey: ""
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts
var validateInputs13, createGatherBlockQuantizedProgramInfo, gatherBlockQuantized, parseGatherBlockQuantizedAttributes;
var init_gather_block_quantized = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs13 = (inputs, attributes) => {
      if (inputs.length < 3 || inputs.length > 4) {
        throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");
      }
      const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputs[0].dims.length);
      const blockSize = attributes.blockSize;
      const data = inputs[0];
      const scales = inputs[2];
      const zeroPoint = inputs.length === 4 ? inputs[3] : void 0;
      if (scales.dims.length !== data.dims.length || !data.dims.map((d, i) => i === quantizeAxis ? Math.ceil(d / blockSize) === scales.dims[i] : d === scales.dims[i]).reduce((a, b) => a && b, true)) {
        throw new Error(
          "Scales must have the same rank as the input tensor and the dims should match except on gatherAxis."
        );
      }
      if (zeroPoint) {
        if (zeroPoint.dataType !== data.dataType) {
          throw new Error("Zero point must have the same data type as the input tensor.");
        }
        if (zeroPoint.dims.length !== scales.dims.length || !zeroPoint.dims.map((d, i) => d === scales.dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error(
            "Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis."
          );
        }
      }
    };
    createGatherBlockQuantizedProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const indicesShape = inputs[1].dims;
      const inputRank = inputShape.length;
      const gatherAxis = ShapeUtil.normalizeAxis(attributes.gatherAxis, inputRank);
      const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputRank);
      const outputShape = inputShape.slice(0);
      outputShape.splice(gatherAxis, 1, ...indicesShape);
      const outputSize = ShapeUtil.size(outputShape);
      const outputType = inputs[2].dataType;
      const inputType = inputs[0].dataType;
      const isSigned = inputType === 22 /* int4 */;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: quantizeAxis },
        { type: 12 /* uint32 */, data: gatherAxis },
        { type: 12 /* uint32 */, data: attributes.blockSize },
        ...createTensorShapeVariables(...inputs.map((input, _) => input.dims), outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
        const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const zeroPoint = inputs.length > 3 ? inputVariable("zeroPoint", inputs[3].dataType, inputs[3].dims.length) : void 0;
        const output = outputVariable("output", outputType, outputShape.length);
        const inputVariables = [data, indices, scales];
        if (zeroPoint) {
          inputVariables.push(zeroPoint);
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "quantize_axis", type: "u32" },
          { name: "gather_axis", type: "u32" },
          { name: "block_size", type: "u32" }
        ];
        return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart()}
        let output_indices = ${output.offsetToIndices("global_idx")};
        var indices_indices = ${indices.type.indices}(0);
        ${(() => {
          if (indicesShape.length > 1) {
            return `
          for (var i: u32 = 0; i < ${indicesShape.length}; i++) {
            let index = ${output.indicesGet("output_indices", "uniforms.gather_axis + i")};
            ${indices.indicesSet("indices_indices", "i", "index")};
          }`;
          } else {
            return `indices_indices = ${output.indicesGet("output_indices", "uniforms.gather_axis")};`;
          }
        })()};
        var data_indices = ${data.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${output.indicesGet("output_indices", "i")};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        var index_from_indices = ${indices.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${inputShape[gatherAxis]};
        }
        ${data.indicesSet("data_indices", "uniforms.gather_axis", "u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${outputShape.length}; i++) {
          let index = ${output.indicesGet("output_indices", `i + ${indicesShape.length} - 1`)};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        let data_offset = ${data.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${data.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${scales.indicesGet("data_indices", "uniforms.quantize_axis")} / uniforms.block_size;
        ${scales.indicesSet("scale_indices", "uniforms.quantize_axis", "quantize_axis_index")};
        var scale = ${scales.getByIndices("scale_indices")};
        ${(() => {
          if (!zeroPoint) {
            return "var zero_point = 0";
          } else {
            return `
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${zeroPoint.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${zeroPoint.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`;
          }
        })()};
        let dequantized_data = ${tensorTypeToWsglValueType(outputType)}(quantized_data - zero_point) * scale;
        ${output.setByOffset("global_idx", "dequantized_data")};
    }`;
      };
      return {
        name: "GatherBlockQuantized",
        shaderCache: {
          hint: `${attributes.cacheKey};${inputs.filter((_, i) => i !== 1).map((input) => input.dims.join("_")).join(";")}`,
          inputDependencies: Array.from({ length: inputs.length }, (_v, _i) => "rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    gatherBlockQuantized = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs13(inputs, attributes);
      context.compute(createGatherBlockQuantizedProgramInfo(context.inputs, attributes));
    };
    parseGatherBlockQuantizedAttributes = (attributes) => createAttributeWithCacheKey({
      blockSize: attributes.blockSize,
      gatherAxis: attributes.gatherAxis,
      quantizeAxis: attributes.quantizeAxis
    });
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather-elements.ts
var validateInputs14, createGatherElementsProgramInfo, parseGatherElementsAttributes, gatherElements;
var init_gather_elements = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs14 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("GatherElements requires 2 inputs.");
      }
      if (inputs[0].dims.length < 1) {
        throw new Error("GatherElements requires that the data input be rank >= 1.");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
      }
    };
    createGatherElementsProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputOutputDataType = inputs[0].dataType;
      const inputRank = inputShape.length;
      const indicesShape = inputs[1].dims;
      const indicesDataType = inputs[1].dataType;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const axisDimLimit = inputShape[axis];
      const outputShape = indicesShape.slice(0);
      const outputSize = ShapeUtil.size(outputShape);
      const input = inputVariable("input", inputOutputDataType, inputRank);
      const indices = inputVariable("indicesInput", indicesDataType, indicesShape.length);
      const output = outputVariable("output", inputOutputDataType, outputShape.length);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: axisDimLimit },
        { type: 12 /* uint32 */, data: axis }
      ];
      programUniforms.push(...createTensorShapeVariables(inputShape, indicesShape, outputShape));
      const inputDependencies = ["rank", "rank"];
      const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(input, indices, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${output.offsetToIndices("global_idx")};

      var idx = ${indices.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${input.type.indices}(outputIndices);
      ${input.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${input.getByIndices("inputIndices")};

      ${output.setByOffset("global_idx", "value")};
  }`;
      return {
        name: "GatherElements",
        shaderCache: { inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGatherElementsAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    gatherElements = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs14(inputs);
      context.compute(createGatherElementsProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gemm.ts
var validateInputs15, createGemmProgramInfo, parseGemmAttributes, gemm;
var init_gemm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gemm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs15 = (inputs) => {
      if (!inputs) {
        throw new Error("Input is missing");
      }
      if (inputs.length < 2 || inputs.length > 3) {
        throw new Error("Invaid input number.");
      }
      if (inputs.length === 3 && inputs[2].dims.length > 2) {
        throw new Error("Invalid input shape of C");
      }
      if (inputs[0].dataType !== inputs[1].dataType || inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
        throw new Error("Input types are mismatched");
      }
    };
    createGemmProgramInfo = (inputs, attributes) => {
      const aShape = inputs[0].dims.slice();
      const bShape = inputs[1].dims.slice();
      const [M, N, K] = GemmUtil.getShapeOfGemmResult(
        aShape,
        attributes.transA,
        bShape,
        attributes.transB,
        inputs.length === 3 ? inputs[2].dims : void 0
      );
      const outputShape = [M, N];
      if (!outputShape) {
        throw new Error("Can't use gemm on the given tensors");
      }
      const tileSize = 16;
      const numTileN = Math.ceil(N / tileSize);
      const numTileM = Math.ceil(M / tileSize);
      const useShared = true;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: useShared ? numTileN : outputSize },
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: K },
        { type: 1 /* float */, data: attributes.alpha },
        { type: 1 /* float */, data: attributes.beta }
      ];
      const inputDependencies = ["type", "type"];
      if (inputs.length === 3) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        let line = "";
        if (attributes.transA && attributes.transB) {
          line = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];";
        } else if (attributes.transA && !attributes.transB) {
          line = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];";
        } else if (!attributes.transA && attributes.transB) {
          line = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];";
        } else if (!attributes.transA && !attributes.transB) {
          line = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];";
        }
        const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
        const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
        const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
        const dataType = a.type.value;
        let c = null;
        const variables = [a, b];
        if (inputs.length === 3) {
          c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
          variables.push(c);
        }
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        variables.push(output);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "beta", type: "f32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${dataType}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${line}
    }

    ${calculateAlpha}
    ${(() => {
          if (c != null) {
            return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${dataType}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
          }
          return "";
        })()}
    output[global_idx] = value;
  }`;
      };
      const getShaderSourceShared = (shaderHelper) => {
        const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
        const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
        let c = null;
        const variables = [a, b];
        if (inputs.length === 3) {
          c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
          variables.push(c);
        }
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        variables.push(output);
        const uniforms = [
          { name: "num_tile_n", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "beta", type: "f32" }
        ];
        let calcResult = "";
        let fillWorkgroupMemory = "";
        if (attributes.transA && attributes.transB) {
          fillWorkgroupMemory = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
          calcResult = `value += tile_a[k][local_id.y] * tile_b[local_id.x][k];`;
        } else if (attributes.transA && !attributes.transB) {
          fillWorkgroupMemory = `
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
          calcResult = `value += tile_a[k][local_id.y] * tile_b[k][local_id.x];`;
        } else if (!attributes.transA && attributes.transB) {
          fillWorkgroupMemory = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
          calcResult = `value += tile_a[local_id.y][k] * tile_b[local_id.x][k];`;
        } else if (!attributes.transA && !attributes.transB) {
          fillWorkgroupMemory = `
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${a.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${b.type.value}(0);
      }
      `;
          calcResult = `value += tile_a[local_id.y][k] * tile_b[k][local_id.x];`;
        }
        const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  var<workgroup> tile_a: array<array<${a.type.storage}, ${tileSize}>, ${tileSize}>;
  var<workgroup> tile_b: array<array<${b.type.storage}, ${tileSize}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${tileSize};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${tileSize};
    let num_tiles = (uniforms.K - 1) / ${tileSize} + 1;
    var k_start = 0u;
    var value = ${output.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${fillWorkgroupMemory}
      k_start = k_start + ${tileSize};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${tileSize}; k++) {
        ${calcResult}
      }
      workgroupBarrier();
    }

    ${calculateAlpha}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${(() => {
          if (c != null) {
            return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${output.type.value}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
          }
          return "";
        })()}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`;
      };
      if (useShared) {
        return {
          name: "GemmShared",
          shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: numTileN * numTileM },
            programUniforms
          }),
          getShaderSource: getShaderSourceShared
        };
      }
      return {
        name: "Gemm",
        shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGemmAttributes = (attributes) => {
      const transA = attributes.transA;
      const transB = attributes.transB;
      const alpha = attributes.alpha;
      const beta = attributes.beta;
      return {
        transA,
        transB,
        alpha,
        beta,
        cacheKey: `${attributes.transA};${attributes.transB};${attributes.alpha === 1}`
      };
    };
    gemm = (context, attributes) => {
      validateInputs15(context.inputs);
      context.compute(createGemmProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/grid-sample.ts
var idxN, idxC, idxH, idxW, validateInputs16, gsGetCubicCoeffs, gsBicubicInterpolate, gsDenormalize, gsReflect, pixelAtGrid, computePixel, createGridSampleProgramInfo, gridSample, parseGridSampleAttributes;
var init_grid_sample = __esm({
  "web/lib/wasm/jsep/webgpu/ops/grid-sample.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    [idxN, idxC, idxH, idxW] = [0, 1, 2, 3];
    validateInputs16 = (inputs) => {
      if (inputs[0].dims.length !== 4) {
        throw new Error("only 4-D tensor is supported.");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("input dimensions must be equal to grid dimensions");
      }
      if (inputs[0].dims.length - 2 !== inputs[1].dims[inputs[1].dims.length - 1]) {
        throw new Error(`last dimension of grid must be equal to ${inputs[0].dims.length - 2}`);
      }
      if (inputs[0].dims[0] !== inputs[1].dims[0]) {
        throw new Error("grid batch size must match input batch size");
      }
    };
    gsGetCubicCoeffs = `
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`;
    gsBicubicInterpolate = (dataType) => `
  fn gs_bicubic_interpolate(p: mat4x4<${dataType}>, x: f32, y: f32) -> ${dataType} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${dataType}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`;
    gsDenormalize = (attributes) => `
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${attributes.alignCorners === 0 ? `
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    ` : `
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`;
    gsReflect = (attributes) => `
  ${attributes.paddingMode === "reflection" ? `
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }` : ""}
`;
    pixelAtGrid = (input, dataType, attributes) => `
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${dataType} {
     var pixel = ${dataType}(0);
     var indices = vec4<u32>(0);
     indices[${idxN}] = batch;
     indices[${idxC}] = channel;` + (() => {
      switch (attributes.paddingMode) {
        case "zeros":
          return `
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${idxH}] = u32(r);
            indices[${idxW}] = u32(c);
          } else {
            return ${dataType}(0);
          }
        `;
        case "border":
          return `
          indices[${idxH}] = u32(clamp(r, 0, H - 1));
          indices[${idxW}] = u32(clamp(c, 0, W - 1));
        `;
        case "reflection":
          return `
          indices[${idxH}] = gs_reflect(r, border[1], border[3]);
          indices[${idxW}] = gs_reflect(c, border[0], border[2]);
        `;
        default:
          throw new Error(`padding mode ${attributes.paddingMode} is not supported`);
      }
    })() + `
    return ${input.getByIndices("indices")};
  }
`;
    computePixel = (output, dataType, attributes) => (() => {
      switch (attributes.mode) {
        case "nearest":
          return `
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${idxN}], indices[${idxC}], border);
        `;
        case "bilinear":
          return `
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${idxN}], indices[${idxC}], border);

          let dx2 = ${dataType}(f32(x2) - x);
          let dx1 = ${dataType}(x - f32(x1));
          let dy2 = ${dataType}(f32(y2) - y);
          let dy1 = ${dataType}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;
        case "bicubic":
          return `
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${dataType}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${idxN}], indices[${idxC}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;
        default:
          throw new Error(`mode ${attributes.mode} is not supported`);
      }
    })() + `${output.setByOffset("global_idx", "result")}`;
    createGridSampleProgramInfo = (inputs, attributes) => {
      const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length);
      const gridShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2]];
      const grid = inputVariable("grid", inputs[1].dataType, gridShape.length, 2);
      let outputShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[1].dims[1], inputs[1].dims[2]];
      if (attributes.format === "NHWC") {
        outputShape = [inputs[0].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[0].dims[3]];
        [idxN, idxC, idxH, idxW] = [0, 3, 1, 2];
      }
      const output = outputVariable("output", inputs[0].dataType, outputShape.length);
      const dataType = x.type.value;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        ...createTensorShapeVariables(inputs[0].dims, gridShape, outputShape)
      ];
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(x, grid, output)}
  ${gsGetCubicCoeffs}
  ${gsBicubicInterpolate(dataType)}
  ${gsDenormalize(attributes)}
  ${gsReflect(attributes)}
  ${pixelAtGrid(x, dataType, attributes)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${idxH}]);
      let W_in = i32(uniforms.x_shape[${idxW}]);

      ${attributes.alignCorners === 0 ? `
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      ` : `
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${output.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${idxN}], indices[${idxH}], indices[${idxW}]);
      let nxy = ${grid.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${computePixel(output, dataType, attributes)}
  }`;
      return {
        name: "GridSample",
        shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies: ["type", "type"] },
        getRunData: (inputs2) => {
          const outputSize2 = ShapeUtil.size(outputShape);
          return {
            outputs: [{ dims: outputShape, dataType: inputs2[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize2 / 64
              /* workgroup size */
            ) },
            programUniforms
          };
        },
        getShaderSource
      };
    };
    gridSample = (context, attributes) => {
      validateInputs16(context.inputs);
      context.compute(createGridSampleProgramInfo(context.inputs, attributes));
    };
    parseGridSampleAttributes = (attributes) => createAttributeWithCacheKey({
      alignCorners: attributes.align_corners,
      mode: attributes.mode,
      paddingMode: attributes.padding_mode,
      format: attributes.format
    });
  }
});

// web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts
var getInput, validateInputs17, parseMultiHeadAttentionAttributes, weightTransposeAttribute2, addBiasTranspose, maybeTransposeToBNSHAndAddBias, multiHeadAttention;
var init_multihead_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_types();
    init_attention();
    init_common();
    init_transpose();
    getInput = (inputs, i) => inputs.length > i && inputs[i].dims.length > 0 ? inputs[i] : void 0;
    validateInputs17 = (inputs, attributes) => {
      const query = inputs[0];
      const key = getInput(inputs, 1);
      const value = getInput(inputs, 2);
      const bias = getInput(inputs, 3);
      const keyPaddingMask = getInput(inputs, 4);
      const attentionBias = getInput(inputs, 5);
      const pastKey = getInput(inputs, 6);
      const pastValue = getInput(inputs, 7);
      if (query.dims.length !== 3 && query.dims.length !== 5) {
        throw new Error("Input query is expected to have 3 or 5 dimensions");
      }
      const batchSize = query.dims[0];
      const sequenceLength = query.dims[1];
      const hiddenSize = query.dims.length === 3 ? query.dims[2] : attributes.numHeads * query.dims[4];
      let kvSequenceLength = sequenceLength;
      let pastSequenceLength = 0;
      let maxSequenceLength = 0;
      const headSize = Math.floor(hiddenSize / attributes.numHeads);
      if (pastKey && pastValue && ShapeUtil.size(pastKey.dims) && ShapeUtil.size(pastValue.dims)) {
        if (pastKey.dims.length !== 4) {
          throw new Error('Input "past_key" is expected to have 4 dimensions');
        }
        if (pastKey.dims[0] !== batchSize || pastKey.dims[1] !== attributes.numHeads || pastKey.dims[3] !== headSize) {
          throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
        }
        if (pastValue.dims[0] !== batchSize || pastValue.dims[1] !== attributes.numHeads || pastValue.dims[3] !== headSize) {
          throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
        }
        if (pastKey.dims[2] !== pastValue.dims[2]) {
          throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
        }
        if (pastValue.dims.length !== 4) {
          throw new Error('Input "past_value" is expected to have 4 dimensions');
        }
        pastSequenceLength = pastKey.dims[2];
        maxSequenceLength = pastKey.dims[2];
      } else if (pastKey && ShapeUtil.size(pastKey.dims) || pastValue && ShapeUtil.size(pastValue.dims)) {
        throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      }
      let qkvFormat;
      if (key && ShapeUtil.size(key.dims) > 0) {
        if (query.dims.length !== 3) {
          throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        }
        if (key.dims.length < 3 || key.dims.length > 5) {
          throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        }
        if (query.dims[0] !== key.dims[0]) {
          throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        }
        if (key.dims.length === 3) {
          if (key.dims[2] !== query.dims[2]) {
            throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
          }
          qkvFormat = 2 /* qkvBSNH */;
          kvSequenceLength = key.dims[1];
        } else if (key.dims.length === 5) {
          if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          }
          if (value) {
            throw new Error('Expect "value" be none when "key" has packed kv format.');
          }
          qkvFormat = 5 /* qKvBSNHxBSN2H */;
          kvSequenceLength = key.dims[1];
        } else {
          if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          }
          qkvFormat = 0 /* unknown */;
          kvSequenceLength = key.dims[2];
        }
      } else {
        if (query.dims.length !== 5) {
          throw new Error('Input "query" is expected to have 5 dimensions when key is empty');
        }
        if (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3) {
          throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        }
        qkvFormat = 3 /* qkvBSN3H */;
      }
      if (bias && ShapeUtil.size(bias.dims) > 0) {
        if (bias.dims.length !== 1) {
          throw new Error('Input "bias" is expected to have 1 dimension');
        }
        if (key) {
          if (key.dims.length === 5 && key.dims[3] === 2) {
            throw new Error("bias is not allowed for packed kv.");
          }
        }
      }
      const totalSequenceLength = pastSequenceLength + kvSequenceLength;
      let maskType = 0 /* none */;
      if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
        maskType = 8 /* maskUnknown */;
        const maskDims = keyPaddingMask.dims;
        if (maskDims.length === 1) {
          if (maskDims[0] === batchSize) {
            maskType = 1 /* mask1dKeySeqLen */;
          } else if (maskDims[0] === 3 * batchSize + 2) {
            maskType = 3 /* mask1DKeySeqLenStart */;
          }
        } else if (maskDims.length === 2 && maskDims[0] === batchSize && maskDims[1] === totalSequenceLength) {
          maskType = 5 /* mask2dKeyPadding */;
        }
        if (maskType === 8 /* maskUnknown */) {
          throw new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)');
        }
        throw new Error("Mask not supported");
      }
      let passPastInKv = false;
      let vHiddenSize = hiddenSize;
      if (value && ShapeUtil.size(value.dims) > 0) {
        if (value.dims.length !== 3 && value.dims.length !== 4) {
          throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        }
        if (query.dims[0] !== value.dims[0]) {
          throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        }
        if (value.dims.length === 3) {
          if (kvSequenceLength !== value.dims[1]) {
            throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[2];
        } else {
          if (kvSequenceLength !== value.dims[2]) {
            throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[1] * value.dims[3];
          passPastInKv = true;
        }
      }
      const broadcastResPosBias = false;
      if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
        throw new Error("Key padding mask is not supported");
      }
      if (attentionBias && ShapeUtil.size(attentionBias.dims) > 0) {
        if (attentionBias.dims.length !== 4) {
          throw new Error('Input "attention_bias" is expected to have 4 dimensions');
        }
        if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
          throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
        }
      }
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize: 0,
        hiddenSize,
        vHiddenSize,
        headSize,
        vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
        numHeads: attributes.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: attributes.maskFilterValue,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias,
        passPastInKv,
        qkvFormat
      };
    };
    parseMultiHeadAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
    weightTransposeAttribute2 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
    addBiasTranspose = (context, qkv, bias, batchSize, sequenceLength, hiddenSize, biasOffset) => {
      const outputShape = [batchSize, sequenceLength, hiddenSize];
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: biasOffset },
        { type: 12 /* uint32 */, data: hiddenSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("qkv_with_bias", qkv.dataType, outputShape);
        const qkvInput = inputVariable("qkv", qkv.dataType, outputShape);
        const biasInput = inputVariable("bias", bias.dataType, outputShape);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "bias_offset", type: "u32" },
          { name: "hidden_size", type: "u32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(qkvInput, biasInput, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
      };
      return context.compute(
        {
          name: "MultiHeadAttentionAddBias",
          shaderCache: { inputDependencies: ["type", "type"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: qkv.dataType, gpuDataType: 0 /* default */ }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [qkv, bias], outputs: [-1] }
      )[0];
    };
    maybeTransposeToBNSHAndAddBias = (context, batchSize, numHeads, sequenceLength, headSize, input, bias, biasOffset) => {
      let reshapedInput = input;
      if (!(bias && ShapeUtil.size(bias.dims) > 0)) {
        if (input.dims.length === 3) {
          reshapedInput = input.reshape([batchSize, sequenceLength, numHeads, headSize]);
        }
        if (numHeads === 1 || sequenceLength === 1) {
          return reshapedInput;
        }
        return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
          inputs: [reshapedInput],
          outputs: [-1]
        })[0];
      } else {
        if (sequenceLength === 1) {
          throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
        } else {
          reshapedInput = addBiasTranspose(
            context,
            input,
            bias,
            batchSize,
            sequenceLength,
            numHeads * headSize,
            biasOffset
          );
          reshapedInput = reshapedInput.reshape([batchSize, sequenceLength, numHeads, headSize]);
          if (numHeads === 1 || sequenceLength === 1) {
            return reshapedInput;
          }
          return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
            inputs: [reshapedInput],
            outputs: [-1]
          })[0];
        }
      }
    };
    multiHeadAttention = (context, attributes) => {
      const params = validateInputs17(context.inputs, attributes);
      const query = context.inputs[0];
      const key = getInput(context.inputs, 1);
      const value = getInput(context.inputs, 2);
      const bias = getInput(context.inputs, 3);
      const keyPaddingMask = getInput(context.inputs, 4);
      const attentionBias = getInput(context.inputs, 5);
      const pastKey = getInput(context.inputs, 6);
      const pastValue = getInput(context.inputs, 7);
      if (query.dims.length === 5) {
        throw new Error("Packed QKV is not implemented");
      }
      if (key?.dims.length === 5) {
        throw new Error("Packed KV is not implemented");
      }
      const kvBNSH = key && value && key.dims.length === 4 && value.dims.length === 4;
      const Q = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.sequenceLength,
        params.headSize,
        query,
        bias,
        0
      );
      if (kvBNSH) {
        return applyAttention(context, Q, key, value, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
      }
      if (!key || !value) {
        throw new Error("key and value must be provided");
      }
      const K = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.kvSequenceLength,
        params.headSize,
        key,
        bias,
        params.hiddenSize
      );
      const V = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.kvSequenceLength,
        params.vHeadSize,
        value,
        bias,
        2 * params.hiddenSize
      );
      applyAttention(context, Q, K, V, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params);
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/split.ts
var validateInputs18, createSplitAttributesFromInputs, calculateOutputIndexImpl, writeBufferDataImpl, createSplitProgramInfo, split, parseSplitAttributes;
var init_split = __esm({
  "web/lib/wasm/jsep/webgpu/ops/split.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs18 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
    };
    createSplitAttributesFromInputs = (inputs, attributes) => {
      const splitSizes = [];
      let numOutputs = attributes.numOutputs;
      if (inputs[1].dims[0] > 0) {
        inputs[1].getBigInt64Array().forEach((v) => splitSizes.push(Number(v)));
        numOutputs = splitSizes.length;
      }
      return createAttributeWithCacheKey({ numOutputs, axis: attributes.axis, splitSizes });
    };
    calculateOutputIndexImpl = (numberOfTensors) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${numberOfTensors}u; i += 1u ) {
    if (index < ${getElementAt("uniforms.size_in_split_axis", "i", numberOfTensors)}) {
        return i;
    }
    }
    return ${numberOfTensors}u;
}`;
    writeBufferDataImpl = (outputs) => {
      const numberOfTensors = outputs.length;
      const codeLines = [];
      for (let i = 0; i < numberOfTensors; ++i) {
        const returnSnippet = outputs[i].setByIndices("indices", "input[global_idx]");
        if (numberOfTensors === 1) {
          codeLines.push(returnSnippet);
        } else if (i === 0) {
          codeLines.push(`if (output_number == ${i}u) { ${returnSnippet} }`);
        } else if (i === numberOfTensors - 1) {
          codeLines.push(`else { ${returnSnippet} }`);
        } else {
          codeLines.push(`else if (output_number == ${i}) { ${returnSnippet} }`);
        }
      }
      return `
      fn writeBufferData(output_number: u32, indices: ${outputs[0].type.indices}, global_idx: u32) {
        ${codeLines.join("\n")}
      }`;
    };
    createSplitProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const dataType = inputs[0].dataType;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      const outputs = new Array(attributes.numOutputs);
      const input = inputVariable("input", dataType, inputShape.length);
      const sizeInSplitAxis = new Array(attributes.numOutputs);
      const outputsTensorInfo = [];
      const outputShapes = [];
      let previousSum = 0;
      const programUniforms = [{ type: 12 /* uint32 */, data: inputSize }];
      for (let i = 0; i < attributes.numOutputs; i++) {
        previousSum += attributes.splitSizes[i];
        sizeInSplitAxis[i] = previousSum;
        const outputShape = inputShape.slice();
        outputShape[axis] = attributes.splitSizes[i];
        outputShapes.push(outputShape);
        outputs[i] = outputVariable(`output${i}`, dataType, outputShape.length);
        outputsTensorInfo.push({ dims: outputShapes[i], dataType: inputs[0].dataType });
      }
      programUniforms.push(
        { type: 12 /* uint32 */, data: sizeInSplitAxis },
        ...createTensorShapeVariables(inputShape, ...outputShapes)
      );
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", sizeInSplitAxis.length).declareVariables(input, ...outputs)}
  ${calculateOutputIndexImpl(sizeInSplitAxis.length)}
  ${writeBufferDataImpl(outputs)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${input.offsetToIndices("global_idx")};
    var index = ${input.indicesGet("indices", axis)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${getElementAt("uniforms.size_in_split_axis", "output_number - 1u", sizeInSplitAxis.length)};
      ${input.indicesSet("indices", axis, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
      return {
        name: "Split",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: outputsTensorInfo,
          dispatchGroup: { x: Math.ceil(
            inputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    split = (context, attributes) => {
      validateInputs18(context.inputs);
      const updatedAttributes = context.inputs.length === 1 ? attributes : createSplitAttributesFromInputs(context.inputs, attributes);
      context.compute(createSplitProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
    parseSplitAttributes = (attributes) => {
      const axis = attributes.axis;
      const splitSizes = attributes.splitSizes;
      const numOutputs = attributes.numOutputs < 0 ? splitSizes.length : attributes.numOutputs;
      if (numOutputs !== splitSizes.length) {
        throw new Error("numOutputs and splitSizes length must be equal");
      }
      return createAttributeWithCacheKey({ axis, numOutputs, splitSizes });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts
var validateInputs19, createRotaryEmbeddingProgramInfo, rotaryEmbedding;
var init_rotary_embedding = __esm({
  "web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs19 = (inputs, attributes) => {
      const [input, positionIds, cosCache, sinCache] = inputs;
      const { numHeads, rotaryEmbeddingDim } = attributes;
      if (input.dims.length !== 3 && input.dims.length !== 4) {
        throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${input.dims.length}`);
      }
      if (!ShapeUtil.areEqual(positionIds.dims, []) && !ShapeUtil.areEqual(positionIds.dims, [1]) && positionIds.dims.length !== 2) {
        throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${positionIds.dims.length}`);
      }
      if (cosCache.dims.length !== 2) {
        throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${cosCache.dims.length}`);
      }
      if (sinCache.dims.length !== 2) {
        throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${sinCache.dims.length}`);
      }
      if (!ShapeUtil.areEqual(cosCache.dims, sinCache.dims)) {
        throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
      }
      if (rotaryEmbeddingDim > 0 && numHeads === 0) {
        throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
      }
      const batchSize = input.dims[0];
      const sequenceLength = input.dims[input.dims.length - 2];
      const maxSequenceLength = cosCache.dims[0];
      const hiddenSize = ShapeUtil.sizeFromDimension(input.dims, 1) / sequenceLength;
      const headSize = rotaryEmbeddingDim === 0 ? cosCache.dims[1] * 2 : hiddenSize / numHeads;
      if (rotaryEmbeddingDim > headSize) {
        throw new Error("rotary_embedding_dim must be less than or equal to head_size");
      }
      if (positionIds.dims.length === 2) {
        if (batchSize !== positionIds.dims[0]) {
          throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${positionIds.dims[0]}`);
        }
        if (sequenceLength !== positionIds.dims[1]) {
          throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${positionIds.dims[1]}`);
        }
      }
      if (headSize / 2 !== cosCache.dims[1] && rotaryEmbeddingDim / 2 !== cosCache.dims[1]) {
        throw new Error(
          `Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${cosCache.dims[1]}`
        );
      }
      if (sequenceLength > maxSequenceLength) {
        throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
      }
    };
    createRotaryEmbeddingProgramInfo = (inputs, attributes) => {
      const { interleaved, numHeads, rotaryEmbeddingDim, scale } = attributes;
      const batchSize = inputs[0].dims[0];
      const batchStride = ShapeUtil.sizeFromDimension(inputs[0].dims, 1);
      const sequenceLength = inputs[0].dims[inputs[0].dims.length - 2];
      const hiddenSize = batchStride / sequenceLength;
      const halfRotaryEmbeddingDim = inputs[2].dims[1];
      const headSize = rotaryEmbeddingDim === 0 ? halfRotaryEmbeddingDim * 2 : hiddenSize / numHeads;
      const globalShape = new Array(
        batchSize,
        sequenceLength,
        hiddenSize / headSize,
        headSize - halfRotaryEmbeddingDim
      );
      const globalStrides = ShapeUtil.computeStrides(globalShape);
      const programUniforms = [
        { type: 1 /* float */, data: scale },
        { type: 12 /* uint32 */, data: globalShape },
        { type: 12 /* uint32 */, data: globalStrides },
        // strides for addressing the input/output tensor, in permutated order to align with the unfolded global index,
        // i.e. BSNH
        ...inputs[0].dims.length === 3 ? new Array({ type: 12 /* uint32 */, data: [batchStride, hiddenSize, headSize, 1] }) : [],
        ...inputs[0].dims.length === 4 ? new Array({
          type: 12 /* uint32 */,
          data: [batchStride, headSize, sequenceLength * headSize, 1]
        }) : [],
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, inputs[2].dims, inputs[3].dims, inputs[0].dims)
      ];
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
        const positionIds = inputVariable("position_ids", inputs[1].dataType, inputs[1].dims.length);
        const cosCache = inputVariable("cos_cache", inputs[2].dataType, inputs[2].dims.length);
        const sinCache = inputVariable("sin_cache", inputs[3].dataType, inputs[3].dims.length);
        const output = outputVariable("output", inputs[0].dataType, inputs[0].dims.length);
        shaderHelper.registerUniforms([
          { name: "scale", type: "f32" },
          { name: "global_shape", type: "u32", length: globalShape.length },
          { name: "global_strides", type: "u32", length: globalStrides.length },
          { name: "input_output_strides", type: "u32", length: globalStrides.length }
        ]);
        return `
        ${shaderHelper.declareVariables(input, positionIds, cosCache, sinCache, output)}

        ${shaderHelper.mainStart(WORKGROUP_SIZE)}
          let half_rotary_emb_dim = uniforms.${cosCache.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${positionIds.broadcastedIndicesToOffset("bsnh.xy", outputVariable("", positionIds.type.tensor, 2))};
            let position_id =
                u32(${positionIds.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${interleaved});
            let j = i + select(half_rotary_emb_dim, 1, ${interleaved});
            let re = ${input.getByOffset("i")} * ${cosCache.get("position_id", "bsnh[3]")} -
                ${input.getByOffset("j")} * ${sinCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("i", "re")}
            let im = ${input.getByOffset("i")} * ${sinCache.get("position_id", "bsnh[3]")} +
                ${input.getByOffset("j")} * ${cosCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${output.setByOffset("k", input.getByOffset("k"))}
          }
        }`;
      };
      return {
        name: "RotaryEmbedding",
        shaderCache: {
          hint: createAttributeWithCacheKey({
            interleaved
          }).cacheKey,
          inputDependencies: ["rank", "rank", "rank", "rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(ShapeUtil.size(globalShape) / WORKGROUP_SIZE) },
          programUniforms
        })
      };
    };
    rotaryEmbedding = (context, attributes) => {
      validateInputs19(context.inputs, attributes);
      context.compute(createRotaryEmbeddingProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts
var validateInputs20, weightTransposeAttribute3, maybeTransposeToBNSH, generatePositionIdsProgramInfo, groupQueryAttention;
var init_group_query_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_wasm_common();
    init_attention();
    init_multihead_attention();
    init_split();
    init_transpose();
    init_rotary_embedding();
    init_common();
    validateInputs20 = (inputs, attributes) => {
      if (attributes.doRotary && inputs.length <= 7) {
        throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");
      }
      const query = inputs[0];
      const key = inputs[1];
      const value = inputs[2];
      const pastKey = inputs[3];
      const pastValue = inputs[4];
      if (attributes.doRotary !== 0 && inputs.length <= 7) {
        throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");
      }
      if (attributes.localWindowSize !== -1) {
        throw new Error("Local attention is not supported");
      }
      if (attributes.softcap !== 0) {
        throw new Error("Softcap is not supported");
      }
      if (attributes.rotaryInterleaved !== 0) {
        throw new Error("Rotary interleaved is not supported");
      }
      if (attributes.smoothSoftmax) {
        throw new Error("Smooth softmax is not supported");
      }
      if (query.dims.length !== 3 && query.dims.length !== 5) {
        throw new Error("Input query is expected to have 3 or 5 dimensions");
      }
      const dmmhaPacking = false;
      const batchSize = query.dims[0];
      const sequenceLength = query.dims[1];
      let hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
      let kvSequenceLength = sequenceLength;
      let pastSequenceLength = 0;
      const packedQKV = !key || key.dims.length === 0;
      const headSize = !packedQKV ? Math.floor(hiddenSize / attributes.numHeads) : Math.floor(hiddenSize / (attributes.numHeads + 2 * attributes.kvNumHeads));
      if (packedQKV) {
        hiddenSize = headSize * attributes.numHeads;
      }
      const hasPastKey = pastKey && pastKey.dims.length !== 0;
      const hasPastValue = pastValue && pastValue.dims.length !== 0;
      const isPastkvBSNH = hasPastKey && pastKey.dims.length === 4 && pastKey.dims[0] === batchSize && pastKey.dims[1] !== attributes.kvNumHeads && pastKey.dims[2] === attributes.kvNumHeads && pastKey.dims[3] === headSize;
      if (isPastkvBSNH) {
        throw new Error("BSNH pastKey/pastValue is not supported");
      }
      if (hasPastKey && hasPastValue) {
        if (pastKey.dims.length !== 4) {
          throw new Error('Input "past_key" is expected to have 4 dimensions');
        }
        if (pastValue.dims.length !== 4) {
          throw new Error('Input "past_value" is expected to have 4 dimensions');
        }
        pastSequenceLength = pastKey.dims[2];
      } else if (hasPastKey || hasPastValue) {
        throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      }
      let qkvFormat = 1 /* qkvBNSH */;
      if (key && key.dims.length > 0) {
        if (query.dims.length !== 3) {
          throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        }
        if (key.dims.length < 3 || key.dims.length > 5) {
          throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        }
        if (query.dims[0] !== key.dims[0]) {
          throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        }
        if (key.dims.length === 3) {
          if (query.dims[2] % key.dims[2] !== 0) {
            throw new Error('Dimension 2 of "query" should be a multiple of "key"');
          }
          kvSequenceLength = key.dims[1];
        } else if (key.dims.length === 5) {
          if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          }
          if (value) {
            throw new Error('Expect "value" be none when "key" has packed kv format.');
          }
          kvSequenceLength = key.dims[1];
        } else {
          if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          }
          kvSequenceLength = key.dims[2];
        }
      } else {
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
        }
        if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
          throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        }
        qkvFormat = 3 /* qkvBSN3H */;
      }
      const maskType = 0 /* none */;
      let passPastInKv = false;
      let vHiddenSize = attributes.kvNumHeads ? headSize * attributes.kvNumHeads : hiddenSize;
      if (value && value.dims.length > 0) {
        if (value.dims.length !== 3 && value.dims.length !== 4) {
          throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        }
        if (query.dims[0] !== value.dims[0]) {
          throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        }
        if (value.dims.length === 3) {
          if (kvSequenceLength !== value.dims[1]) {
            throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[2];
        } else {
          if (kvSequenceLength !== value.dims[2]) {
            throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[1] * value.dims[3];
          passPastInKv = true;
        }
      }
      const seqlLens = inputs.length > 4 ? inputs[5] : void 0;
      if (seqlLens && seqlLens.dims.length !== 1 && seqlLens.dims[0] !== batchSize) {
        throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');
      }
      const totalSequenceLength = -1;
      const maxSequenceLength = -1;
      const broadcastResPosBias = false;
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize: 0,
        hiddenSize,
        vHiddenSize,
        headSize,
        vHeadSize: Math.floor(vHiddenSize / attributes.kvNumHeads),
        numHeads: attributes.numHeads,
        kvNumHeads: attributes.kvNumHeads,
        nReps: attributes.numHeads / attributes.kvNumHeads,
        pastPresentShareBuffer: false,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias,
        passPastInKv,
        qkvFormat
      };
    };
    weightTransposeAttribute3 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
    maybeTransposeToBNSH = (context, input, params) => {
      let reshapedInput = input;
      const numHeads = params.kvNumHeads;
      if (input.dims.length === 3 && params.kvSequenceLength !== 0) {
        reshapedInput = input.reshape([params.batchSize, params.kvSequenceLength, numHeads, params.headSize]);
        reshapedInput = context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute3.perm), {
          inputs: [reshapedInput],
          outputs: [-1]
        })[0];
      }
      return reshapedInput;
    };
    generatePositionIdsProgramInfo = (batchSize, sequenceLength, seqLens, totalSeqLen) => {
      const outputDataType = 7 /* int64 */;
      const inputDependencies = ["type", "type"];
      const outputShape = [batchSize * sequenceLength];
      const outputSize = batchSize * sequenceLength;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: sequenceLength },
        { type: 12 /* uint32 */, data: batchSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const seqLensInputHelper = inputVariable("seq_lens", seqLens.dataType, seqLens.dims);
        const totalSeqLenInputHelper = inputVariable("total_seq_lens", totalSeqLen.dataType, totalSeqLen.dims);
        const positionIdsHelper = outputVariable("pos_ids", outputDataType, outputShape);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "sequence_length", type: "u32" },
          { name: "batch_size", type: "u32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(seqLensInputHelper, totalSeqLenInputHelper, positionIdsHelper)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${totalSeqLenInputHelper.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${seqLensInputHelper.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${positionIdsHelper.setByOffset("global_idx", "pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${positionIdsHelper.setByOffset("global_idx", "pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${positionIdsHelper.setByOffset("global_idx", "seqlen")}
    };
  }
  `;
      };
      return {
        name: "GeneratePositionIds",
        shaderCache: { hint: `${batchSize};${sequenceLength}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    groupQueryAttention = (context, attributes) => {
      const params = validateInputs20(context.inputs, attributes);
      if (context.inputs[0].dims.length === 5) {
        throw new Error("Packed QKV is not implemented");
      }
      if (context.inputs[1]?.dims.length === 5) {
        throw new Error("Packed KV is not implemented");
      }
      const q = context.inputs[0];
      const k = context.inputs[1] && context.inputs[1].dims.length > 0 ? context.inputs[1] : void 0;
      const v = context.inputs[2] && context.inputs[2].dims.length > 0 ? context.inputs[2] : void 0;
      const pastKey = context.inputs[3] && context.inputs[3].dims.length !== 0 ? context.inputs[3] : void 0;
      const pastValue = context.inputs[4] && context.inputs[4].dims.length !== 0 ? context.inputs[4] : void 0;
      const seqLens = context.inputs.length > 4 ? context.inputs[5] : void 0;
      const totalSequenceLengthInput = context.inputs.length > 5 ? context.inputs[6] : void 0;
      const kvNumHeads = params.kvNumHeads ? params.kvNumHeads : params.numHeads;
      const splitAttributes = createAttributeWithCacheKey({
        axis: 2,
        numOutputs: 3,
        splitSizes: [params.numHeads * params.headSize, kvNumHeads * params.headSize, kvNumHeads * params.headSize]
      });
      const [query, key, value] = !k && !v ? context.compute(createSplitProgramInfo([q], splitAttributes), { inputs: [q], outputs: [-1, -1, -1] }) : [q, k, v];
      let qRotary;
      let kRotary;
      if (attributes.doRotary) {
        const posIds = context.compute(
          generatePositionIdsProgramInfo(params.batchSize, params.sequenceLength, seqLens, totalSequenceLengthInput),
          { inputs: [seqLens, totalSequenceLengthInput], outputs: [-1] }
        )[0];
        const cosCache = context.inputs[7];
        const sinCache = context.inputs[8];
        const qRotaryEmbeddingAttributes = createAttributeWithCacheKey({
          interleaved: attributes.rotaryInterleaved !== 0,
          numHeads: params.numHeads,
          rotaryEmbeddingDim: 0,
          scale: attributes.scale
        });
        const inputs = [query, posIds, cosCache, sinCache];
        const outputs = [-1];
        qRotary = context.compute(createRotaryEmbeddingProgramInfo(inputs, qRotaryEmbeddingAttributes), {
          inputs,
          outputs
        })[0];
        inputs.splice(0, 1, key);
        const kRotaryEmbeddingAttributes = createAttributeWithCacheKey({
          interleaved: attributes.rotaryInterleaved !== 0,
          numHeads: params.kvNumHeads,
          rotaryEmbeddingDim: 0,
          scale: attributes.scale
        });
        kRotary = context.compute(createRotaryEmbeddingProgramInfo(inputs, kRotaryEmbeddingAttributes), {
          inputs,
          outputs
        })[0];
      }
      const Q = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.sequenceLength,
        params.headSize,
        attributes.doRotary ? qRotary : query,
        void 0,
        0
      );
      const K = maybeTransposeToBNSH(context, attributes.doRotary ? kRotary : key, params);
      const V = maybeTransposeToBNSH(context, value, params);
      applyAttention(
        context,
        Q,
        K,
        V,
        void 0,
        void 0,
        pastKey,
        pastValue,
        void 0,
        params,
        seqLens,
        totalSequenceLengthInput
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/instance-norm.ts
var computeChannelScaleShift, createInstanceNormProgramInfo, createInstanceNormNHWCProgramInfo, instanceNorm;
var init_instance_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_transpose();
    init_common();
    computeChannelScaleShift = (context, input, scale, bias, n, h, c, epsilon) => {
      const components = getMaxComponents(h);
      const f32Type = components === 1 ? "f32" : `vec${components}f`;
      const wgType = components === 1 ? "vec2f" : `mat2x${components}f`;
      const unitsOfWork = n * c;
      let workgroupSize = 64;
      if (unitsOfWork === 1) {
        workgroupSize = 256;
      }
      const inputShape = [n, c, h / components];
      const outputShape = [n, c, 2];
      const inputDependencies = ["rank", "type", "type"];
      const programUniforms = [];
      programUniforms.push(...createTensorShapeVariables(inputShape, outputShape));
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", input.dataType, 3, components);
        const s = inputVariable("scale", scale.dataType, scale.dims);
        const b = inputVariable("bias", bias.dataType, bias.dims);
        const output = outputVariable("output", 1 /* float */, 3, 2);
        const variables = [x, s, b, output];
        return `
  var<workgroup> workgroup_shared : array<${wgType}, ${workgroupSize}>;
  const workgroup_size = ${workgroupSize}u;
  ${shaderHelper.declareVariables(...variables)}
  ${shaderHelper.mainStart(workgroupSize)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${f32Type}(0);
    var squared_sum = ${f32Type}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${f32Type}(${x.get("batch", "channel", "h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${wgType}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${sumVector("workgroup_shared[0][0]", components)} / f32(hight * ${components});
      let squared_sum_final = ${sumVector("workgroup_shared[0][1]", components)} / f32(hight * ${components});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${epsilon}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`;
      };
      return context.compute(
        {
          name: "InstanceNormComputeChannelScaleShift",
          // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
          shaderCache: { hint: `${components};${epsilon};${workgroupSize}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: 1 /* float */ }],
            dispatchGroup: { x: unitsOfWork },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [input, scale, bias], outputs: [-1] }
      )[0];
    };
    createInstanceNormProgramInfo = (context, inputs, attributes) => {
      const xShape = inputs[0].dims;
      const outputShape = xShape;
      const axis = 2;
      const N = xShape[0];
      const C = xShape[1];
      const H = ShapeUtil.sizeFromDimension(xShape, axis);
      const components = getMaxComponents(H);
      const outputSize = ShapeUtil.size(outputShape) / components;
      const channelScaleShift = computeChannelScaleShift(
        context,
        inputs[0],
        inputs[1],
        inputs[2],
        N,
        H,
        C,
        attributes.epsilon
      );
      const inputShape = [N, C, H / components];
      const scaleShape = [N, C];
      const inputDependencies = ["type", "none"];
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", inputs[0].dataType, inputShape.length, components);
        const scale = inputVariable("scale_shift", 1 /* float */, scaleShape.length, 2);
        const output = outputVariable("output", inputs[0].dataType, inputShape.length, components);
        const variables = [x, scale, output];
        return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(...variables)}
  ${shaderHelper.mainStart()}
  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${output.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${scale.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${x.getByOffset("global_idx")} * ${output.type.value}(scale_shift.x) + ${output.type.value}(scale_shift.y);
      ${output.setByOffset("global_idx", "value")};
  }`;
      };
      context.compute(
        {
          name: "InstanceNormalization",
          shaderCache: { hint: `${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(inputShape, scaleShape, inputShape)
            ]
          }),
          getShaderSource
        },
        { inputs: [inputs[0], channelScaleShift] }
      );
    };
    createInstanceNormNHWCProgramInfo = (context, inputs, attributes) => {
      const xShape = inputs[0].dims;
      const outputShape = xShape;
      const N = xShape[0];
      const C = xShape[xShape.length - 1];
      const H = ShapeUtil.sizeFromDimension(xShape, 1) / C;
      const components = getMaxComponents(C);
      const outputSize = ShapeUtil.size(outputShape) / components;
      const programUniforms = [
        { type: 12 /* uint32 */, data: H },
        { type: 12 /* uint32 */, data: Math.floor(C / components) }
      ];
      const inputDependencies = ["type", "type"];
      let needTranspose = false;
      const transposedXPerm = [0, xShape.length - 1];
      for (let i = 0; i < xShape.length - 2; i++) {
        needTranspose = needTranspose || xShape[i + 1] !== 1;
        transposedXPerm.push(i + 1);
      }
      needTranspose = needTranspose && xShape[xShape.length - 1] !== 1;
      const transposedX = needTranspose ? context.compute(createTransposeProgramInfo(context.inputs[0], transposedXPerm), {
        inputs: [context.inputs[0]],
        outputs: [-1]
      })[0] : context.inputs[0].reshape(Array.from({ length: xShape.length }, (_, i) => xShape[transposedXPerm[i]]));
      const channelScaleShift = computeChannelScaleShift(
        context,
        transposedX,
        inputs[1],
        inputs[2],
        N,
        H,
        C,
        attributes.epsilon
      );
      const getShaderSource = (shaderHelper) => {
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const scaleType = components === 1 ? "vec2f" : `mat${components}x2f`;
        const scaleData = (num) => {
          const index = num === 0 ? "x" : "y";
          const f32Type = components === 1 ? "f32" : `vec${components}f`;
          switch (components) {
            case 1:
              return `${dataType}(${f32Type}(scale.${index}))`;
            case 2:
              return `vec2<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}))`;
            case 4:
              return `vec4<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}, scale[2].${index}, scale[3].${index}))`;
            default:
              throw new Error(`Not supported compoents ${components}`);
          }
        };
        const inputHelper = inputVariable("input", inputs[0].dataType, inputs[0].dims, components);
        const outputHelper = outputVariable("output", inputs[0].dataType, outputShape, components);
        return `
  @group(0) @binding(0) var<storage, read> input : array<${inputHelper.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${scaleType}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${outputHelper.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${scaleData(0)}, ${scaleData(1)});
  }`;
      };
      context.compute(
        {
          name: "InstanceNormalizationNHWC",
          shaderCache: { hint: `${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [inputs[0], channelScaleShift] }
      );
    };
    instanceNorm = (context, attributes) => {
      if (attributes.format === "NHWC") {
        createInstanceNormNHWCProgramInfo(context, context.inputs, attributes);
      } else {
        createInstanceNormProgramInfo(context, context.inputs, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/layer-norm.ts
var validateInputs21, createLayerNormProgramInfo, layerNorm;
var init_layer_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs21 = (inputs) => {
      if (!inputs || inputs.length < 2) {
        throw new Error("layerNorm requires at least 2 inputs.");
      }
    };
    createLayerNormProgramInfo = (inputs, attributes, outputCount) => {
      const simplified = attributes.simplified;
      const xShape = inputs[0].dims;
      const scale = inputs[1];
      const bias = !simplified && inputs[2];
      const outputShape = xShape;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, xShape.length);
      const normCount = ShapeUtil.sizeToDimension(xShape, axis);
      const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
      const scaleSize = ShapeUtil.size(scale.dims);
      const biasSize = bias ? ShapeUtil.size(bias.dims) : 0;
      if (scaleSize !== normSize || bias && biasSize !== normSize) {
        throw new Error(`Size of X.shape()[axis:] == ${normSize}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${scaleSize} and bias size of ${biasSize}`);
      }
      const meanInvStdDevDim = [];
      for (let i = 0; i < xShape.length; ++i) {
        if (i < axis) {
          meanInvStdDevDim.push(xShape[i]);
        } else {
          meanInvStdDevDim.push(1);
        }
      }
      const components = getMaxComponents(normSize);
      const inputDependencies = ["type", "type"];
      const programUniforms = [
        { type: 12 /* uint32 */, data: normCount },
        { type: 1 /* float */, data: normSize },
        { type: 12 /* uint32 */, data: Math.floor(normSize / components) },
        { type: 1 /* float */, data: attributes.epsilon }
      ];
      if (bias) {
        inputDependencies.push("type");
      }
      const hasMeanDataOutput = outputCount > 1;
      const hasInvStdOutput = outputCount > 2;
      const getShaderSource = (shaderHelper) => {
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const variables = [
          inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
          inputVariable("scale", scale.dataType, scale.dims, components)
        ];
        if (bias) {
          variables.push(inputVariable("bias", bias.dataType, bias.dims, components));
        }
        variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
        if (hasMeanDataOutput) {
          variables.push(outputVariable("mean_data_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInvStdOutput) {
          variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
        }
        const uniforms = [
          { name: "norm_count", type: "u32" },
          { name: "norm_size", type: "f32" },
          { name: "norm_size_vectorized", type: "u32" },
          { name: "epsilon", type: "f32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${fillVector("f32", components)};
    var mean_square_vector = ${fillVector("f32", components)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${castToF32(dataType, components, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${sumVector("mean_vector", components)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${sumVector("mean_square_vector", components)} / uniforms.norm_size ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${castToF32(dataType, components, "x[j + offset]")};
      let f32scale = ${castToF32(dataType, components, "scale[j]")};
      output[j + offset] = ${variables[0].type.value}((f32input ${simplified ? "" : "- mean"}) * inv_std_dev * f32scale
        ${bias ? `+ ${castToF32(dataType, components, "bias[j]")}` : ""}
      );
    }

    ${hasMeanDataOutput ? "mean_data_output[global_idx] = mean" : ""};
    ${hasInvStdOutput ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
      };
      const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
      if (hasMeanDataOutput) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (hasInvStdOutput) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      return {
        name: "LayerNormalization",
        shaderCache: { hint: `${components};${outputCount};${simplified}`, inputDependencies },
        getRunData: () => ({
          outputs,
          dispatchGroup: { x: Math.ceil(
            normCount / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    layerNorm = (context, attributes) => {
      validateInputs21(context.inputs);
      context.compute(createLayerNormProgramInfo(context.inputs, attributes, context.outputCount));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmul.ts
var validateInputs22, matMul;
var init_matmul = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmul.ts"() {
    "use strict";
    init_util();
    init_matmul_shaders();
    init_matmul_packed_webgpu();
    validateInputs22 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("MatMul requires 2 inputs.");
      }
      if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
        throw new Error("shared dimension does not match.");
      }
    };
    matMul = (context) => {
      validateInputs22(context.inputs);
      const outputShape = BroadcastUtil.calcShape(context.inputs[0].dims, context.inputs[1].dims, true);
      if (!outputShape) {
        throw new Error("Can't use matmul on the given tensors");
      }
      const N = outputShape[outputShape.length - 1];
      const K = context.inputs[0].dims[context.inputs[0].dims.length - 1];
      if (N < 8 && K < 8) {
        context.compute(createNaiveMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
      } else {
        const M = outputShape[outputShape.length - 2];
        const batchA = ShapeUtil.size(context.inputs[0].dims.slice(0, -2));
        const batchB = ShapeUtil.size(context.inputs[1].dims.slice(0, -2));
        if (batchA !== 1 && M === 1 && batchB === 1) {
          const reshapedA = context.inputs[0].reshape([1, batchA, K]);
          const reshapedB = context.inputs[1].reshape([1, K, N]);
          const matmulOutputShape = [1, batchA, N];
          const matmulInputs = [reshapedA, reshapedB];
          context.compute(createMatmulProgramInfo(matmulInputs, { activation: "" }, outputShape, matmulOutputShape), {
            inputs: matmulInputs
          });
        } else {
          context.compute(createMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
        }
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts
var validateInputs23, createMatMulNBitsProgramInfo, createMatMulNBitsBlockSize32ProgramInfo, matMulNBits, parseMatMulNBitsAttributes;
var init_matmulnbits = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs23 = (inputs, attributes) => {
      if (inputs.length < 3 || inputs.length > 4) {
        throw new Error("MatMulNBits requires 3 or 4 inputs");
      }
      const a = inputs[0];
      const aRank = a.dims.length;
      if (a.dims[aRank - 1] !== attributes.k) {
        throw new Error("The last dim of input shape does not match the k value");
      }
      const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
      const blobSize = attributes.blockSize / 8 * attributes.bits;
      const b = inputs[1];
      if (!ShapeUtil.areEqual(b.dims, [attributes.n, nBlocksPerCol, blobSize])) {
        throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
      }
      const scales = inputs[2];
      const scalesShape = scales.dims;
      if (ShapeUtil.size(scalesShape) !== attributes.n * nBlocksPerCol) {
        throw new Error("scales input size error.");
      }
      if (inputs.length === 4) {
        const zeroPoints = inputs[3];
        const zeroPointsShape = zeroPoints.dims;
        const expectedZeroPointsSize = attributes.n * (attributes.bits === 8 ? nBlocksPerCol : Math.floor((nBlocksPerCol * attributes.bits + 7) / 8));
        if (ShapeUtil.size(zeroPointsShape) !== expectedZeroPointsSize) {
          throw new Error("zeroPoints input size error.");
        }
      }
    };
    createMatMulNBitsProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const aRank = inputShape.length;
      const dimAOuter = inputShape[aRank - 2];
      const dimInner = attributes.k;
      const dimBOuter = attributes.n;
      const batchDims = inputShape.slice(0, aRank - 2);
      const batchSize = ShapeUtil.size(batchDims);
      const blobSize = inputs[1].dims[2];
      const blobSizeInWords = blobSize / 4;
      const dataType = inputs[0].dataType;
      const aComponents = getMaxComponents(attributes.k);
      const bComponents = getMaxComponents(blobSizeInWords);
      const components = getMaxComponents(dimBOuter);
      const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
      const outputNumber = dimAOuter > 1 && dimBOuter / components % 2 === 0 ? 2 : 1;
      const dispatchSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const workgroupSize = 64;
      const programUniforms = [];
      const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
      const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
      bShape.splice(-1, 1, blobSizeInWords / bComponents);
      programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
      programUniforms.push(...createTensorShapeVariables(bShape));
      programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      if (inputs.length === 4) {
        programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
      }
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const inputRank = inputShapeTemp.length;
        const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
        const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const inputVariables = [a, b, scales];
        const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
        if (zeroPoints) {
          inputVariables.push(zeroPoints);
        }
        const outputRank = outputShapeTemp.length;
        const output = outputVariable("output", inputs[0].dataType, outputRank, components);
        const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
        const qDqDataType = (() => {
          switch (aComponents) {
            case 1:
              return `array<${dataType2}, 8>`;
            case 2:
              return `mat4x2<${dataType2}>`;
            case 4:
              return `mat2x4<${dataType2}>`;
            default:
              throw new Error(`${aComponents}-component is not supported.`);
          }
        })();
        const processOneWord = () => {
          let calcStr = `
          // reuse a data
            var input_offset = ${a.indicesToOffset(`${a.type.indices}(batch, row, word_offset)`)};
            var a_data: ${qDqDataType};
            for (var j: u32 = 0; j < ${8 / aComponents}; j++) {
              a_data[j] = ${a.getByOffset("input_offset")};
              input_offset++;
            }
          `;
          for (let c = 0; c < components * outputNumber; c++) {
            calcStr += `
            b_value = ${bComponents === 1 ? `b${c}_data` : `b${c}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${qDqDataType}(${Array.from(
              { length: 4 },
              (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
            ).join(", ")});
            b_dequantized_values = ${(() => {
              if (aComponents === 1) {
                return `${qDqDataType}(${Array.from(
                  { length: 8 },
                  (_, i) => `(b_quantized_values[${i}] - ${zeroPoints ? `zero_point${c}` : "zero_point"}) * scale${c}`
                ).join(", ")});`;
              } else {
                return `(b_quantized_values - ${qDqDataType}(${Array(8).fill(`${zeroPoints ? `zero_point${c}` : "zero_point"}`).join(",")})) * scale${c};`;
              }
            })()};
            workgroup_shared[local_id.x * ${outputNumber} + ${Math.floor(c / components)}]${components > 1 ? `[${c % components}]` : ""} += ${Array.from(
              { length: 8 / aComponents },
              (_, i) => `${aComponents === 1 ? `a_data[${i}] * b_dequantized_values[${i}]` : `dot(a_data[${i}], b_dequantized_values[${i}])`}`
            ).join(" + ")};
          `;
          }
          return calcStr;
        };
        const prepareScaleAndZeroPoint = () => {
          let calcStr = `
            var col_index = col * ${components};
            ${zeroPoints ? `
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${8});`}
            `;
          for (let c = 0; c < components * outputNumber; c++) {
            calcStr += `
            let scale${c} = ${scales.getByOffset(`col_index * nBlocksPerCol + block`)};
            ${zeroPoints ? `
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${c} = ${dataType2}((zero_point_word) & 0xFu);` : ""}
            col_index += 1;`;
          }
          return calcStr;
        };
        const prepareBData = () => {
          let calcStr = `col_index = col * ${components};`;
          for (let c = 0; c < components * outputNumber; c++) {
            calcStr += `
            let b${c}_data = ${b.getByIndices(`${b.type.indices}(col_index, block, word)`)};
            col_index += 1;`;
          }
          calcStr += `
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${qDqDataType};
            var b_dequantized_values: ${qDqDataType};`;
          return calcStr;
        };
        return `
        var<workgroup> workgroup_shared: array<${output.type.value}, ${outputNumber * workgroupSize}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupSize, 1, 1])}
          let output_indices = ${output.offsetToIndices(`(global_idx / ${workgroupSize}) * ${outputNumber}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${workgroupSize}) {
            //process one block
            var word_offset: u32 = block * ${attributes.blockSize / aComponents};
            ${prepareScaleAndZeroPoint()}
            for (var word: u32 = 0; word < ${blobSizeInWords}; word += ${bComponents}) {
              ${prepareBData()}
              for (var i: u32 = 0; i < ${bComponents}; i++) {
                ${processOneWord()}
                word_offset += ${8 / aComponents};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${outputNumber}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${workgroupSize}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${outputNumber};
            }
            ${output.setByIndices(`${output.type.indices}(batch, row, col + local_id.x)`, "output_value")};
          }
        }`;
      };
      return {
        name: "MatMulNBits",
        shaderCache: {
          hint: `${attributes.blockSize};${attributes.bits};${aComponents};${bComponents};${components};${outputNumber};${workgroupSize}`,
          inputDependencies: Array(inputs.length).fill("rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: dispatchSize },
          programUniforms
        }),
        getShaderSource
      };
    };
    createMatMulNBitsBlockSize32ProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const aRank = inputShape.length;
      const dimAOuter = inputShape[aRank - 2];
      const dimInner = attributes.k;
      const dimBOuter = attributes.n;
      const batchDims = inputShape.slice(0, aRank - 2);
      const batchSize = ShapeUtil.size(batchDims);
      const blobSize = inputs[1].dims[2];
      const blobSizeInWords = blobSize / 4;
      const dataType = inputs[0].dataType;
      const aComponents = getMaxComponents(attributes.k);
      const bComponents = getMaxComponents(blobSizeInWords);
      const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
      const workgroupSize = 128;
      const workgroupY = dimBOuter % 8 === 0 ? 8 : dimBOuter % 4 === 0 ? 4 : 1;
      const workgroupX = workgroupSize / workgroupY;
      const tileSize = workgroupX * bComponents * 8;
      const aLengthPerTile = tileSize / aComponents;
      const blocksPerTile = tileSize / attributes.blockSize;
      const dispatchSize = ShapeUtil.size(outputShape) / workgroupY;
      const programUniforms = [];
      const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
      const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
      bShape.splice(-1, 1, blobSizeInWords / bComponents);
      programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
      programUniforms.push(...createTensorShapeVariables(bShape));
      programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      if (inputs.length === 4) {
        programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
      }
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter];
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const inputRank = inputShapeTemp.length;
        const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
        const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const inputVariables = [a, b, scales];
        const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
        if (zeroPoints) {
          inputVariables.push(zeroPoints);
        }
        const outputRank = outputShapeTemp.length;
        const output = outputVariable("output", inputs[0].dataType, outputRank);
        const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
        const readA = () => {
          switch (aComponents) {
            case 1:
              return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;
            case 2:
              return `
          let a_data0 = vec4<${dataType2}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${dataType2}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;
            case 4:
              return `
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;
            default:
              throw new Error(`${aComponents}-component is not supported.`);
          }
        };
        return `
        var<workgroup> sub_a: array<${a.type.value}, ${aLengthPerTile}>;
        var<workgroup> inter_results: array<array<${output.type.value}, ${workgroupX}>, ${workgroupY}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupX, workgroupY, 1])}
          let output_indices = ${output.offsetToIndices(`workgroup_index * ${workgroupY}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${blocksPerTile} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${aLengthPerTile};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${aLengthPerTile}; a_offset += ${workgroupSize})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${a.getByIndices(`${a.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${a.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${blocksPerTile} + local_id.x;
            ${zeroPoints ? `
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${dataType2}((zero_point_word) & 0xFu);` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${8});`}
            let scale = ${scales.getByOffset(`b_row * n_blocks_per_col + block`)};
            let b_data = ${b.getByIndices(`${b.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${attributes.blockSize / aComponents};
            for (var i: u32 = 0; i < ${bComponents}; i++) {
              ${readA()}
              let b_value = ${bComponents === 1 ? `b_data` : `b_data[i]`};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${dataType2}>(${Array.from(
          { length: 4 },
          (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
        ).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${dataType2}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from(
          { length: 2 },
          (_, i) => `${`dot(a_data${i}, b_dequantized_values[${i}])`}`
        ).join(" + ")};
              word_offset += ${8 / aComponents};
            }
            workgroupBarrier();
          }

          if (local_idx < ${workgroupY}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            for (var b = 0u; b < ${workgroupX}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${output.setByIndices(`${output.type.indices}(batch, row, col + local_idx)`, "output_value")}
            }
          }
        }`;
      };
      return {
        name: "BlockwiseMatMulNBits32",
        shaderCache: {
          hint: `${attributes.blockSize};${aComponents};${bComponents};${workgroupX};${workgroupY}`,
          inputDependencies: Array(inputs.length).fill("rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: dispatchSize },
          programUniforms
        }),
        getShaderSource
      };
    };
    matMulNBits = (context, attributes) => {
      validateInputs23(context.inputs, attributes);
      if (attributes.blockSize === 32 && context.adapterInfo.isVendor("intel") && context.adapterInfo.isArchitecture("gen-12lp")) {
        context.compute(createMatMulNBitsBlockSize32ProgramInfo(context.inputs, attributes));
      } else {
        context.compute(createMatMulNBitsProgramInfo(context.inputs, attributes));
      }
    };
    parseMatMulNBitsAttributes = (attributes) => createAttributeWithCacheKey(attributes);
  }
});

// web/lib/wasm/jsep/webgpu/ops/pad.ts
var validateInputs24, getPadConstant, getPadReflect, getPadEdge, getPadWrap, getPadSnippet, createPadProgramInfo, createPadAttributesFromInputs, pad;
var init_pad = __esm({
  "web/lib/wasm/jsep/webgpu/ops/pad.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs24 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("Too few inputs");
      }
      if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */) {
        throw new Error("Input type must be float or float16.");
      }
      if (inputs.length >= 2) {
        let validPads = inputs[0].dims.length * 2 === inputs[1].dims[0];
        if (inputs.length === 4) {
          validPads = inputs[3].dims[0] * 2 === inputs[1].dims[0];
        }
        if (!validPads) {
          throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
        }
      }
    };
    getPadConstant = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
            k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
              break;
            }
            offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
        `;
      }
      return `
          value = ${output.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${block}
            value = x[offset];
          }
      `;
    };
    getPadReflect = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadEdge = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k = i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1;
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadWrap = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0)  {
                  k += i32(${getElementAt("uniforms.x_shape", i, inputRank)}]);
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k -= i32(${getElementAt("uniforms.x_shape", i, inputRank)});
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadSnippet = (output, inputRank, attributes) => {
      switch (attributes.mode) {
        case 0:
          return getPadConstant(output, inputRank, attributes.pads.length);
        case 1:
          return getPadReflect(output, inputRank, attributes.pads.length);
        case 2:
          return getPadEdge(output, inputRank, attributes.pads.length);
        case 3:
          return getPadWrap(output, inputRank, attributes.pads.length);
        default:
          throw new Error("Invalid mode");
      }
    };
    createPadProgramInfo = (inputs, attributes) => {
      const outputShape = ShapeUtil.padShape(inputs[0].dims.slice(), attributes.pads);
      const inputDims = inputs[0].dims;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: attributes.pads }
      ];
      const isValueFromInput = inputs.length >= 3 && inputs[2].data;
      if (attributes.mode === 0) {
        programUniforms.push({ type: isValueFromInput ? inputs[2].dataType : 1 /* float */, data: attributes.value });
      }
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, outputShape));
      const inputDependencies = ["rank"];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const input = inputVariable("x", inputs[0].dataType, inputDims.length);
        const dataType = input.type.value;
        const padSnippet = getPadSnippet(output, inputDims.length, attributes);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "pads", type: "i32", length: attributes.pads.length }
        ];
        if (attributes.mode === 0) {
          uniforms.push({ name: "constant_value", type: isValueFromInput ? dataType : "f32" });
        }
        return `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${output.offsetToIndices("global_idx")};

            var value = ${dataType}(0);
            ${padSnippet}
            output[global_idx] = value;
        }`;
      };
      return {
        name: "Pad",
        shaderCache: { hint: `${attributes.mode}${isValueFromInput}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    createPadAttributesFromInputs = (inputs, attributes) => {
      if (inputs.length > 1) {
        const bigInt64Pads = inputs[1].getBigInt64Array();
        const value = inputs.length >= 3 && inputs[2].data ? inputs[2].dataType === 10 /* float16 */ ? inputs[2].getUint16Array()[0] : inputs[2].getFloat32Array()[0] : 0;
        const inputRank = inputs[0].dims.length;
        const updatePads = new Int32Array(2 * inputRank).fill(0);
        if (inputs.length >= 4) {
          const axes = inputs[3].getBigInt64Array();
          for (let i = 0; i < axes.length; i++) {
            updatePads[Number(axes[i])] = Number(bigInt64Pads[i]);
            updatePads[Number(axes[i]) + inputRank] = Number(bigInt64Pads[i + axes.length]);
          }
        } else {
          bigInt64Pads.forEach((v, i) => updatePads[Number(i)] = Number(v));
        }
        const pads = [];
        updatePads.forEach((v) => pads.push(v));
        return { mode: attributes.mode, value, pads };
      } else {
        return attributes;
      }
    };
    pad = (context, attributes) => {
      validateInputs24(context.inputs);
      const updatedAttributes = createPadAttributesFromInputs(context.inputs, attributes);
      context.compute(createPadProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/pool.ts
var validateInputs25, getAdjustedPoolAttributesAndOutputShape, getUniformAndPadInfo, generatePoolingCode, createShaderKeyFromAttributes, createAveragePoolShaderKeyFromAttributes, createMaxPoolShaderKeyFromAttributes, parsePoolCommonAttributes, createAveragePoolProgramInfo, parseAveragePoolAttributes, averagePool, globalPoolAttributes, parseGlobalAveragePoolAttributes, globalAveragePool, createMaxPoolProgramInfo, maxPool, parseMaxPoolAttributes, parseGlobalMaxPoolAttributes, globalMaxPool;
var init_pool = __esm({
  "web/lib/wasm/jsep/webgpu/ops/pool.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_util();
    init_common();
    validateInputs25 = (inputs) => {
      if (env2.webgpu.validateInputContent && (!inputs || inputs.length !== 1)) {
        throw new Error("Pool ops requires 1 input.");
      }
    };
    getAdjustedPoolAttributesAndOutputShape = (input, attributes, isGlobalOperator) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inputShapeAsChannelFirst = input.dims.slice();
      if (isChannelsLast) {
        inputShapeAsChannelFirst.splice(1, 0, inputShapeAsChannelFirst.pop());
      }
      const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
      const kernelShape = attributes.kernelShape.slice();
      const strides = attributes.strides.slice();
      const dilations = hasDilations ? attributes.dilations.slice() : [];
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShapeAsChannelFirst, kernelShape, strides, dilations, pads);
      const outputShapeAsChannelFirst = PoolConvUtil.computePoolOutputShape(
        isGlobalOperator,
        inputShapeAsChannelFirst,
        strides,
        dilations,
        kernelShape,
        pads,
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      if (hasDilations) {
        Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
      } else {
        Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
      }
      const outputShapeAsChannelLast = outputShapeAsChannelFirst.slice();
      outputShapeAsChannelLast.push(outputShapeAsChannelLast.splice(1, 1)[0]);
      return [newAttributes, isChannelsLast ? outputShapeAsChannelLast : outputShapeAsChannelFirst];
    };
    getUniformAndPadInfo = (outputShape, attributes) => {
      const isChannelsLast = attributes.format === "NHWC";
      const outputSize = ShapeUtil.size(outputShape);
      const kernelSize = ShapeUtil.size(attributes.kernelShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: kernelSize }
      ];
      const uniforms = [
        { name: "outputSize", type: "u32" },
        { name: "kernelSize", type: "u32" }
      ];
      if (attributes.kernelShape.length <= 2) {
        const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
        const sw = attributes.strides[attributes.strides.length - 1];
        const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
        const pwEnd = attributes.pads[attributes.pads.length - 1];
        const pwStartEndNotZero = !!(pwStart + pwEnd);
        programUniforms.push(
          { type: 12 /* uint32 */, data: kw },
          { type: 12 /* uint32 */, data: sw },
          { type: 12 /* uint32 */, data: pwStart },
          { type: 12 /* uint32 */, data: pwEnd }
        );
        uniforms.push(
          { name: "kw", type: "u32" },
          { name: "sw", type: "u32" },
          { name: "pwStart", type: "u32" },
          { name: "pwEnd", type: "u32" }
        );
        let phStartEndNotZero = false;
        if (attributes.kernelShape.length === 2) {
          const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
          const sh = attributes.strides[attributes.strides.length - 2];
          const phStart = attributes.pads[attributes.pads.length / 2 - 2];
          const phEnd = attributes.pads[attributes.pads.length - 2];
          phStartEndNotZero = !!(phStart + phEnd);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kh },
            { type: 12 /* uint32 */, data: sh },
            { type: 12 /* uint32 */, data: phStart },
            { type: 12 /* uint32 */, data: phEnd }
          );
          uniforms.push(
            { name: "kh", type: "u32" },
            { name: "sh", type: "u32" },
            { name: "phStart", type: "u32" },
            { name: "phEnd", type: "u32" }
          );
        }
        return [programUniforms, uniforms, true, pwStartEndNotZero, phStartEndNotZero];
      } else {
        if (isChannelsLast) {
          throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        }
        const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
        programUniforms.push(
          { type: 12 /* uint32 */, data: kernelStrides },
          { type: 12 /* uint32 */, data: attributes.pads },
          { type: 12 /* uint32 */, data: attributes.strides }
        );
        uniforms.push(
          { name: "kernelStrides", type: "u32", length: kernelStrides.length },
          { name: "pads", type: "u32", length: attributes.pads.length },
          { name: "strides", type: "u32", length: attributes.strides.length }
        );
        const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);
        return [programUniforms, uniforms, !!hasPads, false, false];
      }
    };
    generatePoolingCode = (shaderHelper, x, rank, outputShapeRank, attributes, op1, op2, start, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero) => {
      const isChannelsLast = attributes.format === "NHWC";
      const dataType = x.type.value;
      const output = outputVariable("output", x.type.tensor, outputShapeRank);
      if (attributes.kernelShape.length <= 2) {
        let codeW = "";
        let codeH = "";
        let codeHEnd = "";
        const dimIdxW = rank - (isChannelsLast ? 2 : 1);
        if (pwStartEndNotZero) {
          codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${dimIdxW}] < 0 || xIndices[${dimIdxW}]
                      >= uniforms.x_shape[${dimIdxW}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
        } else {
          codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
        }
        if (attributes.kernelShape.length === 2) {
          const dimIdxH = rank - (isChannelsLast ? 3 : 2);
          if (phStartEndNotZero) {
            codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${dimIdxH}] < 0 || xIndices[${dimIdxH}] >= uniforms.x_shape[${dimIdxH}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `;
          } else {
            codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                `;
          }
          codeHEnd = `
              }
            `;
        }
        const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var value = ${dataType}(${start});
              var pad = 0;
              ${codeH}
              ${codeW}
              ${codeHEnd}
              ${op2}

              output[global_idx] = value;
            }`;
        return poolingCode;
      } else {
        if (isChannelsLast) {
          throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        }
        const stridesRank = attributes.kernelShape.length;
        const padsRank = attributes.pads.length;
        let padCode = "";
        if (hasPads) {
          padCode = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${x.indicesToOffset("xIndices")}];
                ${op1}
              }`;
        } else {
          padCode = `
              }
              let x_val = x[${x.indicesToOffset("xIndices")}];
              ${op1}
            `;
        }
        const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var offsets: array<u32, ${stridesRank}>;

              var value = ${dataType}(${start});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${stridesRank - 1}u; j++) {
                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                }
                offsets[${stridesRank - 1}] = offset;

                isPad = false;
                for (var j = ${rank - stridesRank}u; j < ${rank}u; j++) {
                  xIndices[j] = indices[j] * ${getElementAt(
          "uniforms.strides",
          `j - ${rank - stridesRank}u`,
          stridesRank
        )}
                    + offsets[j - ${rank - stridesRank}u] - ${getElementAt("uniforms.pads", "j - 2u", padsRank)};
                  ${padCode}
              }
              ${op2}

              output[global_idx] = value;
            }`;
        return poolingCode;
      }
    };
    createShaderKeyFromAttributes = (attributes) => `${attributes.format};${attributes.ceilMode};${attributes.autoPad};${attributes.kernelShape.length}`;
    createAveragePoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.countIncludePad}`;
    createMaxPoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.storageOrder};${attributes.dilations}`;
    parsePoolCommonAttributes = (attributes) => ({
      format: attributes.format,
      autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad],
      ceilMode: attributes.ceil_mode,
      kernelShape: attributes.kernel_shape,
      strides: attributes.strides,
      pads: attributes.pads
    });
    createAveragePoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
        input,
        attributes,
        isGlobalOperator
      );
      const x = inputVariable("x", input.dataType, input.dims.length);
      const dataType = x.type.value;
      const op1 = "value += x_val;";
      let op2 = "";
      if (adjustedAttributes.countIncludePad) {
        op2 += `value /= ${dataType}(uniforms.kernelSize);`;
      } else {
        op2 += `value /= ${dataType}(i32(uniforms.kernelSize) - pad);`;
      }
      const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
        outputShape,
        adjustedAttributes
      );
      programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
      const inputDependencies = ["rank"];
      return {
        name,
        shaderCache: {
          hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: input.dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource: (shaderHelper) => generatePoolingCode(
          shaderHelper,
          x,
          input.dims.length,
          outputShape.length,
          adjustedAttributes,
          op1,
          op2,
          0,
          uniforms,
          hasPads,
          pwStartEndNotZero,
          phStartEndNotZero
        )
      };
    };
    parseAveragePoolAttributes = (attributes) => {
      const countIncludePad = attributes.count_include_pad === 0 ? false : true;
      const attr = parsePoolCommonAttributes(attributes);
      if (attr.ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
      }
      const averagePoolAttributes = { countIncludePad, ...attr, cacheKey: "" };
      return { ...averagePoolAttributes, cacheKey: createAveragePoolShaderKeyFromAttributes(averagePoolAttributes) };
    };
    averagePool = (context, attributes) => {
      validateInputs25(context.inputs);
      context.compute(createAveragePoolProgramInfo("AveragePool", context.inputs[0], false, attributes));
    };
    globalPoolAttributes = {
      autoPad: "",
      ceilMode: 0,
      countIncludePad: false,
      kernelShape: [],
      strides: [],
      pads: [],
      storageOrder: 0,
      dilations: []
    };
    parseGlobalAveragePoolAttributes = (attributes) => {
      const format = attributes.format;
      return { format, ...globalPoolAttributes, cacheKey: format };
    };
    globalAveragePool = (context, attributes) => {
      validateInputs25(context.inputs);
      context.compute(createAveragePoolProgramInfo("GlobalAveragePool", context.inputs[0], true, attributes));
    };
    createMaxPoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
        input,
        attributes,
        isGlobalOperator
      );
      const op1 = `
      value = max(x_val, value);
    `;
      const op2 = "";
      const x = inputVariable("x", input.dataType, input.dims.length);
      const inputDependencies = ["rank"];
      const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
        outputShape,
        adjustedAttributes
      );
      programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
      return {
        name,
        shaderCache: {
          hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: input.dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource: (shaderHelper) => generatePoolingCode(
          shaderHelper,
          x,
          input.dims.length,
          outputShape.length,
          adjustedAttributes,
          op1,
          op2,
          input.dataType === 10 /* float16 */ ? -65504 : -1e5,
          uniforms,
          hasPads,
          pwStartEndNotZero,
          phStartEndNotZero
        )
      };
    };
    maxPool = (context, attributes) => {
      validateInputs25(context.inputs);
      context.compute(createMaxPoolProgramInfo("MaxPool", context.inputs[0], false, attributes));
    };
    parseMaxPoolAttributes = (attributes) => {
      const storageOrder = attributes.storage_order;
      const dilations = attributes.dilations;
      const attr = parsePoolCommonAttributes(attributes);
      if (storageOrder !== 0) {
        throw new Error("column major storage order is not yet supported for MaxPool");
      }
      if (attr.ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
      }
      const maxPoolAttributes = { storageOrder, dilations, ...attr, cacheKey: "" };
      return { ...maxPoolAttributes, cacheKey: createMaxPoolShaderKeyFromAttributes(maxPoolAttributes) };
    };
    parseGlobalMaxPoolAttributes = (attributes) => {
      const format = attributes.format;
      return { format, ...globalPoolAttributes, cacheKey: format };
    };
    globalMaxPool = (context, attributes) => {
      validateInputs25(context.inputs);
      context.compute(createMaxPoolProgramInfo("GlobalMaxPool", context.inputs[0], true, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts
var validateInputs26, createDequantizeLinearProgramInfo, dequantizeLinear, parseDequantizeLinearAttributes;
var init_quantize_linear = __esm({
  "web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs26 = (inputs, attributes) => {
      if (inputs.length < 2 || inputs.length > 3) {
        throw new Error("DequantizeLinear requires 2 or 3 inputs.");
      }
      if (inputs.length === 3 && inputs[1].dims === inputs[2].dims) {
        throw new Error("x-scale and x-zero-point must have the same shape.");
      }
      if (inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
        throw new Error("x and x-zero-point must have the same data type.");
      }
      if (inputs[0].dataType === 6 /* int32 */ && inputs.length > 2) {
        throw new Error("In the case of dequantizing int32 there is no zero point.");
      }
      if (inputs[1].dims.length !== 0 && inputs[1].dims.length !== 1 && inputs[1].dims.length !== inputs[0].dims.length) {
        throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");
      }
      if (inputs.length > 2) {
        if (inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("x and x-zero-point must have the same data type.");
        }
        if (inputs[1].dims.length !== inputs[2].dims.length) {
          throw new Error("scale and zero-point inputs must have the same rank.");
        }
        if (!inputs[1].dims.map((d, i) => d === inputs[2].dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error("scale and zero-point inputs must have the same shape.");
        }
      }
      if (attributes.blockSize > 0) {
        if (inputs[1].dims.length === 0 || inputs[1].dims.length === 1 && inputs[1].dims[0] === 1) {
          throw new Error("blockSize must be set only for block quantization.");
        }
        if (!inputs[1].dims.map((d, i) => i === attributes.axis || d === inputs[0].dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");
        }
        if (inputs[1].dims.length !== inputs[0].dims.length) {
          throw new Error("For block qunatization the scale input rank must be the same as the x rank.");
        }
        const dI = inputs[0].dims[attributes.axis];
        const si = inputs[1].dims[attributes.axis];
        if (attributes.blockSize < Math.ceil(dI / si) || attributes.blockSize > Math.ceil(dI / (si - 1) - 1)) {
          throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].");
        }
      }
    };
    createDequantizeLinearProgramInfo = (inputs, attributes) => {
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
      const inputType = inputs[0].dataType;
      const isSigned = inputType === 3 /* int8 */;
      const outputShape = inputs[0].dims;
      const dataType = inputs[1].dataType;
      const outputSize = ShapeUtil.size(outputShape);
      const isPacked = inputType === 3 /* int8 */ || inputType === 2 /* uint8 */;
      const inputShape = isPacked ? [Math.ceil(ShapeUtil.size(inputs[0].dims) / 4)] : inputs[0].dims;
      const scaleShape = inputs[1].dims;
      const zeroPointInput = inputs.length > 2 ? inputs[2] : void 0;
      const zeroPointShape = zeroPointInput ? isPacked ? [Math.ceil(ShapeUtil.size(zeroPointInput.dims) / 4)] : zeroPointInput.dims : void 0;
      const perLayerQuantization = scaleShape.length === 0 || scaleShape.length === 1 && scaleShape[0] === 1;
      const perAxisQuantization = perLayerQuantization === false && scaleShape.length === 1;
      const maxComponents = getMaxComponents(outputSize);
      const useComponents = perLayerQuantization && (!isPacked || maxComponents === 4);
      const components = useComponents ? maxComponents : 1;
      const inputComponent = useComponents && !isPacked ? maxComponents : 1;
      const input = inputVariable("input", isPacked ? 12 /* uint32 */ : inputType, inputShape.length, inputComponent);
      const scale = inputVariable("scale", dataType, scaleShape.length);
      const zeroPoint = zeroPointInput ? inputVariable("zero_point", isPacked ? 12 /* uint32 */ : inputType, zeroPointShape.length) : void 0;
      const output = outputVariable("output", dataType, outputShape.length, components);
      const inputVariables = [input, scale];
      if (zeroPoint) {
        inputVariables.push(zeroPoint);
      }
      const inputShapes = [inputShape, scaleShape];
      if (zeroPointInput) {
        inputShapes.push(zeroPointShape);
      }
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize / components },
        { type: 12 /* uint32 */, data: axis },
        { type: 12 /* uint32 */, data: attributes.blockSize },
        ...createTensorShapeVariables(...inputShapes, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "axis", type: "u32" },
          { name: "block_size", type: "u32" }
        ];
        return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${output.offsetToIndices("global_idx")};

          // Set input x
          ${(() => {
          if (isPacked) {
            return `
            let input = ${input.getByOffset("global_idx / 4")};
            let x_vec = ${isSigned ? "unpack4xI8(input)" : "unpack4xU8(input)"};
            let x_value = ${components === 1 ? "x_vec[global_idx % 4]" : "x_vec"};`;
          } else {
            return `let x_value = ${input.getByOffset("global_idx")};`;
          }
        })()};

          // Set scale input
          ${(() => {
          if (perLayerQuantization) {
            return `let scale_value= ${scale.getByOffset("0")}`;
          } else if (perAxisQuantization) {
            return `
            let scale_index = ${output.indicesGet("output_indices", "uniforms.axis")};
            let scale_value= ${scale.getByOffset("scale_index")};`;
          } else {
            return `
            var scale_indices: ${scale.type.indices} = output_indices;
            let index = ${scale.indicesGet("scale_indices", "uniforms.axis")} / uniforms.block_size;
            ${scale.indicesSet("scale_indices", "uniforms.axis", "index")};
            let scale_value= ${scale.getByIndices("scale_indices")};`;
          }
        })()};

          // Set zero-point input
          ${(() => {
          if (zeroPoint) {
            if (perLayerQuantization) {
              if (isPacked) {
                return `
                let zero_point_input = ${zeroPoint.getByOffset("0")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`;
              } else {
                return `let zero_point_value = ${zeroPoint.getByOffset("0")}`;
              }
            } else if (perAxisQuantization) {
              if (isPacked) {
                return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`;
              } else {
                return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_value = ${zeroPoint.getByOffset("zero_point_index")};`;
              }
            } else {
              if (isPacked) {
                return `
                let zero_point_offset = ${scale.indicesToOffset("scale_indices")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`;
              } else {
                return `let zero_point_value = ${zeroPoint.getByIndices("scale_indices")};`;
              }
            }
          } else {
            return `let zero_point_value = ${isPacked ? isSigned ? "i32" : "u32" : input.type.value}(0);`;
          }
        })()};
      // Compute and write output
      ${output.setByOffset("global_idx", `${output.type.value}(x_value - zero_point_value) * scale_value`)};
      }`;
      };
      return {
        name: "DequantizeLinear",
        shaderCache: {
          hint: attributes.cacheKey,
          inputDependencies: zeroPoint ? ["rank", "rank", "rank"] : ["rank", "rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(outputSize / components / 64), y: 1, z: 1 },
          programUniforms
        })
      };
    };
    dequantizeLinear = (context, attributes) => {
      validateInputs26(context.inputs, attributes);
      context.compute(createDequantizeLinearProgramInfo(context.inputs, attributes));
    };
    parseDequantizeLinearAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis, blockSize: attributes.blockSize });
  }
});

// web/lib/wasm/jsep/webgpu/ops/range.ts
var validateInputsContent, createRangeProgramInfo, range;
var init_range = __esm({
  "web/lib/wasm/jsep/webgpu/ops/range.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_common();
    validateInputsContent = (start, limit, delta) => {
      const sameStartLimit = start === limit;
      const increasingRangeNegativeStep = start < limit && delta < 0;
      const decreasingRangePositiveStep = start > limit && delta > 0;
      if (sameStartLimit || increasingRangeNegativeStep || decreasingRangePositiveStep) {
        throw new Error("Range these inputs' contents are invalid.");
      }
    };
    createRangeProgramInfo = (start, limit, delta, dataType) => {
      const numElements = Math.abs(Math.ceil((limit - start) / delta));
      const outputShape = [numElements];
      const outputSize = numElements;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: dataType, data: start },
        { type: dataType, data: delta },
        ...createTensorShapeVariables(outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", dataType, outputShape.length);
        const wgslType = output.type.value;
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "start", type: wgslType },
          { name: "delta", type: wgslType }
        ];
        return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${wgslType}(global_idx) * uniforms.delta;
      }`;
      };
      return {
        name: "Range",
        shaderCache: { hint: `${dataType}` },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    range = (context) => {
      let start = 0;
      let limit = 0;
      let delta = 0;
      if (context.inputs[0].dataType === 6 /* int32 */) {
        start = context.inputs[0].getInt32Array()[0];
        limit = context.inputs[1].getInt32Array()[0];
        delta = context.inputs[2].getInt32Array()[0];
      } else if (context.inputs[0].dataType === 1 /* float */) {
        start = context.inputs[0].getFloat32Array()[0];
        limit = context.inputs[1].getFloat32Array()[0];
        delta = context.inputs[2].getFloat32Array()[0];
      }
      if (env2.webgpu.validateInputContent) {
        validateInputsContent(start, limit, delta);
      }
      context.compute(createRangeProgramInfo(start, limit, delta, context.inputs[0].dataType), { inputs: [] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/scatter-nd.ts
var atomicReductionSnippet, createScatterNDProgramInfo, parseScatterNDAttributes, scatterND;
var init_scatter_nd = __esm({
  "web/lib/wasm/jsep/webgpu/ops/scatter-nd.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    atomicReductionSnippet = (reduction, ptr, v, type) => {
      if (reduction !== "none" && type !== "i32" && type !== "u32" && type !== "f32") {
        throw new Error(`Input ${type} is not supported with reduction ${reduction}.`);
      }
      const floatStart = `{
                var oldValue = 0;
                loop {
                  let newValueF32 =`;
      const floatEnd = `;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${ptr}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;
      switch (reduction) {
        case "none":
          return `${ptr}=${v};`;
        case "add":
          if (type === "i32" || type === "u32") {
            return `atomicAdd(&${ptr}, bitcast<${type}>(${v}));`;
          } else {
            return `
              ${floatStart}bitcast<${type}>(oldValue) + (${v})${floatEnd}`;
          }
        case "max":
          if (type === "i32" || type === "u32") {
            return `atomicMax(&${ptr}, bitcast<${type}>(${v}));`;
          } else {
            return `
                ${floatStart}max(bitcast<f32>(oldValue), (${v}))${floatEnd}`;
          }
        case "min":
          if (type === "i32" || type === "u32") {
            return `atomicMin(&${ptr}, bitcast<${type}>(${v}));`;
          } else {
            return `${floatStart}min(bitcast<${type}>(oldValue), (${v}))${floatEnd}`;
          }
        case "mul":
          return `${floatStart}(bitcast<${type}>(oldValue) * (${v}))${floatEnd}`;
        default:
          throw new Error(`Reduction ${reduction} is not supported.`);
      }
    };
    createScatterNDProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const indicesShape = inputs[1].dims;
      const outputShape = inputShape;
      const components = 1;
      const outputSize = Math.ceil(ShapeUtil.sizeToDimension(indicesShape, indicesShape.length - 1) / components);
      const lastIndexDimension = indicesShape[indicesShape.length - 1];
      const numUpdatesElements = ShapeUtil.sizeFromDimension(inputShape, lastIndexDimension);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: lastIndexDimension },
        { type: 12 /* uint32 */, data: numUpdatesElements },
        ...createTensorShapeVariables(inputs[1].dims, inputs[2].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const indices = inputVariable("indices", inputs[1].dataType, inputs[1].dims.length);
        const updates = inputVariable("updates", inputs[2].dataType, inputs[2].dims.length, components);
        const output = attributes.reduction !== "none" && attributes.reduction !== "" ? atomicOutputVariable("output", inputs[0].dataType, outputShape.length) : outputVariable("output", inputs[0].dataType, outputShape.length, components);
        return `
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("last_index_dimension", "u32").registerUniform("num_updates_elements", "u32").declareVariables(indices, updates, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var data_offset = 0u;
  let indices_start = uniforms.last_index_dimension * global_idx;
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${inputs[0].dims.length === 1 ? `
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;` : `
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${atomicReductionSnippet(
          attributes.reduction,
          "output[data_offset + i]",
          "value",
          output.type.value
        )}
  }

      }`;
      };
      return {
        name: "ScatterND",
        shaderCache: {
          hint: `${attributes.cacheKey}_${attributes.reduction}`,
          inputDependencies: ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseScatterNDAttributes = (attributes) => createAttributeWithCacheKey({ reduction: attributes.reduction });
    scatterND = (context, attributes) => {
      context.compute(createScatterNDProgramInfo(context.inputs, attributes), {
        inputs: [context.inputs[1], context.inputs[2]],
        outputs: []
      });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/resize.ts
var validateScales, updateScales, validateInputs27, getSafeIntegerDivision, getOriginalCoordinateFromResizedCoordinate, getNearestPixelFromOriginal, updateRoI, initOutputShape, adjustOutputShape, calculateOriginalIndicesFromOutputIndices, calculateInputIndicesFromOutputIndices, checkInputIndices, setChannelAndBatchIndices, bilinearInterpolation, bicubicInterpolation, trilinearInterpolation, createResizeProgramInfo, getOpsetVersionFromCustomDataBuffer, resize, parseResizeAttributes;
var init_resize = __esm({
  "web/lib/wasm/jsep/webgpu/ops/resize.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateScales = (scales, attributes) => {
      scales.every(
        (value) => value > 0 || (() => {
          throw new Error("Resize requires scales input values to be positive");
        })
      );
      if (scales.length > 0) {
        if (attributes.mode === "linear") {
          if (!(scales.length === 2 || scales.length === 3 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1 || scales.length === 5 && scales[0] === 1 && scales[1] === 1)) {
            throw new Error(
              `For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`
            );
          }
        } else if (attributes.mode === "cubic") {
          if (!(scales.length === 2 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1)) {
            throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
          }
        }
      }
    };
    updateScales = (scales, axes, rank) => {
      axes.every(
        (value) => value >= 0 && value < rank || (() => {
          throw new Error("Resize requires axes input values to be positive and less than rank");
        })
      );
      const newScales = new Array(rank).fill(1);
      axes.forEach((value, index) => newScales[value] = scales[index]);
      return newScales;
    };
    validateInputs27 = (inputs, attributes, opsetVersion, scales, sizes, roi) => {
      const [roiInputIndex, scalesInputIndex, sizesInputIndex] = opsetVersion > 10 ? [1, 2, 3] : [-1, inputs.length > 1 ? 1 : -1, -1];
      const rank = inputs[0].dims.length;
      if (roiInputIndex > 0 && inputs.length > roiInputIndex && inputs[roiInputIndex].dims.length > 0) {
        inputs[roiInputIndex].getFloat32Array().forEach((value) => roi.push(value));
      } else if (attributes.coordinateTransformMode === "tf_crop_and_resize") {
        throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
      }
      if (scalesInputIndex > 0 && inputs.length > scalesInputIndex && inputs[scalesInputIndex].dims.length === 1 && inputs[scalesInputIndex].dims[0] > 0) {
        inputs[scalesInputIndex].getFloat32Array().forEach((value) => scales.push(value));
        if (scales.length !== 0 && scales.length !== rank && opsetVersion >= 18 && scales.length !== attributes.axes.length) {
          throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");
        }
        validateScales(scales, attributes);
        if (attributes.axes.length > 0) {
          updateScales(scales, attributes.axes, rank).forEach((value, index) => scales[index] = value);
        }
      }
      if (sizesInputIndex > 0 && inputs.length > sizesInputIndex && inputs[sizesInputIndex].dims.length === 1 && inputs[sizesInputIndex].dims[0] > 0) {
        inputs[sizesInputIndex].getBigInt64Array().forEach((value) => sizes.push(Number(value)));
        if (sizes.length !== 0 && sizes.length !== rank && opsetVersion >= 18 && sizes.length !== attributes.axes.length) {
          throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
        }
      }
      if (attributes.axes.length > 0) {
        if (scales.length !== 0 && scales.length !== attributes.axes.length) {
          throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
        }
        if (sizes.length !== 0 && sizes.length !== attributes.axes.length) {
          throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified');
        }
      }
      if (typeof scales !== "undefined" && typeof sizes !== "undefined" && scales.length > 0 && sizes.length > rank) {
        throw new Error("Resize requires only of scales or sizes to be specified");
      }
    };
    getSafeIntegerDivision = (a, b, c, dType) => `
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${a}) * (${b});
  let whole = ${dType}(big / (${c}));
  let fract = ${dType}(big % (${c})) / ${dType}(${c});
  return whole + fract;
`;
    getOriginalCoordinateFromResizedCoordinate = (coordinateTransferMode, dType) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${dType} { ` + (() => {
      switch (coordinateTransferMode) {
        case "asymmetric":
          return `
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${dType}(xResized) / ${dType}(xScale);
          } else {
            ${getSafeIntegerDivision("xResized", "lengthOriginal", "lengthResized", dType)}
          }
        `;
        case "pytorch_half_pixel":
          return `if (lengthResized > 1) {
                    return (${dType}(xResized) + 0.5) / ${dType}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
        case "tf_half_pixel_for_nn":
          return `return (${dType}(xResized) + 0.5) / ${dType}(xScale);`;
        case "align_corners":
          return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${getSafeIntegerDivision("xResized", "lengthOriginal - 1", "lengthResized - 1", dType)}
                  }`;
        case "tf_crop_and_resize":
          return `if (lengthResized > 1) {
                    return ${dType}(roiStart) * ${dType}(lengthOriginal - 1) +
                        (${dType}(xResized) * ${dType}(roiEnd - roiStart) * ${dType}(lengthOriginal - 1)) /
                        ${dType}(lengthResized - 1);
                  } else {
                    return 0.5 * ${dType}(roiStart + roiEnd) * ${dType}(lengthOriginal - 1);
                  }`;
        case "half_pixel_symmetric":
          return `const outputWidth = ${dType}xScale * ${dType}(lengthResized);
                  const adjustment = ${dType}(lengthResized) / outputWidth;
                  const center = ${dType}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
        case "half_pixel":
          return `return ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
        default:
          throw new Error(`Coordinate transform mode ${coordinateTransferMode} is not supported`);
      }
    })() + "}";
    getNearestPixelFromOriginal = (nearestMode, opsetVersion, dType) => `fn getNearestPixelFromOriginal(xOriginal: ${dType}, isDownSample: bool) -> ${dType} {` + (() => {
      switch (nearestMode) {
        case "round_prefer_ceil":
          return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
        case "floor":
          return "return floor(xOriginal);";
        case "ceil":
          return "return ceil(xOriginal);";
        case "round_prefer_floor":
          return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
        case "simple":
        default:
          if (opsetVersion < 11) {
            return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
          }
          throw new Error(`Nearest mode ${nearestMode} is not supported`);
      }
    })() + "}";
    updateRoI = (roi, axes, rank) => {
      const roiTmp = new Array(rank).fill(0).concat(new Array(rank).fill(1));
      const roiLocal = roi.length === 0 ? roiTmp : roi.slice();
      if (axes.length > 0) {
        axes.forEach((v, i) => {
          roiTmp[v] = roiLocal[i];
          roiTmp[i + rank] = roiLocal[axes.length + i];
        });
        return roiTmp;
      }
      return roiLocal;
    };
    initOutputShape = (inputShape, scales, sizes, axes) => {
      let outputShape = [];
      if (sizes.length > 0) {
        if (axes.length > 0) {
          inputShape.forEach((v) => outputShape.push(v));
          if (Math.max(...axes) > inputShape.length) {
            throw new Error("axes is out of bound");
          }
          axes.forEach((v, i) => outputShape[v] = sizes[i]);
        } else {
          sizes.forEach((v) => outputShape.push(v));
        }
      } else {
        if (scales.length === 0) {
          throw new Error("Resize requires either scales or sizes.");
        } else {
          outputShape = inputShape.map((value, index) => Math.round(value * scales[index]));
        }
      }
      return outputShape;
    };
    adjustOutputShape = (inputShape, scales, attributes) => {
      const scaleInPolicy = (() => {
        switch (attributes.keepAspectRatioPolicy) {
          case "not_larger":
            return attributes.axes.length > 0 ? Math.min(...attributes.axes.map((i) => scales[i]), Number.MAX_VALUE) : Math.min(...scales, Number.MAX_VALUE);
          case "not_smaller":
            return attributes.axes.length > 0 ? Math.max(...attributes.axes.map((i) => scales[i]), Number.MIN_VALUE) : Math.max(...scales, Number.MIN_VALUE);
          default:
            throw new Error(`Keep aspect ratio policy ${attributes.keepAspectRatioPolicy} is not supported`);
        }
      })();
      scales.fill(1, 0, scales.length);
      const adjustedOutputShape = inputShape.slice();
      if (attributes.axes.length > 0) {
        attributes.axes.forEach((v) => scales[v] = scaleInPolicy);
        attributes.axes.forEach((v) => adjustedOutputShape[v] = Math.round(inputShape[v] * scales[v]));
      } else {
        scales.fill(scaleInPolicy, 0, scales.length);
        adjustedOutputShape.forEach((v, i) => adjustedOutputShape[i] = Math.round(v * scales[i]));
      }
      return adjustedOutputShape;
    };
    calculateOriginalIndicesFromOutputIndices = (output, inputShape, outputShape, scalesLength, roiLength) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> array<${output.type.value}, ${outputShape.length}> {
      var original_indices: array<${output.type.value}, ${outputShape.length}>;
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
        var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
        if (scale == 1.0) {
          original_indices[i] = ${output.type.value}(output_index);
        } else {
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`;
    calculateInputIndicesFromOutputIndices = (input, output, inputShape, outputShape, scalesLength, roiLength, useExtrapolation) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
      var input_indices: ${input.type.indices};
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
          var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${useExtrapolation} || (original_idx >= 0 && original_idx < ${output.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${output.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${input.indicesSet("input_indices", "i", "input_index")}
      }
      return input_indices;
    }`;
    checkInputIndices = (input, inputShape) => `
    fn checkInputIndices(input_indices: ${input.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${inputShape.length}; i++) {
        var input_index = ${input.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape", "i", inputShape.length)}) {
          return false;
        }
      }
      return true;
    }`;
    setChannelAndBatchIndices = (input, channelIdx, batchIdx, spacialDims) => input.rank > spacialDims ? `
    ${input.indicesSet("input_indices", channelIdx, "channel")};
    ${input.indicesSet("input_indices", batchIdx, "batch")};
` : "";
    bilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
      const isNchw = true;
      const [batchIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 2 ? [-1, 0, 1, -1] : isNchw ? [0, 2, 3, 1] : [0, 1, 2, 3];
      const dType = input.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(row, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(col, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 2)}
      return ${input.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${dType} = originalIndices[${heightIdx}];
      var col:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (row < 0 || row > (${inputShape[heightIdx]} - 1) || col < 0 || col > (${inputShape[widthIdx]} - 1)) {
        return ${extrapolationValue};
      }` : ""};
      row = max(0, min(row, ${inputShape[heightIdx]} - 1));
      col = max(0, min(col, ${inputShape[widthIdx]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${inputShape.length > 2 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 2 ? `u32(originalIndices[${batchIdx}])` : "0"};
      var x11: ${dType} = getInputValue(batch, channel, row1, col1);
      var x12: ${dType} = getInputValue(batch, channel, row1, col2);
      var x21: ${dType} = getInputValue(batch, channel, row2, col1);
      var x22: ${dType} = getInputValue(batch, channel, row2, col2);
      var dx1: ${dType} = abs(row - ${dType}(row1));
      var dx2: ${dType} = abs(${dType}(row2) - row);
      var dy1: ${dType} = abs(col - ${dType}(col1));
      var dy2: ${dType} = abs(${dType}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
    };
    bicubicInterpolation = (input, output, inputShape, outputShape, scales, roi, cubicCoeffA, useExtrapolation, extrapolationValue, excludeOutside) => {
      const is2D = inputShape.length === 2;
      const isNchw = true;
      const [heightIdx, widthIdx] = is2D ? [0, 1] : isNchw ? [2, 3] : [1, 2];
      const dType = input.type.value;
      const createCubicInterpolationFunction = (idx) => {
        const direction = idx === heightIdx ? "row" : "col";
        return `
      fn ${direction}CubicInterpolation(input_indices: ${input.type.indices}, output_indices: ${output.type.indices}) -> ${dType} {
        var output_index = ${output.indicesGet("output_indices", idx)};
        var originalIdx: ${dType} = getOriginalCoordinateFromResizedCoordinate(output_index, ${scales[idx]},
        ${outputShape[idx]}, ${inputShape[idx]}, ${roi[idx]}, ${roi[idx]} + ${inputShape.length});
        var fractOriginalIdx: ${dType} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${useExtrapolation} && (originalIdx < 0 || originalIdx > (${inputShape[idx]} - 1))) {
          return ${extrapolationValue};
        }
        var data: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${direction}: ${dType} = originalIdx + ${dType}(i);
          if (${direction} < 0 || ${direction} >= ${inputShape[idx]}) {
            ${(() => {
          if (excludeOutside) {
            return `coefs[i + 1] = 0.0;
                        continue;`;
          } else if (useExtrapolation) {
            return `return ${extrapolationValue};`;
          } else {
            return `${direction} = max(0, min(${direction}, ${inputShape[idx]} - 1));`;
          }
        })()};
          }
        var input_indices_copy: ${input.type.indices} = input_indices;
          ${input.indicesSet("input_indices_copy", idx, `u32(${direction})`)};
          data[i + 1] = ${idx === heightIdx ? input.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
      };
      return `
    ${createCubicInterpolationFunction(heightIdx)};
    ${createCubicInterpolationFunction(widthIdx)};
  fn getCubicInterpolationCoefs(s: ${dType}) -> array<${dType}, 4> {
    var absS = abs(s);
    var coeffs: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${dType} = 1.0 - absS;
    var twoMinusAbsS: ${dType} = 2.0 - absS;
    var onePlusAbsS: ${dType} = 1.0 + absS;
    coeffs[0] = ((${cubicCoeffA} * onePlusAbsS - 5 * ${cubicCoeffA}) * onePlusAbsS + 8 * ${cubicCoeffA}) * onePlusAbsS - 4 * ${cubicCoeffA};
    coeffs[1] = ((${cubicCoeffA} + 2) * absS - (${cubicCoeffA} + 3)) * absS * absS + 1;
    coeffs[2] = ((${cubicCoeffA} + 2) * oneMinusAbsS - (${cubicCoeffA} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${cubicCoeffA} * twoMinusAbsS - 5 * ${cubicCoeffA}) * twoMinusAbsS + 8 * ${cubicCoeffA}) * twoMinusAbsS - 4 * ${cubicCoeffA};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${dType}, 4>, coefs: array<${dType}, 4>) -> ${dType} {
    var coefsSum: ${dType} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
    var input_indices: ${input.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
    };
    trilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
      const isNchw = true;
      const [batchIdx, depthIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 3 ? [-1, 0, 1, 2, -1] : isNchw ? [0, 2, 3, 4, 1] : [0, 1, 2, 3, 4];
      const dType = input.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", depthIdx, `max(0, min(depth, ${inputShape[depthIdx]} - 1))`)};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(height, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(width, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 3)}
      return ${input.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${dType} = originalIndices[${depthIdx}];
      var height:${dType} = originalIndices[${heightIdx}];
      var width:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (depth < 0 || depth > (${inputShape[depthIdx]} - 1) || height < 0 || height > (${inputShape[heightIdx]} - 1) || width < 0 || (width > ${inputShape[widthIdx]} - 1)) {
      return ${extrapolationValue};
        }` : ""};

    depth = max(0, min(depth, ${inputShape[depthIdx]} - 1));
      height = max(0, min(height, ${inputShape[heightIdx]} - 1));
      width = max(0, min(width, ${inputShape[widthIdx]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${inputShape.length > 3 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 3 ? `u32(originalIndices[${batchIdx}])` : "0"};

      var x111: ${dType} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${dType} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${dType} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${dType} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${dType} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${dType} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${dType} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${dType} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${dType} = abs(depth - ${dType}(depth1));
      var dx2: ${dType} = abs(${dType}(depth2) - depth);
      var dy1: ${dType} = abs(height - ${dType}(height1));
      var dy2: ${dType} = abs(${dType}(height2) - height);
      var dz1: ${dType} = abs(width - ${dType}(width1));
      var dz2: ${dType} = abs(${dType}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
    };
    createResizeProgramInfo = (inputTensor, attributes, opsetVersion, scalesInput, sizes, roiInput) => {
      const inputShape = inputTensor.dims;
      const roi = updateRoI(roiInput, attributes.axes, inputShape.length);
      let outputShape = initOutputShape(inputShape, scalesInput, sizes, attributes.axes);
      let scales = scalesInput.slice();
      if (scalesInput.length === 0) {
        scales = inputShape.map((value, index) => value === 0 ? 1 : outputShape[index] / value);
        if (attributes.keepAspectRatioPolicy !== "stretch") {
          outputShape = adjustOutputShape(inputShape, scales, attributes);
        }
      }
      const output = outputVariable("output", inputTensor.dataType, outputShape.length);
      const input = inputVariable("input", inputTensor.dataType, inputShape.length);
      const outputSize = ShapeUtil.size(outputShape);
      const noScale = inputShape.length === outputShape.length && inputShape.every((d, i) => d === outputShape[i]);
      const useExtrapolation = attributes.coordinateTransformMode === "tf_crop_and_resize";
      const extrapolationValue = attributes.extrapolationValue;
      const dataType = input.type.value;
      const getShaderSource = (shaderHelper) => `
      ${noScale ? "" : `
      ${getOriginalCoordinateFromResizedCoordinate(attributes.coordinateTransformMode, dataType)};
      ${(() => {
        switch (attributes.mode) {
          case "nearest":
            return `
              ${checkInputIndices(input, inputShape)};
              ${getNearestPixelFromOriginal(attributes.nearestMode, opsetVersion, dataType)};
              ${calculateInputIndicesFromOutputIndices(
              input,
              output,
              inputShape,
              outputShape,
              scales.length,
              roi.length,
              useExtrapolation
            )};
              `;
          case "linear":
            return `
              ${calculateOriginalIndicesFromOutputIndices(output, inputShape, outputShape, scales.length, roi.length)};
              ${(() => {
              if (inputShape.length === 2 || inputShape.length === 4) {
                return `${bilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
              } else if (inputShape.length === 3 || inputShape.length === 5) {
                return `${trilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
              } else {
                throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
              }
            })()};
            `;
          case "cubic":
            return `
            ${(() => {
              if (inputShape.length === 2 || inputShape.length === 4) {
                return `${bicubicInterpolation(
                  input,
                  output,
                  inputShape,
                  outputShape,
                  scales,
                  roi,
                  attributes.cubicCoeffA,
                  useExtrapolation,
                  attributes.extrapolationValue,
                  attributes.excludeOutside
                )}`;
              } else {
                throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
              }
            })()};
            `;
          default:
            throw Error("Invalid resize mode");
        }
      })()};
      `}
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("scales", "f32", scales.length).registerUniform("roi", "f32", roi.length).declareVariables(input, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${noScale ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${output.offsetToIndices("global_idx")};
        var input_indices: ${input.type.indices};
        ${(() => {
        switch (attributes.mode) {
          case "nearest":
            return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${input.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${attributes.extrapolationValue};
                }`;
          case "linear":
            return `output[global_idx] = ${inputShape.length === 2 || inputShape.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
          case "cubic":
            return "output[global_idx] = bicubicInterpolation(output_indices);";
          default:
            throw Error(`Unsupported resize mode: ${attributes.mode}`);
        }
      })()};
`}
      }`;
      return {
        name: "Resize",
        shaderCache: {
          hint: `${attributes.cacheKey}|${opsetVersion}|${scales.length > 0 ? attributes.mode === "cubic" ? scales : scales.length : ""}|${sizes.length > 0 ? sizes : ""}|${roi.length > 0 ? roi : ""}|${noScale}|${attributes.mode === "nearest" ? inputShape.length : inputShape}`,
          inputDependencies: ["rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            { type: 1 /* float */, data: scales },
            { type: 1 /* float */, data: roi },
            ...createTensorShapeVariables(inputShape, outputShape)
          ]
        })
      };
    };
    getOpsetVersionFromCustomDataBuffer = (context) => {
      const customDataBuffer = context.customDataBuffer;
      const customDataBuffer32 = new Uint32Array(customDataBuffer, customDataBuffer.byteOffset, 1);
      const opsetVersion = customDataBuffer32[0];
      return opsetVersion;
    };
    resize = (context, attributes) => {
      const scales = [];
      const sizes = [];
      const roi = [];
      const opsetVersion = getOpsetVersionFromCustomDataBuffer(context);
      if (attributes.antialias !== 0) {
        throw Error("Only default value (0) for Antialias attribute is supported");
      }
      validateInputs27(context.inputs, attributes, opsetVersion, scales, sizes, roi);
      context.compute(createResizeProgramInfo(context.inputs[0], attributes, opsetVersion, scales, sizes, roi), {
        inputs: [0]
      });
    };
    parseResizeAttributes = (attributes) => {
      const antialias = attributes.antialias;
      const axes = attributes.axes;
      const coordinateTransformMode = attributes.coordinateTransformMode;
      const cubicCoeffA = attributes.cubicCoeffA;
      const excludeOutside = attributes.excludeOutside !== 0;
      const extrapolationValue = attributes.extrapolationValue;
      const keepAspectRatioPolicy = attributes.keepAspectRatioPolicy;
      const mode = attributes.mode;
      const nearestMode = attributes.nearestMode === "" ? "simple" : attributes.nearestMode;
      return createAttributeWithCacheKey({
        antialias,
        axes,
        coordinateTransformMode,
        cubicCoeffA,
        excludeOutside,
        extrapolationValue,
        keepAspectRatioPolicy,
        mode,
        nearestMode
      });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts
var validateInputs28, createSkipLayerNormProgramInfo, skipLayerNorm;
var init_skip_layer_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs28 = (inputs) => {
      if (!inputs || inputs.length < 3) {
        throw new Error("layerNorm requires at least 3 inputs.");
      }
      const input = inputs[0];
      const skip = inputs[1];
      const gamma = inputs[2];
      if (input.dataType !== skip.dataType || input.dataType !== gamma.dataType) {
        throw new Error("All inputs must have the same data type");
      }
      if (input.dims.length !== 3 && input.dims.length !== 2) {
        throw new Error("Input must be 2D or 3D");
      }
      if (skip.dims.length !== 3 && skip.dims.length !== 2) {
        throw new Error("Skip must be 2D or 3D");
      }
      const hiddenSize = input.dims[input.dims.length - 1];
      const sequenceLength = input.dims[input.dims.length - 2];
      if (skip.dims[skip.dims.length - 1] !== hiddenSize) {
        throw new Error("Skip must have the same hidden size as input");
      }
      if (skip.dims[skip.dims.length - 2] !== sequenceLength) {
        throw new Error("Skip must have the same sequence length as input");
      }
      if (gamma.dims.length !== 1) {
        throw new Error("Gamma must be 1D");
      }
      if (gamma.dims[gamma.dims.length - 1] !== hiddenSize) {
        throw new Error("Gamma must have the same hidden size as input");
      }
      if (inputs.length > 3) {
        const beta = inputs[3];
        if (beta.dims.length !== 1) {
          throw new Error("Beta must be 1D");
        }
        if (beta.dims[beta.dims.length - 1] !== hiddenSize) {
          throw new Error("Beta must have the same hidden size as input");
        }
      }
      if (inputs.length > 4) {
        const bias = inputs[4];
        if (bias.dims.length !== 1) {
          throw new Error("Bias must be 1D");
        }
        if (bias.dims[bias.dims.length - 1] !== hiddenSize) {
          throw new Error("Bias must have the same hidden size as input");
        }
      }
    };
    createSkipLayerNormProgramInfo = (inputs, attributes, outputCount, isTraining) => {
      const simplified = attributes.simplified;
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const outputShape = inputShape;
      const outputSize = inputSize;
      const hiddenSize = inputShape.slice(-1)[0];
      const meanInvStdDevDim = isTraining ? inputShape.slice(0, -1).concat(1) : [];
      const hasBetaInput = !simplified && inputs.length > 3;
      const hasBiasInput = inputs.length > 4;
      const hasMeanOutput = isTraining && outputCount > 1;
      const hasInvStdDevOutput = isTraining && outputCount > 2;
      const hasInputSkipBiasSumOutput = outputCount > 3;
      const workgroupSize = 64;
      const components = getMaxComponents(hiddenSize);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: components },
        { type: 12 /* uint32 */, data: hiddenSize },
        { type: 1 /* float */, data: attributes.epsilon }
      ];
      const getShaderSource = (shaderHelper) => {
        const uniformsArray = [
          { name: "output_size", type: "u32" },
          { name: "components", type: "u32" },
          { name: "hidden_size", type: "u32" },
          { name: "epsilon", type: "f32" }
        ];
        const variables = [
          inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
          inputVariable("skip", inputs[1].dataType, inputs[1].dims, components),
          inputVariable("gamma", inputs[2].dataType, inputs[2].dims, components)
        ];
        if (hasBetaInput) {
          variables.push(inputVariable("beta", inputs[3].dataType, inputs[3].dims, components));
        }
        if (hasBiasInput) {
          variables.push(inputVariable("bias", inputs[4].dataType, inputs[4].dims, components));
        }
        variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
        if (hasMeanOutput) {
          variables.push(outputVariable("mean_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInvStdDevOutput) {
          variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInputSkipBiasSumOutput) {
          variables.push(outputVariable("input_skip_bias_sum", inputs[0].dataType, outputShape, components));
        }
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const vecDataType = tensorTypeToWsglStorageType(1 /* float */, components);
        return `

      ${shaderHelper.registerUniforms(uniformsArray).declareVariables(...variables)}
      var<workgroup> sum_shared : array<${vecDataType}, ${workgroupSize}>;
      var<workgroup> sum_squared_shared : array<${vecDataType}, ${workgroupSize}>;

      ${shaderHelper.mainStart([workgroupSize, 1, 1])}
        let ix = local_id.x;
        let iy = global_id.x / ${workgroupSize};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${workgroupSize};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${workgroupSize - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${hasBiasInput ? "bias[offset1d + i]" : dataType + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${hasInputSkipBiasSumOutput ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${castToF32(dataType, components, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${workgroupSize};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${sumVector("sum", components)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${sumVector("square_sum", components)} / f32(uniforms.hidden_size) ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);
        ${hasMeanOutput ? "mean_output[global_idx] = mean;" : ""}
        ${hasInvStdDevOutput ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${simplified ? "" : `- ${dataType}(mean)`}) *
            ${dataType}(inv_std_dev) * gamma[offset1d + i]
            ${hasBetaInput ? "+ beta[offset1d + i]" : ""};
        }
      }`;
      };
      const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
      if (outputCount > 1) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (outputCount > 2) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (outputCount > 3) {
        outputs.push({ dims: inputShape, dataType: inputs[0].dataType });
      }
      return {
        name: "SkipLayerNormalization",
        shaderCache: {
          hint: `${components};${hasMeanOutput};${hasInvStdDevOutput};${hasInputSkipBiasSumOutput}`,
          inputDependencies: inputs.map((_input, _index) => "type")
        },
        getShaderSource,
        getRunData: () => ({
          outputs,
          dispatchGroup: {
            x: Math.ceil(outputSize / hiddenSize)
          },
          programUniforms
        })
      };
    };
    skipLayerNorm = (context, attributes) => {
      const isTraining = false;
      validateInputs28(context.inputs);
      const outputs = [0];
      if (context.outputCount > 1) {
        outputs.push(isTraining ? 1 : -3);
      }
      if (context.outputCount > 2) {
        outputs.push(isTraining ? 2 : -3);
      }
      if (context.outputCount > 3) {
        outputs.push(3);
      }
      context.compute(createSkipLayerNormProgramInfo(context.inputs, attributes, context.outputCount, isTraining), {
        outputs
      });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/slice.ts
var validateInputs29, readInput, createSliceAttributesFromInputs, fixStartEndValues, calculateInputIndicesImpl, createSliceProgramInfo, slice, parseSliceAttributes;
var init_slice = __esm({
  "web/lib/wasm/jsep/webgpu/ops/slice.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs29 = (inputs, attributes) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      if (attributes.axes.length !== 0) {
        if (attributes.axes.length !== attributes.starts.length || attributes.axes.length !== attributes.ends.length) {
          throw new Error("axes, starts and ends must have the same length");
        }
      } else if (attributes.starts.length !== attributes.ends.length) {
        throw new Error("starts and ends must have the same length");
      }
      inputs.slice(1).forEach((_, idx) => {
        if (inputs[idx + 1].dataType !== 6 /* int32 */ && inputs[idx + 1].dataType !== 7 /* int64 */) {
          throw new Error(`Input ${idx} must be an array of int32 or int64`);
        }
      });
    };
    readInput = (inputs, idx) => {
      const input = [];
      if (inputs.length > idx) {
        if (inputs[idx].dataType === 7 /* int64 */) {
          inputs[idx].getBigInt64Array().forEach((v) => input.push(Number(v)));
        } else if (inputs[idx].dataType === 6 /* int32 */) {
          inputs[idx].getInt32Array().forEach((v) => input.push(Number(v)));
        } else {
          throw new Error(`Input ${idx} must be an array of int32 or int64`);
        }
      }
      return input;
    };
    createSliceAttributesFromInputs = (inputs, attributes) => {
      if (inputs.length > 1) {
        const starts = readInput(inputs, 1);
        const ends = readInput(inputs, 2);
        let axes = readInput(inputs, 3);
        if (axes.length === 0) {
          axes = [...Array(inputs[0].dims.length).keys()];
        }
        return createAttributeWithCacheKey({ starts, ends, axes });
      } else {
        return attributes;
      }
    };
    fixStartEndValues = (value, index, inputShape, axes, steps) => {
      let newValue = value;
      if (value < 0) {
        newValue += inputShape[axes[index]];
      }
      if (steps[index] < 0) {
        return Math.max(0, Math.min(newValue, inputShape[axes[index]] - 1));
      } else {
        return Math.max(0, Math.min(newValue, inputShape[axes[index]]));
      }
    };
    calculateInputIndicesImpl = (input, output, inputShape) => `fn calculateInputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
          var input_indices: ${input.type.indices};
          var carry = 0u;
          for (var i = ${inputShape.length - 1}; i >= 0; i--) {
            let input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
            let steps_i = ${getElementAt("uniforms.steps", "i", inputShape.length)};
            let signs_i = ${getElementAt("uniforms.signs", "i", inputShape.length)};
            let starts_i = ${getElementAt("uniforms.starts", "i", inputShape.length)};
            var output_index = ${output.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${input.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`;
    createSliceProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const axes = attributes.axes.length > 0 ? ShapeUtil.normalizeAxes(attributes.axes, inputShape.length) : [...Array(inputShape.length).keys()];
      let steps = readInput(inputs, 4);
      steps.forEach(
        (step) => step !== 0 || (() => {
          throw new Error("step cannot be 0");
        })
      );
      if (steps.length === 0) {
        steps = Array(axes.length).fill(1);
      }
      const starts = attributes.starts.map((start, i) => fixStartEndValues(start, i, inputShape, axes, steps));
      const ends = attributes.ends.map((end, i) => fixStartEndValues(end, i, inputShape, axes, steps));
      if (axes.length !== starts.length || axes.length !== ends.length) {
        throw new Error("start, ends and axes should have the same number of elements");
      }
      if (axes.length !== inputShape.length) {
        for (let i = 0; i < inputShape.length; ++i) {
          if (!axes.includes(i)) {
            starts.splice(i, 0, 0);
            ends.splice(i, 0, inputShape[i]);
            steps.splice(i, 0, 1);
          }
        }
      }
      const signs = steps.map((step) => Math.sign(step));
      steps.forEach((step, i, array) => {
        if (step < 0) {
          const numSteps = (ends[i] - starts[i]) / step;
          const newEnd = starts[i];
          const newStart = newEnd + numSteps * steps[i];
          starts[i] = newStart;
          ends[i] = newEnd;
          array[i] = -step;
        }
      });
      const outputShape = inputShape.slice(0);
      axes.forEach((axis, _) => {
        outputShape[axis] = Math.ceil((ends[axis] - starts[axis]) / steps[axis]);
      });
      const outputTensorInfo = { dims: outputShape, dataType: inputs[0].dataType };
      const output = outputVariable("output", inputs[0].dataType, outputShape.length);
      const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
      const outputSize = ShapeUtil.size(outputShape);
      const uniforms = [
        { name: "outputSize", type: "u32" },
        { name: "starts", type: "u32", length: starts.length },
        { name: "signs", type: "i32", length: signs.length },
        { name: "steps", type: "u32", length: steps.length }
      ];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: starts },
        { type: 6 /* int32 */, data: signs },
        { type: 12 /* uint32 */, data: steps },
        ...createTensorShapeVariables(inputs[0].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
        ${calculateInputIndicesImpl(input, output, inputShape)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${output.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
      }`;
      return {
        name: "Slice",
        shaderCache: { hint: `${signs.length}_${starts.length}_${steps.length}`, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [outputTensorInfo],
          dispatchGroup: { x: Math.ceil(
            inputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    slice = (context, attributes) => {
      validateInputs29(context.inputs, attributes);
      const updatedAttributes = createSliceAttributesFromInputs(context.inputs, attributes);
      context.compute(createSliceProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
    parseSliceAttributes = (attributes) => {
      const starts = attributes.starts;
      const ends = attributes.ends;
      const axes = attributes.axes;
      return createAttributeWithCacheKey({ starts, ends, axes });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/softmax.ts
var validateInputs30, createSoftmaxProgramInfo, softmax, parseSoftmaxAttributes;
var init_softmax = __esm({
  "web/lib/wasm/jsep/webgpu/ops/softmax.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_transpose();
    init_common();
    validateInputs30 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Softmax op requires 1 input.");
      }
    };
    createSoftmaxProgramInfo = (context, attributes) => {
      const input = context.inputs[0];
      const inputShape = input.dims;
      const outputSize = ShapeUtil.size(inputShape);
      const inputRank = inputShape.length;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const isTransposeRequired = axis < inputShape.length - 1;
      let transposedInput;
      let perm = [];
      if (isTransposeRequired) {
        perm = Array.from({ length: inputRank }, (_, i) => i);
        perm[axis] = inputRank - 1;
        perm[inputRank - 1] = axis;
        transposedInput = context.compute(createTransposeProgramInfo(input, perm), {
          inputs: [input],
          outputs: [-1]
        })[0];
      } else {
        transposedInput = input;
      }
      const transposedInputShape = transposedInput.dims;
      const cols = transposedInputShape[inputRank - 1];
      const rows = outputSize / cols;
      const components = getMaxComponents(cols);
      const packedCols = cols / components;
      let WG = 64;
      if (rows === 1) {
        WG = 256;
      }
      const maxVector = (name, components2) => {
        if (components2 === 4) {
          return `max(max(${name}.x, ${name}.y), max(${name}.z, ${name}.w))`;
        } else if (components2 === 2) {
          return `max(${name}.x, ${name}.y)`;
        } else if (components2 === 3) {
          return `max(max(${name}.x, ${name}.y), ${name}.z)`;
        }
        return name;
      };
      const x = inputVariable("x", transposedInput.dataType, transposedInput.dims, components);
      const output = outputVariable("result", transposedInput.dataType, transposedInput.dims, components);
      const valueType = x.type.value;
      const threadMaxDecl = tensorTypeToWsglStorageType(transposedInput.dataType) === "f32" ? `var threadMax = ${valueType}(-3.402823e+38f);` : `var threadMax = ${valueType}(-65504.0h);`;
      const getShaderSource = (shaderHelper) => `
      var<workgroup> rowMaxShared : ${valueType};
      var<workgroup> rowSumShared : ${valueType};
      var<workgroup> threadShared : array<${valueType}, ${WG}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${valueType} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${valueType}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${shaderHelper.registerUniform("packedCols", "i32").declareVariables(x, output)}
      ${shaderHelper.mainStart(WG)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${WG};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${threadMaxDecl}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${valueType}(${maxVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${valueType}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${valueType}(${sumVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          var value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          // max operation protects against NaN since all values should be >=0
          value = max(value, ${valueType}(0.0));
          setValue(row, col, row_stride, value);
        }
      }`;
      const result = context.compute(
        {
          name: "Softmax",
          // Note that in JSEP, WG size is not included in cache by default, but WebGPU EP it is.
          shaderCache: { hint: `${components};${WG}`, inputDependencies: ["type"] },
          getRunData: () => ({
            outputs: [{ dims: transposedInputShape, dataType: transposedInput.dataType }],
            dispatchGroup: { x: rows },
            programUniforms: [{ type: 6 /* int32 */, data: packedCols }]
          }),
          getShaderSource
        },
        {
          inputs: [transposedInput],
          outputs: [isTransposeRequired ? -1 : 0]
        }
      )[0];
      if (isTransposeRequired) {
        context.compute(createTransposeProgramInfo(result, perm), {
          inputs: [result]
        });
      }
    };
    softmax = (context, attributes) => {
      validateInputs30(context.inputs);
      createSoftmaxProgramInfo(context, attributes);
    };
    parseSoftmaxAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
  }
});

// web/lib/wasm/jsep/webgpu/ops/tile.ts
var getRepeats, validateInputs31, getOutputShape2, createTileProgramInfo, tile;
var init_tile = __esm({
  "web/lib/wasm/jsep/webgpu/ops/tile.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    getRepeats = (repeatsTensorView) => Array.from(repeatsTensorView.getBigInt64Array(), Number);
    validateInputs31 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Tile requires 2 inputs.");
      }
      if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */ && inputs[0].dataType !== 6 /* int32 */ && inputs[0].dataType !== 12 /* uint32 */) {
        throw new Error("Tile only support float, float16, int32, and uint32 data types");
      }
      if (inputs[1].dataType !== 7 /* int64 */) {
        throw new Error("Tile `repeats` input should be of int64 data type");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("Tile `repeats` input should be 1-D");
      }
      const repeats = getRepeats(inputs[1]);
      if (repeats.length !== inputs[0].dims.length) {
        throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
      }
    };
    getOutputShape2 = (inputShape, repeats) => {
      const outputShape = [];
      for (let i = 0; i < inputShape.length; ++i) {
        outputShape.push(inputShape[i] * repeats[i]);
      }
      return outputShape;
    };
    createTileProgramInfo = (inputs, shape) => {
      const inputShape = inputs[0].dims;
      const repeats = shape == null ? getRepeats(inputs[1]) : shape;
      const outputShape = getOutputShape2(inputShape, repeats);
      const outputSize = ShapeUtil.size(outputShape);
      const dataType = inputs[0].dataType;
      const input = inputVariable("input", dataType, inputShape.length);
      const output = outputVariable("output", dataType, outputShape.length);
      const getShaderSource = (shaderHelper) => `
      const inputShape = ${input.indices(...inputShape)};
      ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${output.offsetToIndices("global_idx")};
      var input_indices: ${input.type.indices};
      for (var i = 0; i < ${inputShape.length}; i++) {
        let input_dim_i = ${input.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${output.indicesGet("output_indices", "i")}  % input_dim_i;

        ${input.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
    }`;
      return {
        name: "Tile",
        shaderCache: { hint: `${repeats}`, inputDependencies: ["rank"] },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            ...createTensorShapeVariables(inputs[0].dims, outputShape)
          ]
        }),
        getShaderSource
      };
    };
    tile = (context) => {
      validateInputs31(context.inputs);
      context.compute(createTileProgramInfo(context.inputs), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/where.ts
var createWhereOpProgramShader, createWhereOpProgramInfo, where;
var init_where = __esm({
  "web/lib/wasm/jsep/webgpu/ops/where.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    createWhereOpProgramShader = (shaderHelper, inputs, dimsOutput, isBroadcast, typeOutput) => {
      const output = outputVariable("output_data", typeOutput, dimsOutput.length, 4);
      const a = inputVariable("a_data", inputs[1].dataType, inputs[1].dims.length, 4);
      const b = inputVariable("b_data", inputs[2].dataType, inputs[2].dims.length, 4);
      const c = inputVariable("c_data", inputs[0].dataType, inputs[0].dims.length, 4);
      let assignment;
      const expression = (a2, b2, c2) => `select(${b2}, ${a2}, ${c2})`;
      if (!isBroadcast) {
        assignment = output.setByOffset(
          "global_idx",
          expression(a.getByOffset("global_idx"), b.getByOffset("global_idx"), c.getByOffset("global_idx"))
        );
      } else {
        const singleAssignment = (resStr, x, typeCast = "") => {
          const expressionA = `a_data[index_a${x}][component_a${x}]`;
          const expressionB = `b_data[index_b${x}][component_b${x}]`;
          const expressionC = `bool(c_data[index_c${x}] & (0xffu << (component_c${x} * 8)))`;
          return `
            let output_indices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offset_a${x} = ${a.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_b${x} = ${b.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_c${x} = ${c.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let index_a${x} = offset_a${x} / 4u;
            let index_b${x} = offset_b${x} / 4u;
            let index_c${x} = offset_c${x} / 4u;
            let component_a${x} = offset_a${x} % 4u;
            let component_b${x} = offset_b${x} % 4u;
            let component_c${x} = offset_c${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expression(expressionA, expressionB, expressionC)});
          `;
        };
        if (typeOutput === 9 /* bool */) {
          assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
        } else {
          assignment = `
            ${singleAssignment("output_data[global_idx]", 0)}
            ${singleAssignment("output_data[global_idx]", 1)}
            ${singleAssignment("output_data[global_idx]", 2)}
            ${singleAssignment("output_data[global_idx]", 3)}
          `;
        }
      }
      return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(c, a, b, output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
    };
    createWhereOpProgramInfo = (inputs) => {
      const dimsA = inputs[1].dims;
      const dimsB = inputs[2].dims;
      const dimsC = inputs[0].dims;
      const outputDataType = inputs[1].dataType;
      const isBroadcast = !(ShapeUtil.areEqual(dimsA, dimsB) && ShapeUtil.areEqual(dimsB, dimsC));
      let outputShape = dimsA;
      let outputSize = ShapeUtil.size(dimsA);
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(BroadcastUtil.calcShape(dimsA, dimsB, false), dimsC, false);
        if (!calculatedShape) {
          throw new Error("Can't perform where op on the given tensors");
        }
        outputShape = calculatedShape;
        outputSize = ShapeUtil.size(outputShape);
      }
      const vecSize = Math.ceil(outputSize / 4);
      return {
        name: "Where",
        shaderCache: { inputDependencies: ["rank", "rank", "rank"] },
        getShaderSource: (shaderHelper) => createWhereOpProgramShader(shaderHelper, inputs, outputShape, isBroadcast, outputDataType),
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64 / 4
            /* vec size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: vecSize },
            ...createTensorShapeVariables(dimsC, dimsA, dimsB, outputShape)
          ]
        })
      };
    };
    where = (context) => {
      context.compute(createWhereOpProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/op-resolve-rules.ts
var WEBGPU_OP_RESOLVE_RULES;
var init_op_resolve_rules = __esm({
  "web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"() {
    "use strict";
    init_argminmax();
    init_attention();
    init_batch_norm();
    init_bias_add();
    init_bias_split_gelu();
    init_binary_op();
    init_concat();
    init_conv();
    init_conv_transpose();
    init_cumsum();
    init_depth_to_space();
    init_einsum();
    init_expand();
    init_fast_gelu();
    init_gather();
    init_gather_nd();
    init_gather_block_quantized();
    init_gather_elements();
    init_gemm();
    init_grid_sample();
    init_group_query_attention();
    init_instance_norm();
    init_layer_norm();
    init_matmul();
    init_matmulnbits();
    init_multihead_attention();
    init_pad();
    init_pool();
    init_quantize_linear();
    init_range();
    init_scatter_nd();
    init_reduce();
    init_resize();
    init_rotary_embedding();
    init_skip_layer_norm();
    init_slice();
    init_softmax();
    init_split();
    init_tile();
    init_transpose();
    init_unary_op();
    init_where();
    WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([
      ["Abs", [abs]],
      ["Acos", [acos]],
      ["Acosh", [acosh]],
      ["Add", [add]],
      ["ArgMax", [argMax, parseArgMinMaxAttributes]],
      ["ArgMin", [argMin, parseArgMinMaxAttributes]],
      ["Asin", [asin]],
      ["Asinh", [asinh]],
      ["Atan", [atan]],
      ["Atanh", [atanh]],
      ["Attention", [attention]],
      // TODO: support new attributes for AveragePool-10
      ["AveragePool", [averagePool, parseAveragePoolAttributes]],
      ["BatchNormalization", [batchNorm]],
      ["BiasAdd", [biasAdd]],
      ["BiasSplitGelu", [biasSplitGelu]],
      ["Cast", [cast, parseCastAttributes]],
      ["Ceil", [ceil]],
      ["Clip", [clip]],
      ["Concat", [concat, parseConcatAttributes]],
      ["Conv", [conv, parseConvAttributes]],
      ["ConvTranspose", [convTranspose, parseConvTransposeAttributes]],
      ["Cos", [cos]],
      ["Cosh", [cosh]],
      ["CumSum", [cumsum, parseCumSumAttributes]],
      ["DepthToSpace", [depthToSpace, parseDepthToSpaceAttributes]],
      ["DequantizeLinear", [dequantizeLinear, parseDequantizeLinearAttributes]],
      ["Div", [div]],
      ["Einsum", [einsum, parseEinsumAttributes]],
      ["Elu", [elu, parseAlphaAttributes]],
      ["Equal", [equal]],
      ["Erf", [erf]],
      ["Exp", [exp]],
      ["Expand", [expand]],
      ["FastGelu", [fastGelu2]],
      ["Floor", [floor]],
      ["FusedConv", [conv, parseConvAttributes]],
      ["Gather", [gather, parseGatherAttributes]],
      ["GatherElements", [gatherElements, parseGatherElementsAttributes]],
      ["GatherBlockQuantized", [gatherBlockQuantized, parseGatherBlockQuantizedAttributes]],
      ["GatherND", [gatherND, parseGatherNDAttributes]],
      ["Gelu", [gelu]],
      ["Gemm", [gemm, parseGemmAttributes]],
      ["GlobalAveragePool", [globalAveragePool, parseGlobalAveragePoolAttributes]],
      ["GlobalMaxPool", [globalMaxPool, parseGlobalMaxPoolAttributes]],
      ["Greater", [greater]],
      ["GreaterOrEqual", [greaterOrEqual]],
      ["GridSample", [gridSample, parseGridSampleAttributes]],
      ["GroupQueryAttention", [groupQueryAttention]],
      ["HardSigmoid", [hardSigmoid, parseHardSigmoidAttributes]],
      ["InstanceNormalization", [instanceNorm]],
      ["LayerNormalization", [layerNorm]],
      ["LeakyRelu", [leakyRelu, parseAlphaAttributes]],
      ["Less", [less]],
      ["LessOrEqual", [lessOrEqual]],
      ["Log", [log]],
      ["MatMul", [matMul]],
      ["MatMulNBits", [matMulNBits, parseMatMulNBitsAttributes]],
      // TODO: support new attributes for MaxPool-8 and MaxPool-10
      ["MaxPool", [maxPool, parseMaxPoolAttributes]],
      ["Mul", [mul]],
      ["MultiHeadAttention", [multiHeadAttention, parseMultiHeadAttentionAttributes]],
      ["Neg", [neg]],
      ["Not", [not]],
      ["Pad", [pad]],
      ["Pow", [pow]],
      ["QuickGelu", [quickgelu, parseAlphaAttributes]],
      ["Range", [range]],
      ["Reciprocal", [reciprocal]],
      ["ReduceMin", [reduceMin]],
      ["ReduceMean", [reduceMean]],
      ["ReduceMax", [reduceMax]],
      ["ReduceSum", [reduceSum]],
      ["ReduceProd", [reduceProd]],
      ["ReduceL1", [reduceL1]],
      ["ReduceL2", [reduceL2]],
      ["ReduceLogSum", [reduceLogSum]],
      ["ReduceLogSumExp", [reduceLogSumExp]],
      ["ReduceSumSquare", [reduceSumSquare]],
      ["Relu", [relu]],
      ["Resize", [resize, parseResizeAttributes]],
      ["RotaryEmbedding", [rotaryEmbedding]],
      ["ScatterND", [scatterND, parseScatterNDAttributes]],
      ["Sigmoid", [sigmoid]],
      ["Sin", [sin]],
      ["Sinh", [sinh]],
      ["Slice", [slice, parseSliceAttributes]],
      ["SkipLayerNormalization", [skipLayerNorm]],
      ["Split", [split, parseSplitAttributes]],
      ["Sqrt", [sqrt]],
      ["Softmax", [softmax, parseSoftmaxAttributes]],
      ["Sub", [sub]],
      ["Tan", [tan]],
      ["Tanh", [tanh]],
      ["ThresholdedRelu", [thresholdedRelu, parseAlphaAttributes]],
      ["Tile", [tile]],
      ["Transpose", [transpose, parseTransposeAttributes]],
      ["Where", [where]]
    ]);
  }
});

// web/lib/wasm/jsep/webgpu/program-manager.ts
var ProgramManager;
var init_program_manager = __esm({
  "web/lib/wasm/jsep/webgpu/program-manager.ts"() {
    "use strict";
    init_esm();
    init_log();
    init_common();
    ProgramManager = class {
      constructor(backend) {
        this.backend = backend;
        this.repo = /* @__PURE__ */ new Map();
        this.attributesBound = false;
      }
      getArtifact(key) {
        return this.repo.get(key);
      }
      setArtifact(key, artifact) {
        this.repo.set(key, artifact);
      }
      run(buildArtifact, inputs, outputs, dispatchGroup, uniformBufferBinding) {
        TRACE_FUNC_BEGIN(buildArtifact.programInfo.name);
        const device = this.backend.device;
        const computePassEncoder = this.backend.getComputePassEncoder();
        this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
        const entries = [];
        for (const input of inputs) {
          entries.push({ binding: entries.length, resource: { buffer: input.buffer } });
        }
        for (const output of outputs) {
          entries.push({ binding: entries.length, resource: { buffer: output.buffer } });
        }
        if (uniformBufferBinding) {
          entries.push({ binding: entries.length, resource: uniformBufferBinding });
        }
        const bindGroup = device.createBindGroup({
          layout: buildArtifact.computePipeline.getBindGroupLayout(0),
          entries,
          label: buildArtifact.programInfo.name
        });
        if (this.backend.sessionStatus === "capturing") {
          const commandInfo = {
            kernelId: this.backend.currentKernelId,
            computePipeline: buildArtifact.computePipeline,
            bindGroup,
            dispatchGroup
          };
          const sessionCommandList = this.backend.capturedCommandList.get(this.backend.currentSessionId);
          sessionCommandList.push(commandInfo);
        }
        computePassEncoder.setPipeline(buildArtifact.computePipeline);
        computePassEncoder.setBindGroup(0, bindGroup);
        computePassEncoder.dispatchWorkgroups(...dispatchGroup);
        this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1);
        this.backend.pendingDispatchNumber++;
        if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") {
          this.backend.endComputePass();
        }
        if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber) {
          this.backend.flush();
        }
        TRACE_FUNC_END(buildArtifact.programInfo.name);
      }
      dispose() {
      }
      build(programInfo, normalizedDispatchGroupSize) {
        TRACE_FUNC_BEGIN(programInfo.name);
        const device = this.backend.device;
        const enableDirectives = [];
        const extensionsInfo = [
          { feature: "shader-f16", extension: "f16" },
          { feature: "subgroups", extension: "subgroups" }
        ];
        extensionsInfo.forEach((info) => {
          if (device.features.has(info.feature)) {
            enableDirectives.push(`enable ${info.extension};`);
          }
        });
        const shaderHelper = createShaderHelper(normalizedDispatchGroupSize, this.backend.device.limits);
        const userCode = programInfo.getShaderSource(shaderHelper);
        const code = `${enableDirectives.join("\n")}
${shaderHelper.additionalImplementations}
${userCode}`;
        const shaderModule = device.createShaderModule({ code, label: programInfo.name });
        LOG_DEBUG("verbose", () => `[WebGPU] ${programInfo.name} shader code: ${code}`);
        const computePipeline = device.createComputePipeline({
          compute: { module: shaderModule, entryPoint: "main" },
          layout: "auto",
          label: programInfo.name
        });
        TRACE_FUNC_END(programInfo.name);
        return { programInfo, computePipeline, uniformVariablesInfo: shaderHelper.variablesInfo };
      }
      normalizeDispatchGroupSize(dispatchGroup) {
        const x = typeof dispatchGroup === "number" ? dispatchGroup : dispatchGroup.x;
        const y = typeof dispatchGroup === "number" ? 1 : dispatchGroup.y || 1;
        const z = typeof dispatchGroup === "number" ? 1 : dispatchGroup.z || 1;
        const limitPerDimension = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
        if (x <= limitPerDimension && y <= limitPerDimension && z <= limitPerDimension) {
          return [x, y, z];
        }
        const size = x * y * z;
        let dispatchAverage = Math.ceil(Math.sqrt(size));
        if (dispatchAverage > limitPerDimension) {
          dispatchAverage = Math.ceil(Math.cbrt(size));
          if (dispatchAverage > limitPerDimension) {
            throw new Error("Total dispatch size exceeds WebGPU maximum.");
          }
          return [dispatchAverage, dispatchAverage, dispatchAverage];
        } else {
          return [dispatchAverage, dispatchAverage, 1];
        }
      }
    };
  }
});

// web/lib/wasm/jsep/backend-webgpu.ts
var backend_webgpu_exports = {};
__export(backend_webgpu_exports, {
  WebGpuBackend: () => WebGpuBackend
});
var getProgramInputTensorInfoDependencyKey, getProgramInfoUniqueKey, AdapterInfoImpl, WebGpuBackend;
var init_backend_webgpu = __esm({
  "web/lib/wasm/jsep/backend-webgpu.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_log();
    init_tensor_view();
    init_gpu_data_manager();
    init_op_resolve_rules();
    init_program_manager();
    getProgramInputTensorInfoDependencyKey = (inputTensors, inputDependencies) => {
      if (inputDependencies.length !== inputTensors.length) {
        throw new Error(
          `inputDependencies length ${inputDependencies.length} is not equal to inputTensors length ${inputTensors.length}.`
        );
      }
      const inputInfos = [];
      for (let i = 0; i < inputTensors.length; ++i) {
        const type = inputTensors[i].dataType;
        switch (inputDependencies[i]) {
          case "none": {
            inputInfos.push("");
            break;
          }
          case "type": {
            inputInfos.push(`${type}`);
            break;
          }
          case "rank": {
            const rank = inputTensors[i].dims.length;
            inputInfos.push(`${type};${rank}`);
            break;
          }
          case "dims": {
            const dims = inputTensors[i].dims.join(",");
            inputInfos.push(`${type};${dims}`);
            break;
          }
          default:
            throw new Error(`unsupported input dependency: ${inputDependencies[i]}`);
        }
      }
      return inputInfos.join("|");
    };
    getProgramInfoUniqueKey = (programInfo, inputTensors, is1DimensionDispatch) => {
      let key = programInfo.name;
      if (programInfo.shaderCache?.hint) {
        key += "[" + programInfo.shaderCache.hint + "]";
      }
      key += ":" + is1DimensionDispatch + `:${getProgramInputTensorInfoDependencyKey(
        inputTensors,
        programInfo.shaderCache?.inputDependencies ?? new Array(inputTensors.length).fill("dims")
      )}`;
      return key;
    };
    AdapterInfoImpl = class {
      constructor(adapterInfo) {
        if (adapterInfo) {
          this.architecture = adapterInfo.architecture;
          this.vendor = adapterInfo.vendor;
        }
      }
      isArchitecture(architecture) {
        return this.architecture === architecture;
      }
      isVendor(vendor) {
        return this.vendor === vendor;
      }
    };
    WebGpuBackend = class {
      constructor() {
        /**
         * representing the session ID of which is currently being run.
         * `null` means no session is being run.
         * only valid when session.run is executed.
         */
        this.currentSessionId = null;
        /**
         * representing the kernel ID of which is currently being computed (CPU code perspective).
         * `null` means no kernel is being computed.
         * only one kernel can be computed at a moment.
         */
        this.currentKernelId = null;
        this.commandEncoder = null;
        this.computePassEncoder = null;
        this.maxDispatchNumber = 16;
        this.pendingDispatchNumber = 0;
        // info of kernels pending submission for a single batch
        this.pendingKernels = [];
        // queryReadBuffer -> pendingKernels mapping for all the batches
        this.pendingQueries = /* @__PURE__ */ new Map();
        this.sessionStatus = "default";
        /**
         * a SessionID -> CommandInfo[] mapping. It's used to record all GPU commands for corresponding session.
         */
        this.capturedCommandList = /* @__PURE__ */ new Map();
        /**
         * a SessionID -> PendingKernelInfo[] mapping for profiling.
         */
        this.capturedPendingKernels = /* @__PURE__ */ new Map();
        /**
         * a SessionID -> a Map of (InputOutputIndex -> [ID, GPUBuffer]) mapping.
         */
        this.sessionExternalDataMapping = /* @__PURE__ */ new Map();
      }
      /**
       * get the custom data of the current kernel
       */
      get currentKernelCustomData() {
        if (this.currentKernelId === null) {
          throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
        }
        let data = this.kernelCustomData.get(this.currentKernelId);
        if (!data) {
          data = {};
          this.kernelCustomData.set(this.currentKernelId, data);
        }
        return data;
      }
      async initialize(env3, adapter) {
        this.env = env3;
        const requiredFeatures = [];
        const deviceDescriptor = {
          requiredLimits: {
            maxComputeWorkgroupStorageSize: adapter.limits.maxComputeWorkgroupStorageSize,
            maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,
            maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
            maxBufferSize: adapter.limits.maxBufferSize,
            maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,
            maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,
            maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,
            maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ
          },
          requiredFeatures
        };
        const requireFeatureIfAvailable = (feature) => adapter.features.has(feature) && requiredFeatures.push(feature) && true;
        if (!requireFeatureIfAvailable("chromium-experimental-timestamp-query-inside-passes")) {
          requireFeatureIfAvailable("timestamp-query");
        }
        requireFeatureIfAvailable("shader-f16");
        requireFeatureIfAvailable("subgroups");
        this.device = await adapter.requestDevice(deviceDescriptor);
        this.adapterInfo = new AdapterInfoImpl(adapter.info || await adapter.requestAdapterInfo());
        this.gpuDataManager = createGpuDataManager(this);
        this.programManager = new ProgramManager(this);
        this.kernels = /* @__PURE__ */ new Map();
        this.kernelPersistentData = /* @__PURE__ */ new Map();
        this.kernelCustomData = /* @__PURE__ */ new Map();
        configureLogger(env3.logLevel, !!env3.debug);
        this.device.onuncapturederror = (ev) => {
          if (ev.error instanceof GPUValidationError) {
            console.error(`An uncaught WebGPU validation error was raised: ${ev.error.message}`);
          }
        };
        Object.defineProperty(this.env.webgpu, "device", {
          value: this.device,
          writable: false,
          enumerable: true,
          configurable: false
        });
        Object.defineProperty(this.env.webgpu, "adapter", {
          value: adapter,
          writable: false,
          enumerable: true,
          configurable: false
        });
        this.setQueryType();
      }
      dispose() {
        if (typeof this.querySet !== "undefined") {
          this.querySet.destroy();
        }
        this.gpuDataManager.dispose();
      }
      getCommandEncoder() {
        if (!this.commandEncoder) {
          this.commandEncoder = this.device.createCommandEncoder();
        }
        return this.commandEncoder;
      }
      getComputePassEncoder() {
        if (!this.computePassEncoder) {
          const commandEncoder = this.getCommandEncoder();
          const computePassDescriptor = {};
          if (this.queryType === "at-passes") {
            computePassDescriptor.timestampWrites = {
              querySet: this.querySet,
              beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
              endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
            };
          }
          this.computePassEncoder = commandEncoder.beginComputePass(computePassDescriptor);
        }
        return this.computePassEncoder;
      }
      endComputePass() {
        if (this.computePassEncoder) {
          this.computePassEncoder.end();
          this.computePassEncoder = null;
        }
      }
      flush() {
        if (!this.commandEncoder) {
          return;
        }
        TRACE_FUNC_BEGIN();
        this.endComputePass();
        let queryReadBuffer;
        if (this.queryType !== "none") {
          this.commandEncoder.resolveQuerySet(
            this.querySet,
            0,
            this.pendingDispatchNumber * 2,
            this.queryResolveBuffer,
            0
          );
          queryReadBuffer = this.device.createBuffer(
            // eslint-disable-next-line no-bitwise
            { size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }
          );
          this.pendingQueries.set(queryReadBuffer, this.pendingKernels);
          this.pendingKernels = [];
          this.commandEncoder.copyBufferToBuffer(
            this.queryResolveBuffer,
            0,
            queryReadBuffer,
            0,
            this.pendingDispatchNumber * 2 * 8
          );
        }
        this.device.queue.submit([this.commandEncoder.finish()]);
        this.gpuDataManager.refreshPendingBuffers();
        this.commandEncoder = null;
        this.pendingDispatchNumber = 0;
        if (this.queryType !== "none") {
          void queryReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
            const mappedData = new BigUint64Array(queryReadBuffer.getMappedRange());
            const pendingKernels = this.pendingQueries.get(queryReadBuffer);
            for (let i = 0; i < mappedData.length / 2; i++) {
              const pendingKernelInfo = pendingKernels[i];
              const kernelId = pendingKernelInfo.kernelId;
              const kernelInfo = this.kernels.get(kernelId);
              const kernelType = kernelInfo.kernelType;
              const kernelName = kernelInfo.kernelName;
              const programName = pendingKernelInfo.programName;
              const inputTensorViews = pendingKernelInfo.inputTensorViews;
              const outputTensorViews = pendingKernelInfo.outputTensorViews;
              const startTimeU64 = mappedData[i * 2];
              const endTimeU64 = mappedData[i * 2 + 1];
              if (typeof this.queryTimeBase === "undefined") {
                this.queryTimeBase = startTimeU64;
              }
              const startTime = Number(startTimeU64 - this.queryTimeBase);
              const endTime = Number(endTimeU64 - this.queryTimeBase);
              if (!Number.isSafeInteger(startTime) || !Number.isSafeInteger(endTime)) {
                throw new RangeError("incorrect timestamp range");
              }
              if (this.env.webgpu.profiling?.ondata) {
                this.env.webgpu.profiling.ondata({
                  version: 1,
                  inputsMetadata: inputTensorViews.map((value) => ({
                    dims: value.dims,
                    dataType: tensorDataTypeEnumToString(value.dataType)
                  })),
                  outputsMetadata: outputTensorViews.map((value) => ({
                    dims: value.dims,
                    dataType: tensorDataTypeEnumToString(value.dataType)
                  })),
                  kernelId,
                  kernelType,
                  kernelName,
                  programName,
                  startTime,
                  endTime
                });
              } else {
                let inputShapes = "";
                inputTensorViews.forEach((value, i2) => {
                  inputShapes += `input[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                });
                let outputShapes = "";
                outputTensorViews.forEach((value, i2) => {
                  outputShapes += `output[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                });
                console.log(
                  `[profiling] kernel "${kernelId}|${kernelType}|${kernelName}|${programName}" ${inputShapes}${outputShapes}start time: ${startTime} ns, execution time: ${endTime - startTime} ns`
                );
              }
              TRACE("GPU", `${programName}::${startTimeU64}::${endTimeU64}`);
            }
            queryReadBuffer.unmap();
            this.pendingQueries.delete(queryReadBuffer);
          });
        }
        TRACE_FUNC_END();
      }
      /**
       * run a WebGPU program.
       * @param program a ProgramInfo instance
       * @param inputTensorViews a TensorView array. each element represents a value already exists in GPU.
       * @param outputIndices an indices array. each element can be either -1 (temporary data), -2 (persistent data) or an
       * index to the kernel's output.
       * @param createKernelOutput a callback function that create a value to kernel's output with the given index
       * @param createIntermediateOutput a callback function that create a value as a intermediate value, either temporary
       * or persistent (owned by the current kernel)
       * @returns a TensorView array representing the result.
       */
      run(program, inputTensorViews, outputIndices, createKernelOutput, createIntermediateOutput, outputCount) {
        TRACE_FUNC_BEGIN(program.name);
        const inputDatas = [];
        for (let i = 0; i < inputTensorViews.length; ++i) {
          const data = inputTensorViews[i].data;
          if (data === 0) {
            continue;
          }
          const gpuData = this.gpuDataManager.get(data);
          if (!gpuData) {
            throw new Error(`no GPU data for input: ${data}`);
          }
          inputDatas.push(gpuData);
        }
        const { outputs, dispatchGroup, programUniforms } = program.getRunData(inputTensorViews);
        const validatedOutputIndices = outputIndices.length === 0 ? outputs.map((_, i) => i) : outputIndices;
        if (validatedOutputIndices.length !== outputs.length) {
          throw new Error(`Output size ${validatedOutputIndices.length} must be equal to ${outputs.length}.`);
        }
        const outputTensorViews = [];
        const outputDatas = [];
        for (let i = 0; i < outputs.length; ++i) {
          if (!Number.isInteger(validatedOutputIndices[i]) || validatedOutputIndices[i] < -3 || validatedOutputIndices[i] >= outputCount) {
            throw new Error(`Invalid output index: ${validatedOutputIndices[i]}`);
          }
          if (validatedOutputIndices[i] === -3) {
            continue;
          }
          const isTemporary = validatedOutputIndices[i] === -1;
          const isPersistent = validatedOutputIndices[i] === -2;
          const tensorView = isTemporary || isPersistent ? createIntermediateOutput(outputs[i].dataType, outputs[i].dims) : createKernelOutput(validatedOutputIndices[i], outputs[i].dataType, outputs[i].dims);
          outputTensorViews.push(tensorView);
          if (tensorView.data === 0) {
            continue;
          }
          const gpuData = this.gpuDataManager.get(tensorView.data);
          if (!gpuData) {
            throw new Error(`no GPU data for output: ${tensorView.data}`);
          }
          if (isTemporary) {
            this.temporaryData.push(gpuData);
          }
          if (isPersistent) {
            let persistentData = this.kernelPersistentData.get(this.currentKernelId);
            if (!persistentData) {
              persistentData = [];
              this.kernelPersistentData.set(this.currentKernelId, persistentData);
            }
            persistentData.push(gpuData);
          }
          outputDatas.push(gpuData);
        }
        if (inputDatas.length !== inputTensorViews.length || outputDatas.length !== outputTensorViews.length) {
          if (outputDatas.length === 0) {
            TRACE_FUNC_END(program.name);
            return outputTensorViews;
          }
          throw new Error(
            `Program ${program.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`
          );
        }
        let uniformBufferBinding;
        if (programUniforms) {
          let currentOffset = 0;
          const offsets = [];
          programUniforms.forEach((v) => {
            const data = typeof v.data === "number" ? [v.data] : v.data;
            if (data.length === 0) {
              return;
            }
            const sizeOfElement = v.type === 10 /* float16 */ ? 2 : 4;
            let sizeOfVecOrMat;
            let baseAlignment;
            if (v.type === 10 /* float16 */) {
              baseAlignment = data.length > 4 ? 16 : data.length > 2 ? 8 : data.length * sizeOfElement;
              sizeOfVecOrMat = data.length > 4 ? 16 : sizeOfElement * data.length;
            } else {
              baseAlignment = data.length <= 2 ? data.length * sizeOfElement : 16;
              sizeOfVecOrMat = 16;
            }
            currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;
            offsets.push(currentOffset);
            const elementPerVecOrMat = v.type === 10 /* float16 */ ? 8 : 4;
            currentOffset += data.length > 4 ? Math.ceil(data.length / elementPerVecOrMat) * sizeOfVecOrMat : data.length * sizeOfElement;
          });
          const maxAlignmentOfField = 16;
          currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;
          const arrayBuffer = new ArrayBuffer(currentOffset);
          programUniforms.forEach((v, i) => {
            const offset = offsets[i];
            const data = typeof v.data === "number" ? [v.data] : v.data;
            if (v.type === 6 /* int32 */) {
              new Int32Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 12 /* uint32 */) {
              new Uint32Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 10 /* float16 */) {
              new Uint16Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 1 /* float */) {
              new Float32Array(arrayBuffer, offset, data.length).set(data);
            } else {
              throw new Error(`Unsupported uniform type: ${tensorDataTypeEnumToString(v.type)}`);
            }
          });
          const uniformBufferData = (
            // eslint-disable-next-line no-bitwise
            this.gpuDataManager.create(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM)
          );
          this.device.queue.writeBuffer(uniformBufferData.buffer, 0, arrayBuffer, 0, currentOffset);
          this.gpuDataManager.release(uniformBufferData.id);
          uniformBufferBinding = { offset: 0, size: currentOffset, buffer: uniformBufferData.buffer };
        }
        const normalizedDispatchGroup = this.programManager.normalizeDispatchGroupSize(dispatchGroup);
        const is1DimensionDispatch = normalizedDispatchGroup[1] === 1 && normalizedDispatchGroup[2] === 1;
        const key = getProgramInfoUniqueKey(program, inputTensorViews, is1DimensionDispatch);
        let artifact = this.programManager.getArtifact(key);
        if (!artifact) {
          artifact = this.programManager.build(program, normalizedDispatchGroup);
          this.programManager.setArtifact(key, artifact);
          LOG_DEBUG("info", () => `[artifact] key: ${key}, programName: ${program.name}`);
        }
        if (programUniforms && artifact.uniformVariablesInfo) {
          if (programUniforms.length !== artifact.uniformVariablesInfo.length) {
            throw new Error(
              `Uniform variables count mismatch: expect ${artifact.uniformVariablesInfo.length}, got ${programUniforms.length} in program "${artifact.programInfo.name}".`
            );
          }
          for (let i = 0; i < programUniforms.length; i++) {
            const uniform = programUniforms[i];
            const actualType = uniform.type;
            const actualLength = typeof uniform.data === "number" ? 1 : uniform.data.length;
            const [type, length] = artifact.uniformVariablesInfo[i];
            if (actualType !== type || actualLength !== length) {
              throw new Error(
                `Uniform variable ${i} mismatch: expect type ${type} with size ${length}, got type ${actualType} with size ${actualLength} in program "${artifact.programInfo.name}".`
              );
            }
          }
        }
        LOG_DEBUG(
          "info",
          () => `[ProgramManager] run "${program.name}" (key=${key}) with ${normalizedDispatchGroup[0]}x${normalizedDispatchGroup[1]}x${normalizedDispatchGroup[2]}`
        );
        if (this.queryType !== "none" || this.sessionStatus === "capturing") {
          const pendingKernelInfo = {
            kernelId: this.currentKernelId,
            programName: artifact.programInfo.name,
            inputTensorViews,
            outputTensorViews
          };
          this.pendingKernels.push(pendingKernelInfo);
          if (this.sessionStatus === "capturing") {
            const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
            sessionPendingKernels.push(pendingKernelInfo);
          }
        }
        this.programManager.run(artifact, inputDatas, outputDatas, normalizedDispatchGroup, uniformBufferBinding);
        TRACE_FUNC_END(program.name);
        return outputTensorViews;
      }
      upload(gpuDataId, data) {
        this.gpuDataManager.upload(gpuDataId, data);
      }
      memcpy(src, dst) {
        this.gpuDataManager.memcpy(src, dst);
      }
      async download(gpuDataId, getTargetBuffer) {
        await this.gpuDataManager.download(gpuDataId, getTargetBuffer);
      }
      alloc(size) {
        return this.gpuDataManager.create(size).id;
      }
      free(ptr) {
        return this.gpuDataManager.release(ptr);
      }
      createKernel(kernelType, kernelId, attribute, kernelName) {
        const op = WEBGPU_OP_RESOLVE_RULES.get(kernelType);
        if (!op) {
          throw new Error(`kernel not implemented: ${kernelType}`);
        }
        const kernelInfo = {
          kernelType,
          kernelName,
          kernelEntry: op[0],
          attributes: [op[1], attribute]
        };
        this.kernels.set(kernelId, kernelInfo);
      }
      releaseKernel(kernelId) {
        const persistentData = this.kernelPersistentData.get(kernelId);
        if (persistentData) {
          for (const data of persistentData) {
            this.gpuDataManager.release(data.id);
          }
          this.kernelPersistentData.delete(kernelId);
        }
        this.kernelCustomData.delete(kernelId);
        this.kernels.delete(kernelId);
      }
      computeKernel(kernelId, context, errors) {
        const kernel = this.kernels.get(kernelId);
        if (!kernel) {
          throw new Error(`kernel not created: ${kernelId}`);
        }
        const kernelType = kernel.kernelType;
        const kernelName = kernel.kernelName;
        const kernelEntry = kernel.kernelEntry;
        const attributes = kernel.attributes;
        if (this.currentKernelId !== null) {
          throw new Error(`kernel "[${kernelType}] ${kernelName}" is not allowed to be called recursively`);
        }
        this.currentKernelId = kernelId;
        if (attributes[0]) {
          attributes[1] = attributes[0](attributes[1]);
          attributes[0] = void 0;
        }
        LOG_DEBUG("info", () => `[WebGPU] Start to run kernel "[${kernelType}] ${kernelName}"...`);
        const useErrorScope = this.env.debug;
        this.temporaryData = [];
        try {
          if (useErrorScope) {
            this.device.pushErrorScope("validation");
          }
          kernelEntry(context, attributes[1]);
          return 0;
        } catch (e) {
          errors.push(Promise.resolve(`[WebGPU] Kernel "[${kernelType}] ${kernelName}" failed. ${e}`));
          return 1;
        } finally {
          if (useErrorScope) {
            errors.push(
              this.device.popErrorScope().then(
                (err) => err ? `GPU validation error for kernel "[${kernelType}] ${kernelName}": ${err.message}` : null
              )
            );
          }
          for (const data of this.temporaryData) {
            this.gpuDataManager.release(data.id);
          }
          this.temporaryData = [];
          this.currentKernelId = null;
        }
      }
      // #region external buffer
      registerBuffer(sessionId, index, buffer, size) {
        let sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
        if (!sessionInputOutputMapping) {
          sessionInputOutputMapping = /* @__PURE__ */ new Map();
          this.sessionExternalDataMapping.set(sessionId, sessionInputOutputMapping);
        }
        const previousBuffer = sessionInputOutputMapping.get(index);
        const id = this.gpuDataManager.registerExternalBuffer(buffer, size, previousBuffer);
        sessionInputOutputMapping.set(index, [id, buffer]);
        return id;
      }
      unregisterBuffers(sessionId) {
        const sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
        if (sessionInputOutputMapping) {
          sessionInputOutputMapping.forEach((bufferInfo) => this.gpuDataManager.unregisterExternalBuffer(bufferInfo[0]));
          this.sessionExternalDataMapping.delete(sessionId);
        }
      }
      getBuffer(gpuDataId) {
        const gpuData = this.gpuDataManager.get(gpuDataId);
        if (!gpuData) {
          throw new Error(`no GPU data for buffer: ${gpuDataId}`);
        }
        return gpuData.buffer;
      }
      createDownloader(gpuBuffer, size, type) {
        return async () => {
          const data = await downloadGpuData(this, gpuBuffer, size);
          return createView(data.buffer, type);
        };
      }
      // #endregion
      writeTimestamp(index) {
        if (this.queryType !== "inside-passes") {
          return;
        }
        this.computePassEncoder.writeTimestamp(this.querySet, index);
      }
      setQueryType() {
        this.queryType = "none";
        if (this.env.webgpu.profiling?.mode === "default" || (typeof this.env.trace === "undefined" ? this.env.wasm.trace : this.env.trace)) {
          if (this.device.features.has("chromium-experimental-timestamp-query-inside-passes")) {
            this.queryType = "inside-passes";
          } else if (this.device.features.has("timestamp-query")) {
            this.queryType = "at-passes";
          }
          if (this.queryType !== "none" && typeof this.querySet === "undefined") {
            this.querySet = this.device.createQuerySet({
              type: "timestamp",
              count: this.maxDispatchNumber * 2
            });
            this.queryResolveBuffer = this.device.createBuffer(
              // eslint-disable-next-line no-bitwise
              { size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE }
            );
          }
        }
      }
      captureBegin() {
        LOG_DEBUG("info", "captureBegin");
        if (!this.capturedCommandList.get(this.currentSessionId)) {
          this.capturedCommandList.set(this.currentSessionId, []);
        }
        if (!this.capturedPendingKernels.get(this.currentSessionId)) {
          this.capturedPendingKernels.set(this.currentSessionId, []);
        }
        this.flush();
        this.sessionStatus = "capturing";
      }
      captureEnd() {
        LOG_DEBUG("info", "captureEnd");
        this.flush();
        this.sessionStatus = "default";
      }
      replay() {
        LOG_DEBUG("info", "replay");
        this.sessionStatus = "replaying";
        const sessionCommandList = this.capturedCommandList.get(this.currentSessionId);
        const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
        const length = sessionCommandList.length;
        this.pendingKernels = [];
        for (let i = 0; i < length; i++) {
          const computePassEncoder = this.getComputePassEncoder();
          const command = sessionCommandList[i];
          this.writeTimestamp(this.pendingDispatchNumber * 2);
          computePassEncoder.setPipeline(command.computePipeline);
          computePassEncoder.setBindGroup(0, command.bindGroup);
          computePassEncoder.dispatchWorkgroups(...command.dispatchGroup);
          this.writeTimestamp(this.pendingDispatchNumber * 2 + 1);
          this.pendingDispatchNumber++;
          if (this.queryType !== "none") {
            this.pendingKernels.push(sessionPendingKernels[i]);
          }
          if (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") {
            this.endComputePass();
          }
          if (this.pendingDispatchNumber >= this.maxDispatchNumber) {
            this.flush();
          }
        }
        this.flush();
        this.sessionStatus = "default";
      }
      onCreateSession() {
        this.gpuDataManager.onCreateSession();
      }
      onReleaseSession(sessionId) {
        this.unregisterBuffers(sessionId);
        if (this.capturedCommandList.has(sessionId)) {
          this.capturedCommandList.delete(sessionId);
        }
        if (this.capturedPendingKernels.has(sessionId)) {
          this.capturedPendingKernels.delete(sessionId);
        }
        this.gpuDataManager.onReleaseSession(sessionId);
      }
      onRunStart(sessionId) {
        this.currentSessionId = sessionId;
        this.setQueryType();
      }
    };
  }
});

// web/lib/wasm/jsep/init.ts
var init_exports = {};
__export(init_exports, {
  init: () => init
});
var TensorViewImpl, ComputeContextImpl, init;
var init_init = __esm({
  "web/lib/wasm/jsep/init.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_util();
    init_backend_webnn();
    TensorViewImpl = class _TensorViewImpl {
      constructor(module, dataType, data, dims) {
        this.module = module;
        this.dataType = dataType;
        this.data = data;
        this.dims = dims;
      }
      getFloat32Array() {
        if (this.dataType !== 1 /* float */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getBigInt64Array() {
        if (this.dataType !== 7 /* int64 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getInt32Array() {
        if (this.dataType !== 6 /* int32 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getUint16Array() {
        if (this.dataType !== 10 /* float16 */ && this.dataType !== 4 /* uint16 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Uint16Array() : new Uint16Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      reshape(newDims) {
        if (ShapeUtil.size(newDims) !== ShapeUtil.size(this.dims)) {
          throw new Error("Invalid new shape");
        }
        return new _TensorViewImpl(this.module, this.dataType, this.data, newDims);
      }
    };
    ComputeContextImpl = class {
      constructor(module, backend, contextDataOffset) {
        this.module = module;
        this.backend = backend;
        this.customDataOffset = 0;
        this.customDataSize = 0;
        this.adapterInfo = backend.adapterInfo;
        const ptrSize = module.PTR_SIZE;
        let dataIndex = contextDataOffset / module.PTR_SIZE;
        const type = ptrSize === 4 ? "i32" : "i64";
        this.opKernelContext = Number(module.getValue(ptrSize * dataIndex++, type));
        const inputCount = Number(module.getValue(ptrSize * dataIndex++, type));
        this.outputCount = Number(module.getValue(ptrSize * dataIndex++, type));
        this.customDataOffset = Number(module.getValue(ptrSize * dataIndex++, "*"));
        this.customDataSize = Number(module.getValue(ptrSize * dataIndex++, type));
        const inputs = [];
        for (let i = 0; i < inputCount; i++) {
          const dataType = Number(module.getValue(ptrSize * dataIndex++, type));
          const data = Number(module.getValue(ptrSize * dataIndex++, "*"));
          const dim = Number(module.getValue(ptrSize * dataIndex++, type));
          const dims = [];
          for (let d = 0; d < dim; d++) {
            dims.push(Number(module.getValue(ptrSize * dataIndex++, type)));
          }
          inputs.push(new TensorViewImpl(module, dataType, data, dims));
        }
        this.inputs = inputs;
      }
      get kernelCustomData() {
        return this.backend.currentKernelCustomData;
      }
      get customDataBuffer() {
        return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
      }
      compute(program, inputsOutputsMapping) {
        const mappedInputs = inputsOutputsMapping?.inputs?.map((i) => typeof i === "number" ? this.inputs[i] : i) ?? this.inputs;
        const outputIndices = inputsOutputsMapping?.outputs ?? [];
        const createKernelOutput = (index, dataType, dims) => new TensorViewImpl(this.module, dataType, this.output(index, dims), dims);
        const createTemporaryOutput = (dataType, dims) => {
          const bufferSize = calculateTensorSizeInBytes(dataType, dims);
          if (!bufferSize) {
            throw new Error(`Unsupported data type: ${dataType}`);
          }
          const gpuDataId = bufferSize > 0 ? this.backend.gpuDataManager.create(bufferSize).id : 0;
          return new TensorViewImpl(this.module, dataType, gpuDataId, dims);
        };
        return this.backend.run(
          program,
          mappedInputs,
          outputIndices,
          createKernelOutput,
          createTemporaryOutput,
          this.outputCount
        );
      }
      output(index, dims) {
        const stack = this.module.stackSave();
        try {
          const ptrSize = this.module.PTR_SIZE;
          const type = ptrSize === 4 ? "i32" : "i64";
          const data = this.module.stackAlloc(
            (1 + dims.length) * ptrSize
            /* sizeof(size_t) */
          );
          this.module.setValue(data, dims.length, type);
          for (let i = 0; i < dims.length; i++) {
            this.module.setValue(data + ptrSize * (i + 1), dims[i], type);
          }
          return this.module._JsepOutput(this.opKernelContext, index, data);
        } catch (e) {
          throw new Error(
            `Failed to generate kernel's output[${index}] with dims [${dims}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${e}`
          );
        } finally {
          this.module.stackRestore(stack);
        }
      }
    };
    init = async (name, module, env3, gpuAdapter) => {
      const jsepInit = module.jsepInit;
      if (!jsepInit) {
        throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
      }
      if (name === "webgpu") {
        const webGpuBackendImpl = (init_backend_webgpu(), __toCommonJS(backend_webgpu_exports)).WebGpuBackend;
        const backend = new webGpuBackendImpl();
        await backend.initialize(env3, gpuAdapter);
        jsepInit("webgpu", [
          // backend
          backend,
          // jsepAlloc()
          (size) => backend.alloc(Number(size)),
          // jsepFree()
          (ptr) => backend.free(ptr),
          // jsepCopy(src, dst, size, isSourceGpu)
          (src, dst, size, isSourceGpu = false) => {
            if (isSourceGpu) {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepCopyGpuToGpu: src=${Number(src)}, dst=${Number(dst)}, size=${Number(size)}`
              );
              backend.memcpy(Number(src), Number(dst));
            } else {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(src)}, gpuDataId=${Number(dst)}, size=${Number(size)}`
              );
              const data = module.HEAPU8.subarray(Number(src >>> 0), Number(src >>> 0) + Number(size));
              backend.upload(Number(dst), data);
            }
          },
          // jsepCopyAsync(src, dst, size)
          async (gpuDataId, dataOffset, size) => {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${gpuDataId}, dataOffset=${dataOffset}, size=${size}`
            );
            await backend.download(
              Number(gpuDataId),
              () => module.HEAPU8.subarray(Number(dataOffset) >>> 0, Number(dataOffset + size) >>> 0)
            );
          },
          // jsepCreateKernel
          (kernelType, kernelId, attribute) => backend.createKernel(
            kernelType,
            Number(kernelId),
            attribute,
            module.UTF8ToString(module._JsepGetNodeName(Number(kernelId)))
          ),
          // jsepReleaseKernel
          (kernel) => backend.releaseKernel(kernel),
          // jsepRun
          (kernel, contextDataOffset, sessionHandle, errors) => {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] jsepRun: sessionHandle=${sessionHandle}, kernel=${kernel}, contextDataOffset=${contextDataOffset}`
            );
            const context = new ComputeContextImpl(module, backend, Number(contextDataOffset));
            return backend.computeKernel(Number(kernel), context, errors);
          },
          // jsepCaptureBegin
          () => backend.captureBegin(),
          // jsepCaptureEnd
          () => backend.captureEnd(),
          // jsepReplay
          () => backend.replay()
        ]);
      } else {
        const backend = new WebNNBackend(env3);
        jsepInit("webnn", [
          backend,
          // webnnReserveTensorId
          () => backend.reserveTensorId(),
          // webnnReleaseTensorId
          (tensorId) => backend.releaseTensorId(tensorId),
          // webnnEnsureTensor
          async (sessionId, tensorId, onnxDataType, shape, copyOld) => backend.ensureTensor(sessionId, tensorId, onnxDataType, shape, copyOld),
          // webnnUploadTensor
          (tensorId, data) => {
            backend.uploadTensor(tensorId, data);
          },
          // webnnDownloadTensor
          async (tensorId, dstBuffer) => backend.downloadTensor(tensorId, dstBuffer),
          // webnnRegisterMLContext
          (sessionId, mlContext) => backend.registerMLContext(sessionId, mlContext),
          // webnnEnableTraceEvent
          !!env3.trace
        ]);
      }
    };
  }
});

// web/lib/wasm/wasm-core-impl.ts
var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, getSessionInputOutputMetadata, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
var init_wasm_core_impl = __esm({
  "web/lib/wasm/wasm-core-impl.ts"() {
    "use strict";
    init_esm();
    init_run_options();
    init_session_options();
    init_wasm_common();
    init_wasm_factory();
    init_wasm_utils();
    init_wasm_utils_load_file();
    initOrt = (numThreads, loggingLevel) => {
      const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
      if (errorCode !== 0) {
        checkLastError("Can't initialize onnxruntime.");
      }
    };
    initRuntime = async (env3) => {
      initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
    };
    initEp = async (env3, epName) => {
      getInstance().asyncInit?.();
      let webgpuAdapter = env3.webgpu.adapter;
      if (epName === "webgpu") {
        if (typeof navigator === "undefined" || !navigator.gpu) {
          throw new Error("WebGPU is not supported in current environment");
        }
        if (!webgpuAdapter) {
          const powerPreference = env3.webgpu.powerPreference;
          if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
            throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
          }
          const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
          if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
            throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
          }
          webgpuAdapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
          if (!webgpuAdapter) {
            throw new Error(
              'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
            );
          }
        } else {
          if (typeof webgpuAdapter.limits !== "object" || typeof webgpuAdapter.features !== "object" || typeof webgpuAdapter.requestDevice !== "function") {
            throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
          }
        }
      }
      if (epName === "webnn") {
        if (typeof navigator === "undefined" || !navigator.ml) {
          throw new Error("WebNN is not supported in current environment");
        }
      }
      if (true) {
        const initJsep = (init_init(), __toCommonJS(init_exports)).init;
        if (epName === "webgpu") {
          await initJsep("webgpu", getInstance(), env3, webgpuAdapter);
        }
        if (epName === "webnn") {
          await initJsep("webnn", getInstance(), env3);
        }
      } else {
        if (false) {
          getInstance().webgpuInit((device) => {
            env3.webgpu.device = device;
          });
        }
        if (epName === "webnn") {
          const backend = new null.WebNNBackend(env3);
          getInstance().webnnInit([
            backend,
            // webnnReserveTensorId
            () => backend.reserveTensorId(),
            // webnnReleaseTensorId,
            (tensorId) => backend.releaseTensorId(tensorId),
            // webnnEnsureTensor
            async (sessionId, tensorId, onnxDataType, shape, copyOld) => backend.ensureTensor(sessionId, tensorId, onnxDataType, shape, copyOld),
            // webnnUploadTensor
            (tensorId, data) => {
              backend.uploadTensor(tensorId, data);
            },
            // webnnDownloadTensor
            async (tensorId, dstBuffer) => backend.downloadTensor(tensorId, dstBuffer),
            // webnnRegisterMLContext
            (sessionId, mlContext) => backend.registerMLContext(sessionId, mlContext),
            // webnnEnableTraceEvent
            !!env3.trace
          ]);
        }
      }
    };
    activeSessions = /* @__PURE__ */ new Map();
    getSessionInputOutputCount = (sessionHandle) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      try {
        const ptrSize = wasm2.PTR_SIZE;
        const dataOffset = wasm2.stackAlloc(2 * ptrSize);
        const errorCode = wasm2._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + ptrSize);
        if (errorCode !== 0) {
          checkLastError("Can't get session input/output count.");
        }
        const type = ptrSize === 4 ? "i32" : "i64";
        return [Number(wasm2.getValue(dataOffset, type)), Number(wasm2.getValue(dataOffset + ptrSize, type))];
      } finally {
        wasm2.stackRestore(stack);
      }
    };
    getSessionInputOutputMetadata = (sessionHandle, index) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      let metadataOffset = 0;
      try {
        const ptrSize = wasm2.PTR_SIZE;
        const dataOffset = wasm2.stackAlloc(2 * ptrSize);
        const errorCode = wasm2._OrtGetInputOutputMetadata(sessionHandle, index, dataOffset, dataOffset + ptrSize);
        if (errorCode !== 0) {
          checkLastError("Can't get session input/output metadata.");
        }
        const nameOffset = Number(wasm2.getValue(dataOffset, "*"));
        metadataOffset = Number(wasm2.getValue(dataOffset + ptrSize, "*"));
        const elementType = wasm2.HEAP32[metadataOffset / 4];
        if (elementType === 0) {
          return [nameOffset, 0];
        }
        const dimsCount = wasm2.HEAPU32[metadataOffset / 4 + 1];
        const dims = [];
        for (let i = 0; i < dimsCount; i++) {
          const symbolicDimNameOffset = Number(wasm2.getValue(metadataOffset + 8 + i * ptrSize, "*"));
          dims.push(
            symbolicDimNameOffset !== 0 ? wasm2.UTF8ToString(symbolicDimNameOffset) : Number(wasm2.getValue(metadataOffset + 8 + (i + dimsCount) * ptrSize, "*"))
          );
        }
        return [nameOffset, elementType, dims];
      } finally {
        wasm2.stackRestore(stack);
        if (metadataOffset !== 0) {
          wasm2._OrtFree(metadataOffset);
        }
      }
    };
    copyFromExternalBuffer = (model) => {
      const wasm2 = getInstance();
      const modelDataOffset = wasm2._malloc(model.byteLength);
      if (modelDataOffset === 0) {
        throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
      }
      wasm2.HEAPU8.set(model, modelDataOffset);
      return [modelDataOffset, model.byteLength];
    };
    createSession = async (modelData, options) => {
      let modelDataOffset, modelDataLength;
      const wasm2 = getInstance();
      if (Array.isArray(modelData)) {
        [modelDataOffset, modelDataLength] = modelData;
      } else if (modelData.buffer === wasm2.HEAPU8.buffer) {
        [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
      } else {
        [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
      }
      let sessionHandle = 0;
      let sessionOptionsHandle = 0;
      let ioBindingHandle = 0;
      let allocs = [];
      const inputNamesUTF8Encoded = [];
      const outputNamesUTF8Encoded = [];
      try {
        [sessionOptionsHandle, allocs] = await setSessionOptions(options);
        if (options?.externalData && wasm2.mountExternalData) {
          const loadingPromises = [];
          for (const file of options.externalData) {
            const path = typeof file === "string" ? file : file.path;
            loadingPromises.push(
              loadFile(typeof file === "string" ? file : file.data).then((data) => {
                wasm2.mountExternalData(path, data);
              })
            );
          }
          await Promise.all(loadingPromises);
        }
        for (const provider of options?.executionProviders ?? []) {
          const providerName = typeof provider === "string" ? provider : provider.name;
          if (providerName === "webnn") {
            wasm2.shouldTransferToMLTensor = false;
            if (typeof provider !== "string") {
              const webnnOptions = provider;
              const context = webnnOptions?.context;
              const gpuDevice = webnnOptions?.gpuDevice;
              const deviceType = webnnOptions?.deviceType;
              const powerPreference = webnnOptions?.powerPreference;
              if (context) {
                wasm2.currentContext = context;
              } else if (gpuDevice) {
                wasm2.currentContext = await wasm2.webnnCreateMLContext(gpuDevice);
              } else {
                wasm2.currentContext = await wasm2.webnnCreateMLContext({ deviceType, powerPreference });
              }
            } else {
              wasm2.currentContext = await wasm2.webnnCreateMLContext();
            }
            break;
          }
        }
        sessionHandle = await wasm2._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
        wasm2.webgpuOnCreateSession?.(sessionHandle);
        if (sessionHandle === 0) {
          checkLastError("Can't create a session.");
        }
        wasm2.jsepOnCreateSession?.();
        if (wasm2.currentContext) {
          wasm2.webnnRegisterMLContext(sessionHandle, wasm2.currentContext);
          wasm2.currentContext = void 0;
          wasm2.shouldTransferToMLTensor = true;
        }
        const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
        const enableGraphCapture = !!options?.enableGraphCapture;
        const inputNames = [];
        const outputNames = [];
        const inputMetadata = [];
        const outputMetadata = [];
        const outputPreferredLocations = [];
        for (let i = 0; i < inputCount; i++) {
          const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i);
          if (nameOffset === 0) {
            checkLastError("Can't get an input name.");
          }
          inputNamesUTF8Encoded.push(nameOffset);
          const name = wasm2.UTF8ToString(nameOffset);
          inputNames.push(name);
          inputMetadata.push(
            elementType === 0 ? { name, isTensor: false } : { name, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape }
          );
        }
        for (let i = 0; i < outputCount; i++) {
          const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i + inputCount);
          if (nameOffset === 0) {
            checkLastError("Can't get an output name.");
          }
          outputNamesUTF8Encoded.push(nameOffset);
          const nameString = wasm2.UTF8ToString(nameOffset);
          outputNames.push(nameString);
          outputMetadata.push(
            elementType === 0 ? { name: nameString, isTensor: false } : { name: nameString, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape }
          );
          if (true) {
            if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
              outputPreferredLocations.push("gpu-buffer");
              continue;
            }
            const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
            const isGraphOutput = wasm2.webnnIsGraphOutput;
            if (location2 === "cpu" && isGraphOutput && isGraphOutput(sessionHandle, nameString)) {
              outputPreferredLocations.push("ml-tensor-cpu-output");
              continue;
            }
            if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer" && location2 !== "ml-tensor") {
              throw new Error(`Not supported preferred output location: ${location2}.`);
            }
            if (enableGraphCapture && location2 !== "gpu-buffer") {
              throw new Error(
                `Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`
              );
            }
            outputPreferredLocations.push(location2);
          }
        }
        let bindingState = null;
        if (outputPreferredLocations.some((l) => l === "gpu-buffer" || l === "ml-tensor" || l === "ml-tensor-cpu-output")) {
          ioBindingHandle = wasm2._OrtCreateBinding(sessionHandle);
          if (ioBindingHandle === 0) {
            checkLastError("Can't create IO binding.");
          }
          bindingState = {
            handle: ioBindingHandle,
            outputPreferredLocations,
            outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => l === "ml-tensor-cpu-output" ? "ml-tensor" : l).map((l) => dataLocationStringToEnum(l))
          };
        }
        activeSessions.set(sessionHandle, [
          sessionHandle,
          inputNamesUTF8Encoded,
          outputNamesUTF8Encoded,
          bindingState,
          enableGraphCapture,
          false
        ]);
        return [sessionHandle, inputNames, outputNames, inputMetadata, outputMetadata];
      } catch (e) {
        inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        if (ioBindingHandle !== 0) {
          if (wasm2._OrtReleaseBinding(ioBindingHandle) !== 0) {
            checkLastError("Can't release IO binding.");
          }
        }
        if (sessionHandle !== 0) {
          if (wasm2._OrtReleaseSession(sessionHandle) !== 0) {
            checkLastError("Can't release session.");
          }
        }
        throw e;
      } finally {
        wasm2._free(modelDataOffset);
        if (sessionOptionsHandle !== 0) {
          if (wasm2._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {
            checkLastError("Can't release session options.");
          }
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        wasm2.unmountExternalData?.();
      }
    };
    releaseSession = (sessionId) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot release session. invalid session id: ${sessionId}`);
      }
      const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
      if (ioBindingState) {
        if (enableGraphCapture) {
          if (wasm2._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {
            checkLastError("Can't clear bound outputs.");
          }
        }
        if (wasm2._OrtReleaseBinding(ioBindingState.handle) !== 0) {
          checkLastError("Can't release IO binding.");
        }
      }
      wasm2.jsepOnReleaseSession?.(sessionId);
      wasm2.webnnOnReleaseSession?.(sessionId);
      wasm2.webgpuOnReleaseSession?.(sessionId);
      inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
      outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
      if (wasm2._OrtReleaseSession(sessionHandle) !== 0) {
        checkLastError("Can't release session.");
      }
      activeSessions.delete(sessionId);
    };
    prepareInputOutputTensor = async (tensor, tensorHandles, allocs, sessionId, tensorNameUTF8Encoded, index, enableGraphCapture = false) => {
      if (!tensor) {
        tensorHandles.push(0);
        return;
      }
      const wasm2 = getInstance();
      const ptrSize = wasm2.PTR_SIZE;
      const dataType = tensor[0];
      const dims = tensor[1];
      const location2 = tensor[3];
      let actualLocation = location2;
      let rawData;
      let dataByteLength;
      if (dataType === "string" && (location2 === "gpu-buffer" || location2 === "ml-tensor")) {
        throw new Error("String tensor is not supported on GPU.");
      }
      if (enableGraphCapture && location2 !== "gpu-buffer") {
        throw new Error(
          `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
        );
      }
      if (location2 === "gpu-buffer") {
        const gpuBuffer = tensor[2].gpuBuffer;
        dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
        if (false) {
          const registerBuffer = wasm2.webgpuRegisterBuffer;
          if (!registerBuffer) {
            throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
          }
          rawData = registerBuffer(gpuBuffer, sessionId);
        } else {
          const registerBuffer = wasm2.jsepRegisterBuffer;
          if (!registerBuffer) {
            throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
          }
          rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
        }
      } else if (location2 === "ml-tensor") {
        const mlTensor = tensor[2].mlTensor;
        dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
        const registerMLTensor = wasm2.webnnRegisterMLTensor;
        if (!registerMLTensor) {
          throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
        }
        rawData = registerMLTensor(sessionId, mlTensor, tensorDataTypeStringToEnum(dataType), dims);
      } else {
        const data = tensor[2];
        if (Array.isArray(data)) {
          dataByteLength = ptrSize * data.length;
          rawData = wasm2._malloc(dataByteLength);
          allocs.push(rawData);
          for (let i = 0; i < data.length; i++) {
            if (typeof data[i] !== "string") {
              throw new TypeError(`tensor data at index ${i} is not a string`);
            }
            wasm2.setValue(rawData + i * ptrSize, allocWasmString(data[i], allocs), "*");
          }
        } else {
          const isGraphInput = wasm2.webnnIsGraphInput;
          const isGraphOutput = wasm2.webnnIsGraphOutput;
          if (dataType !== "string" && isGraphInput && isGraphOutput) {
            const tensorName = wasm2.UTF8ToString(tensorNameUTF8Encoded);
            if (isGraphInput(sessionId, tensorName) || isGraphOutput(sessionId, tensorName)) {
              const dataTypeEnum = tensorDataTypeStringToEnum(dataType);
              dataByteLength = calculateTensorSizeInBytes(dataTypeEnum, dims);
              actualLocation = "ml-tensor";
              const createTemporaryTensor = wasm2.webnnCreateTemporaryTensor;
              const uploadTensor = wasm2.webnnUploadTensor;
              if (!createTemporaryTensor || !uploadTensor) {
                throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');
              }
              const tensorId = await createTemporaryTensor(sessionId, dataTypeEnum, dims);
              uploadTensor(tensorId, new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
              rawData = tensorId;
            } else {
              dataByteLength = data.byteLength;
              rawData = wasm2._malloc(dataByteLength);
              allocs.push(rawData);
              wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
            }
          } else {
            dataByteLength = data.byteLength;
            rawData = wasm2._malloc(dataByteLength);
            allocs.push(rawData);
            wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
          }
        }
      }
      const stack = wasm2.stackSave();
      const dimsOffset = wasm2.stackAlloc(4 * dims.length);
      try {
        dims.forEach((d, index2) => wasm2.setValue(dimsOffset + index2 * ptrSize, d, ptrSize === 4 ? "i32" : "i64"));
        const tensor2 = wasm2._OrtCreateTensor(
          tensorDataTypeStringToEnum(dataType),
          rawData,
          dataByteLength,
          dimsOffset,
          dims.length,
          dataLocationStringToEnum(actualLocation)
        );
        if (tensor2 === 0) {
          checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
        }
        tensorHandles.push(tensor2);
      } finally {
        wasm2.stackRestore(stack);
      }
    };
    run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
      const wasm2 = getInstance();
      const ptrSize = wasm2.PTR_SIZE;
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
      }
      const sessionHandle = session[0];
      const inputNamesUTF8Encoded = session[1];
      const outputNamesUTF8Encoded = session[2];
      const ioBindingState = session[3];
      const enableGraphCapture = session[4];
      const inputOutputBound = session[5];
      const inputCount = inputIndices.length;
      const outputCount = outputIndices.length;
      let runOptionsHandle = 0;
      let runOptionsAllocs = [];
      const inputTensorHandles = [];
      const outputTensorHandles = [];
      const inputOutputAllocs = [];
      const beforeRunStack = wasm2.stackSave();
      const inputValuesOffset = wasm2.stackAlloc(inputCount * ptrSize);
      const inputNamesOffset = wasm2.stackAlloc(inputCount * ptrSize);
      const outputValuesOffset = wasm2.stackAlloc(outputCount * ptrSize);
      const outputNamesOffset = wasm2.stackAlloc(outputCount * ptrSize);
      try {
        [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
        TRACE_EVENT_BEGIN("wasm prepareInputOutputTensor");
        for (let i = 0; i < inputCount; i++) {
          await prepareInputOutputTensor(
            inputTensors[i],
            inputTensorHandles,
            inputOutputAllocs,
            sessionId,
            inputNamesUTF8Encoded[inputIndices[i]],
            inputIndices[i],
            enableGraphCapture
          );
        }
        for (let i = 0; i < outputCount; i++) {
          await prepareInputOutputTensor(
            outputTensors[i],
            outputTensorHandles,
            inputOutputAllocs,
            sessionId,
            outputNamesUTF8Encoded[outputIndices[i]],
            inputCount + outputIndices[i],
            enableGraphCapture
          );
        }
        TRACE_EVENT_END("wasm prepareInputOutputTensor");
        for (let i = 0; i < inputCount; i++) {
          wasm2.setValue(inputValuesOffset + i * ptrSize, inputTensorHandles[i], "*");
          wasm2.setValue(inputNamesOffset + i * ptrSize, inputNamesUTF8Encoded[inputIndices[i]], "*");
        }
        for (let i = 0; i < outputCount; i++) {
          wasm2.setValue(outputValuesOffset + i * ptrSize, outputTensorHandles[i], "*");
          wasm2.setValue(outputNamesOffset + i * ptrSize, outputNamesUTF8Encoded[outputIndices[i]], "*");
        }
        if (ioBindingState && !inputOutputBound) {
          const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
          if (inputNamesUTF8Encoded.length !== inputCount) {
            throw new Error(
              `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`
            );
          }
          TRACE_EVENT_BEGIN("wasm bindInputsOutputs");
          for (let i = 0; i < inputCount; i++) {
            const index = inputIndices[i];
            const errorCode2 = await wasm2._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
            if (errorCode2 !== 0) {
              checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
            }
          }
          for (let i = 0; i < outputCount; i++) {
            const index = outputIndices[i];
            const location2 = outputTensors[i]?.[3];
            if (location2) {
              const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
              }
            } else {
              const errorCode2 = wasm2._OrtBindOutput(
                handle,
                outputNamesUTF8Encoded[index],
                0,
                outputPreferredLocationsEncoded[index]
              );
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
              }
            }
          }
          TRACE_EVENT_END("wasm bindInputsOutputs");
          activeSessions.set(sessionId, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            ioBindingState,
            enableGraphCapture,
            true
          ]);
        }
        wasm2.jsepOnRunStart?.(sessionHandle);
        wasm2.webnnOnRunStart?.(sessionHandle);
        let errorCode;
        if (ioBindingState) {
          errorCode = await wasm2._OrtRunWithBinding(
            sessionHandle,
            ioBindingState.handle,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        } else {
          errorCode = await wasm2._OrtRun(
            sessionHandle,
            inputNamesOffset,
            inputValuesOffset,
            inputCount,
            outputNamesOffset,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        }
        if (errorCode !== 0) {
          checkLastError("failed to call OrtRun().");
        }
        const output = [];
        const outputPromises = [];
        TRACE_EVENT_BEGIN("wasm ProcessOutputTensor");
        for (let i = 0; i < outputCount; i++) {
          const tensor = Number(wasm2.getValue(outputValuesOffset + i * ptrSize, "*"));
          if (tensor === outputTensorHandles[i]) {
            output.push(outputTensors[i]);
            continue;
          }
          const beforeGetTensorDataStack = wasm2.stackSave();
          const tensorDataOffset = wasm2.stackAlloc(4 * ptrSize);
          let keepOutputTensor = false;
          let type, dataOffset = 0;
          try {
            const errorCode2 = wasm2._OrtGetTensorData(
              tensor,
              tensorDataOffset,
              tensorDataOffset + ptrSize,
              tensorDataOffset + 2 * ptrSize,
              tensorDataOffset + 3 * ptrSize
            );
            if (errorCode2 !== 0) {
              checkLastError(`Can't access output tensor data on index ${i}.`);
            }
            const valueType = ptrSize === 4 ? "i32" : "i64";
            const dataType = Number(wasm2.getValue(tensorDataOffset, valueType));
            dataOffset = wasm2.getValue(tensorDataOffset + ptrSize, "*");
            const dimsOffset = wasm2.getValue(tensorDataOffset + ptrSize * 2, "*");
            const dimsLength = Number(wasm2.getValue(tensorDataOffset + ptrSize * 3, valueType));
            const dims = [];
            for (let i2 = 0; i2 < dimsLength; i2++) {
              dims.push(Number(wasm2.getValue(dimsOffset + i2 * ptrSize, valueType)));
            }
            if (wasm2._OrtFree(dimsOffset) !== 0) {
              checkLastError("Can't free memory for tensor dims.");
            }
            const size = dims.reduce((a, b) => a * b, 1);
            type = tensorDataTypeEnumToString(dataType);
            const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
            if (type === "string") {
              if (preferredLocation === "gpu-buffer" || preferredLocation === "ml-tensor") {
                throw new Error("String tensor is not supported on GPU.");
              }
              const stringData = [];
              for (let i2 = 0; i2 < size; i2++) {
                const offset = wasm2.getValue(dataOffset + i2 * ptrSize, "*");
                const nextOffset = wasm2.getValue(dataOffset + (i2 + 1) * ptrSize, "*");
                const maxBytesToRead = i2 === size - 1 ? void 0 : nextOffset - offset;
                stringData.push(wasm2.UTF8ToString(offset, maxBytesToRead));
              }
              output.push([type, dims, stringData, "cpu"]);
            } else {
              if (preferredLocation === "gpu-buffer" && size > 0) {
                const getBuffer = false ? wasm2.webgpuGetBuffer : wasm2.jsepGetBuffer;
                if (!getBuffer) {
                  throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                }
                const gpuBuffer = getBuffer(dataOffset);
                const bufferSize = calculateTensorSizeInBytes(dataType, size);
                if (bufferSize === void 0 || !isGpuBufferSupportedType(type)) {
                  throw new Error(`Unsupported data type: ${type}`);
                }
                keepOutputTensor = true;
                if (false) {
                  wasm2.webgpuRegisterBuffer(gpuBuffer, sessionId, dataOffset);
                  const downloadDataFunction = wasm2.webgpuCreateDownloader(gpuBuffer, bufferSize, sessionId);
                  output.push([
                    type,
                    dims,
                    {
                      gpuBuffer,
                      download: async () => {
                        const arrayBuffer = await downloadDataFunction();
                        const data = new (tensorTypeToTypedArrayConstructor(type))(arrayBuffer);
                        return data;
                      },
                      dispose: () => {
                        if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                          checkLastError("Can't release tensor.");
                        }
                      }
                    },
                    "gpu-buffer"
                  ]);
                } else {
                  output.push([
                    type,
                    dims,
                    {
                      gpuBuffer,
                      download: wasm2.jsepCreateDownloader(gpuBuffer, bufferSize, type),
                      dispose: () => {
                        if (wasm2._OrtReleaseTensor(tensor) !== 0) {
                          checkLastError("Can't release tensor.");
                        }
                      }
                    },
                    "gpu-buffer"
                  ]);
                }
              } else if (preferredLocation === "ml-tensor" && size > 0) {
                const ensureTensor = wasm2.webnnEnsureTensor;
                const isGraphInputOutputTypeSupported = wasm2.webnnIsGraphInputOutputTypeSupported;
                if (!ensureTensor || !isGraphInputOutputTypeSupported) {
                  throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');
                }
                const tensorSize = calculateTensorSizeInBytes(dataType, size);
                if (tensorSize === void 0 || !isMLTensorSupportedType(type)) {
                  throw new Error(`Unsupported data type: ${type}`);
                }
                if (!isGraphInputOutputTypeSupported(sessionId, type, false)) {
                  throw new Error(
                    `preferredLocation "ml-tensor" for ${type} output is not supported by current WebNN Context.`
                  );
                }
                const mlTensor = await ensureTensor(sessionId, dataOffset, dataType, dims, false);
                keepOutputTensor = true;
                output.push([
                  type,
                  dims,
                  {
                    mlTensor,
                    download: wasm2.webnnCreateMLTensorDownloader(dataOffset, type),
                    dispose: () => {
                      wasm2.webnnReleaseTensorId(dataOffset);
                      wasm2._OrtReleaseTensor(tensor);
                    }
                  },
                  "ml-tensor"
                ]);
              } else if (preferredLocation === "ml-tensor-cpu-output" && size > 0) {
                const data = wasm2.webnnCreateMLTensorDownloader(dataOffset, type)();
                const index = output.length;
                keepOutputTensor = true;
                outputPromises.push(
                  (async () => {
                    const result = [index, await data];
                    wasm2.webnnReleaseTensorId(dataOffset);
                    wasm2._OrtReleaseTensor(tensor);
                    return result;
                  })()
                );
                output.push([type, dims, [], "cpu"]);
              } else {
                const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                const data = new typedArrayConstructor(size);
                new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(
                  wasm2.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength)
                );
                output.push([type, dims, data, "cpu"]);
              }
            }
          } finally {
            wasm2.stackRestore(beforeGetTensorDataStack);
            if (type === "string" && dataOffset) {
              wasm2._free(dataOffset);
            }
            if (!keepOutputTensor) {
              wasm2._OrtReleaseTensor(tensor);
            }
          }
        }
        if (ioBindingState && !enableGraphCapture) {
          if (wasm2._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {
            checkLastError("Can't clear bound outputs.");
          }
          activeSessions.set(sessionId, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            ioBindingState,
            enableGraphCapture,
            false
          ]);
        }
        for (const [index, data] of await Promise.all(outputPromises)) {
          output[index][2] = data;
        }
        TRACE_EVENT_END("wasm ProcessOutputTensor");
        return output;
      } finally {
        wasm2.webnnOnRunEnd?.(sessionHandle);
        wasm2.stackRestore(beforeRunStack);
        if (false) {
          inputTensors.forEach((t) => {
            if (t && t[3] === "gpu-buffer") {
              wasm2.webgpuUnregisterBuffer(t[2].gpuBuffer);
            }
          });
          outputTensors.forEach((t) => {
            if (t && t[3] === "gpu-buffer") {
              wasm2.webgpuUnregisterBuffer(t[2].gpuBuffer);
            }
          });
        }
        inputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
        outputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
        inputOutputAllocs.forEach((p) => wasm2._free(p));
        if (runOptionsHandle !== 0) {
          wasm2._OrtReleaseRunOptions(runOptionsHandle);
        }
        runOptionsAllocs.forEach((p) => wasm2._free(p));
      }
    };
    endProfiling = (sessionId) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error("invalid session id");
      }
      const sessionHandle = session[0];
      const profileFileName = wasm2._OrtEndProfiling(sessionHandle);
      if (profileFileName === 0) {
        checkLastError("Can't get an profile file name.");
      }
      wasm2._OrtFree(profileFileName);
    };
    extractTransferableBuffers = (tensors) => {
      const buffers = [];
      for (const tensor of tensors) {
        const data = tensor[2];
        if (!Array.isArray(data) && "buffer" in data) {
          buffers.push(data.buffer);
        }
      }
      return buffers;
    };
  }
});

// web/lib/wasm/proxy-wrapper.ts
var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
var init_proxy_wrapper = __esm({
  "web/lib/wasm/proxy-wrapper.ts"() {
    "use strict";
    init_esm();
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
    initializing2 = false;
    initialized2 = false;
    aborted2 = false;
    queuedCallbacks = /* @__PURE__ */ new Map();
    enqueueCallbacks = (type, callbacks) => {
      const queue = queuedCallbacks.get(type);
      if (queue) {
        queue.push(callbacks);
      } else {
        queuedCallbacks.set(type, [callbacks]);
      }
    };
    ensureWorker = () => {
      if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
        throw new Error("worker not ready");
      }
    };
    onProxyWorkerMessage = (ev) => {
      switch (ev.data.type) {
        case "init-wasm":
          initializing2 = false;
          if (ev.data.err) {
            aborted2 = true;
            initWasmCallbacks[1](ev.data.err);
          } else {
            initialized2 = true;
            initWasmCallbacks[0]();
          }
          if (temporaryObjectUrl) {
            URL.revokeObjectURL(temporaryObjectUrl);
            temporaryObjectUrl = void 0;
          }
          break;
        case "init-ep":
        case "copy-from":
        case "create":
        case "release":
        case "run":
        case "end-profiling": {
          const callbacks = queuedCallbacks.get(ev.data.type);
          if (ev.data.err) {
            callbacks.shift()[1](ev.data.err);
          } else {
            callbacks.shift()[0](ev.data.out);
          }
          break;
        }
        default:
      }
    };
    initializeWebAssemblyAndOrtRuntime = async () => {
      if (initialized2) {
        return;
      }
      if (initializing2) {
        throw new Error("multiple calls to 'initWasm()' detected.");
      }
      if (aborted2) {
        throw new Error("previous call to 'initWasm()' failed.");
      }
      initializing2 = true;
      if (isProxy()) {
        return new Promise((resolve, reject) => {
          proxyWorker?.terminate();
          void importProxyWorker().then(([objectUrl, worker]) => {
            try {
              proxyWorker = worker;
              proxyWorker.onerror = (ev) => reject(ev);
              proxyWorker.onmessage = onProxyWorkerMessage;
              initWasmCallbacks = [resolve, reject];
              const message = { type: "init-wasm", in: env2 };
              if (!message.in.wasm.wasmPaths && objectUrl) {
                const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();
                if (inferredWasmPathPrefix) {
                  message.in.wasm.wasmPaths = inferredWasmPathPrefix;
                }
              }
              if (false) {
                message.in.wasm.wasmPaths = {
                  wasm: true ? new URL("ort-wasm-simd-threaded.jsep.wasm", import.meta.url).href : false ? new URL("ort-wasm-simd-threaded.asyncify.wasm", import.meta.url).href : new URL("ort-wasm-simd-threaded.wasm", import.meta.url).href
                };
              }
              proxyWorker.postMessage(message);
              temporaryObjectUrl = objectUrl;
            } catch (e) {
              reject(e);
            }
          }, reject);
        });
      } else {
        try {
          await initializeWebAssembly(env2.wasm);
          await initRuntime(env2);
          initialized2 = true;
        } catch (e) {
          aborted2 = true;
          throw e;
        } finally {
          initializing2 = false;
        }
      }
    };
    initializeOrtEp = async (epName) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("init-ep", [resolve, reject]);
          const message = { type: "init-ep", in: { epName, env: env2 } };
          proxyWorker.postMessage(message);
        });
      } else {
        await initEp(env2, epName);
      }
    };
    copyFromExternalBuffer2 = async (buffer) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("copy-from", [resolve, reject]);
          const message = { type: "copy-from", in: { buffer } };
          proxyWorker.postMessage(message, [buffer.buffer]);
        });
      } else {
        return copyFromExternalBuffer(buffer);
      }
    };
    createSession2 = async (model, options) => {
      if (isProxy()) {
        if (options?.preferredOutputLocation) {
          throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("create", [resolve, reject]);
          const message = { type: "create", in: { model, options: { ...options } } };
          const transferable = [];
          if (model instanceof Uint8Array) {
            transferable.push(model.buffer);
          }
          proxyWorker.postMessage(message, transferable);
        });
      } else {
        return createSession(model, options);
      }
    };
    releaseSession2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("release", [resolve, reject]);
          const message = { type: "release", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        releaseSession(sessionId);
      }
    };
    run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
      if (isProxy()) {
        if (inputs.some((t) => t[3] !== "cpu")) {
          throw new Error("input tensor on GPU is not supported for proxy.");
        }
        if (outputs.some((t) => t)) {
          throw new Error("pre-allocated output tensor is not supported for proxy.");
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("run", [resolve, reject]);
          const serializableInputs = inputs;
          const message = {
            type: "run",
            in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options }
          };
          proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
        });
      } else {
        return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
      }
    };
    endProfiling2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("end-profiling", [resolve, reject]);
          const message = { type: "end-profiling", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        endProfiling(sessionId);
      }
    };
  }
});

// web/lib/wasm/session-handler-inference.ts
var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
var init_session_handler_inference = __esm({
  "web/lib/wasm/session-handler-inference.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_wasm_common();
    init_wasm_utils_env();
    init_wasm_utils_load_file();
    encodeTensorMetadata = (tensor, getName) => {
      switch (tensor.location) {
        case "cpu":
          return [tensor.type, tensor.dims, tensor.data, "cpu"];
        case "gpu-buffer":
          return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
        case "ml-tensor":
          return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, "ml-tensor"];
        default:
          throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
      }
    };
    decodeTensorMetadata = (tensor) => {
      switch (tensor[3]) {
        case "cpu":
          return new Tensor2(tensor[0], tensor[2], tensor[1]);
        case "gpu-buffer": {
          const dataType = tensor[0];
          if (!isGpuBufferSupportedType(dataType)) {
            throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
          }
          const { gpuBuffer, download, dispose } = tensor[2];
          return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
        }
        case "ml-tensor": {
          const dataType = tensor[0];
          if (!isMLTensorSupportedType(dataType)) {
            throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);
          }
          const { mlTensor, download, dispose } = tensor[2];
          return Tensor2.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });
        }
        default:
          throw new Error(`invalid data location: ${tensor[3]}`);
      }
    };
    OnnxruntimeWebAssemblySessionHandler = class {
      async fetchModelAndCopyToWasmMemory(path) {
        return copyFromExternalBuffer2(await loadFile(path));
      }
      async loadModel(pathOrBuffer, options) {
        TRACE_FUNC_BEGIN();
        let model;
        if (typeof pathOrBuffer === "string") {
          if (isNode) {
            model = await loadFile(pathOrBuffer);
          } else {
            model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
          }
        } else {
          model = pathOrBuffer;
        }
        [this.sessionId, this.inputNames, this.outputNames, this.inputMetadata, this.outputMetadata] = await createSession2(
          model,
          options
        );
        TRACE_FUNC_END();
      }
      async dispose() {
        return releaseSession2(this.sessionId);
      }
      async run(feeds, fetches, options) {
        TRACE_FUNC_BEGIN();
        const inputArray = [];
        const inputIndices = [];
        Object.entries(feeds).forEach((kvp) => {
          const name = kvp[0];
          const tensor = kvp[1];
          const index = this.inputNames.indexOf(name);
          if (index === -1) {
            throw new Error(`invalid input '${name}'`);
          }
          inputArray.push(tensor);
          inputIndices.push(index);
        });
        const outputArray = [];
        const outputIndices = [];
        Object.entries(fetches).forEach((kvp) => {
          const name = kvp[0];
          const tensor = kvp[1];
          const index = this.outputNames.indexOf(name);
          if (index === -1) {
            throw new Error(`invalid output '${name}'`);
          }
          outputArray.push(tensor);
          outputIndices.push(index);
        });
        const inputs = inputArray.map(
          (t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`)
        );
        const outputs = outputArray.map(
          (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
        );
        const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
        const resultMap = {};
        for (let i = 0; i < results.length; i++) {
          resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
        }
        TRACE_FUNC_END();
        return resultMap;
      }
      startProfiling() {
      }
      endProfiling() {
        void endProfiling2(this.sessionId);
      }
    };
  }
});

// web/lib/backend-wasm.ts
var backend_wasm_exports = {};
__export(backend_wasm_exports, {
  OnnxruntimeWebAssemblyBackend: () => OnnxruntimeWebAssemblyBackend,
  initializeFlags: () => initializeFlags,
  wasmBackend: () => wasmBackend
});
var initializeFlags, OnnxruntimeWebAssemblyBackend, wasmBackend;
var init_backend_wasm = __esm({
  "web/lib/backend-wasm.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_session_handler_inference();
    initializeFlags = () => {
      if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
        env2.wasm.initTimeout = 0;
      }
      const simd = env2.wasm.simd;
      if (typeof simd !== "boolean" && simd !== void 0 && simd !== "fixed" && simd !== "relaxed") {
        console.warn(
          `Property "env.wasm.simd" is set to unknown value "${simd}". Reset it to \`false\` and ignore SIMD feature checking.`
        );
        env2.wasm.simd = false;
      }
      if (typeof env2.wasm.proxy !== "boolean") {
        env2.wasm.proxy = false;
      }
      if (typeof env2.wasm.trace !== "boolean") {
        env2.wasm.trace = false;
      }
      if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          env2.wasm.numThreads = 1;
        } else {
          const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
          env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
        }
      }
    };
    OnnxruntimeWebAssemblyBackend = class {
      /**
       * This function initializes the WebAssembly backend.
       *
       * This function will be called only once for each backend name. It will be called the first time when
       * `ort.InferenceSession.create()` is called with a registered backend name.
       *
       * @param backendName - the registered backend name.
       */
      async init(backendName) {
        initializeFlags();
        await initializeWebAssemblyAndOrtRuntime();
        await initializeOrtEp(backendName);
      }
      async createInferenceSessionHandler(pathOrBuffer, options) {
        const handler = new OnnxruntimeWebAssemblySessionHandler();
        await handler.loadModel(pathOrBuffer, options);
        return handler;
      }
    };
    wasmBackend = new OnnxruntimeWebAssemblyBackend();
  }
});

// web/lib/index.ts
init_esm();
init_esm();
init_esm();

// web/lib/version.ts
var version2 = "1.23.0";

// web/lib/index.ts
var index_default = esm_exports;
if (false) {
  const onnxjsBackend = null.onnxjsBackend;
  registerBackend("webgl", onnxjsBackend, -10);
}
if (false) {
  throw new Error(
    "The current build is specified to enable both JSEP and WebGPU EP. This is not a valid configuration. JSEP and WebGPU EPs cannot be enabled at the same time."
  );
}
if (false) {
  throw new Error(
    "The current build is specified to enable WebNN EP without JSEP or WebGPU EP. This is not a valid configuration. WebNN EP requires either JSEP or WebGPU EP to be enabled."
  );
}
if (true) {
  const wasmBackend2 = (init_backend_wasm(), __toCommonJS(backend_wasm_exports)).wasmBackend;
  if (true) {
    registerBackend("webgpu", wasmBackend2, 5);
  }
  if (true) {
    registerBackend("webnn", wasmBackend2, 5);
  }
  registerBackend("cpu", wasmBackend2, 10);
  registerBackend("wasm", wasmBackend2, 10);
}
Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
export {
  InferenceSession2 as InferenceSession,
  TRACE,
  TRACE_EVENT_BEGIN,
  TRACE_EVENT_END,
  TRACE_FUNC_BEGIN,
  TRACE_FUNC_END,
  Tensor2 as Tensor,
  index_default as default,
  env2 as env,
  registerBackend
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmRleC50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWVudi50cyIsICIuLi9saWIvd2FzbS9wcm94eS13b3JrZXIvbWFpbi50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50cyIsICIuLi9saWIvd2FzbS93YXNtLWZhY3RvcnkudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy50cyIsICIuLi9saWIvd2FzbS9ydW4tb3B0aW9ucy50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb21tb24udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1sb2FkLWZpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC9sb2cudHMiLCAiLi4vbGliL3dhc20vanNlcC91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvdGVuc29yLXZpZXcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJubi90ZW5zb3ItbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL2JhY2tlbmQtd2Vibm4udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvdHlwZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvZ3B1LWRhdGEtbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXkudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbW1vbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2Utc2hhcmVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZWR1Y2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2FyZ21pbm1heC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYXR0ZW50aW9uLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iYXRjaC1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iaWFzLWFkZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdW5hcnktb3AudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2JpYXMtc3BsaXQtZ2VsdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmluYXJ5LW9wLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb25jYXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2Z1c2UtdXRpbHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9hY3RpdmF0aW9uX3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252X3V0aWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL21hdG11bC1zaGFkZXJzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252MmRfbW1fd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udjNkX25haXZlX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb252LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl9iYWNrcHJvcF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbnYtdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jdW1zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2RlcHRoLXRvLXNwYWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9laW5zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2V4cGFuZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZmFzdC1nZWx1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXIudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dhdGhlci1uZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLWJsb2NrLXF1YW50aXplZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLWVsZW1lbnRzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nZW1tLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9ncmlkLXNhbXBsZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbXVsdGloZWFkLWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc3BsaXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3JvdGFyeS1lbWJlZGRpbmcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvaW5zdGFuY2Utbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbWF0bXVsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9tYXRtdWxuYml0cy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcGFkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9wb29sLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9xdWFudGl6ZS1saW5lYXIudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3JhbmdlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zY2F0dGVyLW5kLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yZXNpemUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NraXAtbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc2xpY2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NvZnRtYXgudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3doZXJlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wLXJlc29sdmUtcnVsZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvcHJvZ3JhbS1tYW5hZ2VyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvYmFja2VuZC13ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC9pbml0LnRzIiwgIi4uL2xpYi93YXNtL3dhc20tY29yZS1pbXBsLnRzIiwgIi4uL2xpYi93YXNtL3Byb3h5LXdyYXBwZXIudHMiLCAiLi4vbGliL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZS50cyIsICIuLi9saWIvYmFja2VuZC13YXNtLnRzIiwgIi4uL2xpYi9pbmRleC50cyIsICIuLi9saWIvdmVyc2lvbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IEJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQuanMnO1xyXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XHJcblxyXG5pbnRlcmZhY2UgQmFja2VuZEluZm8ge1xyXG4gIGJhY2tlbmQ6IEJhY2tlbmQ7XHJcbiAgcHJpb3JpdHk6IG51bWJlcjtcclxuXHJcbiAgaW5pdFByb21pc2U/OiBQcm9taXNlPHZvaWQ+O1xyXG4gIGluaXRpYWxpemVkPzogYm9vbGVhbjtcclxuICBhYm9ydGVkPzogYm9vbGVhbjtcclxuICBlcnJvcj86IHN0cmluZztcclxufVxyXG5cclxuY29uc3QgYmFja2VuZHM6IE1hcDxzdHJpbmcsIEJhY2tlbmRJbmZvPiA9IG5ldyBNYXAoKTtcclxuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5OiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cclxuICpcclxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBhcyBhIGtleSB0byBsb29rdXAgYXMgYW4gZXhlY3V0aW9uIHByb3ZpZGVyLlxyXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cclxuICogQHBhcmFtIHByaW9yaXR5IC0gYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBwcmlvcml0eSBvZiB0aGUgYmFja2VuZC4gSGlnaGVyIG51bWJlciBtZWFucyBoaWdoZXIgcHJpb3JpdHkuIGlmIHByaW9yaXR5XHJcbiAqIDwgMCwgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgJ2JldGEnIHZlcnNpb24gYW5kIHdpbGwgbm90IGJlIHVzZWQgYXMgYSBmYWxsYmFjayBiYWNrZW5kIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBjb25zdCByZWdpc3RlckJhY2tlbmQgPSAobmFtZTogc3RyaW5nLCBiYWNrZW5kOiBCYWNrZW5kLCBwcmlvcml0eTogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgaWYgKGJhY2tlbmQgJiYgdHlwZW9mIGJhY2tlbmQuaW5pdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYmFja2VuZC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoY3VycmVudEJhY2tlbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBiYWNrZW5kcy5zZXQobmFtZSwgeyBiYWNrZW5kLCBwcmlvcml0eSB9KTtcclxuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xyXG4gICAgICAvLyBzYW1lIG5hbWUgaXMgYWxyZWFkeSByZWdpc3RlcmVkIHdpdGggYSBoaWdoZXIgcHJpb3JpdHkuIHNraXAgcmVnaXN0ZXJhdGlvbi5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcclxuICAgICAgaWYgKGN1cnJlbnRCYWNrZW5kLmJhY2tlbmQgIT09IGJhY2tlbmQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtuYW1lfVwiIHVzaW5nIHByaW9yaXR5ICR7cHJpb3JpdHl9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xyXG4gICAgICBjb25zdCBpID0gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LmluZGV4T2YobmFtZSk7XHJcbiAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGJhY2tlbmRzLmdldChiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHlbaV0pIS5wcmlvcml0eSA8PSBwcmlvcml0eSkge1xyXG4gICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAwLCBuYW1lKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSB2YWxpZCBiYWNrZW5kJyk7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYSBiYWNrZW5kLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmFja2VuZE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYmFja2VuZC5cclxuICogQHJldHVybnMgdGhlIGJhY2tlbmQgaW5zdGFuY2UgaWYgcmVzb2x2ZWQgYW5kIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBmYWlsZWQuXHJcbiAqL1xyXG5jb25zdCB0cnlSZXNvbHZlQW5kSW5pdGlhbGl6ZUJhY2tlbmQgPSBhc3luYyAoYmFja2VuZE5hbWU6IHN0cmluZyk6IFByb21pc2U8QmFja2VuZCB8IHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHMuZ2V0KGJhY2tlbmROYW1lKTtcclxuICBpZiAoIWJhY2tlbmRJbmZvKSB7XHJcbiAgICByZXR1cm4gJ2JhY2tlbmQgbm90IGZvdW5kLic7XHJcbiAgfVxyXG5cclxuICBpZiAoYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQpIHtcclxuICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xyXG4gIH0gZWxzZSBpZiAoYmFja2VuZEluZm8uYWJvcnRlZCkge1xyXG4gICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgaXNJbml0aWFsaXppbmcgPSAhIWJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xyXG4gICAgICAgIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlID0gYmFja2VuZEluZm8uYmFja2VuZC5pbml0KGJhY2tlbmROYW1lKTtcclxuICAgICAgfVxyXG4gICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcclxuICAgICAgYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xyXG4gICAgICAgIGJhY2tlbmRJbmZvLmVycm9yID0gYCR7ZX1gO1xyXG4gICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5lcnJvciE7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBkZWxldGUgYmFja2VuZEluZm8uaW5pdFByb21pc2U7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlc29sdmUgZXhlY3V0aW9uIHByb3ZpZGVycyBmcm9tIHRoZSBzcGVjaWZpYyBzZXNzaW9uIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXHJcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgYW4gaW5pdGlhbGl6ZWQgYmFja2VuZCBpbnN0YW5jZSBhbmQgYSBzZXNzaW9uIG9wdGlvbnMgb2JqZWN0IHdpdGhcclxuICogZmlsdGVyZWQgRVAgbGlzdC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMgKFxyXG4gIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXHJcbik6IFByb21pc2U8W2JhY2tlbmQ6IEJhY2tlbmQsIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnNdPiA9PiB7XHJcbiAgLy8gZXh0cmFjdCBiYWNrZW5kIGhpbnRzIGZyb20gc2Vzc2lvbiBvcHRpb25zXHJcbiAgY29uc3QgZXBzID0gb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgfHwgW107XHJcbiAgY29uc3QgYmFja2VuZEhpbnRzID0gZXBzLm1hcCgoaSkgPT4gKHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpKTtcclxuICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xyXG5cclxuICAvLyB0cnkgdG8gcmVzb2x2ZSBhbmQgaW5pdGlhbGl6ZSBhbGwgcmVxdWVzdGVkIGJhY2tlbmRzXHJcbiAgbGV0IGJhY2tlbmQ6IEJhY2tlbmQgfCB1bmRlZmluZWQ7XHJcbiAgY29uc3QgZXJyb3JzID0gW107XHJcbiAgY29uc3QgYXZhaWxhYmxlQmFja2VuZE5hbWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcclxuICAgIGNvbnN0IHJlc29sdmVSZXN1bHQgPSBhd2FpdCB0cnlSZXNvbHZlQW5kSW5pdGlhbGl6ZUJhY2tlbmQoYmFja2VuZE5hbWUpO1xyXG4gICAgaWYgKHR5cGVvZiByZXNvbHZlUmVzdWx0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICBlcnJvcnMucHVzaCh7IG5hbWU6IGJhY2tlbmROYW1lLCBlcnI6IHJlc29sdmVSZXN1bHQgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoIWJhY2tlbmQpIHtcclxuICAgICAgICBiYWNrZW5kID0gcmVzb2x2ZVJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYmFja2VuZCA9PT0gcmVzb2x2ZVJlc3VsdCkge1xyXG4gICAgICAgIGF2YWlsYWJsZUJhY2tlbmROYW1lcy5hZGQoYmFja2VuZE5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBpZiBubyBiYWNrZW5kIGlzIGF2YWlsYWJsZSwgdGhyb3cgZXJyb3IuXHJcbiAgaWYgKCFiYWNrZW5kKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ZXJyb3JzLm1hcCgoZSkgPT4gYFske2UubmFtZX1dICR7ZS5lcnJ9YCkuam9pbignLCAnKX1gKTtcclxuICB9XHJcblxyXG4gIC8vIGZvciBlYWNoIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJhY2tlbmQsIGlmIGl0J3Mgbm90IGF2YWlsYWJsZSwgb3V0cHV0IHdhcm5pbmcgbWVzc2FnZS5cclxuICBmb3IgKGNvbnN0IHsgbmFtZSwgZXJyIH0gb2YgZXJyb3JzKSB7XHJcbiAgICBpZiAoYmFja2VuZEhpbnRzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bmFtZX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZXJyfWAsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBmaWx0ZXJlZEVwcyA9IGVwcy5maWx0ZXIoKGkpID0+IGF2YWlsYWJsZUJhY2tlbmROYW1lcy5oYXModHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xyXG5cclxuICByZXR1cm4gW1xyXG4gICAgYmFja2VuZCxcclxuICAgIG5ldyBQcm94eShvcHRpb25zLCB7XHJcbiAgICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xyXG4gICAgICAgIGlmIChwcm9wID09PSAnZXhlY3V0aW9uUHJvdmlkZXJzJykge1xyXG4gICAgICAgICAgcmV0dXJuIGZpbHRlcmVkRXBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKTtcclxuICAgICAgfSxcclxuICAgIH0pLFxyXG4gIF07XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xyXG5pbXBvcnQgeyBPbm54VmFsdWUgfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBTZXNzaW9uSGFuZGxlciB7XHJcbiAgdHlwZSBGZWVkc1R5cGUgPSB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfTtcclxuICB0eXBlIEZldGNoZXNUeXBlID0geyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbCB9O1xyXG4gIHR5cGUgUmV0dXJuVHlwZSA9IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBzaGFyZWQgU2Vzc2lvbkhhbmRsZXIgZnVuY3Rpb25hbGl0eVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbnRlcmZhY2UgU2Vzc2lvbkhhbmRsZXIge1xyXG4gIGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgcmVhZG9ubHkgaW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XHJcbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xyXG5cclxuICByZWFkb25seSBpbnB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcclxuICByZWFkb25seSBvdXRwdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGFuIGluZmVyZW5jZSBzZXNzaW9uLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIGV4dGVuZHMgU2Vzc2lvbkhhbmRsZXIge1xyXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XHJcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XHJcblxyXG4gIHJ1bihcclxuICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsXHJcbiAgICBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcclxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcclxuICApOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+O1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50IGEgYmFja2VuZCB0aGF0IHByb3ZpZGVzIGltcGxlbWVudGF0aW9uIG9mIG1vZGVsIGluZmVyZW5jaW5nLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tlbmQge1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIGJhY2tlbmQgYXN5bmNocm9ub3VzbHkuIFNob3VsZCB0aHJvdyB3aGVuIGZhaWxlZC5cclxuICAgKi9cclxuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihcclxuICAgIHVyaU9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxyXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XHJcbn1cclxuXHJcbmV4cG9ydCB7IHJlZ2lzdGVyQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IC9qcy9zY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLnRzXHJcbi8vIERvIG5vdCBtb2RpZnkgZmlsZSBjb250ZW50IG1hbnVhbGx5LlxyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4yMy4wJztcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBFbnYgfSBmcm9tICcuL2Vudi5qcyc7XHJcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xyXG5cclxudHlwZSBMb2dMZXZlbFR5cGUgPSBFbnZbJ2xvZ0xldmVsJ107XHJcblxyXG5sZXQgbG9nTGV2ZWxWYWx1ZTogUmVxdWlyZWQ8TG9nTGV2ZWxUeXBlPiA9ICd3YXJuaW5nJztcclxuXHJcbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IHtcclxuICB3YXNtOiB7fSBhcyBFbnYuV2ViQXNzZW1ibHlGbGFncyxcclxuICB3ZWJnbDoge30gYXMgRW52LldlYkdMRmxhZ3MsXHJcbiAgd2ViZ3B1OiB7fSBhcyBFbnYuV2ViR3B1RmxhZ3MsXHJcbiAgdmVyc2lvbnM6IHsgY29tbW9uOiB2ZXJzaW9uIH0sXHJcblxyXG4gIHNldCBsb2dMZXZlbCh2YWx1ZTogTG9nTGV2ZWxUeXBlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBbJ3ZlcmJvc2UnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJywgJ2ZhdGFsJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHt2YWx1ZX1gKTtcclxuICAgIH1cclxuICAgIGxvZ0xldmVsVmFsdWUgPSB2YWx1ZTtcclxuICB9LFxyXG4gIGdldCBsb2dMZXZlbCgpOiBSZXF1aXJlZDxMb2dMZXZlbFR5cGU+IHtcclxuICAgIHJldHVybiBsb2dMZXZlbFZhbHVlO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vLyBzZXQgcHJvcGVydHkgJ2xvZ0xldmVsJyBzbyB0aGF0IHRoZXkgY2FuIGJlIGNvcnJlY3RseSB0cmFuc2ZlcnJlZCB0byB3b3JrZXIgYnkgYHBvc3RNZXNzYWdlKClgLlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LCAnbG9nTGV2ZWwnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgZW52IGFzIGVudkltcGwgfSBmcm9tICcuL2Vudi1pbXBsLmpzJztcclxuaW1wb3J0IHsgVHJ5R2V0R2xvYmFsVHlwZSB9IGZyb20gJy4vdHlwZS1oZWxwZXIuanMnO1xyXG5cclxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEVudiB7XHJcbiAgZXhwb3J0IHR5cGUgV2FzbVBhdGhQcmVmaXggPSBzdHJpbmc7XHJcbiAgZXhwb3J0IGludGVyZmFjZSBXYXNtRmlsZVBhdGhzIHtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSB0aGUgb3ZlcnJpZGUgcGF0aCBmb3IgdGhlIG1haW4gLndhc20gZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC53YXNtIGZpbGUgaXM6XHJcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21gIGZvciBkZWZhdWx0IGJ1aWxkXHJcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbWAgZm9yIEpTRVAgYnVpbGQgKHdpdGggV2ViR1BVIGFuZCBXZWJOTilcclxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuYXN5bmNpZnkud2FzbWAgZm9yIFdlYkdQVSBidWlsZCB3aXRoIEFzeW5jaWZ5ICh3aXRoIFdlYk5OKVxyXG4gICAgICovXHJcbiAgICB3YXNtPzogVVJMIHwgc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAubWpzIGZpbGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIElmIG5vdCBtb2RpZmllZCwgdGhlIGZpbGVuYW1lIG9mIHRoZSAubWpzIGZpbGUgaXM6XHJcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLm1qc2AgZm9yIGRlZmF1bHQgYnVpbGRcclxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNgIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXHJcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmFzeW5jaWZ5Lm1qc2AgZm9yIFdlYkdQVSBidWlsZCB3aXRoIEFzeW5jaWZ5ICh3aXRoIFdlYk5OKVxyXG4gICAgICovXHJcbiAgICBtanM/OiBVUkwgfCBzdHJpbmc7XHJcbiAgfVxyXG4gIGV4cG9ydCB0eXBlIFdhc21QcmVmaXhPckZpbGVQYXRocyA9IFdhc21QYXRoUHJlZml4IHwgV2FzbUZpbGVQYXRocztcclxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkFzc2VtYmx5RmxhZ3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBzZXQgb3IgZ2V0IG51bWJlciBvZiB0aHJlYWQocykuIElmIG9taXR0ZWQgb3Igc2V0IHRvIDAsIG51bWJlciBvZiB0aHJlYWQocykgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHN5c3RlbS4gSWYgc2V0XHJcbiAgICAgKiB0byAxLCBubyB3b3JrZXIgdGhyZWFkIHdpbGwgYmUgc3Bhd25lZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgd2hlbiBXZWJBc3NlbWJseSBtdWx0aXRocmVhZCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcclxuICAgICAqL1xyXG4gICAgbnVtVGhyZWFkcz86IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldCBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBlbmFibGUgU0lNRC5cclxuICAgICAqXHJcbiAgICAgKiBPTk5YIFJ1bnRpbWUgd2lsbCBwZXJmb3JtIGZlYXR1cmUgZGV0ZWN0aW9uIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5LiBTcGVjaWZpY2FsbHksIHdoZW4gdGhlIHZhbHVlIGlzXHJcbiAgICAgKiBzZXQgdG86XHJcbiAgICAgKiAtIGB1bmRlZmluZWRgLCBgdHJ1ZWAgb3IgYFwiZml4ZWRcImA6IHdpbGwgY2hlY2sgYXZhaWxhYmlsaXR5IG9mIEZpeGVkLXdpZHRoIFNJTUQuXHJcbiAgICAgKiAtIGBcInJlbGF4ZWRcImA6IHdpbGwgY2hlY2sgYXZhaWxhYmlsaXR5IG9mIFJlbGF4ZWQgU0lNRC5cclxuICAgICAqIC0gYGZhbHNlYDogd2lsbCBub3QgcGVyZm9ybSBTSU1EIGZlYXR1cmUgY2hlY2tpbmcuXHJcbiAgICAgKlxyXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IGRvZXMgbm90IG1ha2UgT05OWCBSdW50aW1lIHRvIHN3aXRjaCB0byB0aGUgY29ycmVzcG9uZGluZyBydW50aW1lIGF1dG9tYXRpY2FsbHkuIFVzZXIgbmVlZFxyXG4gICAgICogdG8gc2V0IGB3YXNtUGF0aHNgIG9yIGB3YXNtQmluYXJ5YCBwcm9wZXJ0eSB0byBsb2FkIHRoZSBjb3JyZXNwb25kaW5nIHJ1bnRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgU0lNRCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgdHJ1ZWBcclxuICAgICAqL1xyXG4gICAgc2ltZD86IGJvb2xlYW4gfCAnZml4ZWQnIHwgJ3JlbGF4ZWQnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGVudi50cmFjZWAgaW5zdGVhZC4gSWYgYGVudi50cmFjZWAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgdHJhY2U/OiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCBhIG51bWJlciBzcGVjaWZ5aW5nIHRoZSB0aW1lb3V0IGZvciBpbml0aWFsaXphdGlvbiBvZiBXZWJBc3NlbWJseSBiYWNrZW5kLCBpbiBtaWxsaXNlY29uZHMuIEEgemVyb1xyXG4gICAgICogdmFsdWUgaW5kaWNhdGVzIG5vIHRpbWVvdXQgaXMgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBkZWZhdWx0VmFsdWUgYDBgXHJcbiAgICAgKi9cclxuICAgIGluaXRUaW1lb3V0PzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY3VzdG9tIFVSTCBwcmVmaXggdG8gdGhlIC53YXNtLy5tanMgZmlsZXMsIG9yIGFuIG9iamVjdCBvZiBvdmVycmlkZXMgZm9yIGJvdGggLndhc20vLm1qcyBmaWxlLiBUaGUgb3ZlcnJpZGVcclxuICAgICAqIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHdhc21QYXRocz86IFdhc21QcmVmaXhPckZpbGVQYXRocztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGN1c3RvbSBidWZmZXIgd2hpY2ggY29udGFpbnMgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeS4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBgd2FzbVBhdGhzYCBwcm9wZXJ0eSB3aWxsXHJcbiAgICAgKiBiZSBpZ25vcmVkLlxyXG4gICAgICovXHJcbiAgICB3YXNtQmluYXJ5PzogQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBwcm94eSB0aGUgZXhlY3V0aW9uIG9mIG1haW4gdGhyZWFkIHRvIGEgd29ya2VyIHRocmVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcclxuICAgICAqL1xyXG4gICAgcHJveHk/OiBib29sZWFuO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEZsYWdzIHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgV2ViR0wgQ29udGV4dCBJRCAod2ViZ2wgb3Igd2ViZ2wyKS5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAnd2ViZ2wyJ2BcclxuICAgICAqL1xyXG4gICAgY29udGV4dElkPzogJ3dlYmdsJyB8ICd3ZWJnbDInO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBjb250ZXh0OiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIG1heGltdW0gYmF0Y2ggc2l6ZSBmb3IgbWF0bXVsLiAwIG1lYW5zIHRvIGRpc2FibGUgYmF0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgbWF0bXVsTWF4QmF0Y2hTaXplPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSB0ZXh0dXJlIGNhY2hlIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgJ2Z1bGwnYFxyXG4gICAgICovXHJcbiAgICB0ZXh0dXJlQ2FjaGVNb2RlPzogJ2luaXRpYWxpemVyT25seScgfCAnZnVsbCc7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHBhY2tlZCB0ZXh0dXJlIG1vZGVcclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcclxuICAgICAqL1xyXG4gICAgcGFjaz86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciBlbmFibGUgYXN5bmMgZG93bmxvYWQuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXHJcbiAgICAgKi9cclxuICAgIGFzeW5jPzogYm9vbGVhbjtcclxuICB9XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGEge1xyXG4gICAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XHJcbiAgICBkYXRhVHlwZTogc3RyaW5nO1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMSB7XHJcbiAgICB2ZXJzaW9uOiAxO1xyXG4gICAgaW5wdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XHJcbiAgICBvdXRwdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XHJcbiAgICBrZXJuZWxJZDogbnVtYmVyO1xyXG4gICAga2VybmVsVHlwZTogc3RyaW5nO1xyXG4gICAga2VybmVsTmFtZTogc3RyaW5nO1xyXG4gICAgcHJvZ3JhbU5hbWU6IHN0cmluZztcclxuICAgIHN0YXJ0VGltZTogbnVtYmVyO1xyXG4gICAgZW5kVGltZTogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgZXhwb3J0IHR5cGUgV2ViR3B1UHJvZmlsaW5nRGF0YSA9IFdlYkdwdVByb2ZpbGluZ0RhdGFWMTtcclxuXHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVGbGFncyB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBtb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaW5zdGVhZC4gSWYgYGVudi53ZWJncHUucHJvZmlsaW5nLm1vZGVgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlXHJcbiAgICAgKiBpZ25vcmVkLlxyXG4gICAgICovXHJcbiAgICBwcm9maWxpbmdNb2RlPzogJ29mZicgfCAnZGVmYXVsdCc7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBjb25maWd1cmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBwcm9maWxpbmc6IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBtb2RlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcclxuICAgICAgICovXHJcbiAgICAgIG1vZGU/OiAnb2ZmJyB8ICdkZWZhdWx0JztcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZXQgb3IgZ2V0IGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIHByb2ZpbGluZyBkYXRhIGlzIHJlY2VpdmVkLiBJZiBub3Qgc2V0LCB0aGUgcHJvZmlsaW5nIGRhdGEgd2lsbCBiZVxyXG4gICAgICAgKiBwcmludGVkIHRvIGNvbnNvbGUuXHJcbiAgICAgICAqL1xyXG4gICAgICBvbmRhdGE/OiAoZGF0YTogV2ViR3B1UHJvZmlsaW5nRGF0YSkgPT4gdm9pZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIHBvd2VyIHByZWZlcmVuY2UuXHJcbiAgICAgKlxyXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IG9ubHkgaGFzIGVmZmVjdCBiZWZvcmUgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZVxyXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cclxuICAgICAqXHJcbiAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vZ3B1d2ViLmdpdGh1Yi5pby9ncHV3ZWIvI2RpY3RkZWYtZ3B1cmVxdWVzdGFkYXB0ZXJvcHRpb25zfSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICpcclxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBDcmVhdGUgeW91ciBvd24gR1BVQWRhcHRlciwgdXNlIGl0IHRvIGNyZWF0ZSBhIEdQVURldmljZSBpbnN0YW5jZSBhbmQgc2V0IHtAbGluayBkZXZpY2V9IHByb3BlcnR5IGlmXHJcbiAgICAgKiB5b3Ugd2FudCB0byB1c2UgYSBzcGVjaWZpYyBwb3dlciBwcmVmZXJlbmNlLlxyXG4gICAgICovXHJcbiAgICBwb3dlclByZWZlcmVuY2U/OiAnbG93LXBvd2VyJyB8ICdoaWdoLXBlcmZvcm1hbmNlJztcclxuICAgIC8qKlxyXG4gICAgICogU2V0IG9yIGdldCB0aGUgZm9yY2UgZmFsbGJhY2sgYWRhcHRlciBmbGFnLlxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcclxuICAgICAqIHVzZWQgYXMgb3B0aW9ucyBmb3IgYG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKWAuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgQ3JlYXRlIHlvdXIgb3duIEdQVUFkYXB0ZXIsIHVzZSBpdCB0byBjcmVhdGUgYSBHUFVEZXZpY2UgaW5zdGFuY2UgYW5kIHNldCB7QGxpbmsgZGV2aWNlfSBwcm9wZXJ0eSBpZlxyXG4gICAgICogeW91IHdhbnQgdG8gdXNlIGEgc3BlY2lmaWMgZmFsbGJhY2sgb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBmb3JjZUZhbGxiYWNrQWRhcHRlcj86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgdGhlIGFkYXB0ZXIgZm9yIFdlYkdQVS5cclxuICAgICAqXHJcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXHJcbiAgICAgKiB1c2VkIGFzIHRoZSBHUFUgYWRhcHRlciBmb3IgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQgdG8gY3JlYXRlIEdQVSBkZXZpY2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhpcyBwcm9wZXJ0eSBpcyBub3Qgc2V0LCBpdCB3aWxsIGJlIGF2YWlsYWJsZSB0byBnZXQgYWZ0ZXIgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGVcclxuICAgICAqIHZhbHVlIHdpbGwgYmUgdGhlIEdQVSBhZGFwdGVyIHRoYXQgY3JlYXRlZCBieSB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZC5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHVzZSB3aXRoIFR5cGVTY3JpcHQsIHRoZSB0eXBlIG9mIHRoaXMgcHJvcGVydHkgaXMgYEdQVUFkYXB0ZXJgIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgSXQgaXMgbm8gbG9uZ2VyIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIHByb3BlcnR5LiBUaGUgbGF0ZXN0IFdlYkdQVSBzcGVjIGFkZHMgYEdQVURldmljZS5hZGFwdGVySW5mb2BcclxuICAgICAqIChodHRwczovL3d3dy53My5vcmcvVFIvd2ViZ3B1LyNkb20tZ3B1ZGV2aWNlLWFkYXB0ZXJpbmZvKSwgd2hpY2ggYWxsb3dzIHRvIGdldCB0aGUgYWRhcHRlciBpbmZvcm1hdGlvbiBmcm9tIHRoZVxyXG4gICAgICogZGV2aWNlLiBXaGVuIGl0J3MgYXZhaWxhYmxlLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNldC9nZXQgdGhlIHtAbGluayBhZGFwdGVyfSBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgYWRhcHRlcjogVHJ5R2V0R2xvYmFsVHlwZTwnR1BVQWRhcHRlcic+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBHUFUgZGV2aWNlIGZvciBXZWJHUFUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlcmUgYXJlIDMgdmFsaWQgc2NlbmFyaW9zIG9mIGFjY2Vzc2luZyB0aGlzIHByb3BlcnR5OlxyXG4gICAgICogLSBTZXQgYSB2YWx1ZSBiZWZvcmUgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZSB1c2VkIGJ5IHRoZSBXZWJHUFUgYmFja2VuZFxyXG4gICAgICogdG8gcGVyZm9ybSBjYWxjdWxhdGlvbnMuIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBgR1BVRGV2aWNlYCBvYmplY3QsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG4gICAgICogLSBHZXQgdGhlIHZhbHVlIGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoaXMgd2lsbCB0cnkgdG8gY3JlYXRlIGEgbmV3IEdQVURldmljZVxyXG4gICAgICogaW5zdGFuY2UuIFJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byBhIGBHUFVEZXZpY2VgIG9iamVjdC5cclxuICAgICAqIC0gR2V0IHRoZSB2YWx1ZSBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFJldHVybnMgYSByZXNvbHZlZCBgUHJvbWlzZWAgdG8gdGhlXHJcbiAgICAgKiBgR1BVRGV2aWNlYCBvYmplY3QgdXNlZCBieSB0aGUgV2ViR1BVIGJhY2tlbmQuXHJcbiAgICAgKi9cclxuICAgIGdldCBkZXZpY2UoKTogUHJvbWlzZTxUcnlHZXRHbG9iYWxUeXBlPCdHUFVEZXZpY2UnPj47XHJcbiAgICBzZXQgZGV2aWNlKHZhbHVlOiBUcnlHZXRHbG9iYWxUeXBlPCdHUFVEZXZpY2UnPik7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciB2YWxpZGF0ZSBpbnB1dCBjb250ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZUlucHV0Q29udGVudD86IGJvb2xlYW47XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVudiB7XHJcbiAgLyoqXHJcbiAgICogc2V0IHRoZSBzZXZlcml0eSBsZXZlbCBmb3IgbG9nZ2luZy5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0VmFsdWUgYCd3YXJuaW5nJ2BcclxuICAgKi9cclxuICBsb2dMZXZlbD86ICd2ZXJib3NlJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnZmF0YWwnO1xyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHJ1biBpbiBkZWJ1ZyBtb2RlLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXHJcbiAgICovXHJcbiAgZGVidWc/OiBib29sZWFuO1xyXG5cclxuICAvKipcclxuICAgKiBzZXQgb3IgZ2V0IGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gZW5hYmxlIHRyYWNlLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXHJcbiAgICovXHJcbiAgdHJhY2U/OiBib29sZWFuO1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgdmVyc2lvbiBvZiB0aGUgY3VycmVudCBwYWNrYWdlLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IHZlcnNpb25zOiB7XHJcbiAgICByZWFkb25seSBjb21tb246IHN0cmluZztcclxuICAgIHJlYWRvbmx5IHdlYj86IHN0cmluZztcclxuICAgIHJlYWRvbmx5IG5vZGU/OiBzdHJpbmc7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbiAgICByZWFkb25seSAncmVhY3QtbmF0aXZlJz86IHN0cmluZztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkFzc2VtYmx5XHJcbiAgICovXHJcbiAgcmVhZG9ubHkgd2FzbTogRW52LldlYkFzc2VtYmx5RmxhZ3M7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR0xcclxuICAgKi9cclxuICByZWFkb25seSB3ZWJnbDogRW52LldlYkdMRmxhZ3M7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR1BVXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgd2ViZ3B1OiBFbnYuV2ViR3B1RmxhZ3M7XHJcblxyXG4gIFtuYW1lOiBzdHJpbmddOiB1bmtub3duO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGFzIGEgZ2xvYmFsIHNpbmdsZXRvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IGVudkltcGw7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yVG9EYXRhVXJsT3B0aW9ucywgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zIH0gZnJvbSAnLi90ZW5zb3ItY29udmVyc2lvbi5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcclxuXHJcbi8qKlxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9EYXRhVVJMKClcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0RhdGFVUkwgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBjYW52YXMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykgOiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xyXG4gIGNhbnZhcy53aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xyXG4gIGNhbnZhcy5oZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcclxuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhc1xyXG4gICAgfCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuICAgIHwgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcbiAgICB8IG51bGw7XHJcblxyXG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xyXG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcclxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xyXG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xyXG4gICAgaWYgKG9wdGlvbnM/LnRlbnNvckxheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcclxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcclxuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbM107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXHJcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbM107XHJcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucz8uZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InO1xyXG5cclxuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xyXG4gICAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG5vcm1NZWFuID0gWzI1NSwgMjU1LCAyNTUsIDI1NV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhblswXSwgbm9ybS5tZWFuWzFdLCBub3JtLm1lYW5bMl0sIDBdO1xyXG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcclxuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xyXG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXHJcbiAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLFxyXG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSxcclxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxyXG4gICAgICBhVGVuc29yUG9pbnRlciA9IC0xO1xyXG5cclxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcclxuICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XHJcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcclxuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XHJcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcclxuICAgICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xyXG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcclxuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xyXG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcclxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xyXG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcclxuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xyXG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcclxuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XHJcbiAgICAgICAgY29uc3QgUiA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXHJcbiAgICAgICAgY29uc3QgRyA9ICgodGVuc29yLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXHJcbiAgICAgICAgY29uc3QgQiA9ICgodGVuc29yLmRhdGFbYlRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAvLyBCIHZhbHVlXHJcbiAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXHJcbiAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBSICsgJywnICsgRyArICcsJyArIEIgKyAnLCcgKyBBICsgJyknO1xyXG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCd0b0RhdGFVUkwnIGluIGNhbnZhcykge1xyXG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLnRvSW1hZ2VEYXRhKClcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0ltYWdlRGF0YSA9ICh0ZW5zb3I6IFRlbnNvciwgb3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSA9PiB7XHJcbiAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID1cclxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpXHJcbiAgICAgIDogKG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSkuZ2V0Q29udGV4dCgnMmQnKSBhcyBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpO1xyXG4gIGxldCBpbWFnZTogSW1hZ2VEYXRhO1xyXG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xyXG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcclxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xyXG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xyXG4gICAgbGV0IGNoYW5uZWxzOiBudW1iZXI7XHJcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xyXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xyXG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1sxXTtcclxuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1szXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIERlZmF1bHQgbGF5b3V0IGlzIE5DV0hcclxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcclxuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XHJcbiAgICAgIGNoYW5uZWxzID0gdGVuc29yLmRpbXNbMV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcclxuXHJcbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcclxuICAgIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgICBsZXQgbm9ybUJpYXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xyXG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAyNTVdO1xyXG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcclxuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xyXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgY2hhbm5lbHMgPT09IDQgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0JBJykgfHxcclxuICAgICAgICAoY2hhbm5lbHMgPT09IDMgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0InICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnQkdSJylcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGZvcm1hdCBkb2Vzbid0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXHJcbiAgICBjb25zdCBzdGVwID0gNDtcclxuICAgIGxldCBySW1hZ2VQb2ludGVyID0gMCxcclxuICAgICAgZ0ltYWdlUG9pbnRlciA9IDEsXHJcbiAgICAgIGJJbWFnZVBvaW50ZXIgPSAyLFxyXG4gICAgICBhSW1hZ2VQb2ludGVyID0gMztcclxuICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsXHJcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxyXG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXHJcbiAgICAgIGFUZW5zb3JQb2ludGVyID0gLTE7XHJcblxyXG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxyXG4gICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcclxuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xyXG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcclxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xyXG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XHJcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xyXG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XHJcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xyXG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XHJcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkJHJykge1xyXG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XHJcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xyXG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XHJcbiAgICB9XHJcblxyXG4gICAgaW1hZ2UgPSBwaXhlbHMyRENvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIGZvciAoXHJcbiAgICAgIGxldCBpID0gMDtcclxuICAgICAgaSA8IGhlaWdodCAqIHdpZHRoO1xyXG4gICAgICBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGkrK1xyXG4gICAgKSB7XHJcbiAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgLy8gUiB2YWx1ZVxyXG4gICAgICBpbWFnZS5kYXRhW2dJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMV0pICogbm9ybU1lYW5bMV07IC8vIEcgdmFsdWVcclxuICAgICAgaW1hZ2UuZGF0YVtiSW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbYlRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAvLyBCIHZhbHVlXHJcbiAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPVxyXG4gICAgICAgIGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xyXG4gIH1cclxuICByZXR1cm4gaW1hZ2U7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHtcclxuICBPcHRpb25zRGltZW5zaW9ucyxcclxuICBPcHRpb25zRm9ybWF0LFxyXG4gIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyxcclxuICBPcHRpb25zVGVuc29yRm9ybWF0LFxyXG4gIE9wdGlvbnNUZW5zb3JMYXlvdXQsXHJcbiAgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsXHJcbiAgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcclxuICBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucyxcclxuICBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcclxuICBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zLFxyXG4gIFRlbnNvckZyb21UZXh0dXJlT3B0aW9ucyxcclxuICBUZW5zb3JGcm9tVXJsT3B0aW9ucyxcclxufSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcclxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL3RlbnNvci5qcyc7XHJcblxyXG5pbnRlcmZhY2UgQnVmZmVyVG9UZW5zb3JPcHRpb25zXHJcbiAgZXh0ZW5kcyBPcHRpb25zRGltZW5zaW9ucyxcclxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXHJcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsXHJcbiAgICBPcHRpb25zRm9ybWF0LFxyXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCB7fVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gaW1hZ2Ugb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBidWZmZXIgLSBFeHRyYWN0ZWQgaW1hZ2UgYnVmZmVyIGRhdGEgLSBhc3N1bWluZyBSR0JBIGZvcm1hdFxyXG4gKiBAcGFyYW0gaW1hZ2VGb3JtYXQgLSBpbnB1dCBpbWFnZSBjb25maWd1cmF0aW9uIC0gcmVxdWlyZWQgY29uZmlndXJhdGlvbnMgaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XHJcbiAqIEBwYXJhbSB0ZW5zb3JGb3JtYXQgLSBvdXRwdXQgdGVuc29yIGNvbmZpZ3VyYXRpb24gLSBEZWZhdWx0IGlzIFJHQiBmb3JtYXRcclxuICovXHJcbmV4cG9ydCBjb25zdCBidWZmZXJUb1RlbnNvciA9IChidWZmZXI6IFVpbnQ4Q2xhbXBlZEFycmF5IHwgdW5kZWZpbmVkLCBvcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMpOiBUZW5zb3IgPT4ge1xyXG4gIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkJyk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMud2lkdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZCcpO1xyXG4gIH1cclxuICBpZiAob3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gb3B0aW9ucztcclxuXHJcbiAgY29uc3Qgbm9ybSA9IG9wdGlvbnMubm9ybSA/PyB7IG1lYW46IDI1NSwgYmlhczogMCB9O1xyXG4gIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuXHJcbiAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XHJcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4hWzBdLCBub3JtLm1lYW4hWzFdLCBub3JtLm1lYW4hWzJdLCBub3JtLm1lYW4hWzNdID8/IDI1NV07XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIG5vcm0uYmlhcyA9PT0gJ251bWJlcicpIHtcclxuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XHJcbiAgfSBlbHNlIHtcclxuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcyFbMF0sIG5vcm0uYmlhcyFbMV0sIG5vcm0uYmlhcyFbMl0sIG5vcm0uYmlhcyFbM10gPz8gMF07XHJcbiAgfVxyXG5cclxuICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0JBJztcclxuICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcclxuXHJcbiAgY29uc3Qgb3V0cHV0Zm9ybWF0ID1cclxuICAgIG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XHJcbiAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XHJcbiAgY29uc3QgZmxvYXQzMkRhdGEgPSBvdXRwdXRmb3JtYXQgPT09ICdSR0JBJyA/IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogNCkgOiBuZXcgRmxvYXQzMkFycmF5KHN0cmlkZSAqIDMpO1xyXG5cclxuICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcclxuICBsZXQgc3RlcCA9IDQsXHJcbiAgICBySW1hZ2VQb2ludGVyID0gMCxcclxuICAgIGdJbWFnZVBvaW50ZXIgPSAxLFxyXG4gICAgYkltYWdlUG9pbnRlciA9IDIsXHJcbiAgICBhSW1hZ2VQb2ludGVyID0gMztcclxuICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLFxyXG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsXHJcbiAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXHJcbiAgICBhVGVuc29yUG9pbnRlciA9IC0xO1xyXG5cclxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XHJcbiAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xyXG4gICAgc3RlcCA9IDM7XHJcbiAgICBySW1hZ2VQb2ludGVyID0gMDtcclxuICAgIGdJbWFnZVBvaW50ZXIgPSAxO1xyXG4gICAgYkltYWdlUG9pbnRlciA9IDI7XHJcbiAgICBhSW1hZ2VQb2ludGVyID0gLTE7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcclxuICBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcclxuICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcclxuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcclxuICAgIHJUZW5zb3JQb2ludGVyID0gMDtcclxuICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xyXG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xyXG4gIH0gZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnQkdSJykge1xyXG4gICAgYlRlbnNvclBvaW50ZXIgPSAwO1xyXG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XHJcbiAgICByVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XHJcbiAgfVxyXG5cclxuICBmb3IgKFxyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgaSA8IHN0cmlkZTtcclxuICAgIGkrKywgckltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwXHJcbiAgKSB7XHJcbiAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1swXSkgLyBub3JtTWVhblswXTtcclxuICAgIGZsb2F0MzJEYXRhW2dUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltnSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzFdKSAvIG5vcm1NZWFuWzFdO1xyXG4gICAgZmxvYXQzMkRhdGFbYlRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMl0pIC8gbm9ybU1lYW5bMl07XHJcbiAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XHJcbiAgICAgIGZsb2F0MzJEYXRhW2FUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlclthSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzNdKSAvIG5vcm1NZWFuWzNdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmxvYXQzMkFycmF5IC0+IG9ydC5UZW5zb3JcclxuICBjb25zdCBvdXRwdXRUZW5zb3IgPVxyXG4gICAgb3V0cHV0Zm9ybWF0ID09PSAnUkdCQSdcclxuICAgICAgPyBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCA0LCBoZWlnaHQsIHdpZHRoXSlcclxuICAgICAgOiBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCAzLCBoZWlnaHQsIHdpZHRoXSk7XHJcbiAgcmV0dXJuIG91dHB1dFRlbnNvcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUltYWdlKCkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUltYWdlID0gYXN5bmMgKFxyXG4gIGltYWdlOiBJbWFnZURhdGEgfCBIVE1MSW1hZ2VFbGVtZW50IHwgSW1hZ2VCaXRtYXAgfCBzdHJpbmcsXHJcbiAgb3B0aW9ucz86XHJcbiAgICB8IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zXHJcbiAgICB8IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zXHJcbiAgICB8IFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcclxuICAgIHwgVGVuc29yRnJvbVVybE9wdGlvbnMsXHJcbik6IFByb21pc2U8VGVuc29yPiA9PiB7XHJcbiAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XHJcbiAgY29uc3QgaXNIVE1MSW1hZ2VFbGUgPSB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xyXG4gIGNvbnN0IGlzSW1hZ2VEYXRhRWxlID0gdHlwZW9mIEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGE7XHJcbiAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcclxuICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZyc7XHJcblxyXG4gIGxldCBkYXRhOiBVaW50OENsYW1wZWRBcnJheSB8IHVuZGVmaW5lZDtcclxuICBsZXQgYnVmZmVyVG9UZW5zb3JPcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xyXG5cclxuICBjb25zdCBjcmVhdGVDYW52YXMgPSAoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgY29uc3QgY3JlYXRlQ2FudmFzQ29udGV4dCA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICB9IGVsc2UgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xyXG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICBpZiAoaXNIVE1MSW1hZ2VFbGUpIHtcclxuICAgIC8vIEhUTUxJbWFnZUVsZW1lbnQgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgaXMgUkdCQSBieSBkZWZhdWx0XHJcbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcclxuXHJcbiAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcclxuICAgICAgbGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuICAgICAgbGV0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkV2lkdGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcclxuICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XHJcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcbiAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XHJcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XHJcbiAgICBsZXQgd2lkdGg6IG51bWJlcjtcclxuXHJcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xyXG4gICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5mb3JtYXQgPSAnUkdCQSc7XHJcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCB0ZW1wQ2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XHJcblxyXG4gICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dCh0ZW1wQ2FudmFzKTtcclxuXHJcbiAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xyXG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xyXG4gICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRhdGEgPSBpbWFnZS5kYXRhO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNJbWFnZUJpdG1hcCkge1xyXG4gICAgLy8gSW1hZ2VCaXRtYXAgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgbXVzdCBiZSBwcm92aWRlZCBieSB1c2VyXHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xyXG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xyXG5cclxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcbiAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xyXG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcclxuICAgICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGlzU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcclxuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcclxuICAgICAgaWYgKCFpbWFnZSB8fCAhY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiByZWplY3QoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBuZXdJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICBuZXdJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xyXG4gICAgICBuZXdJbWFnZS5zcmMgPSBpbWFnZTtcclxuICAgICAgbmV3SW1hZ2Uub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdJbWFnZS5oZWlnaHQ7XHJcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UobmV3SW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gY2FudmFzLndpZHRoO1xyXG4gICAgICAgIHJlc29sdmUoYnVmZmVyVG9UZW5zb3IoaW1nLmRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucykpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcclxuICB9XHJcblxyXG4gIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tVGV4dHVyZSgpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21UZXh0dXJlID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXHJcbiAgdGV4dHVyZTogVGVuc29ySW50ZXJmYWNlLlRleHR1cmVUeXBlLFxyXG4gIG9wdGlvbnM6IFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUPixcclxuKTogVGVuc29yID0+IHtcclxuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xyXG4gIC8vIEFsd2F5cyBhc3N1bWUgUkdCQUYzMi4gVE9ETzogc3VwcG9ydCBkaWZmZXJlbnQgdGV4dHVyZSBmb3JtYXRcclxuICBjb25zdCBkaW1zID0gWzEsIGhlaWdodCwgd2lkdGgsIDRdO1xyXG4gIHJldHVybiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICd0ZXh0dXJlJywgdHlwZTogJ2Zsb2F0MzInLCB0ZXh0dXJlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcigpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21HcHVCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJEYXRhVHlwZXM+KFxyXG4gIGdwdUJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlclR5cGUsXHJcbiAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXHJcbik6IFRlbnNvciA9PiB7XHJcbiAgY29uc3QgeyBkYXRhVHlwZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IG9wdGlvbnM7XHJcbiAgcmV0dXJuIG5ldyBUZW5zb3IoeyBsb2NhdGlvbjogJ2dwdS1idWZmZXInLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIGdwdUJ1ZmZlciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21NTFRlbnNvcigpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21NTFRlbnNvciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yRGF0YVR5cGVzPihcclxuICBtbFRlbnNvcjogVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZSxcclxuICBvcHRpb25zOiBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQ+LFxyXG4pOiBUZW5zb3IgPT4ge1xyXG4gIGNvbnN0IHsgZGF0YVR5cGUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xyXG4gIHJldHVybiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICdtbC10ZW5zb3InLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIG1sVGVuc29yLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVBpbm5lZEJ1ZmZlcigpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21QaW5uZWRCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5DcHVQaW5uZWREYXRhVHlwZXM+KFxyXG4gIHR5cGU6IFQsXHJcbiAgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sXHJcbiAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4pOiBUZW5zb3IgPT4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsIHR5cGUsIGRhdGE6IGJ1ZmZlciwgZGltczogZGltcyA/PyBbYnVmZmVyLmxlbmd0aF0gfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xyXG5cclxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9XHJcbiAgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcclxuICB8IEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgQmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvcjtcclxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheSA9IEluc3RhbmNlVHlwZTxTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzPjtcclxuXHJcbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXHJcbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQID0gbmV3IE1hcDxzdHJpbmcsIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+KFtcclxuICBbJ2Zsb2F0MzInLCBGbG9hdDMyQXJyYXldLFxyXG4gIFsndWludDgnLCBVaW50OEFycmF5XSxcclxuICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxyXG4gIFsndWludDE2JywgVWludDE2QXJyYXldLFxyXG4gIFsnaW50MTYnLCBJbnQxNkFycmF5XSxcclxuICBbJ2ludDMyJywgSW50MzJBcnJheV0sXHJcbiAgWydib29sJywgVWludDhBcnJheV0sXHJcbiAgWydmbG9hdDY0JywgRmxvYXQ2NEFycmF5XSxcclxuICBbJ3VpbnQzMicsIFVpbnQzMkFycmF5XSxcclxuICBbJ2ludDQnLCBVaW50OEFycmF5XSxcclxuICBbJ3VpbnQ0JywgVWludDhBcnJheV0sXHJcbl0pO1xyXG5cclxuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cclxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAgPSBuZXcgTWFwPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsIFRlbnNvci5UeXBlPihbXHJcbiAgW0Zsb2F0MzJBcnJheSwgJ2Zsb2F0MzInXSxcclxuICBbVWludDhBcnJheSwgJ3VpbnQ4J10sXHJcbiAgW0ludDhBcnJheSwgJ2ludDgnXSxcclxuICBbVWludDE2QXJyYXksICd1aW50MTYnXSxcclxuICBbSW50MTZBcnJheSwgJ2ludDE2J10sXHJcbiAgW0ludDMyQXJyYXksICdpbnQzMiddLFxyXG4gIFtGbG9hdDY0QXJyYXksICdmbG9hdDY0J10sXHJcbiAgW1VpbnQzMkFycmF5LCAndWludDMyJ10sXHJcbl0pO1xyXG5cclxuLy8gdGhlIGZvbGxvd2luZyBjb2RlIGFsbG93cyBkZWxheWluZyBleGVjdXRpb24gb2YgQmlnSW50L0Zsb2F0MTZBcnJheSBjaGVja2luZy4gVGhpcyBhbGxvd3MgbGF6eSBpbml0aWFsaXphdGlvbiBmb3JcclxuLy8gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCBhbmQgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCwgd2hpY2ggYWxsb3dzIEJpZ0ludC9GbG9hdDE2QXJyYXlcclxuLy8gcG9seWZpbGwgaWYgYXZhaWxhYmxlLlxyXG5sZXQgaXNUeXBlZEFycmF5Q2hlY2tlZCA9IGZhbHNlO1xyXG5leHBvcnQgY29uc3QgY2hlY2tUeXBlZEFycmF5ID0gKCkgPT4ge1xyXG4gIGlmICghaXNUeXBlZEFycmF5Q2hlY2tlZCkge1xyXG4gICAgaXNUeXBlZEFycmF5Q2hlY2tlZCA9IHRydWU7XHJcbiAgICBjb25zdCBpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnSW50NjRBcnJheS5mcm9tO1xyXG4gICAgY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnVWludDY0QXJyYXkuZnJvbTtcclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBjb25zdCBGbG9hdDE2QXJyYXkgPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLkZsb2F0MTZBcnJheTtcclxuICAgIGNvbnN0IGlzRmxvYXQxNkFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb207XHJcblxyXG4gICAgaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xyXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnaW50NjQnLCBCaWdJbnQ2NEFycmF5KTtcclxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnSW50NjRBcnJheSwgJ2ludDY0Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSkge1xyXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgndWludDY0JywgQmlnVWludDY0QXJyYXkpO1xyXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRmxvYXQxNkFycmF5QXZhaWxhYmxlKSB7XHJcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgRmxvYXQxNkFycmF5KTtcclxuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoRmxvYXQxNkFycmF5LCAnZmxvYXQxNicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaWYgRmxvYXQxNkFycmF5IGlzIG5vdCBhdmFpbGFibGUsIHVzZSAnVWludDE2QXJyYXknIHRvIHN0b3JlIHRoZSBkYXRhLlxyXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnZmxvYXQxNicsIFVpbnQxNkFycmF5KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHtcclxuICBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXHJcbiAgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxyXG4gIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxyXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXHJcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xyXG5cclxuLyoqXHJcbiAqIGNhbGN1bGF0ZSBzaXplIGZyb20gZGltcy5cclxuICpcclxuICogQHBhcmFtIGRpbXMgdGhlIGRpbXMgYXJyYXkuIE1heSBiZSBhbiBpbGxlZ2FsIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcclxuICBsZXQgc2l6ZSA9IDE7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xyXG4gICAgaWYgKHR5cGVvZiBkaW0gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaW0pKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpbSA8IDApIHtcclxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xyXG4gICAgfVxyXG4gICAgc2l6ZSAqPSBkaW07XHJcbiAgfVxyXG4gIHJldHVybiBzaXplO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5yZXNoYXBlKClcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XHJcbiAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcclxuICAgIGNhc2UgJ2NwdSc6XHJcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XHJcbiAgICBjYXNlICdjcHUtcGlubmVkJzpcclxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xyXG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXHJcbiAgICAgICAgZGF0YTogdGVuc29yLmRhdGEgYXMgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzWydkYXRhJ10sXHJcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXHJcbiAgICAgICAgZGltcyxcclxuICAgICAgfSk7XHJcbiAgICBjYXNlICd0ZXh0dXJlJzpcclxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xyXG4gICAgICAgIGxvY2F0aW9uOiAndGV4dHVyZScsXHJcbiAgICAgICAgdGV4dHVyZTogdGVuc29yLnRleHR1cmUsXHJcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxyXG4gICAgICAgIGRpbXMsXHJcbiAgICAgIH0pO1xyXG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XHJcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHtcclxuICAgICAgICBsb2NhdGlvbjogJ2dwdS1idWZmZXInLFxyXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcclxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcclxuICAgICAgICBkaW1zLFxyXG4gICAgICB9KTtcclxuICAgIGNhc2UgJ21sLXRlbnNvcic6XHJcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHtcclxuICAgICAgICBsb2NhdGlvbjogJ21sLXRlbnNvcicsXHJcbiAgICAgICAgbWxUZW5zb3I6IHRlbnNvci5tbFRlbnNvcixcclxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxyXG4gICAgICAgIGRpbXMsXHJcbiAgICAgIH0pO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgdGVuc29yVG9EYXRhVVJMLCB0ZW5zb3JUb0ltYWdlRGF0YSB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcyc7XHJcbmltcG9ydCB7IFRlbnNvclRvRGF0YVVybE9wdGlvbnMsIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xyXG5pbXBvcnQge1xyXG4gIHRlbnNvckZyb21HcHVCdWZmZXIsXHJcbiAgdGVuc29yRnJvbUltYWdlLFxyXG4gIHRlbnNvckZyb21NTFRlbnNvcixcclxuICB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyLFxyXG4gIHRlbnNvckZyb21UZXh0dXJlLFxyXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnktaW1wbC5qcyc7XHJcbmltcG9ydCB7XHJcbiAgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxyXG4gIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcclxuICBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcclxuICBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9ucyxcclxuICBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zLFxyXG4gIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxyXG4gIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLFxyXG4gIFRlbnNvckZyb21NTFRlbnNvck9wdGlvbnMsXHJcbiAgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLFxyXG4gIFRlbnNvckZyb21VcmxPcHRpb25zLFxyXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXHJcbn0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XHJcbmltcG9ydCB7XHJcbiAgY2hlY2tUeXBlZEFycmF5LFxyXG4gIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAsXHJcbiAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCxcclxuICBTdXBwb3J0ZWRUeXBlZEFycmF5LFxyXG4gIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMsXHJcbn0gZnJvbSAnLi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcuanMnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVTaXplLCB0ZW5zb3JSZXNoYXBlIH0gZnJvbSAnLi90ZW5zb3ItdXRpbHMtaW1wbC5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2UgfSBmcm9tICcuL3RlbnNvci5qcyc7XHJcblxyXG4vLyB0eXBlIGFsaWFzZXMgZm9yIHRob3NlIGV4cG9ydGVkIGZyb20gVGVuc29yIGludGVyZmFjZVxyXG5cclxudHlwZSBUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLlR5cGU7XHJcbnR5cGUgVGVuc29yRGF0YVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGU7XHJcbnR5cGUgVGVuc29yRGF0YUxvY2F0aW9uID0gVGVuc29ySW50ZXJmYWNlLkRhdGFMb2NhdGlvbjtcclxudHlwZSBUZW5zb3JUZXh0dXJlVHlwZSA9IFRlbnNvckludGVyZmFjZS5UZXh0dXJlVHlwZTtcclxudHlwZSBUZW5zb3JHcHVCdWZmZXJUeXBlID0gVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlclR5cGU7XHJcbnR5cGUgVGVuc29yTUxUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yVHlwZTtcclxuXHJcbi8qKlxyXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgVGVuc29yIGludGVyZmFjZS5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRlbnNvciBpbXBsZW1lbnRzIFRlbnNvckludGVyZmFjZSB7XHJcbiAgLy8gI3JlZ2lvbiBjb25zdHJ1Y3RvcnNcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICB0eXBlOiBUZW5zb3JUeXBlLFxyXG4gICAgZGF0YTogVGVuc29yRGF0YVR5cGUgfCBVaW50OENsYW1wZWRBcnJheSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBib29sZWFuW10sXHJcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKTtcclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy4gVHlwZSBpcyBpbmZlcnJlZCBmcm9tIGRhdGEuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBkYXRhOiBUZW5zb3JEYXRhVHlwZSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgcmVhZG9ubHkgc3RyaW5nW10gfCByZWFkb25seSBib29sZWFuW10sXHJcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKTtcclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBwaW5uZWQgQ1BVIGRhdGEgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdjcHUtcGlubmVkJy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBXZWJHTCB0ZXh0dXJlIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAndGV4dHVyZScuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihwYXJhbXM6IFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdQVSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdncHUtYnVmZmVyJy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViTk4gTUxUZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdtbC10ZW5zb3InLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHBhcmFtcyAtIFNwZWNpZnkgdGhlIHBhcmFtZXRlcnMgdG8gY29uc3RydWN0IHRoZSB0ZW5zb3IuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocGFyYW1zOiBNTFRlbnNvckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGltcGxlbWVudGF0aW9uLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgYXJnMDpcclxuICAgICAgfCBUZW5zb3JUeXBlXHJcbiAgICAgIHwgVGVuc29yRGF0YVR5cGVcclxuICAgICAgfCBVaW50OENsYW1wZWRBcnJheVxyXG4gICAgICB8IHJlYWRvbmx5IHN0cmluZ1tdXHJcbiAgICAgIHwgcmVhZG9ubHkgYm9vbGVhbltdXHJcbiAgICAgIHwgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzXHJcbiAgICAgIHwgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1xyXG4gICAgICB8IEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVyc1xyXG4gICAgICB8IE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxyXG4gICAgYXJnMT86IFRlbnNvckRhdGFUeXBlIHwgVWludDhDbGFtcGVkQXJyYXkgfCByZWFkb25seSBudW1iZXJbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxyXG4gICAgYXJnMj86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICkge1xyXG4gICAgLy8gcGVyZm9ybSBvbmUtdGltZSBjaGVjayBmb3IgQmlnSW50L0Zsb2F0MTZBcnJheSBzdXBwb3J0XHJcbiAgICBjaGVja1R5cGVkQXJyYXkoKTtcclxuXHJcbiAgICBsZXQgdHlwZTogVGVuc29yVHlwZTtcclxuICAgIGxldCBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdvYmplY3QnICYmICdsb2NhdGlvbicgaW4gYXJnMCkge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cclxuICAgICAgLy9cclxuICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSBhcmcwLmxvY2F0aW9uO1xyXG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xyXG4gICAgICBkaW1zID0gYXJnMC5kaW1zO1xyXG4gICAgICBzd2l0Y2ggKGFyZzAubG9jYXRpb24pIHtcclxuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xyXG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldCh0eXBlKTtcclxuICAgICAgICAgIGlmICghZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCEoYXJnMC5kYXRhIGluc3RhbmNlb2YgZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmNwdURhdGEgPSBhcmcwLmRhdGE7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAndGV4dHVyZSc6IHtcclxuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcclxuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XHJcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gYXJnMC5kaXNwb3NlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDMyJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQxNicgJiZcclxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAnaW50NjQnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50MzInICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcclxuICAgICAgICAgICAgdHlwZSAhPT0gJ2Jvb2wnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50NCcgJiZcclxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gZ3B1IGJ1ZmZlcmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5ncHVCdWZmZXJEYXRhID0gYXJnMC5ncHVCdWZmZXI7XHJcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xyXG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdtbC10ZW5zb3InOiB7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDMyJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQxNicgJiZcclxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAnaW50NjQnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50MzInICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50NjQnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ4JyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDgnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxyXG4gICAgICAgICAgICB0eXBlICE9PSAndWludDQnICYmXHJcbiAgICAgICAgICAgIHR5cGUgIT09ICdpbnQ0J1xyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLm1sVGVuc29yRGF0YSA9IGFyZzAubWxUZW5zb3I7XHJcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xyXG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgY29uc3RydWN0b3I6IHVuc3VwcG9ydGVkIGxvY2F0aW9uICcke3RoaXMuZGF0YUxvY2F0aW9ufSdgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy9cclxuICAgICAgLy8gY29uc3RydWN0aW5nIHRlbnNvciBvZiBsb2NhdGlvbiAnY3B1J1xyXG4gICAgICAvL1xyXG4gICAgICBsZXQgZGF0YTogVGVuc29yRGF0YVR5cGU7XHJcbiAgICAgIGxldCBtYXliZURpbXM6IHR5cGVvZiBhcmcxIHwgdHlwZW9mIGFyZzI7XHJcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcclxuICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIC4uLilcclxuICAgICAgICAvL1xyXG4gICAgICAgIHR5cGUgPSBhcmcwO1xyXG4gICAgICAgIG1heWJlRGltcyA9IGFyZzI7XHJcbiAgICAgICAgaWYgKGFyZzAgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXHJcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgc3RyaW5nIHRlbnNvcidzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS5cIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcclxuICAgICAgICAgIC8vIGVycm9yIHdpbGwgYmUgcG9wdWxhdGVkIGF0IGluZmVyZW5jZVxyXG4gICAgICAgICAgZGF0YSA9IGFyZzE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG51bWVyaWMgdGVuc29yXHJcbiAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldChhcmcwKTtcclxuICAgICAgICAgIGlmICh0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHthcmcwfS5gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XHJcbiAgICAgICAgICAgIGlmICgoYXJnMCA9PT0gJ2Zsb2F0MTYnICYmIHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9PT0gVWludDE2QXJyYXkpIHx8IGFyZzAgPT09ICd1aW50NCcgfHwgYXJnMCA9PT0gJ2ludDQnKSB7XHJcbiAgICAgICAgICAgICAgLy8gLSAnZmxvYXQxNic6XHJcbiAgICAgICAgICAgICAgLy8gICBXaGVuIG5vIEZsb2F0MTZBcnJheSBwb2x5ZmlsbCBpcyB1c2VkLCB3ZSBjYW5ub3QgY3JlYXRlICdmbG9hdDE2JyB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAvLyAgIFRocm93IGVycm9yIGhlcmUgYmVjYXVzZSB3aGVuIHVzZXIgdHJ5IHRvIHVzZSBudW1iZXIgYXJyYXkgYXMgZGF0YSxcclxuICAgICAgICAgICAgICAvLyAgIGUuZy4gbmV3IFRlbnNvcignZmxvYXQxNicsIFsxLCAyLCAzLCA0XSwgZGltcykpLCBpdCB3aWxsIGFjdHVhbGx5IGNhbGxcclxuICAgICAgICAgICAgICAvLyAgIFVpbnQxNkFycmF5LmZyb20oYXJnMSkgd2hpY2ggZ2VuZXJhdGVzIHdyb25nIGRhdGEuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAvLyAtICd1aW50NCcgYW5kICdpbnQ0JzpcclxuICAgICAgICAgICAgICAvLyAgIFVpbnQ4QXJyYXkuZnJvbShhcmcxKSB3aWxsIGdlbmVyYXRlIHdyb25nIGRhdGEgZm9yICd1aW50NCcgYW5kICdpbnQ0JyB0ZW5zb3IuXHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgICAgICAgICAgYENyZWF0aW5nIGEgJHthcmcwfSB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSAke3R5cGVkQXJyYXlDb25zdHJ1Y3Rvci5uYW1lfSBhcyBkYXRhLmAsXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwID09PSAndWludDY0JyB8fCBhcmcwID09PSAnaW50NjQnKSB7XHJcbiAgICAgICAgICAgICAgLy8gdXNlICdhcyBhbnknIGhlcmUgYmVjYXVzZTpcclxuICAgICAgICAgICAgICAvLyAxLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdHlwZSBvZiAnQXJyYXkuaXNBcnJheSgpJyBkb2VzIG5vdCB3b3JrIHdpdGggcmVhZG9ubHkgYXJyYXlzLlxyXG4gICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MDAyXHJcbiAgICAgICAgICAgICAgLy8gMi4gVHlwZVNjcmlwdCdzIGNoZWNrIG9uIHVuaW9uIHR5cGUgb2YgJyhCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvcikuZnJvbSgpJ1xyXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXIgbWFwRm4uXHJcbiAgICAgICAgICAgICAgLy8gMy4gcGFyYW1ldGVycyBvZiAnU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycy5mcm9tKCknIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlbWVudCBvZiB0aGUgdW5pb25cclxuICAgICAgICAgICAgICAvLyB0eXBlLlxyXG5cclxuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBiaWdpbnRbXVwiIGhlcmUuXHJcblxyXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEsIEJpZ0ludCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW11cIiBoZXJlLlxyXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgZGF0YSA9IGFyZzE7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xyXG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ3VpbnQ4Jykge1xyXG4gICAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBVaW50OENsYW1wZWRBcnJheSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiB1aW50OGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzAgPT09ICdmbG9hdDE2JyAmJiBhcmcxIGluc3RhbmNlb2YgVWludDE2QXJyYXkgJiYgdHlwZWRBcnJheUNvbnN0cnVjdG9yICE9PSBVaW50MTZBcnJheSkge1xyXG4gICAgICAgICAgICAvLyB3aGVuIEZsb2F0MTZBcnJheSBpcyBhdmFpbGFibGUgYW5kIGRhdGEgaXMgb2YgdHlwZSBVaW50MTZBcnJheS5cclxuICAgICAgICAgICAgLy8gV2UgYWxsb3cgVWludDE2QXJyYXkgdG8gYmUgcGFzc2VkIGluIGFzIGRhdGEgZm9yICdmbG9hdDE2JyB0ZW5zb3IgdW50aWwgRmxvYXQxNkFycmF5IGlzIGdlbmVyYWxseVxyXG4gICAgICAgICAgICAvLyBzdXBwb3J0ZWQgaW4gSmF2YVNjcmlwdCBlbnZpcm9ubWVudC5cclxuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgKGdsb2JhbFRoaXMgYXMgYW55KS5GbG9hdDE2QXJyYXkoYXJnMS5idWZmZXIsIGFyZzEuYnl0ZU9mZnNldCwgYXJnMS5sZW5ndGgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke3R5cGV9IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yfWApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3RvcihkYXRhLCAuLi4pXHJcbiAgICAgICAgLy9cclxuICAgICAgICBtYXliZURpbXMgPSBhcmcxO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XHJcbiAgICAgICAgICAvLyBvbmx5IGJvb2xlYW5bXSBhbmQgc3RyaW5nW10gaXMgc3VwcG9ydGVkXHJcbiAgICAgICAgICBpZiAoYXJnMC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnRUeXBlID0gdHlwZW9mIGFyZzBbMF07XHJcbiAgICAgICAgICBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdHlwZSA9ICdzdHJpbmcnO1xyXG4gICAgICAgICAgICBkYXRhID0gYXJnMDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAnYm9vbCc7XHJcbiAgICAgICAgICAgIC8vICdhcmcwJyBpcyBvZiB0eXBlICdib29sZWFuW10nLiBVaW50OEFycmF5LmZyb20oYm9vbGVhbltdKSBhY3R1YWxseSB3b3JrcywgYnV0IHR5cGVzY3JpcHQgdGhpbmtzIHRoaXMgaXNcclxuICAgICAgICAgICAgLy8gd3JvbmcgdHlwZS4gV2UgdXNlICdhcyBhbnknIHRvIG1ha2UgaXQgaGFwcHkuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCBhcyBhbnlbXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke2ZpcnN0RWxlbWVudFR5cGV9LmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XHJcbiAgICAgICAgICB0eXBlID0gJ3VpbnQ4JztcclxuICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGdldCB0ZW5zb3IgdHlwZSBmcm9tIFR5cGVkQXJyYXlcclxuICAgICAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPSBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLmdldChcclxuICAgICAgICAgICAgYXJnMC5jb25zdHJ1Y3RvciBhcyBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGlmIChtYXBwZWRUeXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0eXBlID0gbWFwcGVkVHlwZTtcclxuICAgICAgICAgIGRhdGEgPSBhcmcwIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0eXBlIGFuZCBkYXRhIGlzIHByb2Nlc3NlZCwgbm93IHByb2Nlc3NpbmcgZGltc1xyXG4gICAgICBpZiAobWF5YmVEaW1zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcclxuICAgICAgICBtYXliZURpbXMgPSBbZGF0YS5sZW5ndGhdO1xyXG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1heWJlRGltcykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSB0ZW5zb3IncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXlcIik7XHJcbiAgICAgIH1cclxuICAgICAgZGltcyA9IG1heWJlRGltcyBhcyByZWFkb25seSBudW1iZXJbXTtcclxuXHJcbiAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XHJcbiAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ2NwdSc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcGVyZm9ybSBjaGVjayBvbiBkaW1zXHJcbiAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcclxuICAgIC8vIGlmIGRhdGEgaXMgb24gQ1BVLCBjaGVjayB3aGV0aGVyIGRhdGEgbGVuZ3RoIG1hdGNoZXMgdGVuc29yIHNpemVcclxuICAgIGlmICh0aGlzLmNwdURhdGEgJiYgc2l6ZSAhPT0gdGhpcy5jcHVEYXRhLmxlbmd0aCkge1xyXG4gICAgICBpZiAoKHR5cGUgPT09ICd1aW50NCcgfHwgdHlwZSA9PT0gJ2ludDQnKSAmJiBNYXRoLmNlaWwoc2l6ZSAvIDIpID09PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gZm9yICh1KWludDQsIHRoZSBkYXRhIGxlbmd0aCBpcyBoYWxmIG9mIHRoZSB0ZW5zb3Igc2l6ZS4gU28gd2UgY2hlY2sgdGhpcyBzcGVjaWFsIGNhc2Ugd2hlbiBzaXplIGlzIG9kZC5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHt0aGlzLmNwdURhdGEubGVuZ3RofSkuYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgdGhpcy5kaW1zID0gZGltcztcclxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgfVxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBmYWN0b3J5XHJcbiAgc3RhdGljIGFzeW5jIGZyb21JbWFnZShcclxuICAgIGltYWdlOiBJbWFnZURhdGEgfCBIVE1MSW1hZ2VFbGVtZW50IHwgSW1hZ2VCaXRtYXAgfCBzdHJpbmcsXHJcbiAgICBvcHRpb25zPzpcclxuICAgICAgfCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xyXG4gICAgICB8IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zXHJcbiAgICAgIHwgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc1xyXG4gICAgICB8IFRlbnNvckZyb21VcmxPcHRpb25zLFxyXG4gICk6IFByb21pc2U8VGVuc29ySW50ZXJmYWNlPiB7XHJcbiAgICByZXR1cm4gdGVuc29yRnJvbUltYWdlKGltYWdlLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tVGV4dHVyZTxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLlRleHR1cmVEYXRhVHlwZXM+KFxyXG4gICAgdGV4dHVyZTogVGVuc29yVGV4dHVyZVR5cGUsXHJcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4sXHJcbiAgKTogVGVuc29ySW50ZXJmYWNlIHtcclxuICAgIHJldHVybiB0ZW5zb3JGcm9tVGV4dHVyZSh0ZXh0dXJlLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tR3B1QnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcclxuICAgIGdwdUJ1ZmZlcjogVGVuc29yR3B1QnVmZmVyVHlwZSxcclxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+LFxyXG4gICk6IFRlbnNvckludGVyZmFjZSB7XHJcbiAgICByZXR1cm4gdGVuc29yRnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGZyb21NTFRlbnNvcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLk1MVGVuc29yRGF0YVR5cGVzPihcclxuICAgIG1sVGVuc29yOiBUZW5zb3JNTFRlbnNvclR5cGUsXHJcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQ+LFxyXG4gICk6IFRlbnNvckludGVyZmFjZSB7XHJcbiAgICByZXR1cm4gdGVuc29yRnJvbU1MVGVuc29yKG1sVGVuc29yLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcclxuICAgIHR5cGU6IFQsXHJcbiAgICBidWZmZXI6IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZU1hcFtUXSxcclxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcclxuICApOiBUZW5zb3Ige1xyXG4gICAgcmV0dXJuIHRlbnNvckZyb21QaW5uZWRCdWZmZXIodHlwZSwgYnVmZmVyLCBkaW1zKTtcclxuICB9XHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBjb252ZXJzaW9uc1xyXG4gIHRvRGF0YVVSTChvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGVuc29yVG9EYXRhVVJMKHRoaXMsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSB7XHJcbiAgICByZXR1cm4gdGVuc29yVG9JbWFnZURhdGEodGhpcywgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBwdWJsaWMgZmllbGRzXHJcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XHJcbiAgcmVhZG9ubHkgdHlwZTogVGVuc29yVHlwZTtcclxuICByZWFkb25seSBzaXplOiBudW1iZXI7XHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAvLyAjcmVnaW9uIHByaXZhdGUgZmllbGRzXHJcblxyXG4gIC8qKlxyXG4gICAqIHN0b3JlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBkYXRhTG9jYXRpb246IFRlbnNvckRhdGFMb2NhdGlvbjtcclxuXHJcbiAgLyoqXHJcbiAgICogc3RvcmVzIHRoZSBkYXRhIG9uIENQVSwgaWYgbG9jYXRpb24gaXMgJ2NwdScgb3IgJ2NwdS1waW5uZWQnLiBvdGhlcndpc2UgZW1wdHkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBjcHVEYXRhPzogVGVuc29yRGF0YVR5cGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyB0ZXh0dXJlIHdoZW4gbG9jYXRpb24gaXMgJ3RleHR1cmUnLiBvdGhlcndpc2UgZW1wdHkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBncHVUZXh0dXJlRGF0YT86IFRlbnNvclRleHR1cmVUeXBlO1xyXG5cclxuICAvKipcclxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgR1BVIGJ1ZmZlciB3aGVuIGxvY2F0aW9uIGlzICdncHUtYnVmZmVyJy4gb3RoZXJ3aXNlIGVtcHR5LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ3B1QnVmZmVyRGF0YT86IFRlbnNvckdwdUJ1ZmZlclR5cGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyBXZWJOTiBNTFRlbnNvciB3aGVuIGxvY2F0aW9uIGlzICdtbC10ZW5zb3InLiBvdGhlcndpc2UgZW1wdHkuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBtbFRlbnNvckRhdGE/OiBUZW5zb3JNTFRlbnNvclR5cGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIHN0b3JlcyBhbiBvcHRpb25hbCBkb3dubG9hZGVyIGZ1bmN0aW9uIHRvIGRvd25sb2FkIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgZG93bmxvYWRlcj8oKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT47XHJcblxyXG4gIC8qKlxyXG4gICAqIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgaXMgYmVpbmcgZG93bmxvYWRlZCBmcm9tIEdQVSB0byBDUFUuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBpc0Rvd25sb2FkaW5nPzogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRpc3Bvc2VyIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHVuZGVybHlpbmcgZGF0YS5cclxuICAgKi9cclxuICBwcml2YXRlIGRpc3Bvc2VyPygpOiB2b2lkO1xyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBwcm9wZXJ0aWVzXHJcbiAgZ2V0IGRhdGEoKTogVGVuc29yRGF0YVR5cGUge1xyXG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xyXG4gICAgaWYgKCF0aGlzLmNwdURhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICdUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCAnICtcclxuICAgICAgICAgICdvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuJyxcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmNwdURhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgbG9jYXRpb24oKTogVGVuc29yRGF0YUxvY2F0aW9uIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGFMb2NhdGlvbjtcclxuICB9XHJcblxyXG4gIGdldCB0ZXh0dXJlKCk6IFRlbnNvclRleHR1cmVUeXBlIHtcclxuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcclxuICAgIGlmICghdGhpcy5ncHVUZXh0dXJlRGF0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgZ3B1QnVmZmVyKCk6IFRlbnNvckdwdUJ1ZmZlclR5cGUge1xyXG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xyXG4gICAgaWYgKCF0aGlzLmdwdUJ1ZmZlckRhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR1BVIGJ1ZmZlci4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgbWxUZW5zb3IoKTogVGVuc29yTUxUZW5zb3JUeXBlIHtcclxuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcclxuICAgIGlmICghdGhpcy5tbFRlbnNvckRhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5tbFRlbnNvckRhdGE7XHJcbiAgfVxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBtZXRob2RzXHJcblxyXG4gIGFzeW5jIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT4ge1xyXG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xyXG4gICAgc3dpdGNoICh0aGlzLmRhdGFMb2NhdGlvbikge1xyXG4gICAgICBjYXNlICdjcHUnOlxyXG4gICAgICBjYXNlICdjcHUtcGlubmVkJzpcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgICBjYXNlICd0ZXh0dXJlJzpcclxuICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XHJcbiAgICAgIGNhc2UgJ21sLXRlbnNvcic6IHtcclxuICAgICAgICBpZiAoIXRoaXMuZG93bmxvYWRlcikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZG93bmxvYWRlcigpO1xyXG4gICAgICAgICAgdGhpcy5kb3dubG9hZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcclxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAgICAgaWYgKHJlbGVhc2VEYXRhICYmIHRoaXMuZGlzcG9zZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwb3NlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kaXNwb3Nlcikge1xyXG4gICAgICB0aGlzLmRpc3Bvc2VyKCk7XHJcbiAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNwdURhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmdwdVRleHR1cmVEYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5ncHVCdWZmZXJEYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5tbFRlbnNvckRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnbm9uZSc7XHJcbiAgfVxyXG5cclxuICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gIC8vICNyZWdpb24gdGVuc29yIHV0aWxpdGllc1xyXG4gIHByaXZhdGUgZW5zdXJlVmFsaWQoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5kYXRhTG9jYXRpb24gPT09ICdub25lJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29ySW50ZXJmYWNlIHtcclxuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcclxuICAgIGlmICh0aGlzLmRvd25sb2FkZXIgfHwgdGhpcy5kaXNwb3Nlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVuc29yUmVzaGFwZSh0aGlzLCBkaW1zKTtcclxuICB9XHJcbiAgLy8gI2VuZHJlZ2lvblxyXG59XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yRmFjdG9yeSB9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xyXG5pbXBvcnQgeyBUZW5zb3IgYXMgVGVuc29ySW1wbCB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xyXG5pbXBvcnQgeyBUeXBlZFRlbnNvclV0aWxzIH0gZnJvbSAnLi90ZW5zb3ItdXRpbHMuanMnO1xyXG5pbXBvcnQgeyBUcnlHZXRHbG9iYWxUeXBlIH0gZnJvbSAnLi90eXBlLWhlbHBlci5qcyc7XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXHJcblxyXG4vKipcclxuICogcmVwcmVzZW50IGEgYmFzaWMgdGVuc29yIHdpdGggc3BlY2lmaWVkIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZS5cclxuICovXHJcbmludGVyZmFjZSBUeXBlZFRlbnNvckJhc2U8VCBleHRlbmRzIFRlbnNvci5UeXBlPiB7XHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cclxuICAgKi9cclxuICByZWFkb25seSB0eXBlOiBUO1xyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cclxuICAgKlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBDUFUgKGVnLiBpdCdzIGluIHRoZSBmb3JtIG9mIFdlYkdMIHRleHR1cmUgb3IgV2ViR1BVIGJ1ZmZlciksIHRocm93IGVycm9yLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcclxuICAvKipcclxuICAgKiBHZXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiBUZW5zb3IuRGF0YUxvY2F0aW9uO1xyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR0wgdGV4dHVyZSwgdGhyb3cgZXJyb3IuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgdGV4dHVyZTogVGVuc29yLlRleHR1cmVUeXBlO1xyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR1BVIGJ1ZmZlciwgdGhyb3cgZXJyb3IuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgZ3B1QnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBXZWJOTiBNTFRlbnNvciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBpbiBhIFdlYk5OIE1MVGVuc29yLCB0aHJvdyBlcnJvci5cclxuICAgKi9cclxuICByZWFkb25seSBtbFRlbnNvcjogVGVuc29yLk1MVGVuc29yVHlwZTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZXR1cm5zIHRoZSBkYXRhIGltbWVkaWF0ZWx5LlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgZG93bmxvYWRzIHRoZSBkYXRhIGFuZCByZXR1cm5zIHRoZSBwcm9taXNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlbGVhc2VEYXRhIC0gd2hldGhlciByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS4gSWdub3JlIGlmIGRhdGEgaXMgYWxyZWFkeSBvbiBDUFUuXHJcbiAgICovXHJcbiAgZ2V0RGF0YShyZWxlYXNlRGF0YT86IGJvb2xlYW4pOiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZU1hcFtUXT47XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3Bvc2UgdGhlIHRlbnNvciBkYXRhLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZW1vdmUgaXRzIGludGVybmFsIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBkYXRhLlxyXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuXHJcbiAgICpcclxuICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIHRoZSB0ZW5zb3IgaXMgY29uc2lkZXJlZCBubyBsb25nZXIgdmFsaWQuIEl0cyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnbm9uZScuXHJcbiAgICovXHJcbiAgZGlzcG9zZSgpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVGVuc29yIHtcclxuICBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xyXG4gICAgZmxvYXQzMjogRmxvYXQzMkFycmF5O1xyXG4gICAgdWludDg6IFVpbnQ4QXJyYXk7XHJcbiAgICBpbnQ4OiBJbnQ4QXJyYXk7XHJcbiAgICB1aW50MTY6IFVpbnQxNkFycmF5O1xyXG4gICAgaW50MTY6IEludDE2QXJyYXk7XHJcbiAgICBpbnQzMjogSW50MzJBcnJheTtcclxuICAgIGludDY0OiBCaWdJbnQ2NEFycmF5O1xyXG4gICAgc3RyaW5nOiBzdHJpbmdbXTtcclxuICAgIGJvb2w6IFVpbnQ4QXJyYXk7XHJcbiAgICBmbG9hdDE2OiBVaW50MTZBcnJheTsgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxyXG4gICAgZmxvYXQ2NDogRmxvYXQ2NEFycmF5O1xyXG4gICAgdWludDMyOiBVaW50MzJBcnJheTtcclxuICAgIHVpbnQ2NDogQmlnVWludDY0QXJyYXk7XHJcbiAgICAvLyBjb21wbGV4NjQ6IG5ldmVyO1xyXG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XHJcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XHJcbiAgICB1aW50NDogVWludDhBcnJheTtcclxuICAgIGludDQ6IEludDhBcnJheTtcclxuICB9XHJcblxyXG4gIGludGVyZmFjZSBFbGVtZW50VHlwZU1hcCB7XHJcbiAgICBmbG9hdDMyOiBudW1iZXI7XHJcbiAgICB1aW50ODogbnVtYmVyO1xyXG4gICAgaW50ODogbnVtYmVyO1xyXG4gICAgdWludDE2OiBudW1iZXI7XHJcbiAgICBpbnQxNjogbnVtYmVyO1xyXG4gICAgaW50MzI6IG51bWJlcjtcclxuICAgIGludDY0OiBiaWdpbnQ7XHJcbiAgICBzdHJpbmc6IHN0cmluZztcclxuICAgIGJvb2w6IGJvb2xlYW47XHJcbiAgICBmbG9hdDE2OiBudW1iZXI7IC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cclxuICAgIGZsb2F0NjQ6IG51bWJlcjtcclxuICAgIHVpbnQzMjogbnVtYmVyO1xyXG4gICAgdWludDY0OiBiaWdpbnQ7XHJcbiAgICAvLyBjb21wbGV4NjQ6IG5ldmVyO1xyXG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XHJcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XHJcbiAgICB1aW50NDogbnVtYmVyO1xyXG4gICAgaW50NDogbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgdHlwZSBEYXRhVHlwZSA9IERhdGFUeXBlTWFwW1R5cGVdO1xyXG4gIHR5cGUgRWxlbWVudFR5cGUgPSBFbGVtZW50VHlwZU1hcFtUeXBlXTtcclxuXHJcbiAgLyoqXHJcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBDcHVQaW5uZWREYXRhVHlwZXMgPSBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJz47XHJcblxyXG4gIC8qKlxyXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdMIHRleHR1cmVcclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBUZXh0dXJlVHlwZSA9IFdlYkdMVGV4dHVyZTtcclxuXHJcbiAgLyoqXHJcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic7XHJcblxyXG4gIHR5cGUgR3B1QnVmZmVyVHlwZUZhbGxiYWNrID0geyBzaXplOiBudW1iZXI7IG1hcFN0YXRlOiAndW5tYXBwZWQnIHwgJ3BlbmRpbmcnIHwgJ21hcHBlZCcgfTtcclxuICAvKipcclxuICAgKiB0eXBlIGFsaWFzIGZvciBXZWJHUFUgYnVmZmVyXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyVHlwZSA9IFRyeUdldEdsb2JhbFR5cGU8J0dQVUJ1ZmZlcicsIEdwdUJ1ZmZlclR5cGVGYWxsYmFjaz47XHJcblxyXG4gIHR5cGUgTUxUZW5zb3JUeXBlRmFsbGJhY2sgPSB7IGRlc3Ryb3koKTogdm9pZCB9O1xyXG4gIC8qKlxyXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYk5OIE1MVGVuc29yXHJcbiAgICpcclxuICAgKiBUaGUgc3BlY2lmaWNhdGlvbiBmb3IgV2ViTk4ncyBNTFRlbnNvciBpcyBjdXJyZW50bHkgaW4gZmx1eC5cclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBNTFRlbnNvclR5cGUgPSBUcnlHZXRHbG9iYWxUeXBlPCdNTFRlbnNvcicsIE1MVGVuc29yVHlwZUZhbGxiYWNrPjtcclxuXHJcbiAgLyoqXHJcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIEdwdUJ1ZmZlckRhdGFUeXBlcyA9ICdmbG9hdDMyJyB8ICdmbG9hdDE2JyB8ICdpbnQzMicgfCAnaW50NjQnIHwgJ3VpbnQzMicgfCAndWludDgnIHwgJ2Jvb2wnO1xyXG5cclxuICAvKipcclxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJOTiBNTFRlbnNvclxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIE1MVGVuc29yRGF0YVR5cGVzID1cclxuICAgIHwgJ2Zsb2F0MzInXHJcbiAgICB8ICdmbG9hdDE2J1xyXG4gICAgfCAnaW50OCdcclxuICAgIHwgJ3VpbnQ4J1xyXG4gICAgfCAnaW50MzInXHJcbiAgICB8ICd1aW50MzInXHJcbiAgICB8ICdpbnQ2NCdcclxuICAgIHwgJ3VpbnQ2NCdcclxuICAgIHwgJ2Jvb2wnXHJcbiAgICB8ICd1aW50NCdcclxuICAgIHwgJ2ludDQnO1xyXG5cclxuICAvKipcclxuICAgKiByZXByZXNlbnQgd2hlcmUgdGhlIHRlbnNvciBkYXRhIGlzIHN0b3JlZFxyXG4gICAqL1xyXG4gIGV4cG9ydCB0eXBlIERhdGFMb2NhdGlvbiA9ICdub25lJyB8ICdjcHUnIHwgJ2NwdS1waW5uZWQnIHwgJ3RleHR1cmUnIHwgJ2dwdS1idWZmZXInIHwgJ21sLXRlbnNvcic7XHJcblxyXG4gIC8qKlxyXG4gICAqIHJlcHJlc2VudCB0aGUgZGF0YSB0eXBlIG9mIGEgdGVuc29yXHJcbiAgICovXHJcbiAgZXhwb3J0IHR5cGUgVHlwZSA9IGtleW9mIERhdGFUeXBlTWFwO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50IG11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyB0byBmZWVkIHRvIG9yIGZldGNoIGZyb20gbW9kZWwgaW5mZXJlbmNpbmcuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVkVGVuc29yPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4gZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VD4sIFR5cGVkVGVuc29yVXRpbHM8VD4ge31cclxuLyoqXHJcbiAqIFJlcHJlc2VudCBtdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgdG8gZmVlZCB0byBvciBmZXRjaCBmcm9tIG1vZGVsIGluZmVyZW5jaW5nLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3IgZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VGVuc29yLlR5cGU+LCBUeXBlZFRlbnNvclV0aWxzPFRlbnNvci5UeXBlPiB7fVxyXG5cclxuLyoqXHJcbiAqIHR5cGUgVGVuc29yQ29uc3RydWN0b3IgZGVmaW5lcyB0aGUgY29uc3RydWN0b3JzIG9mICdUZW5zb3InIHRvIGNyZWF0ZSBDUFUgdGVuc29yIGluc3RhbmNlcy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yQ29uc3RydWN0b3IgZXh0ZW5kcyBUZW5zb3JGYWN0b3J5IHtcclxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBzcGVjaWZ5IGVsZW1lbnQgdHlwZVxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyBzdHJpbmcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChcclxuICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXSB8IHJlYWRvbmx5IHN0cmluZ1tdLFxyXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChcclxuICAgIHR5cGU6ICdib29sJyxcclxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFsnYm9vbCddIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxyXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IFR5cGVkVGVuc29yPCdib29sJz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gYSBVaW50OENsYW1wZWRBcnJheSwgZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAodHlwZTogJ3VpbnQ4JywgZGF0YTogVWludDhDbGFtcGVkQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgNjQtYml0IGludGVnZXIgdHlwZWQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IDxUIGV4dGVuZHMgJ3VpbnQ2NCcgfCAnaW50NjQnPihcclxuICAgIHR5cGU6IFQsXHJcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0gfCByZWFkb25seSBiaWdpbnRbXSB8IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgbnVtZXJpYyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgPFQgZXh0ZW5kcyBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJyB8ICdib29sJyB8ICd1aW50NjQnIHwgJ2ludDY0Jz4+KFxyXG4gICAgdHlwZTogVCxcclxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXSB8IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gaW5mZXIgZWxlbWVudCB0eXBlc1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKGRhdGE6IEZsb2F0MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Zsb2F0MzInPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBJbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ4Jz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKGRhdGE6IFVpbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBVaW50OENsYW1wZWRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ4Jz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50MTYgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBVaW50MTZBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQxNic+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50MTYgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBJbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MTYnPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAoZGF0YTogSW50MzJBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDMyJz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKGRhdGE6IEJpZ0ludDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ2NCc+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAoZGF0YTogcmVhZG9ubHkgc3RyaW5nW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiByZWFkb25seSBib29sZWFuW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdib29sJz47XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyBmbG9hdDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAoZGF0YTogRmxvYXQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnZmxvYXQ2NCc+O1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxyXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxyXG4gICAqL1xyXG4gIG5ldyAoZGF0YTogVWludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MzInPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKGRhdGE6IEJpZ1VpbnQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDY0Jz47XHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gZmFsbCBiYWNrIHRvIG5vbi1nZW5lcmljIHRlbnNvciB0eXBlIGRlY2xhcmF0aW9uXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cclxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cclxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKi9cclxuICBuZXcgKFxyXG4gICAgdHlwZTogVGVuc29yLlR5cGUsXHJcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGUgfCByZWFkb25seSBudW1iZXJbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgcmVhZG9ubHkgYmlnaW50W10gfCByZWFkb25seSBib29sZWFuW10sXHJcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKTogVGVuc29yO1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXHJcbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXHJcbiAgICovXHJcbiAgbmV3IChkYXRhOiBUZW5zb3IuRGF0YVR5cGUsIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvcjtcclxuICAvLyAjZW5kcmVnaW9uXHJcbn1cclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cclxuZXhwb3J0IGNvbnN0IFRlbnNvciA9IFRlbnNvckltcGwgYXMgVGVuc29yQ29uc3RydWN0b3I7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XHJcblxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRSQUNFID0gKGRldmljZVR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZykgPT4ge1xyXG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICBjb25zb2xlLnRpbWVTdGFtcChgJHtkZXZpY2VUeXBlfTo6T1JUOjoke2xhYmVsfWApO1xyXG59O1xyXG5cclxuY29uc3QgVFJBQ0VfRlVOQyA9IChtc2c6IHN0cmluZywgZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcclxuICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZykgfHwgW107XHJcbiAgbGV0IGhhc1RyYWNlRnVuYyA9IGZhbHNlO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChoYXNUcmFjZUZ1bmMgJiYgIXN0YWNrW2ldLmluY2x1ZGVzKCdUUkFDRV9GVU5DJykpIHtcclxuICAgICAgbGV0IGxhYmVsID0gYEZVTkNfJHttc2d9Ojoke3N0YWNrW2ldLnRyaW0oKS5zcGxpdCgnICcpWzFdfWA7XHJcbiAgICAgIGlmIChleHRyYU1zZykge1xyXG4gICAgICAgIGxhYmVsICs9IGA6OiR7ZXh0cmFNc2d9YDtcclxuICAgICAgfVxyXG4gICAgICBUUkFDRSgnQ1BVJywgbGFiZWwpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xyXG4gICAgICBoYXNUcmFjZUZ1bmMgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19CRUdJTiA9IChleHRyYU1zZz86IHN0cmluZykgPT4ge1xyXG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgVFJBQ0VfRlVOQygnQkVHSU4nLCBleHRyYU1zZyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfRU5EID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBUUkFDRV9GVU5DKCdFTkQnLCBleHRyYU1zZyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRSQUNFX0VWRU5UX0JFR0lOID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gIGNvbnNvbGUudGltZShgT1JUOjoke2V4dHJhTXNnfWApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBjb25zdCBUUkFDRV9FVkVOVF9FTkQgPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcclxuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgY29uc29sZS50aW1lRW5kKGBPUlQ6OiR7ZXh0cmFNc2d9YCk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMgfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XHJcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcclxuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XHJcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XHJcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcclxuaW1wb3J0IHsgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkQsIFRSQUNFX0VWRU5UX0JFR0lOLCBUUkFDRV9FVkVOVF9FTkQgfSBmcm9tICcuL3RyYWNlLmpzJztcclxuXHJcbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xyXG50eXBlIFJ1bk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlJ1bk9wdGlvbnM7XHJcbnR5cGUgRmVlZHNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5GZWVkc1R5cGU7XHJcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xyXG50eXBlIFJldHVyblR5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlJldHVyblR5cGU7XHJcblxyXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xyXG4gIHByaXZhdGUgY29uc3RydWN0b3IoaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIpIHtcclxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgfVxyXG4gIHJ1bihmZWVkczogRmVlZHNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XHJcbiAgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGZldGNoZXM6IEZldGNoZXNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XHJcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XHJcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XHJcbiAgICBUUkFDRV9FVkVOVF9CRUdJTignSW5mZXJlbmNlU2Vzc2lvbi5ydW4nKTtcclxuICAgIGNvbnN0IGZldGNoZXM6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfSA9IHt9O1xyXG4gICAgbGV0IG9wdGlvbnM6IFJ1bk9wdGlvbnMgPSB7fTtcclxuICAgIC8vIGNoZWNrIGlucHV0c1xyXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICBcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XHJcbiAgICAvLyBkZXRlcm1pbmUgd2hpY2ggb3ZlcnJpZGUgaXMgYmVpbmcgdXNlZFxyXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYSBUZW5zb3JcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XHJcbiAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xyXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXHJcbiAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcclxuICAgICAgICAgIGlmIChhcmcxS2V5cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCB2ID0gKGFyZzEgYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5OdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGUpW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XHJcbiAgICAgICAgICAgICAgaXNGZXRjaGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNGZXRjaGVzKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNoZWNrIGlmIGFsbCBpbnB1dHMgYXJlIGluIGZlZWRcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmlucHV0TmFtZXMpIHtcclxuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke25hbWV9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XHJcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcclxuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcclxuICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcclxuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfSA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xyXG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywga2V5KSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcclxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVGVuc29yKSB7XHJcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gcmVzdWx0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gbmV3IFRlbnNvcihyZXN1bHQudHlwZSwgcmVzdWx0LmRhdGEsIHJlc3VsdC5kaW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFRSQUNFX0VWRU5UX0VORCgnSW5mZXJlbmNlU2Vzc2lvbi5ydW4nKTtcclxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XHJcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XHJcbiAgfVxyXG5cclxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY3JlYXRlKHBhdGg6IHN0cmluZywgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcclxuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xyXG4gIHN0YXRpYyBjcmVhdGUoXHJcbiAgICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZSxcclxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcclxuICAgIGJ5dGVMZW5ndGg/OiBudW1iZXIsXHJcbiAgICBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcclxuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcclxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKFxyXG4gICAgYXJnMDogc3RyaW5nIHwgQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheSxcclxuICAgIGFyZzE/OiBTZXNzaW9uT3B0aW9ucyB8IG51bWJlcixcclxuICAgIGFyZzI/OiBudW1iZXIsXHJcbiAgICBhcmczPzogU2Vzc2lvbk9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPiB7XHJcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XHJcbiAgICBUUkFDRV9FVkVOVF9CRUdJTignSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUnKTtcclxuICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxyXG4gICAgbGV0IGZpbGVQYXRoT3JVaW50OEFycmF5OiBzdHJpbmcgfCBVaW50OEFycmF5O1xyXG4gICAgbGV0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0ge307XHJcblxyXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xyXG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XHJcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSBhcmcxO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcclxuICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGFyZzAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxyXG4gICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpXHJcbiAgICApIHtcclxuICAgICAgY29uc3QgYnVmZmVyID0gYXJnMDtcclxuICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xyXG4gICAgICBsZXQgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aDtcclxuICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYnl0ZU9mZnNldCA9IGFyZzE7XHJcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlT2Zmc2V0KSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke2J1ZmZlci5ieXRlTGVuZ3RofSkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBhcmcyO1xyXG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlTGVuZ3RoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke2J1ZmZlci5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldH1dLmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcclxuICAgIGNvbnN0IFtiYWNrZW5kLCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQc10gPSBhd2FpdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyhvcHRpb25zKTtcclxuICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGZpbGVQYXRoT3JVaW50OEFycmF5LCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQcyk7XHJcbiAgICBUUkFDRV9FVkVOVF9FTkQoJ0luZmVyZW5jZVNlc3Npb24uY3JlYXRlJyk7XHJcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xyXG4gICAgcmV0dXJuIG5ldyBJbmZlcmVuY2VTZXNzaW9uKGhhbmRsZXIpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XHJcbiAgICB0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKTtcclxuICB9XHJcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xyXG4gICAgdGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGlucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzO1xyXG4gIH1cclxuICBnZXQgb3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcclxuICB9XHJcblxyXG4gIGdldCBpbnB1dE1ldGFkYXRhKCk6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuVmFsdWVNZXRhZGF0YVtdIHtcclxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXRNZXRhZGF0YTtcclxuICB9XHJcblxyXG4gIGdldCBvdXRwdXRNZXRhZGF0YSgpOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlZhbHVlTWV0YWRhdGFbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE1ldGFkYXRhO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVyOiBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcjtcclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGwgfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMnO1xyXG5pbXBvcnQgeyBPbm54TW9kZWxPcHRpb25zIH0gZnJvbSAnLi9vbm54LW1vZGVsLmpzJztcclxuaW1wb3J0IHsgT25ueFZhbHVlLCBPbm54VmFsdWVEYXRhTG9jYXRpb24gfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xyXG5pbXBvcnQgdHlwZSB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcclxuaW1wb3J0IHsgVHJ5R2V0R2xvYmFsVHlwZSB9IGZyb20gJy4vdHlwZS1oZWxwZXIuanMnO1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xyXG5cclxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEluZmVyZW5jZVNlc3Npb24ge1xyXG4gIC8vICNyZWdpb24gaW5wdXQvb3V0cHV0IHR5cGVzXHJcblxyXG4gIHR5cGUgT25ueFZhbHVlTWFwVHlwZSA9IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9O1xyXG4gIHR5cGUgTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlID0geyByZWFkb25seSBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbCB9O1xyXG5cclxuICAvKipcclxuICAgKiBBIGZlZWRzIChtb2RlbCBpbnB1dHMpIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxyXG4gICAqL1xyXG4gIHR5cGUgRmVlZHNUeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBmZXRjaGVzIChtb2RlbCBvdXRwdXRzKSBjb3VsZCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcclxuICAgKlxyXG4gICAqIC0gT21pdHRlZC4gVXNlIG1vZGVsJ3Mgb3V0cHV0IG5hbWVzIGRlZmluaXRpb24uXHJcbiAgICogLSBBbiBhcnJheSBvZiBzdHJpbmcgaW5kaWNhdGluZyB0aGUgb3V0cHV0IG5hbWVzLlxyXG4gICAqIC0gQW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgb3IgbnVsbCBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEByZW1hcmtcclxuICAgKiBkaWZmZXJlbnQgZnJvbSBpbnB1dCBhcmd1bWVudCwgaW4gb3V0cHV0LCBPbm54VmFsdWUgaXMgb3B0aW9uYWwuIElmIGFuIE9ubnhWYWx1ZSBpcyBwcmVzZW50IGl0IHdpbGwgYmVcclxuICAgKiB1c2VkIGFzIGEgcHJlLWFsbG9jYXRlZCB2YWx1ZSBieSB0aGUgaW5mZXJlbmNlIGVuZ2luZTsgaWYgb21pdHRlZCwgaW5mZXJlbmNlIGVuZ2luZSB3aWxsIGFsbG9jYXRlIGJ1ZmZlclxyXG4gICAqIGludGVybmFsbHkuXHJcbiAgICovXHJcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHJlYWRvbmx5IHN0cmluZ1tdIHwgTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlO1xyXG5cclxuICAvKipcclxuICAgKiBBIGluZmVyZW5jaW5nIHJldHVybiB0eXBlIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cclxuICAgKi9cclxuICB0eXBlIFJldHVyblR5cGUgPSBPbm54VmFsdWVNYXBUeXBlO1xyXG5cclxuICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gIC8vICNyZWdpb24gc2Vzc2lvbiBvcHRpb25zXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBzZXNzaW9uIGJlaGF2aW9yLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbk9wdGlvbnMgZXh0ZW5kcyBPbm54TW9kZWxPcHRpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQW4gZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbiBjYW4gYmUgYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgbmFtZSBvZiB0aGUgZXhlY3V0aW9uIHByb3ZpZGVyLFxyXG4gICAgICogb3IgYW4gb2JqZWN0IG9mIGNvcnJlc3BvbmRpbmcgdHlwZS5cclxuICAgICAqL1xyXG4gICAgZXhlY3V0aW9uUHJvdmlkZXJzPzogcmVhZG9ubHkgRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbnRyYSBPUCB0aHJlYWRzIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cclxuICAgICAqL1xyXG4gICAgaW50cmFPcE51bVRocmVhZHM/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW50ZXIgT1AgdGhyZWFkcyBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXHJcbiAgICAgKi9cclxuICAgIGludGVyT3BOdW1UaHJlYWRzPzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcclxuICAgICAqL1xyXG4gICAgZnJlZURpbWVuc2lvbk92ZXJyaWRlcz86IHsgcmVhZG9ubHkgW2RpbWVuc2lvbk5hbWU6IHN0cmluZ106IG51bWJlciB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wdGltaXphdGlvbiBsZXZlbC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/OiAnZGlzYWJsZWQnIHwgJ2Jhc2ljJyB8ICdleHRlbmRlZCcgfCAnbGF5b3V0JyB8ICdhbGwnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBlbmFibGUgQ1BVIG1lbW9yeSBhcmVuYS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIGVuYWJsZUNwdU1lbUFyZW5hPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgZW5hYmxlIG1lbW9yeSBwYXR0ZXJuLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcclxuICAgICAqL1xyXG4gICAgZW5hYmxlTWVtUGF0dGVybj86IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRpb24gbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIGV4ZWN1dGlvbk1vZGU/OiAnc2VxdWVudGlhbCcgfCAncGFyYWxsZWwnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3B0aW1pemVkIG1vZGVsIGZpbGUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGlzIHNldHRpbmcgaXMgc3BlY2lmaWVkLCB0aGUgb3B0aW1pemVkIG1vZGVsIHdpbGwgYmUgZHVtcGVkLiBJbiBicm93c2VyLCBhIGJsb2Igd2lsbCBiZSBjcmVhdGVkXHJcbiAgICAgKiB3aXRoIGEgcG9wLXVwIHdpbmRvdy5cclxuICAgICAqL1xyXG4gICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aD86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgZW5hYmxlIHByb2ZpbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxyXG4gICAgICovXHJcbiAgICBlbmFibGVQcm9maWxpbmc/OiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsZSBwcmVmaXggZm9yIHByb2ZpbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxyXG4gICAgICovXHJcbiAgICBwcm9maWxlRmlsZVByZWZpeD86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBJRC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIGxvZ0lkPzogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcclxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9jb21tb24vbG9nZ2luZy9zZXZlcml0eS5oXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxyXG4gICAgICovXHJcbiAgICBsb2dTZXZlcml0eUxldmVsPzogMCB8IDEgfCAyIHwgMyB8IDQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcclxuICAgICAqL1xyXG4gICAgbG9nVmVyYm9zaXR5TGV2ZWw/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IHN0cmluZyBhcyBhIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGZvciBhbGwgb3V0cHV0cywgb3IgYW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBhXHJcbiAgICAgKiBwcmVmZXJyZWQgZGF0YSBsb2NhdGlvbiBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHTCBhbmQgV2ViR1BVIEVQLlxyXG4gICAgICovXHJcbiAgICBwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj86IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB8IHsgcmVhZG9ubHkgW291dHB1dE5hbWU6IHN0cmluZ106IE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBlbmFibGUgZ3JhcGggY2FwdHVyZS5cclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSBXZWIgZm9yIFdlYkdQVSBFUC5cclxuICAgICAqL1xyXG4gICAgZW5hYmxlR3JhcGhDYXB0dXJlPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlIGNvbmZpZ3VyYXRpb25zIGZvciBhIHNlc3Npb24uIFNlZVxyXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXHJcbiAgICAgKiBvbm54cnVudGltZV9zZXNzaW9uX29wdGlvbnNfY29uZmlnX2tleXMuaFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBganNcclxuICAgICAqIGV4dHJhOiB7XHJcbiAgICAgKiAgIHNlc3Npb246IHtcclxuICAgICAqICAgICBzZXRfZGVub3JtYWxfYXNfemVybzogXCIxXCIsXHJcbiAgICAgKiAgICAgZGlzYWJsZV9wcmVwYWNraW5nOiBcIjFcIlxyXG4gICAgICogICB9LFxyXG4gICAgICogICBvcHRpbWl6YXRpb246IHtcclxuICAgICAqICAgICBlbmFibGVfZ2VsdV9hcHByb3hpbWF0aW9uOiBcIjFcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICB9XHJcblxyXG4gIC8vICNyZWdpb24gZXhlY3V0aW9uIHByb3ZpZGVyc1xyXG5cclxuICAvLyBDdXJyZW50bHksIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBiYWNrZW5kcyB0byBzdXBwb3J0IGV4ZWN1dGlvbiBwcm92aWRlcnM6XHJcbiAgLy8gQmFja2VuZCBOb2RlLmpzIGJpbmRpbmc6IHN1cHBvcnRzICdjcHUnLCAnZG1sJyAod2luMzIpLCAnY29yZW1sJyAobWFjT1MpIGFuZCAnY3VkYScgKGxpbnV4KS5cclxuICAvLyBCYWNrZW5kIFdlYkFzc2VtYmx5OiBzdXBwb3J0cyAnY3B1JywgJ3dhc20nLCAnd2ViZ3B1JyBhbmQgJ3dlYm5uJy5cclxuICAvLyBCYWNrZW5kIE9OTlguanM6IHN1cHBvcnRzICd3ZWJnbCcuXHJcbiAgLy8gQmFja2VuZCBSZWFjdCBOYXRpdmU6IHN1cHBvcnRzICdjcHUnLCAneG5ucGFjaycsICdjb3JlbWwnIChpT1MpLCAnbm5hcGknIChBbmRyb2lkKS5cclxuICBpbnRlcmZhY2UgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXAge1xyXG4gICAgY29yZW1sOiBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcclxuICAgIGNwdTogQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICBjdWRhOiBDdWRhRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICBkbWw6IERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xyXG4gICAgbm5hcGk6IE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICB0ZW5zb3JydDogVGVuc29yUnRFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcclxuICAgIHdhc206IFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICB3ZWJnbDogV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcclxuICAgIHdlYmdwdTogV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICB3ZWJubjogV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcclxuICAgIHFubjogUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICB4bm5wYWNrOiBYbm5wYWNrRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgfVxyXG5cclxuICB0eXBlIEV4ZWN1dGlvblByb3ZpZGVyTmFtZSA9IGtleW9mIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uTWFwO1xyXG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJDb25maWcgPVxyXG4gICAgfCBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcFtFeGVjdXRpb25Qcm92aWRlck5hbWVdXHJcbiAgICB8IEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uXHJcbiAgICB8IEV4ZWN1dGlvblByb3ZpZGVyTmFtZVxyXG4gICAgfCBzdHJpbmc7XHJcblxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogJ2NwdSc7XHJcbiAgICB1c2VBcmVuYT86IGJvb2xlYW47XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogJ2N1ZGEnO1xyXG4gICAgZGV2aWNlSWQ/OiBudW1iZXI7XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgRG1sRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XHJcbiAgICByZWFkb25seSBuYW1lOiAnZG1sJztcclxuICAgIGRldmljZUlkPzogbnVtYmVyO1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XHJcbiAgICByZWFkb25seSBuYW1lOiAndGVuc29ycnQnO1xyXG4gICAgZGV2aWNlSWQ/OiBudW1iZXI7XHJcbiAgfVxyXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICd3YXNtJztcclxuICB9XHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYmdsJztcclxuICAgIC8vIFRPRE86IGFkZCBmbGFnc1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIFhubnBhY2tFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICd4bm5wYWNrJztcclxuICB9XHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJncHUnO1xyXG4gICAgcHJlZmVycmVkTGF5b3V0PzogJ05DSFcnIHwgJ05IV0MnO1xyXG4gIH1cclxuXHJcbiAgLy8gI3JlZ2lvbiBXZWJOTiBvcHRpb25zXHJcblxyXG4gIGludGVyZmFjZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJubic7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgV2ViTk4gTUxDb250ZXh0LlxyXG4gICAqXHJcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RpY3RkZWYtbWxjb250ZXh0b3B0aW9uc1xyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5Db250ZXh0T3B0aW9ucyB7XHJcbiAgICBkZXZpY2VUeXBlPzogJ2NwdScgfCAnZ3B1JyB8ICducHUnO1xyXG4gICAgbnVtVGhyZWFkcz86IG51bWJlcjtcclxuICAgIHBvd2VyUHJlZmVyZW5jZT86ICdkZWZhdWx0JyB8ICdsb3ctcG93ZXInIHwgJ2hpZ2gtcGVyZm9ybWFuY2UnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aG91dCBNTENvbnRleHQuXHJcbiAgICovXHJcbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXaXRob3V0TUxDb250ZXh0IGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUsIFdlYk5OQ29udGV4dE9wdGlvbnMge1xyXG4gICAgY29udGV4dD86IG5ldmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aCBNTENvbnRleHQuXHJcbiAgICpcclxuICAgKiBXaGVuIE1MQ29udGV4dCBpcyBwcm92aWRlZCwgdGhlIGRldmljZVR5cGUgaXMgYWxzbyByZXF1aXJlZCBzbyB0aGF0IHRoZSBXZWJOTiBFUCBjYW4gZGV0ZXJtaW5lIHRoZSBwcmVmZXJyZWRcclxuICAgKiBjaGFubmVsIGxheW91dC5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dFxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dFxyXG4gICAgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSxcclxuICAgICAgT21pdDxXZWJOTkNvbnRleHRPcHRpb25zLCAnZGV2aWNlVHlwZSc+LFxyXG4gICAgICBSZXF1aXJlZDxQaWNrPFdlYk5OQ29udGV4dE9wdGlvbnMsICdkZXZpY2VUeXBlJz4+IHtcclxuICAgIGNvbnRleHQ6IFRyeUdldEdsb2JhbFR5cGU8J01MQ29udGV4dCc+O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aCBNTENvbnRleHQgd2hpY2ggaXMgY3JlYXRlZCBmcm9tIEdQVURldmljZS5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dC1ncHVkZXZpY2VcclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dlYkdwdSBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lIHtcclxuICAgIGNvbnRleHQ6IFRyeUdldEdsb2JhbFR5cGU8J01MQ29udGV4dCc+O1xyXG4gICAgZ3B1RGV2aWNlOiBUcnlHZXRHbG9iYWxUeXBlPCdHUFVEZXZpY2UnPjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlci5cclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uID1cclxuICAgIHwgV2ViTk5PcHRpb25zV2l0aG91dE1MQ29udGV4dFxyXG4gICAgfCBXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0XHJcbiAgICB8IFdlYk5OT3B0aW9uc1dlYkdwdTtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICBleHBvcnQgaW50ZXJmYWNlIFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xyXG4gICAgcmVhZG9ubHkgbmFtZTogJ3Fubic7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgdGhlIFFOTiBiYWNrZW5kIHR5cGUuIEUuZy4sICdjcHUnIG9yICdodHAnLlxyXG4gICAgICogTXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggYGJhY2tlbmRQYXRoYC5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdCAnaHRwJ1xyXG4gICAgICovXHJcbiAgICBiYWNrZW5kVHlwZT86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSBhIHBhdGggdG8gdGhlIFFOTiBiYWNrZW5kIGxpYnJhcnkuXHJcbiAgICAgKiBNdXR1YWxseSBleGNsdXNpdmUgd2l0aCBgYmFja2VuZFR5cGVgLlxyXG4gICAgICovXHJcbiAgICBiYWNrZW5kUGF0aD86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIGVuYWJsZSBIVFAgRlAxNiBwcmVjaXNpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXHJcbiAgICBlbmFibGVGcDE2UHJlY2lzaW9uPzogYm9vbGVhbjtcclxuICB9XHJcbiAgZXhwb3J0IGludGVyZmFjZSBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcclxuICAgIHJlYWRvbmx5IG5hbWU6ICdjb3JlbWwnO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYml0IGZsYWdzIGZvciBDb3JlTUwgZXhlY3V0aW9uIHByb3ZpZGVyLlxyXG4gICAgICpcclxuICAgICAqIGBgYFxyXG4gICAgICogQ09SRU1MX0ZMQUdfVVNFX0NQVV9PTkxZID0gMHgwMDFcclxuICAgICAqIENPUkVNTF9GTEFHX0VOQUJMRV9PTl9TVUJHUkFQSCA9IDB4MDAyXHJcbiAgICAgKiBDT1JFTUxfRkxBR19PTkxZX0VOQUJMRV9ERVZJQ0VfV0lUSF9BTkUgPSAweDAwNFxyXG4gICAgICogQ09SRU1MX0ZMQUdfT05MWV9BTExPV19TVEFUSUNfSU5QVVRfU0hBUEVTID0gMHgwMDhcclxuICAgICAqIENPUkVNTF9GTEFHX0NSRUFURV9NTFBST0dSQU0gPSAweDAxMFxyXG4gICAgICogQ09SRU1MX0ZMQUdfVVNFX0NQVV9BTkRfR1BVID0gMHgwMjBcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIFNlZSBpbmNsdWRlL29ubnhydW50aW1lL2NvcmUvcHJvdmlkZXJzL2NvcmVtbC9jb3JlbWxfcHJvdmlkZXJfZmFjdG9yeS5oIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmbGFnIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcpLlxyXG4gICAgICovXHJcbiAgICBjb3JlTWxGbGFncz86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIHVzZSBDUFUgb25seSBpbiBDb3JlTUwgRVAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxyXG4gICAgICovXHJcbiAgICB1c2VDUFVPbmx5PzogYm9vbGVhbjtcclxuICAgIHVzZUNQVUFuZEdQVT86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBlbmFibGUgQ29yZU1MIEVQIG9uIHN1YmdyYXBoLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cclxuICAgICAqL1xyXG4gICAgZW5hYmxlT25TdWJncmFwaD86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBvbmx5IGVuYWJsZSBDb3JlTUwgRVAgZm9yIEFwcGxlIGRldmljZXMgd2l0aCBBTkUgKEFwcGxlIE5ldXJhbCBFbmdpbmUpLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cclxuICAgICAqL1xyXG4gICAgb25seUVuYWJsZURldmljZVdpdGhBTkU/OiBib29sZWFuO1xyXG4gIH1cclxuICBleHBvcnQgaW50ZXJmYWNlIE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XHJcbiAgICByZWFkb25seSBuYW1lOiAnbm5hcGknO1xyXG4gICAgdXNlRlAxNj86IGJvb2xlYW47XHJcbiAgICB1c2VOQ0hXPzogYm9vbGVhbjtcclxuICAgIGNwdURpc2FibGVkPzogYm9vbGVhbjtcclxuICAgIGNwdU9ubHk/OiBib29sZWFuO1xyXG4gIH1cclxuICAvLyAjZW5kcmVnaW9uXHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiBydW4gb3B0aW9uc1xyXG5cclxuICAvKipcclxuICAgKiBBIHNldCBvZiBjb25maWd1cmF0aW9ucyBmb3IgaW5mZXJlbmNlIHJ1biBiZWhhdmlvclxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgUnVuT3B0aW9ucyB7XHJcbiAgICAvKipcclxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXHJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcclxuICAgICAqL1xyXG4gICAgbG9nU2V2ZXJpdHlMZXZlbD86IDAgfCAxIHwgMiB8IDMgfCA0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIHZlcmJvc2l0eSBsZXZlbC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXHJcbiAgICAgKi9cclxuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVybWluYXRlIGFsbCBpbmNvbXBsZXRlIE9ydFJ1biBjYWxscyBhcyBzb29uIGFzIHBvc3NpYmxlIGlmIHRydWVcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXHJcbiAgICAgKi9cclxuICAgIHRlcm1pbmF0ZT86IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHRhZyBmb3IgdGhlIFJ1bigpIGNhbGxzIHVzaW5nIHRoaXNcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXHJcbiAgICAgKi9cclxuICAgIHRhZz86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIHNpbmdsZSBydW4gY29uZmlndXJhdGlvbiBlbnRyeS4gU2VlXHJcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvc2Vzc2lvbi9cclxuICAgICAqIG9ubnhydW50aW1lX3J1bl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogZXh0cmE6IHtcclxuICAgICAqICAgbWVtb3J5OiB7XHJcbiAgICAgKiAgICAgZW5hYmxlX21lbW9yeV9hcmVuYV9zaHJpbmthZ2U6IFwiMVwiLFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICB9XHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxuXHJcbiAgLy8gI3JlZ2lvbiB2YWx1ZSBtZXRhZGF0YVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgY29tbW9uIHBhcnQgb2YgdGhlIHZhbHVlIG1ldGFkYXRhIHR5cGUgZm9yIGJvdGggdGVuc29yIGFuZCBub24tdGVuc29yIHZhbHVlcy5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlTWV0YWRhdGFCYXNlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHNwZWNpZmllZCBpbnB1dCBvciBvdXRwdXQuXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgdGhlIG1ldGFkYXRhIG9mIGEgbm9uLXRlbnNvciB2YWx1ZS5cclxuICAgKi9cclxuICBleHBvcnQgaW50ZXJmYWNlIE5vblRlbnNvclZhbHVlTWV0YWRhdGEgZXh0ZW5kcyBWYWx1ZU1ldGFkYXRhQmFzZSB7XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdmFsdWUgaXMgYSB0ZW5zb3IuXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IGlzVGVuc29yOiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgdGhlIG1ldGFkYXRhIG9mIGEgdGVuc29yIHZhbHVlLlxyXG4gICAqL1xyXG4gIGV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVmFsdWVNZXRhZGF0YSBleHRlbmRzIFZhbHVlTWV0YWRhdGFCYXNlIHtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHRlbnNvci5cclxuICAgICAqL1xyXG4gICAgcmVhZG9ubHkgaXNUZW5zb3I6IHRydWU7XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICAgKi9cclxuICAgIHJlYWRvbmx5IHR5cGU6IFRlbnNvci5UeXBlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNoYXBlIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIHNoYXBlIGlzIG5vdCBkZWZpbmVkLCB0aGUgdmFsdWUgd2lsbCBhbiBlbXB0eSBhcnJheS4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgc2hhcGVcclxuICAgICAqIG9mIHRoZSB0ZW5zb3IuIEVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nLiBJZiB0aGUgZWxlbWVudCBpcyBhIG51bWJlciwgaXQgcmVwcmVzZW50c1xyXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgZGltZW5zaW9uIHNpemUuIElmIHRoZSBlbGVtZW50IGlzIGEgc3RyaW5nLCBpdCByZXByZXNlbnRzIGEgc3ltYm9saWMgZGltZW5zaW9uLlxyXG4gICAgICovXHJcbiAgICByZWFkb25seSBzaGFwZTogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyB0aGUgbWV0YWRhdGEgb2YgYSB2YWx1ZS5cclxuICAgKi9cclxuICBleHBvcnQgdHlwZSBWYWx1ZU1ldGFkYXRhID0gTm9uVGVuc29yVmFsdWVNZXRhZGF0YSB8IFRlbnNvclZhbHVlTWV0YWRhdGE7XHJcblxyXG4gIC8vICNlbmRyZWdpb25cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudCBhIHJ1bnRpbWUgaW5zdGFuY2Ugb2YgYW4gT05OWCBtb2RlbC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XHJcbiAgLy8gI3JlZ2lvbiBydW4oKVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlIHRoZSBtb2RlbCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcyBhbmQgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3IgZGV0YWlsLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgaW5mZXJlbmNlLlxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXHJcbiAgICovXHJcbiAgcnVuKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZSB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMsIGZldGNoZXMgYW5kIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cclxuICAgKiBAcGFyYW0gZmV0Y2hlcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLk91dHB1dFR5cGVgIGZvclxyXG4gICAqIGRldGFpbC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cclxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxyXG4gICAqL1xyXG4gIHJ1bihcclxuICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSxcclxuICAgIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXHJcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxyXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxyXG4gICAqL1xyXG4gIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAvLyAjcmVnaW9uIHByb2ZpbGluZ1xyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBwcm9maWxpbmcuXHJcbiAgICovXHJcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogRW5kIHByb2ZpbGluZy5cclxuICAgKi9cclxuICBlbmRQcm9maWxpbmcoKTogdm9pZDtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG5cclxuICAvLyAjcmVnaW9uIG1ldGFkYXRhXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBpbnB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIG1vZGVsLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgaW5wdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cclxuICAgKi9cclxuICByZWFkb25seSBpbnB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG91dHB1dCBtZXRhZGF0YSBvZiB0aGUgbG9hZGVkIG1vZGVsLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXTtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb25GYWN0b3J5IHtcclxuICAvLyAjcmVnaW9uIGNyZWF0ZSgpXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGFuIE9OTlggbW9kZWwgZmlsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB1cmkgLSBUaGUgVVJJIG9yIGZpbGUgcGF0aCBvZiB0aGUgbW9kZWwgdG8gbG9hZC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXHJcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgY3JlYXRlKHVyaTogc3RyaW5nLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGFuIGFycmF5IGJ1ZmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIGNyZWF0ZShidWZmZXI6IEFycmF5QnVmZmVyTGlrZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBzZWdtZW50IG9mIGFuIGFycmF5IGJ1ZmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXHJcbiAgICogQHBhcmFtIGJ5dGVPZmZzZXQgLSBUaGUgYmVnaW5uaW5nIG9mIHRoZSBzcGVjaWZpZWQgcG9ydGlvbiBvZiB0aGUgYXJyYXkgYnVmZmVyLlxyXG4gICAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBpbiBieXRlcyBvZiB0aGUgYXJyYXkgYnVmZmVyLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cclxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cclxuICAgKi9cclxuICBjcmVhdGUoXHJcbiAgICBidWZmZXI6IEFycmF5QnVmZmVyTGlrZSxcclxuICAgIGJ5dGVPZmZzZXQ6IG51bWJlcixcclxuICAgIGJ5dGVMZW5ndGg/OiBudW1iZXIsXHJcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcclxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhIFVpbnQ4QXJyYXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYnVmZmVyIC0gQSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxyXG4gICAqL1xyXG4gIGNyZWF0ZShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcclxuXHJcbiAgLy8gI2VuZHJlZ2lvblxyXG59XHJcblxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uOiBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSA9IEluZmVyZW5jZVNlc3Npb25JbXBsO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycywgT3B0aW9uc1RlbnNvckxheW91dCB9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0RhdGFVcmxPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyBleHRlbmRzIE9wdGlvbnNUZW5zb3JMYXlvdXQsIE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzaW9uVXRpbHMge1xyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZXMgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGVuc29yXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGhlIHRlbnNvci5cclxuICAgKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XHJcbiAgICogLSBgZm9ybWF0YDogYCdSR0InYFxyXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXHJcbiAgICogQHJldHVybnMgYSBEYXRhVVJMIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXHJcbiAgICovXHJcbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGVzIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRlbnNvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRoZSB0ZW5zb3IuXHJcbiAgICpcclxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxyXG4gICAqIC0gYGZvcm1hdGA6IGAnUkdCJ2BcclxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxyXG4gICAqIEByZXR1cm5zIGFuIEltYWdlRGF0YSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXHJcbiAgICovXHJcbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YTtcclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IFRlbnNvciwgVHlwZWRUZW5zb3IgfSBmcm9tICcuL3RlbnNvci5qcyc7XHJcblxyXG5leHBvcnQgdHlwZSBJbWFnZUZvcm1hdCA9ICdSR0InIHwgJ1JHQkEnIHwgJ0JHUicgfCAnUkJHJztcclxuZXhwb3J0IHR5cGUgSW1hZ2VUZW5zb3JMYXlvdXQgPSAnTkhXQycgfCAnTkNIVyc7XHJcblxyXG4vLyB0aGUgZm9sbG93aW5nIHJlZ2lvbiBjb250YWlucyB0eXBlIGRlZmluaXRpb25zIGZvciBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cclxuXHJcbi8vICNyZWdpb24gdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb25cclxuXHJcbi8qKlxyXG4gKiByZXByZXNlbnQgY29tbW9uIHByb3BlcnRpZXMgb2YgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cclxuICovXHJcbmludGVyZmFjZSBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgdHlwZTogVDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIEdQVSByZXNvdXJjZS5cclxuICovXHJcbmludGVyZmFjZSBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IHtcclxuICAvKipcclxuICAgKiBhbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBkb3dubG9hZCBkYXRhIGZyb20gR1BVIHRvIENQVS5cclxuICAgKlxyXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIHRlbnNvciB0cmVhdCB0aGUgR1BVIGRhdGEgYXMgZXh0ZXJuYWwgcmVzb3VyY2UuXHJcbiAgICovXHJcbiAgZG93bmxvYWQ/KCk6IFByb21pc2U8VGVuc29yLkRhdGFUeXBlTWFwW1RdPjtcclxuXHJcbiAgLyoqXHJcbiAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuXHJcbiAgICpcclxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0ZW5zb3IgdHJlYXQgdGhlIEdQVSBkYXRhIGFzIGV4dGVybmFsIHJlc291cmNlLlxyXG4gICAqL1xyXG4gIGRpc3Bvc2U/KCk6IHZvaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBwaW5uZWQgQ1BVIGJ1ZmZlclxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5DcHVQaW5uZWREYXRhVHlwZXMgPSBUZW5zb3IuQ3B1UGlubmVkRGF0YVR5cGVzPlxyXG4gIGV4dGVuZHMgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcclxuICAvKipcclxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAnY3B1LXBpbm5lZCcuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgbG9jYXRpb246ICdjcHUtcGlubmVkJztcclxuICAvKipcclxuICAgKiBTcGVjaWZ5IHRoZSBDUFUgcGlubmVkIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKi9cclxuICByZWFkb25seSBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHTCB0ZXh0dXJlXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXHJcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ3RleHR1cmUnLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAndGV4dHVyZSc7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKi9cclxuICByZWFkb25seSB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9IFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXHJcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2dwdS1idWZmZXInLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcic7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKi9cclxuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1MVGVuc29yQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXMgPSBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sXHJcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ21sLXRlbnNvcicuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgbG9jYXRpb246ICdtbC10ZW5zb3InO1xyXG5cclxuICAvKipcclxuICAgKiBTcGVjaWZ5IHRoZSBXZWJOTiBNTFRlbnNvciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cclxuICAgKi9cclxuICByZWFkb25seSBtbFRlbnNvcjogVGVuc29yLk1MVGVuc29yVHlwZTtcclxufVxyXG5cclxuLy8gI2VuZHJlZ2lvblxyXG5cclxuLy8gdGhlIGZvbGxvd2luZyByZWdpb24gY29udGFpbnMgdHlwZSBkZWZpbml0aW9ucyBvZiBlYWNoIGluZGl2aWR1YWwgb3B0aW9ucy5cclxuLy8gdGhlIHRlbnNvciBmYWN0b3J5IGZ1bmN0aW9ucyB1c2UgYSBjb21wb3NpdGlvbiBvZiB0aG9zZSBvcHRpb25zIGFzIHRoZSBwYXJhbWV0ZXIgdHlwZS5cclxuXHJcbi8vICNyZWdpb24gT3B0aW9ucyBmaWVsZHNcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0Zvcm1hdCB7XHJcbiAgLyoqXHJcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBmb3JtYXQgcmVwcmVzZW50ZWQgaW4gUkdCQSBjb2xvciBzcGFjZS5cclxuICAgKi9cclxuICBmb3JtYXQ/OiBJbWFnZUZvcm1hdDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yRm9ybWF0IHtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCBvZiB0aGUgdGVuc29yLlxyXG4gICAqXHJcbiAgICogTk9URTogdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBvcHRpb24gJ2Zvcm1hdCcuIFdoaWxlIG9wdGlvbiAnZm9ybWF0JyByZXByZXNlbnRzIHRoZSBvcmlnaW5hbCBpbWFnZSwgJ3RlbnNvckZvcm1hdCdcclxuICAgKiByZXByZXNlbnRzIHRoZSB0YXJnZXQgZm9ybWF0IG9mIHRoZSB0ZW5zb3IuIEEgdHJhbnNwb3NlIHdpbGwgYmUgcGVyZm9ybWVkIGlmIHRoZXkgYXJlIGRpZmZlcmVudC5cclxuICAgKi9cclxuICB0ZW5zb3JGb3JtYXQ/OiBJbWFnZUZvcm1hdDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yRGF0YVR5cGUge1xyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXHJcbiAgICovXHJcbiAgZGF0YVR5cGU/OiAnZmxvYXQzMicgfCAndWludDgnO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JMYXlvdXQge1xyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyB0aGUgdGVuc29yIGxheW91dCB3aGVuIHJlcHJlc2VudGluZyBkYXRhIG9mIG9uZSBvciBtb3JlIGltYWdlKHMpLlxyXG4gICAqL1xyXG4gIHRlbnNvckxheW91dD86IEltYWdlVGVuc29yTGF5b3V0O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNEaW1lbnNpb25zIHtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGhlaWdodCBpbiBwaXhlbFxyXG4gICAqL1xyXG4gIGhlaWdodD86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIHdpZHRoIGluIHBpeGVsXHJcbiAgICovXHJcbiAgd2lkdGg/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMge1xyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyB0aGUgcmVzaXplZCBoZWlnaHQuIElmIG9taXR0ZWQsIG9yaWdpbmFsIGhlaWdodCB3aWxsIGJlIHVzZWQuXHJcbiAgICovXHJcbiAgcmVzaXplZEhlaWdodD86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgcmVzaXplZCB3aWR0aCAtIGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGVuc29yIGRpbWVuc2lvbnMgYXMgd2VsbFxyXG4gICAqL1xyXG4gIHJlc2l6ZWRXaWR0aD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge1xyXG4gIC8qKlxyXG4gICAqIERlc2NyaWJlcyBub3JtYWxpemF0aW9uIHBhcmFtZXRlcnMgd2hlbiBwcmVwcm9jZXNzaW5nIHRoZSBpbWFnZSBhcyBtb2RlbCBpbnB1dC5cclxuICAgKlxyXG4gICAqIERhdGEgZWxlbWVudCBhcmUgcmFuZ2VkIGZyb20gMCB0byAyNTUuXHJcbiAgICovXHJcbiAgbm9ybT86IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlICdiaWFzJyB2YWx1ZSBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cclxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMC5cclxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxyXG4gICAgICogLSBJZiBpdCdzIGFuIGFycmF5IG9mIDMgb3IgNCBudW1iZXJzLCBhcHBseSBlbGVtZW50LXdpc2UuIE51bWJlciBvZiBlbGVtZW50cyBuZWVkIHRvIG1hdGNoIHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcclxuICAgICAqIGZvciB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBmb3JtYXRcclxuICAgICAqL1xyXG4gICAgYmlhcz86IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgJ21lYW4nIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxyXG4gICAgICogLSBJZiBvbWl0dGVkLCB1c2UgZGVmYXVsdCB2YWx1ZSAyNTUuXHJcbiAgICAgKiAtIElmIGl0J3MgYSBzaW5nbGUgbnVtYmVyLCBhcHBseSB0byBlYWNoIGNoYW5uZWxcclxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXHJcbiAgICAgKiBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZm9ybWF0XHJcbiAgICAgKi9cclxuICAgIG1lYW4/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuICB9O1xyXG59XHJcblxyXG4vLyAjZW5kcmVnaW9uXHJcblxyXG4vLyAjcmVnaW9uIE9wdGlvbnMgY29tcG9zaXRpb25cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnNcclxuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxyXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcclxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXHJcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXHJcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcclxuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxyXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcclxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXHJcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXHJcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbVVybE9wdGlvbnNcclxuICBleHRlbmRzIE9wdGlvbnNEaW1lbnNpb25zLFxyXG4gICAgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXHJcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxyXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcclxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcclxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zXHJcbiAgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcclxuICAgIE9wdGlvbnNUZW5zb3JGb3JtYXQsXHJcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxyXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxyXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBSZXF1aXJlZDxPcHRpb25zRGltZW5zaW9ucz4sXHJcbiAgICBPcHRpb25zRm9ybWF0LFxyXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gLyogVE9ETzogYWRkIG1vcmUgKi8ge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPixcclxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxyXG4gICAqL1xyXG4gIGRhdGFUeXBlPzogVDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuTUxUZW5zb3JEYXRhVHlwZXM+XHJcbiAgZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPixcclxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcclxuICAvKipcclxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxyXG4gICAqL1xyXG4gIGRhdGFUeXBlPzogVDtcclxufVxyXG5cclxuLy8gI2VuZHJlZ2lvblxyXG5cclxuLyoqXHJcbiAqIHR5cGUgVGVuc29yRmFjdG9yeSBkZWZpbmVzIHRoZSBmYWN0b3J5IGZ1bmN0aW9ucyBvZiAnVGVuc29yJyB0byBjcmVhdGUgdGVuc29yIGluc3RhbmNlcyBmcm9tIGV4aXN0aW5nIGRhdGEgb3JcclxuICogcmVzb3VyY2VzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGYWN0b3J5IHtcclxuICAvKipcclxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZURhdGEgb2JqZWN0XHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW1hZ2VEYXRhIC0gdGhlIEltYWdlRGF0YSBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEltYWdlRGF0YS5cclxuICAgKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XHJcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxyXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXHJcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxyXG4gICAqL1xyXG4gIGZyb21JbWFnZShcclxuICAgIGltYWdlRGF0YTogSW1hZ2VEYXRhLFxyXG4gICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLFxyXG4gICk6IFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcclxuXHJcbiAgLyoqXHJcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGltYWdlRWxlbWVudCAtIHRoZSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gSFRNTEltYWdlRWxlbWVudC5cclxuICAgKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XHJcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxyXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXHJcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxyXG4gICAqL1xyXG4gIGZyb21JbWFnZShcclxuICAgIGltYWdlRWxlbWVudDogSFRNTEltYWdlRWxlbWVudCxcclxuICAgIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyxcclxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIFVSTFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHVybFNvdXJjZSAtIGEgc3RyaW5nIGFzIGEgVVJMIHRvIHRoZSBpbWFnZSBvciBhIGRhdGEgVVJMIGNvbnRhaW5pbmcgdGhlIGltYWdlIGRhdGEuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cclxuICAgKlxyXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XHJcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxyXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXHJcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxyXG4gICAqL1xyXG4gIGZyb21JbWFnZSh1cmxTb3VyY2U6IHN0cmluZywgb3B0aW9ucz86IFRlbnNvckZyb21VcmxPcHRpb25zKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZUJpdG1hcCBvYmplY3RcclxuICAgKlxyXG4gICAqIEBwYXJhbSBiaXRtYXAgLSB0aGUgSW1hZ2VCaXRtYXAgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBVUkwuXHJcbiAgICpcclxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxyXG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcclxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxyXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcclxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcclxuICAgKi9cclxuICBmcm9tSW1hZ2UoXHJcbiAgICBiaXRtYXA6IEltYWdlQml0bWFwLFxyXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcclxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHRleHR1cmUgLSB0aGUgV2ViR0xUZXh0dXJlIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR0wgdGV4dHVyZS5cclxuICAgKlxyXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICogLSBgd2lkdGhgOiB0aGUgd2lkdGggb2YgdGhlIHRleHR1cmUuIFJlcXVpcmVkLlxyXG4gICAqIC0gYGhlaWdodGA6IHRoZSBoZWlnaHQgb2YgdGhlIHRleHR1cmUuIFJlcXVpcmVkLlxyXG4gICAqIC0gYGZvcm1hdGA6IHRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIElmIG9taXR0ZWQsIGFzc3VtZSAnUkdCQScuXHJcbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcclxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcclxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cclxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXHJcbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XHJcbiAgICovXHJcbiAgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInPihcclxuICAgIHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZSxcclxuICAgIG9wdGlvbnM6IFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUPixcclxuICApOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSBidWZmZXIgLSB0aGUgR1BVQnVmZmVyIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR1BVIGJ1ZmZlci5cclxuICAgKlxyXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXHJcbiAgICogLSBgZGltc2A6IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gUmVxdWlyZWQuXHJcbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcclxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcclxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cclxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXHJcbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XHJcbiAgICovXHJcbiAgZnJvbUdwdUJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXHJcbiAgICBidWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlLFxyXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXHJcbiAgKTogVHlwZWRUZW5zb3I8VD47XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViTk4gTUxUZW5zb3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB0ZW5zb3IgLSB0aGUgTUxUZW5zb3Igb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBhIFdlYk5OIE1MVGVuc29yLlxyXG4gICAqXHJcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgKiAtIGBkYXRhVHlwZWA6IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYXNzdW1lICdmbG9hdDMyJy5cclxuICAgKiAtIGBkaW1zYDogdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBSZXF1aXJlZC5cclxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIHRoZSBNTFRlbnNvciB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvclxyXG4gICAqIGRhdGEgd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSB0aGUgV2ViTk4gYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLlxyXG4gICAqIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiB0aGUgV2ViTk4gTUxUZW5zb3IuIElmIG9taXR0ZWQsIHRoZSBNTFRlbnNvciB3aWxsXHJcbiAgICogbm90IGJlIGRpc3Bvc2VkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IHRoZSBXZWJOTiBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG9cclxuICAgKiBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcclxuICAgKi9cclxuICBmcm9tTUxUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcz4oXHJcbiAgICB0ZW5zb3I6IFRlbnNvci5NTFRlbnNvclR5cGUsXHJcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tTUxUZW5zb3JPcHRpb25zPFQ+LFxyXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xyXG5cclxuICAvKipcclxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIHByZS1hbGxvY2F0ZWQgYnVmZmVyLiBUaGUgYnVmZmVyIHdpbGwgYmUgdXNlZCBhcyBhIHBpbm5lZCBidWZmZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgZWxlbWVudCB0eXBlLlxyXG4gICAqIEBwYXJhbSBidWZmZXIgLSBhIFR5cGVkQXJyYXkgY29ycmVzcG9uZGluZyB0byB0aGUgdHlwZS5cclxuICAgKiBAcGFyYW0gZGltcyAtIHNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxyXG4gICAqL1xyXG4gIGZyb21QaW5uZWRCdWZmZXI8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPj4oXHJcbiAgICB0eXBlOiBULFxyXG4gICAgYnVmZmVyOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0sXHJcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKTogVHlwZWRUZW5zb3I8VD47XHJcbn1cclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG4vKipcclxuICogQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmlsZSdzIFVSTCBvciBwYXRoLlxyXG4gKlxyXG4gKiBQYXRoIGlzIHZhaWxhYmxlIG9ubHkgaW4gb25ueHJ1bnRpbWUtbm9kZSBvciBvbm54cnVudGltZS13ZWIgcnVubmluZyBpbiBOb2RlLmpzLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgRmlsZVVybE9yUGF0aCA9IHN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBBIEJsb2Igb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGZpbGUuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBGaWxlQmxvYiA9IEJsb2I7XHJcblxyXG4vKipcclxuICogQSBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZSBjb250ZW50LlxyXG4gKlxyXG4gKiBXaGVuIGl0IGlzIGFuIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyLCB0aGUgd2hvbGUgYnVmZmVyIGlzIGFzc3VtZWQgdG8gYmUgdGhlIGZpbGUgY29udGVudC5cclxuICovXHJcbmV4cG9ydCB0eXBlIEZpbGVEYXRhID0gVWludDhBcnJheSB8IEFycmF5QnVmZmVyTGlrZTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgZmlsZSB0aGF0IGNhbiBiZSBsb2FkZWQgYnkgdGhlIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSS5cclxuICovXHJcbmV4cG9ydCB0eXBlIEZpbGVUeXBlID0gRmlsZVVybE9yUGF0aCB8IEZpbGVCbG9iIHwgRmlsZURhdGE7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBleHRlcm5hbCBkYXRhIGZpbGUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybmFsRGF0YUZpbGVEZXNjcmlwdGlvbiB7XHJcbiAgLyoqXHJcbiAgICogU3BlY2lmeSB0aGUgZXh0ZXJuYWwgZGF0YSBmaWxlLlxyXG4gICAqL1xyXG4gIGRhdGE6IEZpbGVUeXBlO1xyXG4gIC8qKlxyXG4gICAqIFNwZWNpZnkgdGhlIGZpbGUgcGF0aC5cclxuICAgKi9cclxuICBwYXRoOiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGV4dGVybmFsIGRhdGEgZmlsZS5cclxuICpcclxuICogV2hlbiB1c2luZyBhIHN0cmluZywgaXQgc2hvdWxkIGJlIGEgZmlsZSBVUkwgb3IgcGF0aCB0aGF0IGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyB0aGUgbW9kZWwgZmlsZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIEV4dGVybmFsRGF0YUZpbGVUeXBlID0gRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHwgRmlsZVVybE9yUGF0aDtcclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIGZvciBtb2RlbCBsb2FkaW5nLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBPbm54TW9kZWxPcHRpb25zIHtcclxuICAvKipcclxuICAgKiBTcGVjaWZ5aW5nIGEgbGlzdCBvZiBmaWxlcyB0aGF0IHJlcHJlc2VudHMgdGhlIGV4dGVybmFsIGRhdGEuXHJcbiAgICovXHJcbiAgZXh0ZXJuYWxEYXRhPzogcmVhZG9ubHkgRXh0ZXJuYWxEYXRhRmlsZVR5cGVbXTtcclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcclxuXHJcbmV4cG9ydCB0eXBlIE5vblRlbnNvclR5cGUgPSBuZXZlcjtcclxuXHJcbi8qKlxyXG4gKiBUeXBlIE9ubnhWYWx1ZSBSZXByZXNlbnRzIGJvdGggdGVuc29ycyBhbmQgbm9uLXRlbnNvcnMgdmFsdWUgZm9yIG1vZGVsJ3MgaW5wdXRzL291dHB1dHMuXHJcbiAqXHJcbiAqIE5PVEU6IGN1cnJlbnRseSBub3Qgc3VwcG9ydCBub24tdGVuc29yXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBPbm54VmFsdWUgPSBUZW5zb3IgfCBOb25UZW5zb3JUeXBlO1xyXG5cclxuLyoqXHJcbiAqIFR5cGUgT25ueFZhbHVlRGF0YUxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIG9mIGFuIE9ubnhWYWx1ZS5cclxuICovXHJcbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiA9IFRlbnNvci5EYXRhTG9jYXRpb247XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuLyoqXHJcbiAqICMgT05OWCBSdW50aW1lIEphdmFTY3JpcHQgQVBJXHJcbiAqXHJcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcclxuICpcclxuICogLSBbb25ueHJ1bnRpbWUtbm9kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtbm9kZSlcclxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXHJcbiAqIC0gW29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtcmVhY3QtbmF0aXZlKVxyXG4gKlxyXG4gKiBTZWUgYWxzbzpcclxuICogLSBbR2V0IFN0YXJ0ZWRdKGh0dHBzOi8vb25ueHJ1bnRpbWUuYWkvZG9jcy9nZXQtc3RhcnRlZC93aXRoLWphdmFzY3JpcHQvKVxyXG4gKiAtIFtJbmZlcmVuY2UgZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUtaW5mZXJlbmNlLWV4YW1wbGVzL3RyZWUvbWFpbi9qcylcclxuICpcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5cclxuZXhwb3J0ICogZnJvbSAnLi9iYWNrZW5kLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9lbnYuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3IuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdHJhY2UuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL29ubngtbW9kZWwuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL29ubngtdmFsdWUuanMnO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmV4cG9ydCBjb25zdCBpc05vZGUgPSAhISh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbi8vLyA8cmVmZXJlbmNlIGxpYj1cIndlYndvcmtlclwiIC8+XHJcblxyXG4vL1xyXG4vLyAqIHR5cGUgaGFjayBmb3IgXCJIVE1MSW1hZ2VFbGVtZW50XCJcclxuLy9cclxuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJIVE1MSW1hZ2VFbGVtZW50XCIgaXMgZGVmaW5lZCBpbiBsaWIuZG9tLmQudHMsIHdoaWNoIGlzIGNvbmZsaWN0IHdpdGggbGliLndlYndvcmtlci5kLnRzLlxyXG4vLyB3aGVuIHdlIHVzZSB3ZWJ3b3JrZXIsIHRoZSBsaWIud2Vid29ya2VyLmQudHMgd2lsbCBiZSB1c2VkLCB3aGljaCBkb2VzIG5vdCBoYXZlIEhUTUxJbWFnZUVsZW1lbnQgZGVmaW5lZC5cclxuLy9cclxuLy8gd2Ugd2lsbCBnZXQgdGhlIGZvbGxvd2luZyBlcnJvcnMgY29tcGxhaW5pbmcgdGhhdCBIVE1MSW1hZ2VFbGVtZW50IGlzIG5vdCBkZWZpbmVkOlxyXG4vL1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL1xyXG4vLyAuLi9jb21tb24vZGlzdC9janMvdGVuc29yLWZhY3RvcnkuZC50czoxODc6MjkgLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxJbWFnZUVsZW1lbnQnLiBEaWQgeW91IG1lYW5cclxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xyXG4vL1xyXG4vLyAxODcgICAgIGZyb21JbWFnZShpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyk6XHJcbi8vIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XHJcbi8vXHJcbi8vIG5vZGVfbW9kdWxlcy9Ad2ViZ3B1L3R5cGVzL2Rpc3QvaW5kZXguZC50czo4Mzo3IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MSW1hZ2VFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXHJcbi8vICdIVE1MTElFbGVtZW50Jz9cclxuLy9cclxuLy8gODMgICAgIHwgSFRNTEltYWdlRWxlbWVudFxyXG4vLyAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XHJcbi8vXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vXHJcbi8vIGBIVE1MSW1hZ2VFbGVtZW50YCBpcyBvbmx5IHVzZWQgaW4gdHlwZSBkZWNsYXJhdGlvbiBhbmQgbm90IGluIHJlYWwgY29kZS4gU28gd2UgZGVmaW5lIGl0IGFzIGB1bmtub3duYCBoZXJlIHRvXHJcbi8vIGJ5cGFzcyB0aGUgdHlwZSBjaGVjay5cclxuXHJcbi8vXHJcbi8vICogdHlwZSBoYWNrIGZvciBcImRvY3VtZW50XCJcclxuLy9cclxuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJkb2N1bWVudFwiIGlzIGRlZmluZWQgaW4gbGliLmRvbS5kLnRzLCBzbyBpdCdzIG5vdCBhdmFpbGFibGUgaW4gd2Vid29ya2VyLlxyXG4vL1xyXG4vLyB3ZSB3aWxsIGdldCB0aGUgZm9sbG93aW5nIGVycm9ycyBjb21wbGFpbmluZyB0aGF0IGRvY3VtZW50IGlzIG5vdCBkZWZpbmVkOlxyXG4vL1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL1xyXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3OjMzIC0gZXJyb3IgVFMyNTg0OiBDYW5ub3QgZmluZCBuYW1lICdkb2N1bWVudCcuIERvIHlvdSBuZWVkIHRvIGNoYW5nZSB5b3VyIHRhcmdldFxyXG4vLyBsaWJyYXJ5PyBUcnkgY2hhbmdpbmcgdGhlICdsaWInIGNvbXBpbGVyIG9wdGlvbiB0byBpbmNsdWRlICdkb20nLlxyXG4vL1xyXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XHJcbi8vXHJcbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6NjEgLSBlcnJvciBUUzI1ODQ6IENhbm5vdCBmaW5kIG5hbWUgJ2RvY3VtZW50Jy4gRG8geW91IG5lZWQgdG8gY2hhbmdlIHlvdXIgdGFyZ2V0XHJcbi8vIGxpYnJhcnk/IFRyeSBjaGFuZ2luZyB0aGUgJ2xpYicgY29tcGlsZXIgb3B0aW9uIHRvIGluY2x1ZGUgJ2RvbScuXHJcbi8vXHJcbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XHJcbi8vXHJcbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6ODggLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxTY3JpcHRFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXHJcbi8vICdIVE1MTElFbGVtZW50Jz9cclxuLy9cclxuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5+fn5+fn5+fn5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy9cclxuLy8gYGRvY3VtZW50YCBpcyB1c2VkIHRvIGdldCB0aGUgY3VycmVudCBzY3JpcHQgVVJMLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluIHdlYndvcmtlci4gVGhpcyBmaWxlIGlzIHNlcnZlZCBhcyBhXHJcbi8vIFwiZHVhbFwiIGZpbGUgZm9yIGVudHJpZXMgb2YgYm90aCB3ZWJ3b3JrZXIgYW5kIHRoZSBlc20gbW9kdWxlLlxyXG4vL1xyXG5kZWNsYXJlIGdsb2JhbCB7XHJcbiAgdHlwZSBIVE1MSW1hZ2VFbGVtZW50ID0gdW5rbm93bjtcclxuICB0eXBlIEhUTUxTY3JpcHRFbGVtZW50ID0geyBzcmM/OiBzdHJpbmcgfTtcclxuICBjb25zdCBkb2N1bWVudDogdW5kZWZpbmVkIHwgeyBjdXJyZW50U2NyaXB0PzogSFRNTFNjcmlwdEVsZW1lbnQgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBzdW1tYXJ5XHJcbiAqXHJcbiAqIFRoaXMgZmlsZSBpcyBzZXJ2ZWQgYXMgYSBcImR1YWxcIiBmaWxlIGZvciBib3RoIGVudHJpZXMgb2YgdGhlIGZvbGxvd2luZzpcclxuICogLSBUaGUgcHJveHkgd29ya2VyIGl0c2VsZi5cclxuICogICAtIFdoZW4gdXNlZCBhcyBhIHdvcmtlciwgaXQgbGlzdGVucyB0byB0aGUgbWVzc2FnZXMgZnJvbSB0aGUgbWFpbiB0aHJlYWQgYW5kIHBlcmZvcm1zIHRoZSBjb3JyZXNwb25kaW5nIG9wZXJhdGlvbnMuXHJcbiAqICAgLSBTaG91bGQgYmUgaW1wb3J0ZWQgZGlyZWN0bHkgdXNpbmcgYG5ldyBXb3JrZXIoKWAgaW4gdGhlIG1haW4gdGhyZWFkLlxyXG4gKlxyXG4gKiAtIFRoZSBFU00gbW9kdWxlIHRoYXQgY3JlYXRlcyB0aGUgcHJveHkgd29ya2VyIChhcyBhIHdvcmtlciBsYXVuY2hlcikuXHJcbiAqICAgLSBXaGVuIHVzZWQgYXMgYSB3b3JrZXIgbGF1bmNoZXIsIGl0IGNyZWF0ZXMgdGhlIHByb3h5IHdvcmtlciBhbmQgcmV0dXJucyBpdC5cclxuICogICAtIFNob3VsZCBiZSBpbXBvcnRlZCB1c2luZyBgaW1wb3J0KClgIGluIHRoZSBtYWluIHRocmVhZCwgd2l0aCB0aGUgcXVlcnkgcGFyYW1ldGVyIGBpbXBvcnQ9MWAuXHJcbiAqXHJcbiAqIFRoaXMgZmlsZSB3aWxsIGJlIGFsd2F5cyBjb21waWxpbmcgaW50byBFU00gZm9ybWF0LlxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1lc3NhZ2UsIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhIH0gZnJvbSAnLi4vcHJveHktbWVzc2FnZXMuanMnO1xyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVNlc3Npb24sXHJcbiAgY29weUZyb21FeHRlcm5hbEJ1ZmZlcixcclxuICBlbmRQcm9maWxpbmcsXHJcbiAgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMsXHJcbiAgaW5pdEVwLFxyXG4gIGluaXRSdW50aW1lLFxyXG4gIHJlbGVhc2VTZXNzaW9uLFxyXG4gIHJ1bixcclxufSBmcm9tICcuLi93YXNtLWNvcmUtaW1wbC5qcyc7XHJcbmltcG9ydCB7IGluaXRpYWxpemVXZWJBc3NlbWJseSB9IGZyb20gJy4uL3dhc20tZmFjdG9yeS5qcyc7XHJcbmltcG9ydCB7IHNjcmlwdFNyYyB9IGZyb20gJy4uL3dhc20tdXRpbHMtaW1wb3J0LmpzJztcclxuXHJcbmNvbnN0IFdPUktFUl9OQU1FID0gJ29ydC13YXNtLXByb3h5LXdvcmtlcic7XHJcbmNvbnN0IGlzUHJveHlXb3JrZXIgPSBnbG9iYWxUaGlzLnNlbGY/Lm5hbWUgPT09IFdPUktFUl9OQU1FO1xyXG5cclxuaWYgKGlzUHJveHlXb3JrZXIpIHtcclxuICAvLyBXb3JrZXIgdGhyZWFkXHJcbiAgc2VsZi5vbm1lc3NhZ2UgPSAoZXY6IE1lc3NhZ2VFdmVudDxPcnRXYXNtTWVzc2FnZT4pOiB2b2lkID0+IHtcclxuICAgIGNvbnN0IHsgdHlwZSwgaW46IG1lc3NhZ2UgfSA9IGV2LmRhdGE7XHJcbiAgICB0cnkge1xyXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlICdpbml0LXdhc20nOlxyXG4gICAgICAgICAgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KG1lc3NhZ2UhLndhc20pLnRoZW4oXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICBpbml0UnVudGltZShtZXNzYWdlISkudGhlbihcclxuICAgICAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdpbml0LWVwJzoge1xyXG4gICAgICAgICAgY29uc3QgeyBlcE5hbWUsIGVudiB9ID0gbWVzc2FnZSE7XHJcbiAgICAgICAgICBpbml0RXAoZW52LCBlcE5hbWUpLnRoZW4oXHJcbiAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnY29weS1mcm9tJzoge1xyXG4gICAgICAgICAgY29uc3QgeyBidWZmZXIgfSA9IG1lc3NhZ2UhO1xyXG4gICAgICAgICAgY29uc3QgYnVmZmVyRGF0YSA9IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIoYnVmZmVyKTtcclxuICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgb3V0OiBidWZmZXJEYXRhIH0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ2NyZWF0ZSc6IHtcclxuICAgICAgICAgIGNvbnN0IHsgbW9kZWwsIG9wdGlvbnMgfSA9IG1lc3NhZ2UhO1xyXG4gICAgICAgICAgY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucykudGhlbihcclxuICAgICAgICAgICAgKHNlc3Npb25NZXRhZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgb3V0OiBzZXNzaW9uTWV0YWRhdGEgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAncmVsZWFzZSc6XHJcbiAgICAgICAgICByZWxlYXNlU2Vzc2lvbihtZXNzYWdlISk7XHJcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdydW4nOiB7XHJcbiAgICAgICAgICBjb25zdCB7IHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG9wdGlvbnMgfSA9IG1lc3NhZ2UhO1xyXG4gICAgICAgICAgcnVuKHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG5ldyBBcnJheShvdXRwdXRJbmRpY2VzLmxlbmd0aCkuZmlsbChudWxsKSwgb3B0aW9ucykudGhlbihcclxuICAgICAgICAgICAgKG91dHB1dHMpID0+IHtcclxuICAgICAgICAgICAgICBpZiAob3V0cHV0cy5zb21lKChvKSA9PiBvWzNdICE9PSAnY3B1JykpIHtcclxuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyOiAnUHJveHkgZG9lcyBub3Qgc3VwcG9ydCBub24tY3B1IHRlbnNvciBsb2NhdGlvbi4nIH0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZShcclxuICAgICAgICAgICAgICAgICAgeyB0eXBlLCBvdXQ6IG91dHB1dHMgfSBhcyBPcnRXYXNtTWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMoWy4uLmlucHV0cywgLi4ub3V0cHV0c10gYXMgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSksXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdlbmQtcHJvZmlsaW5nJzpcclxuICAgICAgICAgIGVuZFByb2ZpbGluZyhtZXNzYWdlISk7XHJcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBlcnIgfSBhcyBPcnRXYXNtTWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgaXNQcm94eVdvcmtlclxyXG4gID8gbnVsbFxyXG4gIDogKHVybE92ZXJyaWRlPzogc3RyaW5nKSA9PlxyXG4gICAgICBuZXcgV29ya2VyKHVybE92ZXJyaWRlID8/IHNjcmlwdFNyYyEsIHsgdHlwZTogQlVJTERfREVGUy5JU19FU00gPyAnbW9kdWxlJyA6ICdjbGFzc2ljJywgbmFtZTogV09SS0VSX05BTUUgfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHR5cGUgeyBPcnRXYXNtTW9kdWxlIH0gZnJvbSAnLi93YXNtLXR5cGVzJztcclxuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XHJcblxyXG4vKipcclxuICogVGhlIG9yaWdpbiBvZiB0aGUgY3VycmVudCBsb2NhdGlvbi5cclxuICpcclxuICogSW4gTm9kZS5qcywgdGhpcyBpcyB1bmRlZmluZWQuXHJcbiAqL1xyXG5jb25zdCBvcmlnaW4gPSBpc05vZGUgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uLm9yaWdpbjtcclxuXHJcbi8qKlxyXG4gKiBTb21lIGJ1bmRsZXJzIChlZy4gV2VicGFjaykgd2lsbCByZXdyaXRlIGBpbXBvcnQubWV0YS51cmxgIHRvIGEgZmlsZSBVUkwgYXQgY29tcGlsZSB0aW1lLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiBgaW1wb3J0Lm1ldGEudXJsYCBzdGFydHMgd2l0aCBgZmlsZTpgLCBidXQgdXNpbmcgdGhlIGA+YCBhbmQgYDxgIG9wZXJhdG9ycyBpbnN0ZWFkIG9mXHJcbiAqIGBzdGFydHNXaXRoYCBmdW5jdGlvbiBzbyB0aGF0IGNvZGUgbWluaW1pemVycyBjYW4gcmVtb3ZlIHRoZSBkZWFkIGNvZGUgY29ycmVjdGx5LlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgaWYgd2UgdXNlIHRlcnNlciB0byBtaW5pZnkgdGhlIGZvbGxvd2luZyBjb2RlOlxyXG4gKiBgYGBqc1xyXG4gKiBpZiAoXCJmaWxlOi8vaGFyZC1jb2RlZC1maWxlbmFtZVwiLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSkge1xyXG4gKiAgIGNvbnNvbGUubG9nKDEpXHJcbiAqIH0gZWxzZSB7XHJcbiAqICAgY29uc29sZS5sb2coMilcclxuICogfVxyXG4gKlxyXG4gKiBpZiAoXCJmaWxlOi8vaGFyZC1jb2RlZC1maWxlbmFtZVwiID4gXCJmaWxlOlwiICYmIFwiZmlsZTovL2hhcmQtY29kZWQtZmlsZW5hbWVcIiA8IFwiZmlsZTtcIikge1xyXG4gKiAgIGNvbnNvbGUubG9nKDMpXHJcbiAqIH0gZWxzZSB7XHJcbiAqICAgY29uc29sZS5sb2coNClcclxuICogfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIG1pbmlmaWVkIGNvZGUgd2lsbCBiZTpcclxuICogYGBganNcclxuICogXCJmaWxlOi8vaGFyZC1jb2RlZC1maWxlbmFtZVwiLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKT9jb25zb2xlLmxvZygxKTpjb25zb2xlLmxvZygyKSxjb25zb2xlLmxvZygzKTtcclxuICogYGBgXHJcbiAqXHJcbiAqICh1c2UgVGVyc2VyIDUuMzkuMCB3aXRoIGRlZmF1bHQgb3B0aW9ucywgaHR0cHM6Ly90cnkudGVyc2VyLm9yZy8pXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGltcG9ydC5tZXRhLnVybCBpcyBoYXJkY29kZWQgYXMgYSBmaWxlIFVSSS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBpc0VzbUltcG9ydE1ldGFVcmxIYXJkY29kZWRBc0ZpbGVVcmkgPVxyXG4gIEJVSUxEX0RFRlMuSVNfRVNNICYmIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCEgPiAnZmlsZTonICYmIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCEgPCAnZmlsZTsnO1xyXG5cclxuY29uc3QgZ2V0U2NyaXB0U3JjID0gKCk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XHJcbiAgLy8gaWYgTm9kZWpzLCByZXR1cm4gdW5kZWZpbmVkXHJcbiAgaWYgKGlzTm9kZSkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbiAgLy8gaWYgSXQncyBFU00sIHVzZSBpbXBvcnQubWV0YS51cmxcclxuICBpZiAoQlVJTERfREVGUy5JU19FU00pIHtcclxuICAgIC8vIEZvciBFU00sIGlmIHRoZSBpbXBvcnQubWV0YS51cmwgaXMgYSBmaWxlIFVSTCwgdGhpcyB1c3VhbGx5IG1lYW5zIHRoZSBidW5kbGVyIHJld3JpdGVzIGBpbXBvcnQubWV0YS51cmxgIHRvXHJcbiAgICAvLyB0aGUgZmlsZSBwYXRoIGF0IGNvbXBpbGUgdGltZS4gSW4gdGhpcyBjYXNlLCB0aGlzIGZpbGUgcGF0aCBjYW5ub3QgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJ1bnRpbWUgVVJMLlxyXG4gICAgLy9cclxuICAgIC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBVUkwgY29uc3RydWN0b3IgbGlrZSB0aGlzOlxyXG4gICAgLy8gYGBganNcclxuICAgIC8vIG5ldyBVUkwoJ2FjdHVhbC1idW5kbGUtbmFtZS5qcycsIGltcG9ydC5tZXRhLnVybCkuaHJlZlxyXG4gICAgLy8gYGBgXHJcbiAgICAvLyBTbyB0aGF0IGJ1bmRsZXIgY2FuIHByZXByb2Nlc3MgdGhlIFVSTCBjb3JyZWN0bHkuXHJcbiAgICBpZiAoaXNFc21JbXBvcnRNZXRhVXJsSGFyZGNvZGVkQXNGaWxlVXJpKSB7XHJcbiAgICAgIC8vIGlmIHRoZSByZXdyaXR0ZW4gVVJMIGlzIGEgcmVsYXRpdmUgcGF0aCwgd2UgbmVlZCB0byB1c2UgdGhlIG9yaWdpbiB0byByZXNvbHZlIHRoZSBVUkwuXHJcblxyXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgd29ya2Fyb3VuZCBmb3IgVml0ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVml0ZSB1c2VzIGEgYnVuZGxlcihyb2xsdXAvcm9sbGRvd24pIHRoYXQgZG9lcyBub3QgcmV3cml0ZSBgaW1wb3J0Lm1ldGEudXJsYCB0byBhIGZpbGUgVVJMLiBTbyBpbiB0aGVvcnksIHRoaXNcclxuICAgICAgLy8gY29kZSBwYXRoIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQgaW4gVml0ZS4gSG93ZXZlciwgdGhlIGJ1bmRsZXIgZG9lcyBub3Qga25vdyBpdCBhbmQgaXQgc3RpbGwgdHJ5IHRvIGxvYWQgdGhlXHJcbiAgICAgIC8vIGZvbGxvd2luZyBwYXR0ZXJuOlxyXG4gICAgICAvLyAtIGByZXR1cm4gbmV3IFVSTCgnZmlsZW5hbWUnLCBpbXBvcnQubWV0YS51cmwpLmhyZWZgXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIEJ5IHJlcGxhY2luZyB0aGUgcGF0dGVybiBhYm92ZSB3aXRoIHRoZSBmb2xsb3dpbmcgY29kZSwgd2UgY2FuIHNraXAgdGhlIHJlc291cmNlIGxvYWRpbmcgYmVoYXZpb3I6XHJcbiAgICAgIC8vIC0gYGNvbnN0IFVSTDIgPSBVUkw7IHJldHVybiBuZXcgVVJMMignZmlsZW5hbWUnLCBpbXBvcnQubWV0YS51cmwpLmhyZWY7YFxyXG4gICAgICAvL1xyXG4gICAgICAvLyBBbmQgaXQgc3RpbGwgd29ya3MgaW4gV2VicGFjay5cclxuICAgICAgY29uc3QgVVJMMiA9IFVSTDtcclxuICAgICAgcmV0dXJuIG5ldyBVUkwobmV3IFVSTDIoQlVJTERfREVGUy5CVU5ETEVfRklMRU5BTUUsIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCkuaHJlZiwgb3JpZ2luKS5ocmVmO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkw7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgPyAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyY1xyXG4gICAgOiAvLyB1c2UgYHNlbGYubG9jYXRpb24uaHJlZmAgaWYgYXZhaWxhYmxlXHJcbiAgICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICA/IHNlbGYubG9jYXRpb24/LmhyZWZcclxuICAgICAgOiB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGNsYXNzaWMgc2NyaXB0IHNvdXJjZSBVUkwuIFRoaXMgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gbm9uIEVTTW9kdWxlIGVudmlyb25tZW50cy5cclxuICpcclxuICogSW4gTm9kZS5qcywgdGhpcyBpcyB1bmRlZmluZWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gZ2V0U2NyaXB0U3JjKCk7XHJcblxyXG4vKipcclxuICogSW5mZXIgdGhlIHdhc20gcGF0aCBwcmVmaXggZnJvbSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBpbmZlcnJlZCB3YXNtIHBhdGggcHJlZml4LCBvciB1bmRlZmluZWQgaWYgdGhlIHNjcmlwdCBzb3VyY2UgVVJMIGlzIG5vdCBhdmFpbGFibGUgb3IgaXMgYSBibG9iIFVSTC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBpbmZlcldhc21QYXRoUHJlZml4RnJvbVNjcmlwdFNyYyA9ICgpOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xyXG4gIGlmIChzY3JpcHRTcmMgJiYgIXNjcmlwdFNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XHJcbiAgICByZXR1cm4gc2NyaXB0U3JjLnN1YnN0cmluZygwLCBzY3JpcHRTcmMubGFzdEluZGV4T2YoJy8nKSArIDEpO1xyXG4gIH1cclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBmaWxlbmFtZSB3aXRoIHByZWZpeCBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cclxuICovXHJcbmNvbnN0IGlzU2FtZU9yaWdpbiA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBiYXNlVXJsID0gcHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0U3JjO1xyXG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XHJcbiAgICByZXR1cm4gdXJsLm9yaWdpbiA9PT0gb3JpZ2luO1xyXG4gIH0gY2F0Y2gge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgdGhlIGlucHV0cyB0byBhbiBhYnNvbHV0ZSBVUkwgd2l0aCB0aGUgZ2l2ZW4gcHJlZml4IG92ZXJyaWRlLiBJZiBmYWlsZWQsIHJldHVybiB1bmRlZmluZWQuXHJcbiAqL1xyXG5jb25zdCBub3JtYWxpemVVcmwgPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IHtcclxuICBjb25zdCBiYXNlVXJsID0gcHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0U3JjO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB1cmwgPSBiYXNlVXJsID8gbmV3IFVSTChmaWxlbmFtZSwgYmFzZVVybCkgOiBuZXcgVVJMKGZpbGVuYW1lKTtcclxuICAgIHJldHVybiB1cmwuaHJlZjtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGZhbGxiYWNrIFVSTCBpZiBhbiBhYnNvbHV0ZSBVUkwgY2Fubm90IGJlIGNyZWF0ZWQgYnkgdGhlIG5vcm1hbGl6ZVVybCBmdW5jdGlvbi5cclxuICovXHJcbmNvbnN0IGZhbGxiYWNrVXJsID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiBgJHtwcmVmaXhPdmVycmlkZSA/PyAnLi8nfSR7ZmlsZW5hbWV9YDtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiBpcyB1c2VkIHRvIHByZWxvYWQgYSBtb2R1bGUgZnJvbSBhIFVSTC5cclxuICpcclxuICogSWYgdGhlIG9yaWdpbiBvZiB0aGUgd29ya2VyIFVSTCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBvcmlnaW4sIHRoZSB3b3JrZXIgY2Fubm90IGJlIGxvYWRlZCBkaXJlY3RseS5cclxuICogU2VlIGRpc2N1c3Npb25zIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvd29ya2VyLWxvYWRlci9pc3N1ZXMvMTU0XHJcbiAqXHJcbiAqIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBmZXRjaCB0aGUgd29ya2VyIFVSTCBhbmQgY3JlYXRlIGEgbmV3IEJsb2IgVVJMIHdpdGggdGhlIHNhbWUgb3JpZ2luIGFzIGEgd29ya2Fyb3VuZC5cclxuICpcclxuICogQHBhcmFtIGFic29sdXRlVXJsIC0gVGhlIGFic29sdXRlIFVSTCB0byBwcmVsb2FkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IEJsb2IgVVJMXHJcbiAqL1xyXG5jb25zdCBwcmVsb2FkID0gYXN5bmMgKGFic29sdXRlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYWJzb2x1dGVVcmwsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSk7XHJcbiAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcclxuICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiBpcyB1c2VkIHRvIGR5bmFtaWNhbGx5IGltcG9ydCBhIG1vZHVsZSBmcm9tIGEgVVJMLlxyXG4gKlxyXG4gKiBUaGUgYnVpbGQgc2NyaXB0IGhhcyBzcGVjaWFsIGhhbmRsaW5nIGZvciB0aGlzIGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0IHRoZSBVUkwgaXMgbm90IGJ1bmRsZWQgaW50byB0aGUgZmluYWwgb3V0cHV0LlxyXG4gKlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBpbXBvcnQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlZmF1bHQgZXhwb3J0IG9mIHRoZSBtb2R1bGUuXHJcbiAqL1xyXG5jb25zdCBkeW5hbWljSW1wb3J0RGVmYXVsdCA9IGFzeW5jIDxUPih1cmw6IHN0cmluZyk6IFByb21pc2U8VD4gPT5cclxuICAoYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gdXJsKSkuZGVmYXVsdDtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcHJveHkgd29ya2VyIGZhY3RvcnkgaW1wb3J0ZWQgZnJvbSB0aGUgcHJveHkgd29ya2VyIG1vZHVsZS5cclxuICpcclxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBXZWJBc3NlbWJseSBwcm94eSBpcyBub3QgZGlzYWJsZWQuXHJcbiAqL1xyXG5jb25zdCBjcmVhdGVQcm94eVdvcmtlcjogKCh1cmxPdmVycmlkZT86IHN0cmluZykgPT4gV29ya2VyKSB8IHVuZGVmaW5lZCA9XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcclxuICBCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSA/IHVuZGVmaW5lZCA6IHJlcXVpcmUoJy4vcHJveHktd29ya2VyL21haW4nKS5kZWZhdWx0O1xyXG5cclxuLyoqXHJcbiAqIEltcG9ydCB0aGUgcHJveHkgd29ya2VyLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxyXG4gKiAxLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxyXG4gKiAyLiBVc2UgdGhlIHByb3h5IHdvcmtlciBmYWN0b3J5IHRvIGNyZWF0ZSB0aGUgcHJveHkgd29ya2VyLlxyXG4gKlxyXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgMiBlbGVtZW50czpcclxuICogICAgICAgICAgICAtIFRoZSBvYmplY3QgVVJMIG9mIHRoZSBwcmVsb2FkZWQgbW9kdWxlLCBvciB1bmRlZmluZWQgaWYgbm8gcHJlbG9hZCBpcyBuZWVkZWQuXHJcbiAqICAgICAgICAgICAgLSBUaGUgcHJveHkgd29ya2VyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGltcG9ydFByb3h5V29ya2VyID0gYXN5bmMgKCk6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgV29ya2VyXT4gPT4ge1xyXG4gIGlmICghc2NyaXB0U3JjKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHByb3h5IHdvcmtlcjogY2Fubm90IGRldGVybWluZSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuJyk7XHJcbiAgfVxyXG5cclxuICAvLyBJZiB0aGUgc2NyaXB0IHNvdXJjZSBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbiwgd2UgY2FuIHVzZSB0aGUgZW1iZWRkZWQgcHJveHkgbW9kdWxlIGRpcmVjdGx5LlxyXG4gIGlmIChpc1NhbWVPcmlnaW4oc2NyaXB0U3JjKSkge1xyXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGNyZWF0ZVByb3h5V29ya2VyISgpXTtcclxuICB9XHJcblxyXG4gIC8vIE90aGVyd2lzZSwgbmVlZCB0byBwcmVsb2FkXHJcbiAgY29uc3QgdXJsID0gYXdhaXQgcHJlbG9hZChzY3JpcHRTcmMpO1xyXG4gIHJldHVybiBbdXJsLCBjcmVhdGVQcm94eVdvcmtlciEodXJsKV07XHJcbn07XHJcblxyXG4vKipcclxuICogVGhlIGVtYmVkZGVkIFdlYkFzc2VtYmx5IG1vZHVsZS5cclxuICpcclxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBFU00gYW5kIHdoZW4gZW1iZWRkaW5nIGlzIG5vdCBkaXNhYmxlZC5cclxuICovXHJcbmNvbnN0IGVtYmVkZGVkV2FzbU1vZHVsZTogRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT4gfCB1bmRlZmluZWQgPVxyXG4gIEJVSUxEX0RFRlMuSVNfRVNNICYmIEJVSUxEX0RFRlMuRU5BQkxFX0JVTkRMRV9XQVNNX0pTXHJcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXHJcbiAgICAgIHJlcXVpcmUoXHJcbiAgICAgICAgIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQXHJcbiAgICAgICAgICA/ICcuLi8uLi9kaXN0L29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanMnXHJcbiAgICAgICAgICA6ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVXHJcbiAgICAgICAgICAgID8gJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5hc3luY2lmeS5tanMnXHJcbiAgICAgICAgICAgIDogJy4uLy4uL2Rpc3Qvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanMnLFxyXG4gICAgICApLmRlZmF1bHRcclxuICAgIDogdW5kZWZpbmVkO1xyXG5cclxuLyoqXHJcbiAqIEltcG9ydCB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxyXG4gKiAxLiBJZiB0aGUgZW1iZWRkZWQgbW9kdWxlIGV4aXN0cyBhbmQgbm8gY3VzdG9tIFVSTCBpcyBzcGVjaWZpZWQsIHVzZSB0aGUgZW1iZWRkZWQgbW9kdWxlLlxyXG4gKiAyLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxyXG4gKiAzLiBPdGhlcndpc2UsIGl0IHdpbGwgcGVyZm9ybSBhIGR5bmFtaWMgaW1wb3J0IG9mIHRoZSBtb2R1bGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiAyIGVsZW1lbnRzOlxyXG4gKiAgICAgICAgICAgIC0gVGhlIG9iamVjdCBVUkwgb2YgdGhlIHByZWxvYWRlZCBtb2R1bGUsIG9yIHVuZGVmaW5lZCBpZiBubyBwcmVsb2FkIGlzIG5lZWRlZC5cclxuICogICAgICAgICAgICAtIFRoZSBkZWZhdWx0IGV4cG9ydCBvZiB0aGUgbW9kdWxlLCB3aGljaCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaW1wb3J0V2FzbU1vZHVsZSA9IGFzeW5jIChcclxuICB1cmxPdmVycmlkZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxyXG4gIHByZWZpeE92ZXJyaWRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXHJcbiAgaXNNdWx0aVRocmVhZGVkOiBib29sZWFuLFxyXG4gIGlzV2FzbU92ZXJyaWRkZW46IGJvb2xlYW4sXHJcbik6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT5dPiA9PiB7XHJcbiAgLy9cclxuICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgdXNlIHRoZSBlbWJlZGRlZCBtb2R1bGUuXHJcbiAgLy9cclxuXHJcbiAgLy8gVG8gdXNlIHRoZSBlbWJlZGRlZCBtb2R1bGUsIGl0IHNob3VsZCBiZSBhdmFpbGFibGUsIGFuZCBubyBVUkwgb3ZlcnJpZGUgb3IgcHJlZml4IG92ZXJyaWRlIHNob3VsZCBiZSBzcGVjaWZpZWQuXHJcbiAgbGV0IHVzZUVtYmVkZGVkTW9kdWxlID0gZW1iZWRkZWRXYXNtTW9kdWxlICYmICEodXJsT3ZlcnJpZGUgfHwgcHJlZml4T3ZlcnJpZGUpO1xyXG4gIGlmICh1c2VFbWJlZGRlZE1vZHVsZSkge1xyXG4gICAgaWYgKCFzY3JpcHRTcmMpIHtcclxuICAgICAgLy8gbm8gVVJMIGluZm8gYXZhaWxhYmxlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBOb3RlOiB3aGVuIHRoZSBlbWJlZGRlZCBtb2R1bGUgaXMgYXZhaWxhYmxlLCBpdCBtZWFucyB0aGUgY3VycmVudCBzY3JpcHQgaXMgRVNNLiBVc3VhbGx5LCBpbiBFU00sIHRoZVxyXG4gICAgICAvLyBgaW1wb3J0Lm1ldGEudXJsYCBpcyBhdmFpbGFibGUuIEJ1dCBpbiBzb21lIGNhc2VzIChlZy4gQ2xvdWRmbGFyZSBXb3JrZXJzKSwgdGhlIHZhbHVlIG9mIGBpbXBvcnQubWV0YS51cmxgXHJcbiAgICAgIC8vIGNhbiBiZSBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuIEluIHRoaXMgY2FzZSwgd2UgY2FuIG9ubHkgbG9hZCB0aGUgZW1iZWRkZWQgbW9kdWxlIHdoZW46XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIDEuIFRoZSBXZWJBc3NlbWJseSBtb2R1bGUgYmluYXJ5IGlzIG92ZXJyaWRkZW46XHJcbiAgICAgIC8vICAgIGBgYGpzXHJcbiAgICAgIC8vICAgIGVudi53YXNtLndhc21QYXRocyA9IHVuZGVmaW5lZDsgIC8vIG9yIG5vdCBzcGVjaWZpZWRcclxuICAgICAgLy8gICAgZW52Lndhc20ud2FzbUJpbmFyeSA9IC8qIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBXZWJBc3NlbWJseSBiaW5hcnkgKi87XHJcbiAgICAgIC8vICAgIGBgYFxyXG4gICAgICAvL1xyXG4gICAgICAvLyAyLiBUaGUgXCIud2FzbVwiIG9ubHkgaXMgb3ZlcnJpZGRlbi5cclxuICAgICAgLy8gICAgYGBganNcclxuICAgICAgLy8gICAgZW52Lndhc20ud2FzbVBhdGhzID0geyB3YXNtOiAvKiBVUkwgb2YgdGhlIC53YXNtIGZpbGUgKi8gfTtcclxuICAgICAgLy8gICAgYGBgXHJcbiAgICAgIC8vXHJcbiAgICAgIGlmIChpc1dhc21PdmVycmlkZGVuICYmICFpc011bHRpVGhyZWFkZWQpIHtcclxuICAgICAgICB1c2VFbWJlZGRlZE1vZHVsZSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC4nKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaWYgdGhlIHNjcmlwdCBzb3VyY2UgaXMgYXZhaWxhYmxlLCB3ZSBjYW4gY2hlY2sgaWYgaXQgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4uXHJcbiAgICAgIHVzZUVtYmVkZGVkTW9kdWxlID0gaXNTYW1lT3JpZ2luKHNjcmlwdFNyYyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmICh1c2VFbWJlZGRlZE1vZHVsZSkge1xyXG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGVtYmVkZGVkV2FzbU1vZHVsZSFdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCB3YXNtTW9kdWxlRmlsZW5hbWUgPSAhQlVJTERfREVGUy5ESVNBQkxFX0pTRVBcclxuICAgICAgPyAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qcydcclxuICAgICAgOiAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVVxyXG4gICAgICAgID8gJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQuYXN5bmNpZnkubWpzJ1xyXG4gICAgICAgIDogJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzJztcclxuICAgIGNvbnN0IHdhc21Nb2R1bGVVcmwgPSB1cmxPdmVycmlkZSA/PyBub3JtYWxpemVVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSk7XHJcbiAgICAvLyBuZWVkIHRvIHByZWxvYWQgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gICAgLy8gMS4gbm90IGluIE5vZGUuanMuXHJcbiAgICAvLyAgICAtIE5vZGUuanMgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBvcmlnaW4gcG9saWN5IGZvciBjcmVhdGluZyB3b3JrZXJzLlxyXG4gICAgLy8gMi4gbXVsdGktdGhyZWFkZWQgaXMgZW5hYmxlZC5cclxuICAgIC8vICAgIC0gSWYgbXVsdGktdGhyZWFkZWQgaXMgZGlzYWJsZWQsIG5vIHdvcmtlciB3aWxsIGJlIGNyZWF0ZWQuIFNvIHdlIGRvbid0IG5lZWQgdG8gcHJlbG9hZCB0aGUgbW9kdWxlLlxyXG4gICAgLy8gMy4gdGhlIGFic29sdXRlIFVSTCBpcyBhdmFpbGFibGUuXHJcbiAgICAvLyAgICAtIElmIHRoZSBhYnNvbHV0ZSBVUkwgaXMgZmFpbGVkIHRvIGJlIGNyZWF0ZWQsIHRoZSBvcmlnaW4gY2Fubm90IGJlIGRldGVybWluZWQuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBub3RcclxuICAgIC8vICAgIHByZWxvYWQgdGhlIG1vZHVsZS5cclxuICAgIC8vIDQuIHRoZSB3b3JrZXIgVVJMIGlzIG5vdCBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cclxuICAgIC8vICAgIC0gSWYgdGhlIHdvcmtlciBVUkwgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4sIHdlIGNhbiBjcmVhdGUgdGhlIHdvcmtlciBkaXJlY3RseS5cclxuICAgIGNvbnN0IG5lZWRQcmVsb2FkID0gIWlzTm9kZSAmJiBpc011bHRpVGhyZWFkZWQgJiYgd2FzbU1vZHVsZVVybCAmJiAhaXNTYW1lT3JpZ2luKHdhc21Nb2R1bGVVcmwsIHByZWZpeE92ZXJyaWRlKTtcclxuICAgIGNvbnN0IHVybCA9IG5lZWRQcmVsb2FkXHJcbiAgICAgID8gYXdhaXQgcHJlbG9hZCh3YXNtTW9kdWxlVXJsKVxyXG4gICAgICA6ICh3YXNtTW9kdWxlVXJsID8/IGZhbGxiYWNrVXJsKHdhc21Nb2R1bGVGaWxlbmFtZSwgcHJlZml4T3ZlcnJpZGUpKTtcclxuICAgIHJldHVybiBbbmVlZFByZWxvYWQgPyB1cmwgOiB1bmRlZmluZWQsIGF3YWl0IGR5bmFtaWNJbXBvcnREZWZhdWx0PEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+Pih1cmwpXTtcclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcclxuXHJcbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1vZHVsZSB9IGZyb20gJy4vd2FzbS10eXBlcyc7XHJcbmltcG9ydCB7IGltcG9ydFdhc21Nb2R1bGUsIGluZmVyV2FzbVBhdGhQcmVmaXhGcm9tU2NyaXB0U3JjIH0gZnJvbSAnLi93YXNtLXV0aWxzLWltcG9ydCc7XHJcblxyXG5sZXQgd2FzbTogT3J0V2FzbU1vZHVsZSB8IHVuZGVmaW5lZDtcclxubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XHJcbmxldCBpbml0aWFsaXppbmcgPSBmYWxzZTtcclxubGV0IGFib3J0ZWQgPSBmYWxzZTtcclxuXHJcbmNvbnN0IGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XHJcbiAgLy8gSWYgJ1NoYXJlZEFycmF5QnVmZmVyJyBpcyBub3QgYXZhaWxhYmxlLCBXZWJBc3NlbWJseSB0aHJlYWRzIHdpbGwgbm90IHdvcmsuXHJcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBUZXN0IGZvciB0cmFuc2ZlcmFiaWxpdHkgb2YgU0FCcyAoZm9yIGJyb3dzZXJzLiBuZWVkZWQgZm9yIEZpcmVmb3gpXHJcbiAgICAvLyBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhbXNnL21vemlsbGEuZGV2LnBsYXRmb3JtL0lIa0JabEhFVHBBL2R3c01OY2hXRVFBSlxyXG4gICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSB0aHJlYWRzIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxyXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyB0aHJlYWRlZCBpbnN0cnVjdGlvbnMuXHJcbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUoXHJcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcclxuICAgICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCA1LCA0LCAxLCAzLCAxLCAxLCAxMCwgMTEsIDEsIDksIDAsIDY1LCAwLCAyNTQsIDE2LFxyXG4gICAgICAgIDIsIDAsIDI2LCAxMSxcclxuICAgICAgXSksXHJcbiAgICApO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBpc1NpbWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIFRlc3QgZm9yIFdlYkFzc2VtYmx5IFNJTUQgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXHJcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIFNJTUQgaW5zdHJ1Y3Rpb25zLlxyXG5cclxuICAgIC8vIFRoZSBiaW5hcnkgZGF0YSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgZm9sbG93aW5nIGNvZGUgYnkgd2F0Mndhc206XHJcbiAgICAvL1xyXG4gICAgLy8gKG1vZHVsZVxyXG4gICAgLy8gICAodHlwZSAkdDAgKGZ1bmMpKVxyXG4gICAgLy8gICAoZnVuYyAkZjAgKHR5cGUgJHQwKVxyXG4gICAgLy8gICAgIChkcm9wXHJcbiAgICAvLyAgICAgICAoaTMyeDQuZG90X2kxNng4X3NcclxuICAgIC8vICAgICAgICAgKGk4eDE2LnNwbGF0XHJcbiAgICAvLyAgICAgICAgICAgKGkzMi5jb25zdCAwKSlcclxuICAgIC8vICAgICAgICAgKHYxMjguY29uc3QgaTMyeDQgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDAgMHgwMDAwMDAwMCkpKSkpXHJcblxyXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxyXG4gICAgICBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCA0LCAxLCA5NiwgMCwgMCwgMywgMiwgMSwgMCwgMTAsIDMwLCAxLCAyOCwgMCwgNjUsIDAsIDI1MywgMTUsIDI1MywgMTIsIDAsIDAsIDAsXHJcbiAgICAgICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMjUzLCAxODYsIDEsIDI2LCAxMSxcclxuICAgICAgXSksXHJcbiAgICApO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBpc1JlbGF4ZWRTaW1kU3VwcG9ydGVkID0gKCk6IGJvb2xlYW4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSBSZWxheGVkIFNJTUQgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXHJcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIFJlbGF4ZWQgU0lNRCBpbnN0cnVjdGlvbnMuXHJcblxyXG4gICAgLy8gVGhlIGJpbmFyeSBkYXRhIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBmb2xsb3dpbmcgY29kZSBieSB3YXQyd2FzbTpcclxuICAgIC8vIChtb2R1bGVcclxuICAgIC8vICAgKGZ1bmMgKHJlc3VsdCB2MTI4KVxyXG4gICAgLy8gICAgICBpMzIuY29uc3QgMVxyXG4gICAgLy8gICAgICBpOHgxNi5zcGxhdFxyXG4gICAgLy8gICAgICBpMzIuY29uc3QgMlxyXG4gICAgLy8gICAgICBpOHgxNi5zcGxhdFxyXG4gICAgLy8gICAgICBpMzIuY29uc3QgM1xyXG4gICAgLy8gICAgICBpOHgxNi5zcGxhdFxyXG4gICAgLy8gICAgICBpMzJ4NC5yZWxheGVkX2RvdF9pOHgxNl9pN3gxNl9hZGRfc1xyXG4gICAgLy8gICApXHJcbiAgICAvLyAgKVxyXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxyXG4gICAgICBuZXcgVWludDhBcnJheShbXHJcbiAgICAgICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCA1LCAxLCA5NiwgMCwgMSwgMTIzLCAzLCAyLCAxLCAwLCAxMCwgMTksIDEsIDE3LCAwLCA2NSwgMSwgMjUzLCAxNSwgNjUsIDIsIDI1MyxcclxuICAgICAgICAxNSwgNjUsIDMsIDI1MywgMTUsIDI1MywgMTQ3LCAyLCAxMSxcclxuICAgICAgXSksXHJcbiAgICApO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5ID0gYXN5bmMgKGZsYWdzOiBFbnYuV2ViQXNzZW1ibHlGbGFncyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGlmIChpbml0aWFsaXplZCkge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH1cclxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtcclxuICB9XHJcbiAgaWYgKGFib3J0ZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO1xyXG4gIH1cclxuXHJcbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcclxuXHJcbiAgLy8gd2FzbSBmbGFncyBhcmUgYWxyZWFkeSBpbml0aWFsaXplZFxyXG4gIGNvbnN0IHRpbWVvdXQgPSBmbGFncy5pbml0VGltZW91dCE7XHJcbiAgbGV0IG51bVRocmVhZHMgPSBmbGFncy5udW1UaHJlYWRzITtcclxuXHJcbiAgLy8gZW5zdXJlIFNJTUQgaXMgc3VwcG9ydGVkXHJcbiAgaWYgKGZsYWdzLnNpbWQgPT09IGZhbHNlKSB7XHJcbiAgICAvLyBza2lwIFNJTUQgZmVhdHVyZSBjaGVja2luZyBhcyBpdCBpcyBkaXNhYmxlZCBleHBsaWNpdGx5IGJ5IHVzZXJcclxuICB9IGVsc2UgaWYgKGZsYWdzLnNpbWQgPT09ICdyZWxheGVkJykge1xyXG4gICAgLy8gY2hlY2sgaWYgcmVsYXhlZCBTSU1EIGlzIHN1cHBvcnRlZFxyXG4gICAgaWYgKCFpc1JlbGF4ZWRTaW1kU3VwcG9ydGVkKCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWxheGVkIFdlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4nKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKCFpc1NpbWRTdXBwb3J0ZWQoKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuJyk7XHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBpZiBtdWx0aS10aHJlYWRpbmcgaXMgc3VwcG9ydGVkXHJcbiAgY29uc3QgbXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSBpc011bHRpVGhyZWFkU3VwcG9ydGVkKCk7XHJcbiAgaWYgKG51bVRocmVhZHMgPiAxICYmICFtdWx0aVRocmVhZFN1cHBvcnRlZCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAnZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gJyArXHJcbiAgICAgICAgICBudW1UaHJlYWRzICtcclxuICAgICAgICAgICcsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiAnICtcclxuICAgICAgICAgICdTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uJyxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgY29uc29sZS53YXJuKFxyXG4gICAgICAnV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICcgKyAnRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuJyxcclxuICAgICk7XHJcblxyXG4gICAgLy8gc2V0IGZsYWdzLm51bVRocmVhZHMgdG8gMSBzbyB0aGF0IE9ydEluaXQoKSB3aWxsIG5vdCBjcmVhdGUgYSBnbG9iYWwgdGhyZWFkIHBvb2wuXHJcbiAgICBmbGFncy5udW1UaHJlYWRzID0gbnVtVGhyZWFkcyA9IDE7XHJcbiAgfVxyXG5cclxuICBjb25zdCB3YXNtUGF0aHMgPSBmbGFncy53YXNtUGF0aHM7XHJcbiAgY29uc3Qgd2FzbVByZWZpeE92ZXJyaWRlID0gdHlwZW9mIHdhc21QYXRocyA9PT0gJ3N0cmluZycgPyB3YXNtUGF0aHMgOiB1bmRlZmluZWQ7XHJcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy5tanM7XHJcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlID0gKG1qc1BhdGhPdmVycmlkZUZsYWcgYXMgVVJMKT8uaHJlZiA/PyBtanNQYXRoT3ZlcnJpZGVGbGFnO1xyXG4gIGNvbnN0IHdhc21QYXRoT3ZlcnJpZGVGbGFnID0gKHdhc21QYXRocyBhcyBFbnYuV2FzbUZpbGVQYXRocyk/Lndhc207XHJcbiAgY29uc3Qgd2FzbVBhdGhPdmVycmlkZSA9ICh3YXNtUGF0aE92ZXJyaWRlRmxhZyBhcyBVUkwpPy5ocmVmID8/IHdhc21QYXRoT3ZlcnJpZGVGbGFnO1xyXG4gIGNvbnN0IHdhc21CaW5hcnlPdmVycmlkZSA9IGZsYWdzLndhc21CaW5hcnk7XHJcblxyXG4gIGNvbnN0IFtvYmplY3RVcmwsIG9ydFdhc21GYWN0b3J5XSA9IGF3YWl0IGltcG9ydFdhc21Nb2R1bGUoXHJcbiAgICBtanNQYXRoT3ZlcnJpZGUsXHJcbiAgICB3YXNtUHJlZml4T3ZlcnJpZGUsXHJcbiAgICBudW1UaHJlYWRzID4gMSxcclxuICAgICEhd2FzbUJpbmFyeU92ZXJyaWRlIHx8ICEhd2FzbVBhdGhPdmVycmlkZSxcclxuICApO1xyXG5cclxuICBsZXQgaXNUaW1lb3V0ID0gZmFsc2U7XHJcblxyXG4gIGNvbnN0IHRhc2tzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IFtdO1xyXG5cclxuICAvLyBwcm9taXNlIGZvciB0aW1lb3V0XHJcbiAgaWYgKHRpbWVvdXQgPiAwKSB7XHJcbiAgICB0YXNrcy5wdXNoKFxyXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgaXNUaW1lb3V0ID0gdHJ1ZTtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gcHJvbWlzZSBmb3IgbW9kdWxlIGluaXRpYWxpemF0aW9uXHJcbiAgdGFza3MucHVzaChcclxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgY29uc3QgY29uZmlnOiBQYXJ0aWFsPE9ydFdhc21Nb2R1bGU+ID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGhyZWFkcy4gV2ViQXNzZW1ibHkgd2lsbCBjcmVhdGUgKE1vZHVsZS5udW1UaHJlYWRzIC0gMSkgd29ya2Vycy4gSWYgaXQgaXMgMSwgbm8gd29ya2VyIHdpbGwgYmVcclxuICAgICAgICAgKiBjcmVhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG51bVRocmVhZHMsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBpZiAod2FzbUJpbmFyeU92ZXJyaWRlKSB7XHJcbiAgICAgICAgLy8gU2V0IGEgY3VzdG9tIGJ1ZmZlciB3aGljaCBjb250YWlucyB0aGUgV2ViQXNzZW1ibHkgYmluYXJ5LiBUaGlzIHdpbGwgc2tpcCB0aGUgd2FzbSBmaWxlIGZldGNoaW5nLlxyXG4gICAgICAgIGNvbmZpZy53YXNtQmluYXJ5ID0gd2FzbUJpbmFyeU92ZXJyaWRlO1xyXG4gICAgICB9IGVsc2UgaWYgKHdhc21QYXRoT3ZlcnJpZGUgfHwgd2FzbVByZWZpeE92ZXJyaWRlKSB7XHJcbiAgICAgICAgLy8gQSBjYWxsYmFjayBmdW5jdGlvbiB0byBsb2NhdGUgdGhlIFdlYkFzc2VtYmx5IGZpbGUuIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRoZSBmdWxsIHBhdGggb2YgdGhlIGZpbGUuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBTaW5jZSBFbXNjcmlwdGVuIDMuMS41OCwgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgdGhlIC53YXNtIGZpbGUuXHJcbiAgICAgICAgY29uZmlnLmxvY2F0ZUZpbGUgPSAoZmlsZU5hbWUpID0+IHdhc21QYXRoT3ZlcnJpZGUgPz8gd2FzbVByZWZpeE92ZXJyaWRlICsgZmlsZU5hbWU7XHJcbiAgICAgIH0gZWxzZSBpZiAobWpzUGF0aE92ZXJyaWRlICYmIG1qc1BhdGhPdmVycmlkZS5pbmRleE9mKCdibG9iOicpICE9PSAwKSB7XHJcbiAgICAgICAgLy8gaWYgbWpzIHBhdGggaXMgc3BlY2lmaWVkLCB1c2UgaXQgYXMgdGhlIGJhc2UgcGF0aCBmb3IgdGhlIC53YXNtIGZpbGUuXHJcbiAgICAgICAgY29uZmlnLmxvY2F0ZUZpbGUgPSAoZmlsZU5hbWUpID0+IG5ldyBVUkwoZmlsZU5hbWUsIG1qc1BhdGhPdmVycmlkZSkuaHJlZjtcclxuICAgICAgfSBlbHNlIGlmIChvYmplY3RVcmwpIHtcclxuICAgICAgICBjb25zdCBpbmZlcnJlZFdhc21QYXRoUHJlZml4ID0gaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMoKTtcclxuICAgICAgICBpZiAoaW5mZXJyZWRXYXNtUGF0aFByZWZpeCkge1xyXG4gICAgICAgICAgLy8gaWYgdGhlIHdhc20gbW9kdWxlIGlzIHByZWxvYWRlZCwgdXNlIHRoZSBpbmZlcnJlZCB3YXNtIHBhdGggYXMgdGhlIGJhc2UgcGF0aCBmb3IgdGhlIC53YXNtIGZpbGUuXHJcbiAgICAgICAgICBjb25maWcubG9jYXRlRmlsZSA9IChmaWxlTmFtZSkgPT4gaW5mZXJyZWRXYXNtUGF0aFByZWZpeCArIGZpbGVOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgb3J0V2FzbUZhY3RvcnkoY29uZmlnKS50aGVuKFxyXG4gICAgICAgIC8vIHdhc20gbW9kdWxlIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVxyXG4gICAgICAgIChtb2R1bGUpID0+IHtcclxuICAgICAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgd2FzbSA9IG1vZHVsZTtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgIGlmIChvYmplY3RVcmwpIHtcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgZmFpbGVkIHRvIGluaXRpYWxpemVcclxuICAgICAgICAod2hhdCkgPT4ge1xyXG4gICAgICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHJlamVjdCh3aGF0KTtcclxuICAgICAgICB9LFxyXG4gICAgICApO1xyXG4gICAgfSksXHJcbiAgKTtcclxuXHJcbiAgYXdhaXQgUHJvbWlzZS5yYWNlKHRhc2tzKTtcclxuXHJcbiAgaWYgKGlzVGltZW91dCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dGltZW91dH1tc2ApO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRJbnN0YW5jZSA9ICgpOiBPcnRXYXNtTW9kdWxlID0+IHtcclxuICBpZiAoaW5pdGlhbGl6ZWQgJiYgd2FzbSkge1xyXG4gICAgcmV0dXJuIHdhc207XHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGlzcG9zZSA9ICgpOiB2b2lkID0+IHtcclxuICBpZiAoaW5pdGlhbGl6ZWQgJiYgIWluaXRpYWxpemluZyAmJiAhYWJvcnRlZCkge1xyXG4gICAgLy8gVE9ETzogY3VycmVudGx5IFwiUFRocmVhZC50ZXJtaW5hdGVBbGxUaHJlYWRzKClcIiBpcyBub3QgZXhwb3NlZCBpbiB0aGUgd2FzbSBtb2R1bGUuXHJcbiAgICAvLyAgICAgICBBbmQgdGhpcyBmdW5jdGlvbiBpcyBub3QgeWV0IGNhbGxlZCBieSBhbnkgY29kZS5cclxuICAgIC8vICAgICAgIElmIGl0IGlzIG5lZWRlZCBpbiB0aGUgZnV0dXJlLCB3ZSBzaG91bGQgZXhwb3NlIGl0IGluIHRoZSB3YXNtIG1vZHVsZSBhbmQgdW5jb21tZW50IHRoZSBmb2xsb3dpbmcgbGluZS5cclxuXHJcbiAgICAvLyB3YXNtPy5QVGhyZWFkPy50ZXJtaW5hdGVBbGxUaHJlYWRzKCk7XHJcbiAgICB3YXNtID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIGFib3J0ZWQgPSB0cnVlO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcclxuXHJcbmV4cG9ydCBjb25zdCBhbGxvY1dhc21TdHJpbmcgPSAoZGF0YTogc3RyaW5nLCBhbGxvY3M6IG51bWJlcltdKTogbnVtYmVyID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuXHJcbiAgY29uc3QgZGF0YUxlbmd0aCA9IHdhc20ubGVuZ3RoQnl0ZXNVVEY4KGRhdGEpICsgMTtcclxuICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFMZW5ndGgpO1xyXG4gIHdhc20uc3RyaW5nVG9VVEY4KGRhdGEsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xyXG4gIGFsbG9jcy5wdXNoKGRhdGFPZmZzZXQpO1xyXG5cclxuICByZXR1cm4gZGF0YU9mZnNldDtcclxufTtcclxuXHJcbmludGVyZmFjZSBFeHRyYU9wdGlvbnNIYW5kbGVyIHtcclxuICAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGl0ZXJhdGVFeHRyYU9wdGlvbnMgPSAoXHJcbiAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXHJcbiAgcHJlZml4OiBzdHJpbmcsXHJcbiAgc2VlbjogV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4sXHJcbiAgaGFuZGxlcjogRXh0cmFPcHRpb25zSGFuZGxlcixcclxuKTogdm9pZCA9PiB7XHJcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcclxuICAgIGlmIChzZWVuLmhhcyhvcHRpb25zKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZWVuLmFkZChvcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgY29uc3QgbmFtZSA9IHByZWZpeCA/IHByZWZpeCArIGtleSA6IGtleTtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnModmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIG5hbWUgKyAnLicsIHNlZW4sIGhhbmRsZXIpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZSA/ICcxJyA6ICcwJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgdmFsdWV9YCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogY2hlY2sgd2ViIGFzc2VtYmx5IEFQSSdzIGxhc3QgZXJyb3IgYW5kIHRocm93IGVycm9yIGlmIGFueSBlcnJvciBvY2N1cnJlZC5cclxuICogQHBhcmFtIG1lc3NhZ2UgYSBtZXNzYWdlIHVzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjaGVja0xhc3RFcnJvciA9IChtZXNzYWdlOiBzdHJpbmcpOiB2b2lkID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuXHJcbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcclxuICAgIGNvbnN0IHBhcmFtc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYygyICogcHRyU2l6ZSk7XHJcbiAgICB3YXNtLl9PcnRHZXRMYXN0RXJyb3IocGFyYW1zT2Zmc2V0LCBwYXJhbXNPZmZzZXQgKyBwdHJTaXplKTtcclxuICAgIGNvbnN0IGVycm9yQ29kZSA9IE51bWJlcih3YXNtLmdldFZhbHVlKHBhcmFtc09mZnNldCwgcHRyU2l6ZSA9PT0gNCA/ICdpMzInIDogJ2k2NCcpKTtcclxuICAgIGNvbnN0IGVycm9yTWVzc2FnZVBvaW50ZXIgPSB3YXNtLmdldFZhbHVlKHBhcmFtc09mZnNldCArIHB0clNpemUsICcqJyk7XHJcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2VQb2ludGVyID8gd2FzbS5VVEY4VG9TdHJpbmcoZXJyb3JNZXNzYWdlUG9pbnRlcikgOiAnJztcclxuICAgIHRocm93IG5ldyBFcnJvcihgJHttZXNzYWdlfSBFUlJPUl9DT0RFOiAke2Vycm9yQ29kZX0sIEVSUk9SX01FU1NBR0U6ICR7ZXJyb3JNZXNzYWdlfWApO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XHJcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnMgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNldFJ1bk9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XHJcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICBjb25zdCBydW5PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICB0cnkge1xyXG4gICAgaWYgKG9wdGlvbnM/LmxvZ1NldmVyaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBydW5PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPSAyOyAvLyBEZWZhdWx0IHRvIHdhcm5pbmdcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIHR5cGVvZiBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8XHJcbiAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCkgfHxcclxuICAgICAgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsIDwgMCB8fFxyXG4gICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPiA0XHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2V2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucz8ubG9nVmVyYm9zaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID0gMDsgLy8gRGVmYXVsdCB0byAwXHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWx9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnM/LnRlcm1pbmF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJ1bk9wdGlvbnMudGVybWluYXRlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRhZ0RhdGFPZmZzZXQgPSAwO1xyXG4gICAgaWYgKG9wdGlvbnM/LnRhZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRhZ0RhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcob3B0aW9ucy50YWcsIGFsbG9jcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcnVuT3B0aW9uc0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZVJ1bk9wdGlvbnMoXHJcbiAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCEsXHJcbiAgICAgIHJ1bk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwhLFxyXG4gICAgICAhIXJ1bk9wdGlvbnMudGVybWluYXRlISxcclxuICAgICAgdGFnRGF0YU9mZnNldCxcclxuICAgICk7XHJcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSA9PT0gMCkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnM/LmV4dHJhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyhvcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xyXG5cclxuICAgICAgICBpZiAod2FzbS5fT3J0QWRkUnVuQ29uZmlnRW50cnkocnVuT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xyXG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtydW5PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmIChydW5PcHRpb25zSGFuZGxlICE9PSAwKSB7XHJcbiAgICAgIHdhc20uX09ydFJlbGVhc2VSdW5PcHRpb25zKHJ1bk9wdGlvbnNIYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XHJcbiAgICB0aHJvdyBlO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgdHlwZSB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XHJcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnMgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xyXG5cclxuY29uc3QgZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsID0gKGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw6IHN0cmluZyB8IHVua25vd24pOiBudW1iZXIgPT4ge1xyXG4gIHN3aXRjaCAoZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCkge1xyXG4gICAgY2FzZSAnZGlzYWJsZWQnOlxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGNhc2UgJ2Jhc2ljJzpcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICBjYXNlICdleHRlbmRlZCc6XHJcbiAgICAgIHJldHVybiAyO1xyXG4gICAgY2FzZSAnbGF5b3V0JzpcclxuICAgICAgcmV0dXJuIDM7XHJcbiAgICBjYXNlICdhbGwnOlxyXG4gICAgICByZXR1cm4gOTk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtncmFwaE9wdGltaXphdGlvbkxldmVsfWApO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGdldEV4ZWN1dGlvbk1vZGUgPSAoZXhlY3V0aW9uTW9kZTogJ3NlcXVlbnRpYWwnIHwgJ3BhcmFsbGVsJyk6IG51bWJlciA9PiB7XHJcbiAgc3dpdGNoIChleGVjdXRpb25Nb2RlKSB7XHJcbiAgICBjYXNlICdzZXF1ZW50aWFsJzpcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICBjYXNlICdwYXJhbGxlbCc6XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtleGVjdXRpb25Nb2RlfWApO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGFwcGVuZERlZmF1bHRPcHRpb25zID0gKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiB2b2lkID0+IHtcclxuICBpZiAoIW9wdGlvbnMuZXh0cmEpIHtcclxuICAgIG9wdGlvbnMuZXh0cmEgPSB7fTtcclxuICB9XHJcbiAgaWYgKCFvcHRpb25zLmV4dHJhLnNlc3Npb24pIHtcclxuICAgIG9wdGlvbnMuZXh0cmEuc2Vzc2lvbiA9IHt9O1xyXG4gIH1cclxuICBjb25zdCBzZXNzaW9uID0gb3B0aW9ucy5leHRyYS5zZXNzaW9uIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbiAgaWYgKCFzZXNzaW9uLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcclxuICAgIHNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSA9ICcxJztcclxuICB9XHJcblxyXG4gIC8vIGlmIHVzaW5nIEpTRVAgd2l0aCBXZWJHUFUsIGFsd2F5cyBkaXNhYmxlIG1lbW9yeSBwYXR0ZXJuXHJcbiAgaWYgKFxyXG4gICAgb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgJiZcclxuICAgIG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUoKGVwKSA9PiAodHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZSkgPT09ICd3ZWJncHUnKVxyXG4gICkge1xyXG4gICAgb3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuID0gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgYXBwZW5kU2Vzc2lvbkNvbmZpZyA9IChzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLCBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgYWxsb2NzOiBudW1iZXJbXSk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoa2V5LCBhbGxvY3MpO1xyXG4gIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcclxuICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XHJcbiAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGFwcGVuZEVwT3B0aW9uID0gKGVwT3B0aW9uczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4sIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBhbGxvY3M6IG51bWJlcltdKTogdm9pZCA9PiB7XHJcbiAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XHJcbiAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xyXG4gIGVwT3B0aW9ucy5wdXNoKFtrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXRdKTtcclxufTtcclxuXHJcbmNvbnN0IHNldEV4ZWN1dGlvblByb3ZpZGVycyA9IGFzeW5jIChcclxuICBzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLFxyXG4gIGV4ZWN1dGlvblByb3ZpZGVyczogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5FeGVjdXRpb25Qcm92aWRlckNvbmZpZ1tdLFxyXG4gIGFsbG9jczogbnVtYmVyW10sXHJcbik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGZvciAoY29uc3QgZXAgb2YgZXhlY3V0aW9uUHJvdmlkZXJzKSB7XHJcbiAgICBsZXQgZXBOYW1lID0gdHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZTtcclxuICAgIGNvbnN0IGVwT3B0aW9uczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcclxuXHJcbiAgICAvLyBjaGVjayBFUCBuYW1lXHJcbiAgICBzd2l0Y2ggKGVwTmFtZSkge1xyXG4gICAgICBjYXNlICd3ZWJubic6XHJcbiAgICAgICAgZXBOYW1lID0gJ1dFQk5OJztcclxuICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gZXAgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xyXG4gICAgICAgICAgLy8gY29uc3QgY29udGV4dCA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0KT8uY29udGV4dDtcclxuICAgICAgICAgIGNvbnN0IGRldmljZVR5cGUgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LmRldmljZVR5cGU7XHJcbiAgICAgICAgICBpZiAoZGV2aWNlVHlwZSkge1xyXG4gICAgICAgICAgICBhcHBlbmRTZXNzaW9uQ29uZmlnKHNlc3Npb25PcHRpb25zSGFuZGxlLCAnZGV2aWNlVHlwZScsIGRldmljZVR5cGUsIGFsbG9jcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd3ZWJncHUnOlxyXG4gICAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSkge1xyXG4gICAgICAgICAgZXBOYW1lID0gJ1dlYkdQVSc7XHJcbiAgICAgICAgICBsZXQgY3VzdG9tRGV2aWNlOiBHUFVEZXZpY2UgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VzdG9tT3B0aW9ucyA9IGVwIGFzIHVua25vd24gYXMgeyBkZXZpY2U6IEdQVURldmljZSB9O1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tT3B0aW9ucy5kZXZpY2UpIHtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIEdQVURldmljZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY3VzdG9tT3B0aW9ucy5kZXZpY2UgaW5zdGFuY2VvZiBHUFVEZXZpY2UpIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbURldmljZSA9IGN1c3RvbU9wdGlvbnMuZGV2aWNlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR1BVIGRldmljZSBzZXQgaW4gV2ViR1BVIEVQIG9wdGlvbnMuJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgbW9yZSBvcHRpb25zXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgaW5mbyA9IGdldEluc3RhbmNlKCkud2ViZ3B1UmVnaXN0ZXJEZXZpY2UhKGN1c3RvbURldmljZSk7XHJcbiAgICAgICAgICBpZiAoaW5mbykge1xyXG4gICAgICAgICAgICBjb25zdCBbZGV2aWNlSWQsIGluc3RhbmNlSGFuZGxlLCBkZXZpY2VIYW5kbGVdID0gaW5mbztcclxuICAgICAgICAgICAgYXBwZW5kRXBPcHRpb24oZXBPcHRpb25zLCAnZGV2aWNlSWQnLCBkZXZpY2VJZC50b1N0cmluZygpLCBhbGxvY3MpO1xyXG4gICAgICAgICAgICBhcHBlbmRFcE9wdGlvbihlcE9wdGlvbnMsICd3ZWJncHVJbnN0YW5jZScsIGluc3RhbmNlSGFuZGxlLnRvU3RyaW5nKCksIGFsbG9jcyk7XHJcbiAgICAgICAgICAgIGFwcGVuZEVwT3B0aW9uKGVwT3B0aW9ucywgJ3dlYmdwdURldmljZScsIGRldmljZUhhbmRsZS50b1N0cmluZygpLCBhbGxvY3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlcE5hbWUgPSAnSlMnO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3Qgd2ViZ3B1T3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XHJcbiAgICAgICAgICAgIGlmICh3ZWJncHVPcHRpb25zPy5wcmVmZXJyZWRMYXlvdXQpIHtcclxuICAgICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOQ0hXJyAmJiB3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCAhPT0gJ05IV0MnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke3dlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0fWApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBhcHBlbmRTZXNzaW9uQ29uZmlnKHNlc3Npb25PcHRpb25zSGFuZGxlLCAncHJlZmVycmVkTGF5b3V0Jywgd2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQsIGFsbG9jcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3dhc20nOlxyXG4gICAgICBjYXNlICdjcHUnOlxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZXBOYW1lfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGVwTmFtZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZXBOYW1lLCBhbGxvY3MpO1xyXG4gICAgY29uc3QgZXBPcHRpb25zQ291bnQgPSBlcE9wdGlvbnMubGVuZ3RoO1xyXG4gICAgbGV0IGtleXNPZmZzZXQgPSAwO1xyXG4gICAgbGV0IHZhbHVlc09mZnNldCA9IDA7XHJcbiAgICBpZiAoZXBPcHRpb25zQ291bnQgPiAwKSB7XHJcbiAgICAgIGtleXNPZmZzZXQgPSBnZXRJbnN0YW5jZSgpLl9tYWxsb2MoZXBPcHRpb25zQ291bnQgKiBnZXRJbnN0YW5jZSgpLlBUUl9TSVpFKTtcclxuICAgICAgYWxsb2NzLnB1c2goa2V5c09mZnNldCk7XHJcbiAgICAgIHZhbHVlc09mZnNldCA9IGdldEluc3RhbmNlKCkuX21hbGxvYyhlcE9wdGlvbnNDb3VudCAqIGdldEluc3RhbmNlKCkuUFRSX1NJWkUpO1xyXG4gICAgICBhbGxvY3MucHVzaCh2YWx1ZXNPZmZzZXQpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVwT3B0aW9uc0NvdW50OyBpKyspIHtcclxuICAgICAgICBnZXRJbnN0YW5jZSgpLnNldFZhbHVlKGtleXNPZmZzZXQgKyBpICogZ2V0SW5zdGFuY2UoKS5QVFJfU0laRSwgZXBPcHRpb25zW2ldWzBdLCAnKicpO1xyXG4gICAgICAgIGdldEluc3RhbmNlKCkuc2V0VmFsdWUodmFsdWVzT2Zmc2V0ICsgaSAqIGdldEluc3RhbmNlKCkuUFRSX1NJWkUsIGVwT3B0aW9uc1tpXVsxXSwgJyonKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKFxyXG4gICAgICAoYXdhaXQgZ2V0SW5zdGFuY2UoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoXHJcbiAgICAgICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUsXHJcbiAgICAgICAgZXBOYW1lRGF0YU9mZnNldCxcclxuICAgICAgICBrZXlzT2Zmc2V0LFxyXG4gICAgICAgIHZhbHVlc09mZnNldCxcclxuICAgICAgICBlcE9wdGlvbnNDb3VudCxcclxuICAgICAgKSkgIT09IDBcclxuICAgICkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlcE5hbWV9LmApO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzZXRTZXNzaW9uT3B0aW9ucyA9IGFzeW5jIChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8W251bWJlciwgbnVtYmVyW11dPiA9PiB7XHJcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XHJcbiAgbGV0IHNlc3Npb25PcHRpb25zSGFuZGxlID0gMDtcclxuICBjb25zdCBhbGxvY3M6IG51bWJlcltdID0gW107XHJcblxyXG4gIGNvbnN0IHNlc3Npb25PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICBhcHBlbmREZWZhdWx0T3B0aW9ucyhzZXNzaW9uT3B0aW9ucyk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBncmFwaE9wdGltaXphdGlvbkxldmVsID0gZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsKHNlc3Npb25PcHRpb25zLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPz8gJ2FsbCcpO1xyXG4gICAgY29uc3QgZXhlY3V0aW9uTW9kZSA9IGdldEV4ZWN1dGlvbk1vZGUoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uTW9kZSA/PyAnc2VxdWVudGlhbCcpO1xyXG4gICAgY29uc3QgbG9nSWREYXRhT2Zmc2V0ID1cclxuICAgICAgdHlwZW9mIHNlc3Npb25PcHRpb25zLmxvZ0lkID09PSAnc3RyaW5nJyA/IGFsbG9jV2FzbVN0cmluZyhzZXNzaW9uT3B0aW9ucy5sb2dJZCwgYWxsb2NzKSA6IDA7XHJcblxyXG4gICAgY29uc3QgbG9nU2V2ZXJpdHlMZXZlbCA9IHNlc3Npb25PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPz8gMjsgLy8gRGVmYXVsdCB0byAyIC0gd2FybmluZ1xyXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1NldmVyaXR5TGV2ZWwpIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPiA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHNldmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtsb2dTZXZlcml0eUxldmVsfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxvZ1ZlcmJvc2l0eUxldmVsID0gc2Vzc2lvbk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgPz8gMDsgLy8gRGVmYXVsdCB0byAwIC0gdmVyYm9zZVxyXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1ZlcmJvc2l0eUxldmVsKSB8fCBsb2dWZXJib3NpdHlMZXZlbCA8IDAgfHwgbG9nVmVyYm9zaXR5TGV2ZWwgPiA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bG9nVmVyYm9zaXR5TGV2ZWx9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCA9XHJcbiAgICAgIHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoID09PSAnc3RyaW5nJ1xyXG4gICAgICAgID8gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsIGFsbG9jcylcclxuICAgICAgICA6IDA7XHJcblxyXG4gICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhcclxuICAgICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCxcclxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVDcHVNZW1BcmVuYSxcclxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuLFxyXG4gICAgICBleGVjdXRpb25Nb2RlLFxyXG4gICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZVByb2ZpbGluZyxcclxuICAgICAgMCxcclxuICAgICAgbG9nSWREYXRhT2Zmc2V0LFxyXG4gICAgICBsb2dTZXZlcml0eUxldmVsLFxyXG4gICAgICBsb2dWZXJib3NpdHlMZXZlbCxcclxuICAgICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCxcclxuICAgICk7XHJcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPT09IDApIHtcclxuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzKSB7XHJcbiAgICAgIGF3YWl0IHNldEV4ZWN1dGlvblByb3ZpZGVycyhzZXNzaW9uT3B0aW9uc0hhbmRsZSwgc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLCBhbGxvY3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAodHlwZW9mIHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZSAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7c2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlfWApO1xyXG4gICAgICB9XHJcbiAgICAgIGFwcGVuZFNlc3Npb25Db25maWcoXHJcbiAgICAgICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUsXHJcbiAgICAgICAgJ2VuYWJsZUdyYXBoQ2FwdHVyZScsXHJcbiAgICAgICAgc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgYWxsb2NzLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke25hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3ZhbHVlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuYW1lT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKG5hbWUsIGFsbG9jcyk7XHJcbiAgICAgICAgaWYgKHdhc20uX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShzZXNzaW9uT3B0aW9uc0hhbmRsZSwgbmFtZU9mZnNldCwgdmFsdWUpICE9PSAwKSB7XHJcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7bmFtZX0gLSAke3ZhbHVlfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXh0cmEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHNlc3Npb25PcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgYXBwZW5kU2Vzc2lvbkNvbmZpZyhzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5LCB2YWx1ZSwgYWxsb2NzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcclxuICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSkgIT09IDApIHtcclxuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XHJcbiAgICB0aHJvdyBlO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuLy8gYSBkdW1teSB0eXBlIGRlY2xhcmF0aW9uIGZvciBGbG9hdDE2QXJyYXkgaW4gY2FzZSBhbnkgcG9seWZpbGwgaXMgYXZhaWxhYmxlLlxyXG5kZWNsYXJlIGdsb2JhbCB7XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gIGNvbnN0IEZsb2F0MTZBcnJheTogYW55O1xyXG59XHJcblxyXG4vLyBUaGlzIGZpbGUgaW5jbHVkZXMgY29tbW9uIGRlZmluaXRpb25zLiBUaGV5IGRvIE5PVCBoYXZlIGRlcGVuZGVuY3kgb24gdGhlIFdlYkFzc2VtYmx5IGluc3RhbmNlLlxyXG5cclxuLyoqXHJcbiAqIENvcGllZCBmcm9tIE9OTlggZGVmaW5pdGlvbi4gVXNlIHRoaXMgdG8gZHJvcCBkZXBlbmRlbmN5ICdvbm54X3Byb3RvJyB0byBkZWNyZWFzZSBjb21waWxlZCAuanMgZmlsZSBzaXplLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVudW0gRGF0YVR5cGUge1xyXG4gIHVuZGVmaW5lZCA9IDAsXHJcbiAgZmxvYXQgPSAxLFxyXG4gIHVpbnQ4ID0gMixcclxuICBpbnQ4ID0gMyxcclxuICB1aW50MTYgPSA0LFxyXG4gIGludDE2ID0gNSxcclxuICBpbnQzMiA9IDYsXHJcbiAgaW50NjQgPSA3LFxyXG4gIHN0cmluZyA9IDgsXHJcbiAgYm9vbCA9IDksXHJcbiAgZmxvYXQxNiA9IDEwLFxyXG4gIGRvdWJsZSA9IDExLFxyXG4gIHVpbnQzMiA9IDEyLFxyXG4gIHVpbnQ2NCA9IDEzLFxyXG4gIGNvbXBsZXg2NCA9IDE0LFxyXG4gIGNvbXBsZXgxMjggPSAxNSxcclxuICBiZmxvYXQxNiA9IDE2LFxyXG5cclxuICAvLyA0LWJpdCBkYXRhLXR5cGVzXHJcbiAgdWludDQgPSAyMSxcclxuICBpbnQ0ID0gMjIsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXAgc3RyaW5nIHRlbnNvciBkYXRhIHRvIGVudW0gdmFsdWVcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSA9ICh0eXBlOiBzdHJpbmcpOiBEYXRhVHlwZSA9PiB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICdpbnQ4JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDg7XHJcbiAgICBjYXNlICd1aW50OCc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50ODtcclxuICAgIGNhc2UgJ2Jvb2wnOlxyXG4gICAgICByZXR1cm4gRGF0YVR5cGUuYm9vbDtcclxuICAgIGNhc2UgJ2ludDE2JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDE2O1xyXG4gICAgY2FzZSAndWludDE2JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQxNjtcclxuICAgIGNhc2UgJ2ludDMyJzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDMyO1xyXG4gICAgY2FzZSAndWludDMyJzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQzMjtcclxuICAgIGNhc2UgJ2Zsb2F0MTYnOlxyXG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQxNjtcclxuICAgIGNhc2UgJ2Zsb2F0MzInOlxyXG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQ7XHJcbiAgICBjYXNlICdmbG9hdDY0JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmRvdWJsZTtcclxuICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS5zdHJpbmc7XHJcbiAgICBjYXNlICdpbnQ2NCc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ2NDtcclxuICAgIGNhc2UgJ3VpbnQ2NCc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50NjQ7XHJcbiAgICBjYXNlICdpbnQ0JzpcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDQ7XHJcbiAgICBjYXNlICd1aW50NCc6XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50NDtcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYXAgZW51bSB2YWx1ZSB0byBzdHJpbmcgdGVuc29yIGRhdGFcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyA9ICh0eXBlUHJvdG86IERhdGFUeXBlKTogVGVuc29yLlR5cGUgPT4ge1xyXG4gIHN3aXRjaCAodHlwZVByb3RvKSB7XHJcbiAgICBjYXNlIERhdGFUeXBlLmludDg6XHJcbiAgICAgIHJldHVybiAnaW50OCc7XHJcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ4OlxyXG4gICAgICByZXR1cm4gJ3VpbnQ4JztcclxuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcclxuICAgICAgcmV0dXJuICdib29sJztcclxuICAgIGNhc2UgRGF0YVR5cGUuaW50MTY6XHJcbiAgICAgIHJldHVybiAnaW50MTYnO1xyXG4gICAgY2FzZSBEYXRhVHlwZS51aW50MTY6XHJcbiAgICAgIHJldHVybiAndWludDE2JztcclxuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XHJcbiAgICAgIHJldHVybiAnaW50MzInO1xyXG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XHJcbiAgICAgIHJldHVybiAndWludDMyJztcclxuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcclxuICAgICAgcmV0dXJuICdmbG9hdDE2JztcclxuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XHJcbiAgICAgIHJldHVybiAnZmxvYXQzMic7XHJcbiAgICBjYXNlIERhdGFUeXBlLmRvdWJsZTpcclxuICAgICAgcmV0dXJuICdmbG9hdDY0JztcclxuICAgIGNhc2UgRGF0YVR5cGUuc3RyaW5nOlxyXG4gICAgICByZXR1cm4gJ3N0cmluZyc7XHJcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxyXG4gICAgICByZXR1cm4gJ2ludDY0JztcclxuICAgIGNhc2UgRGF0YVR5cGUudWludDY0OlxyXG4gICAgICByZXR1cm4gJ3VpbnQ2NCc7XHJcbiAgICBjYXNlIERhdGFUeXBlLmludDQ6XHJcbiAgICAgIHJldHVybiAnaW50NCc7XHJcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ0OlxyXG4gICAgICByZXR1cm4gJ3VpbnQ0JztcclxuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlUHJvdG99YCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGdldCB0ZW5zb3Igc2l6ZSBpbiBieXRlcyBieSB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCBkaW1lbnNpb25zXHJcbiAqIEByZXR1cm5zIHNpemUgaW4gaW50ZWdlciBvciB1bmRlZmluZWQgaWYgdGhlIGRhdGEgdHlwZSBpcyBub3Qgc3VwcG9ydGVkXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMgPSAoXHJcbiAgZGF0ZVR5cGU6IG51bWJlcixcclxuICBkaW1zT3JTaXplOiByZWFkb25seSBudW1iZXJbXSB8IG51bWJlcixcclxuKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcclxuICBjb25zdCBlbGVtZW50U2l6ZSA9IFtcclxuICAgIC0xLCAvLyB1bmRlZmluZWQgPSAwXHJcbiAgICA0LCAvLyBmbG9hdCA9IDFcclxuICAgIDEsIC8vIHVpbnQ4ID0gMlxyXG4gICAgMSwgLy8gaW50OCA9IDNcclxuICAgIDIsIC8vIHVpbnQxNiA9IDRcclxuICAgIDIsIC8vIGludDE2ID0gNVxyXG4gICAgNCwgLy8gaW50MzIgPSA2XHJcbiAgICA4LCAvLyBpbnQ2NCA9IDdcclxuICAgIC0xLCAvLyBzdHJpbmcgPSA4XHJcbiAgICAxLCAvLyBib29sID0gOVxyXG4gICAgMiwgLy8gZmxvYXQxNiA9IDEwXHJcbiAgICA4LCAvLyBkb3VibGUgPSAxMVxyXG4gICAgNCwgLy8gdWludDMyID0gMTJcclxuICAgIDgsIC8vIHVpbnQ2NCA9IDEzXHJcbiAgICAtMSwgLy8gY29tcGxleDY0ID0gMTRcclxuICAgIC0xLCAvLyBjb21wbGV4MTI4ID0gMTVcclxuICAgIC0xLCAvLyBiZmxvYXQxNiA9IDE2XHJcbiAgICAtMSwgLy8gRkxPQVQ4RTRNM0ZOID0gMTdcclxuICAgIC0xLCAvLyBGTE9BVDhFNE0zRk5VWiA9IDE4XHJcbiAgICAtMSwgLy8gRkxPQVQ4RTVNMiA9IDE5XHJcbiAgICAtMSwgLy8gRkxPQVQ4RTVNMkZOVVogPSAyMFxyXG4gICAgMC41LCAvLyB1aW50NCA9IDIxXHJcbiAgICAwLjUsIC8vIGludDQgPSAyMlxyXG4gIF1bZGF0ZVR5cGVdO1xyXG5cclxuICBjb25zdCBzaXplID0gdHlwZW9mIGRpbXNPclNpemUgPT09ICdudW1iZXInID8gZGltc09yU2l6ZSA6IGRpbXNPclNpemUucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XHJcbiAgcmV0dXJuIGVsZW1lbnRTaXplID4gMCA/IE1hdGguY2VpbChzaXplICogZWxlbWVudFNpemUpIDogdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGdldCB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciBieSB0aGUgZ2l2ZW4gdGVuc29yIHR5cGVcclxuICovXHJcbmV4cG9ydCBjb25zdCB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IgPSAoXHJcbiAgdHlwZTogVGVuc29yLlR5cGUsXHJcbik6XHJcbiAgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBJbnQ4QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBJbnQzMkFycmF5Q29uc3RydWN0b3JcclxuICB8IEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXHJcbiAgfCBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvclxyXG4gIHwgQmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvciA9PiB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICdmbG9hdDE2JzpcclxuICAgICAgLy8gYWxsb3cgRmxvYXQxNkFycmF5IHBvbHlmaWxsLlxyXG4gICAgICByZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb20gPyBGbG9hdDE2QXJyYXkgOiBVaW50MTZBcnJheTtcclxuICAgIGNhc2UgJ2Zsb2F0MzInOlxyXG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xyXG4gICAgY2FzZSAndWludDgnOlxyXG4gICAgICByZXR1cm4gVWludDhBcnJheTtcclxuICAgIGNhc2UgJ2ludDgnOlxyXG4gICAgICByZXR1cm4gSW50OEFycmF5O1xyXG4gICAgY2FzZSAndWludDE2JzpcclxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xyXG4gICAgY2FzZSAnaW50MTYnOlxyXG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcclxuICAgIGNhc2UgJ2ludDMyJzpcclxuICAgICAgcmV0dXJuIEludDMyQXJyYXk7XHJcbiAgICBjYXNlICdib29sJzpcclxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XHJcbiAgICBjYXNlICdmbG9hdDY0JzpcclxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcclxuICAgIGNhc2UgJ3VpbnQzMic6XHJcbiAgICAgIHJldHVybiBVaW50MzJBcnJheTtcclxuICAgIGNhc2UgJ2ludDY0JzpcclxuICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XHJcbiAgICBjYXNlICd1aW50NjQnOlxyXG4gICAgICByZXR1cm4gQmlnVWludDY0QXJyYXk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogTWFwIHN0cmluZyBsb2cgbGV2ZWwgdG8gaW50ZWdlciB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxvZ0xldmVsU3RyaW5nVG9FbnVtID0gKGxvZ0xldmVsPzogJ3ZlcmJvc2UnIHwgJ2luZm8nIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJyB8ICdmYXRhbCcpOiBudW1iZXIgPT4ge1xyXG4gIHN3aXRjaCAobG9nTGV2ZWwpIHtcclxuICAgIGNhc2UgJ3ZlcmJvc2UnOlxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGNhc2UgJ2luZm8nOlxyXG4gICAgICByZXR1cm4gMTtcclxuICAgIGNhc2UgJ3dhcm5pbmcnOlxyXG4gICAgICByZXR1cm4gMjtcclxuICAgIGNhc2UgJ2Vycm9yJzpcclxuICAgICAgcmV0dXJuIDM7XHJcbiAgICBjYXNlICdmYXRhbCc6XHJcbiAgICAgIHJldHVybiA0O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2xvZ0xldmVsfWApO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgR1BVIGJ1ZmZlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IHR5cGUgaXMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9PlxyXG4gIHR5cGUgPT09ICdmbG9hdDMyJyB8fFxyXG4gIHR5cGUgPT09ICdmbG9hdDE2JyB8fFxyXG4gIHR5cGUgPT09ICdpbnQzMicgfHxcclxuICB0eXBlID09PSAnaW50NjQnIHx8XHJcbiAgdHlwZSA9PT0gJ3VpbnQzMicgfHxcclxuICB0eXBlID09PSAndWludDgnIHx8XHJcbiAgdHlwZSA9PT0gJ2Jvb2wnIHx8XHJcbiAgdHlwZSA9PT0gJ3VpbnQ0JyB8fFxyXG4gIHR5cGUgPT09ICdpbnQ0JztcclxuXHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgV2ViTk4gTUxUZW5zb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IHR5cGUgaXMgVGVuc29yLk1MVGVuc29yRGF0YVR5cGVzID0+XHJcbiAgdHlwZSA9PT0gJ2Zsb2F0MzInIHx8XHJcbiAgdHlwZSA9PT0gJ2Zsb2F0MTYnIHx8XHJcbiAgdHlwZSA9PT0gJ2ludDMyJyB8fFxyXG4gIHR5cGUgPT09ICdpbnQ2NCcgfHxcclxuICB0eXBlID09PSAndWludDMyJyB8fFxyXG4gIHR5cGUgPT09ICd1aW50NjQnIHx8XHJcbiAgdHlwZSA9PT0gJ2ludDgnIHx8XHJcbiAgdHlwZSA9PT0gJ3VpbnQ4JyB8fFxyXG4gIHR5cGUgPT09ICdib29sJyB8fFxyXG4gIHR5cGUgPT09ICd1aW50NCcgfHxcclxuICB0eXBlID09PSAnaW50NCc7XHJcblxyXG4vKipcclxuICogTWFwIHN0cmluZyBkYXRhIGxvY2F0aW9uIHRvIGludGVnZXIgdmFsdWVcclxuICovXHJcbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0gPSAobG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb24pOiBudW1iZXIgPT4ge1xyXG4gIHN3aXRjaCAobG9jYXRpb24pIHtcclxuICAgIGNhc2UgJ25vbmUnOlxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGNhc2UgJ2NwdSc6XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XHJcbiAgICAgIHJldHVybiAyO1xyXG4gICAgY2FzZSAndGV4dHVyZSc6XHJcbiAgICAgIHJldHVybiAzO1xyXG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XHJcbiAgICAgIHJldHVybiA0O1xyXG4gICAgY2FzZSAnbWwtdGVuc29yJzpcclxuICAgICAgcmV0dXJuIDU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7bG9jYXRpb259YCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hcCBpbnRlZ2VyIGRhdGEgbG9jYXRpb24gdG8gc3RyaW5nIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGF0YUxvY2F0aW9uRW51bVRvU3RyaW5nID0gKGxvY2F0aW9uOiBudW1iZXIpOiBUZW5zb3IuRGF0YUxvY2F0aW9uIHwgdW5kZWZpbmVkID0+XHJcbiAgKFsnbm9uZScsICdjcHUnLCAnY3B1LXBpbm5lZCcsICd0ZXh0dXJlJywgJ2dwdS1idWZmZXInLCAnbWwtdGVuc29yJ10gYXMgY29uc3QpW2xvY2F0aW9uXTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcclxuXHJcbi8qKlxyXG4gKiBMb2FkIGEgZmlsZSBpbnRvIGEgVWludDhBcnJheS5cclxuICpcclxuICogQHBhcmFtIGZpbGUgLSB0aGUgZmlsZSB0byBsb2FkLiBDYW4gYmUgYSBVUkwvcGF0aCwgYSBCbG9iLCBhbiBBcnJheUJ1ZmZlciwgb3IgYSBVaW50OEFycmF5LlxyXG4gKiBAcmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZmlsZSBkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxvYWRGaWxlID0gYXN5bmMgKGZpbGU6IHN0cmluZyB8IEJsb2IgfCBBcnJheUJ1ZmZlckxpa2UgfCBVaW50OEFycmF5KTogUHJvbWlzZTxVaW50OEFycmF5PiA9PiB7XHJcbiAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xyXG4gICAgaWYgKGlzTm9kZSkge1xyXG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBOb2RlLmpzXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyByZWFkRmlsZSB9ID0gcmVxdWlyZSgnbm9kZTpmcy9wcm9taXNlcycpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCByZWFkRmlsZShmaWxlKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZS5jb2RlID09PSAnRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFJykge1xyXG4gICAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBmcy5jcmVhdGVSZWFkU3RyZWFtIGluc3RlYWRcclxuICAgICAgICAgIGNvbnN0IHsgY3JlYXRlUmVhZFN0cmVhbSB9ID0gcmVxdWlyZSgnbm9kZTpmcycpO1xyXG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbShmaWxlKTtcclxuICAgICAgICAgIGNvbnN0IGNodW5rczogVWludDhBcnJheVtdID0gW107XHJcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gbG9hZCBmaWxlIGludG8gQXJyYXlCdWZmZXIgaW4gYnJvd3NlcnNcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlKTtcclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2ZpbGV9YCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY29udGVudExlbmd0aEhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpO1xyXG4gICAgICBjb25zdCBmaWxlU2l6ZSA9IGNvbnRlbnRMZW5ndGhIZWFkZXIgPyBwYXJzZUludChjb250ZW50TGVuZ3RoSGVhZGVyLCAxMCkgOiAwO1xyXG4gICAgICBpZiAoZmlsZVNpemUgPCAxMDczNzQxODI0IC8qIDFHQiAqLykge1xyXG4gICAgICAgIC8vIHdoZW4gQ29udGVudC1MZW5ndGggaGVhZGVyIGlzIG5vdCBzZXQsIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGZpbGUgc2l6ZS4gV2UgYXNzdW1lIGl0IGlzIHNtYWxsIGVub3VnaCB0b1xyXG4gICAgICAgIC8vIGxvYWQgaW50byBtZW1vcnkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGZpbGUgaXMgdG9vIGxhcmdlLCB1c2Ugc3RyZWFtIGluc3RlYWRcclxuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2ZpbGV9LCBubyByZXNwb25zZSBib2R5LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xyXG5cclxuICAgICAgICBsZXQgYnVmZmVyO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAvLyB0cnkgdG8gY3JlYXRlIEFycmF5QnVmZmVyIGRpcmVjdGx5XHJcbiAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZmlsZVNpemUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xyXG4gICAgICAgICAgICAvLyB1c2UgV2ViQXNzZW1ibHkgTWVtb3J5IHRvIGFsbG9jYXRlIGxhcmdlciBBcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IE1hdGguY2VpbChmaWxlU2l6ZSAvIDY1NTM2KTtcclxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7IGluaXRpYWw6IHBhZ2VzLCBtYXhpbXVtOiBwYWdlcyB9KS5idWZmZXI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBjaHVua1NpemUgPSB2YWx1ZS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgY2h1bmtTaXplKTtcclxuICAgICAgICAgIGNodW5rLnNldCh2YWx1ZSk7XHJcbiAgICAgICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCBmaWxlU2l6ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBCbG9iKSB7XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpKTtcclxuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICByZXR1cm4gZmlsZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGZpbGUpO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgbG9nTGV2ZWxTdHJpbmdUb0VudW0gfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XHJcblxyXG50eXBlIExvZ0xldmVsID0gTm9uTnVsbGFibGU8RW52Wydsb2dMZXZlbCddPjtcclxudHlwZSBNZXNzYWdlU3RyaW5nID0gc3RyaW5nO1xyXG50eXBlIE1lc3NhZ2VGdW5jdGlvbiA9ICgpID0+IHN0cmluZztcclxudHlwZSBNZXNzYWdlID0gTWVzc2FnZVN0cmluZyB8IE1lc3NhZ2VGdW5jdGlvbjtcclxuXHJcbmNvbnN0IGxvZ0xldmVsUHJlZml4ID0gWydWJywgJ0knLCAnVycsICdFJywgJ0YnXTtcclxuXHJcbmNvbnN0IGRvTG9nID0gKGxldmVsOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQgPT4ge1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgY29uc29sZS5sb2coYFske2xvZ0xldmVsUHJlZml4W2xldmVsXX0sJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9XSR7bWVzc2FnZX1gKTtcclxufTtcclxuXHJcbmxldCBjb25maWdMb2dMZXZlbDogTG9nTGV2ZWwgfCB1bmRlZmluZWQ7XHJcbmxldCBkZWJ1ZzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuXHJcbmV4cG9ydCBjb25zdCBjb25maWd1cmVMb2dnZXIgPSAoJGNvbmZpZ0xvZ0xldmVsOiBMb2dMZXZlbCwgJGRlYnVnOiBib29sZWFuKTogdm9pZCA9PiB7XHJcbiAgY29uZmlnTG9nTGV2ZWwgPSAkY29uZmlnTG9nTGV2ZWw7XHJcbiAgZGVidWcgPSAkZGVidWc7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBzaW1wbGUgbG9nZ2luZyB1dGlsaXR5IHRvIGxvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBMT0cgPSAobG9nTGV2ZWw6IExvZ0xldmVsLCBtc2c6IE1lc3NhZ2UpOiB2b2lkID0+IHtcclxuICBjb25zdCBtZXNzYWdlTGV2ZWwgPSBsb2dMZXZlbFN0cmluZ1RvRW51bShsb2dMZXZlbCk7XHJcbiAgY29uc3QgY29uZmlnTGV2ZWwgPSBsb2dMZXZlbFN0cmluZ1RvRW51bShjb25maWdMb2dMZXZlbCk7XHJcbiAgaWYgKG1lc3NhZ2VMZXZlbCA+PSBjb25maWdMZXZlbCkge1xyXG4gICAgZG9Mb2cobWVzc2FnZUxldmVsLCB0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nID8gbXNnKCkgOiBtc2cpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIHNpbXBsZSBsb2dnaW5nIHV0aWxpdHkgdG8gbG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlLiBPbmx5IGxvZ3Mgd2hlbiBkZWJ1ZyBpcyBlbmFibGVkLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IExPR19ERUJVRzogdHlwZW9mIExPRyA9ICguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBMT0c+KSA9PiB7XHJcbiAgaWYgKGRlYnVnKSB7XHJcbiAgICBMT0coLi4uYXJncyk7XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXHJcblxyXG5leHBvcnQgY2xhc3MgTWF0TXVsVXRpbCB7XHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSB3aGVuIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxyXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xyXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xyXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGNNYXRNdWxTaGFwZShhOiBbbnVtYmVyLCBudW1iZXJdLCBiOiBbbnVtYmVyLCBudW1iZXJdKTogW251bWJlciwgbnVtYmVyXSB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gYVsxXSAhPT0gYlswXSA/IHVuZGVmaW5lZCA6IFthWzBdLCBiWzFdXTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCcm9hZGNhc3RVdGlsIHtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gYnJvYWRjYXN0aW5nIDIgdGVuc29yc1xyXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXHJcbiAgICogQHBhcmFtIGIgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50ZWdlcnNcclxuICAgKiBAcGFyYW0gaXNNYXRNdWwgV2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIE1hdE11bFxyXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGNTaGFwZShcclxuICAgIGFkaW1zOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIGJkaW1zOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIGlzTWF0TXVsID0gZmFsc2UsXHJcbiAgKTogcmVhZG9ubHkgbnVtYmVyW10gfCB1bmRlZmluZWQge1xyXG4gICAgY29uc3QgYXJhbmsgPSBhZGltcy5sZW5ndGg7XHJcbiAgICBjb25zdCBicmFuayA9IGJkaW1zLmxlbmd0aDtcclxuICAgIGlmIChhcmFuayA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gYmRpbXM7XHJcbiAgICB9XHJcbiAgICBpZiAoYnJhbmsgPT09IDApIHtcclxuICAgICAgcmV0dXJuIGFkaW1zO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY3JhbmsgPSBNYXRoLm1heChhZGltcy5sZW5ndGgsIGJkaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBjZGltcyA9IG5ldyBBcnJheTxudW1iZXI+KGNyYW5rKTtcclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGxhc3QgMiBkaW1lbnNpb24gaWYgaXQgaXMgTWF0TXVsXHJcbiAgICBpZiAoaXNNYXRNdWwpIHtcclxuICAgICAgaWYgKGFyYW5rIDwgMiB8fCBicmFuayA8IDIpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNTaGFwZU1hdE11bCA9IE1hdE11bFV0aWwuY2FsY01hdE11bFNoYXBlKFxyXG4gICAgICAgIFthZGltc1thcmFuayAtIDJdLCBhZGltc1thcmFuayAtIDFdXSxcclxuICAgICAgICBbYmRpbXNbYnJhbmsgLSAyXSwgYmRpbXNbYnJhbmsgLSAxXV0sXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChjU2hhcGVNYXRNdWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgW2NkaW1zW2NyYW5rIC0gMl0sIGNkaW1zW2NyYW5rIC0gMV1dID0gY1NoYXBlTWF0TXVsO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSBpc01hdE11bCA/IDMgOiAxOyBpIDw9IGNyYW5rOyBpKyspIHtcclxuICAgICAgY29uc3QgYUxlbiA9IGFyYW5rIC0gaSA8IDAgPyAxIDogYWRpbXNbYXJhbmsgLSBpXTtcclxuICAgICAgY29uc3QgYkxlbiA9IGJyYW5rIC0gaSA8IDAgPyAxIDogYmRpbXNbYnJhbmsgLSBpXTtcclxuXHJcbiAgICAgIGlmIChhTGVuICE9PSBiTGVuICYmIGFMZW4gPiAxICYmIGJMZW4gPiAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChhTGVuLCBiTGVuKTtcclxuICAgICAgaWYgKGFMZW4gJiYgYkxlbikge1xyXG4gICAgICAgIGNkaW1zW2NyYW5rIC0gaV0gPSBNYXRoLm1heChhTGVuLCBiTGVuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB3aGVuIGVpdGhlciBhTGVuIG9yIGJMZW4gaXMgMCwgdGhlIG90aGVyIHNob3VsZCBiZSBlaXRoZXIgMCBvciAxLCBvdGhlcndpc2UgaXQgaXMgbm90IGJyb2FkY2FzdGFibGUuXHJcbiAgICAgICAgaWYgKG1heCA+IDEpIHtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNkaW1zW2NyYW5rIC0gaV0gPSAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNkaW1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2hhcGUgaXMgdW5pZGlyZWN0aW9uYWwgYnJvYWRjYXN0YWJsZSB0byBhbm90aGVyIHNoYXBlXHJcbiAgICogQHBhcmFtIHNoYXBlIFRoZSBpbnB1dCBzaGFwZVxyXG4gICAqIEBwYXJhbSBmaW5hbFNoYXBlIFRoZSBkZXNpcmVkIHNoYXBlIGFmdGVyIGJyb2FkY2FzdGluZ1xyXG4gICAqL1xyXG4gIHN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZmluYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcclxuICAgIC8vIGFsaWduIHNoYXBlIHRvIHRoZSByaWdodFxyXG4gICAgY29uc3QgaW5wdXRSYW5rID0gc2hhcGUubGVuZ3RoO1xyXG4gICAgY29uc3QgZmluYWxSYW5rID0gZmluYWxTaGFwZS5sZW5ndGg7XHJcbiAgICBpZiAoaW5wdXRSYW5rID4gZmluYWxSYW5rKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGlucHV0UmFuazsgaSsrKSB7XHJcbiAgICAgIGlmIChzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gMSAmJiBzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gZmluYWxTaGFwZVtmaW5hbFJhbmsgLSBpXSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2hhcGVVdGlsIHtcclxuICAvKipcclxuICAgKiBjYWxjdWxhdGUgdGhlIHNpemUgKG51bWJlciBvZiBlbGVtZW50cylcclxuICAgKi9cclxuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgMCwgZGltcy5sZW5ndGgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY29udmVydCBkaW1zIGNvcnJlc3BvbmRpbmcgdG8gdHlwZSBjaGFuZ2UgdG8gcGFjay4gZXguIHVpbnQ4IGRhdGEgdG8gdWludDMyXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbnZlcnRTaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgc2l6ZSA9IDQpOiByZWFkb25seSBudW1iZXJbXSB7XHJcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XHJcbiAgICBpZiAocmFuayA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdEaW1zID0gbmV3IEFycmF5KHJhbmspO1xyXG4gICAgbGV0IGkgPSByYW5rIC0gMTtcclxuICAgIHdoaWxlIChpID49IDApIHtcclxuICAgICAgaWYgKGRpbXNbaV0gJSBzaXplID09PSAwKSB7XHJcbiAgICAgICAgbmV3RGltc1tpXSA9IGRpbXNbaV0gLyBzaXplO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaXplICUgZGltc1tpXSAhPT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNvbnZlcnQgc2hhcGUnKTtcclxuICAgICAgfVxyXG4gICAgICBuZXdEaW1zW2ldID0gMTtcclxuICAgICAgc2l6ZSAvPSBkaW1zW2ldO1xyXG4gICAgICBpLS07XHJcbiAgICB9XHJcbiAgICBmb3IgKGktLTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgbmV3RGltc1tpXSA9IGRpbXNbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3RGltcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIHRoZSBnaXZlbiBheGlzIChpbmNsdXNpdmUpXHJcbiAgICovXHJcbiAgc3RhdGljIHNpemVGcm9tRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7YXhpc30gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCBheGlzLCBkaW1zLmxlbmd0aCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjYWxjdWxhdGUgdGhlIHNpemUgKG51bWJlciBvZiBlbGVtZW50cykgdG8gdGhlIGdpdmVuIGF4aXMgKGV4Y2x1c2l2ZSlcclxuICAgKi9cclxuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7YXhpc30gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgMCwgYXhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjYWxjdWxhdGUgdGhlIHNpemUgKG51bWJlciBvZiBlbGVtZW50cykgZnJvbSBhbmQgdG8gdGhlIGdpdmVuIGF4aXMgW3N0YXJ0LCBlbmQpXHJcbiAgICovXHJcbiAgc3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIGxldCBzaXplID0gMTtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICAgIC8vIHNhZmV0eSBjaGVjayBhcyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgbXVsdGlwbGUgb3RoZXIgbWV0aG9kcyByZXF1aXJpbmcgc2l6ZS5cclxuICAgICAgLy8gc2l6ZSBjYW5ub3QgYmUgbmVnYXRpdmUuXHJcbiAgICAgIGlmIChkaW1zW2ldIDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXHJcbiAgICAgICAgICAnY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLicsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBzaXplICo9IE51bWJlcihkaW1zW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaXplO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNvbXB1dGVTdHJpZGVzKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xyXG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xyXG4gICAgaWYgKHJhbmsgPT09IDApIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBbMV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmspO1xyXG4gICAgc3RyaWRlc1tyYW5rIC0gMV0gPSAxO1xyXG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBkaW1zW3JhbmsgLSAxXTtcclxuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogZGltc1tpICsgMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyaWRlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG5vcm1hbGl6ZSBheGlzIG9mIHJhbmdlIFstciwgcikgaW50byBbMCwgcikuXHJcbiAgICovXHJcbiAgc3RhdGljIG5vcm1hbGl6ZUF4aXMoYXhpczogbnVtYmVyLCB0ZW5zb3JSYW5rOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgaWYgKGF4aXMgPCAtdGVuc29yUmFuayAmJiBheGlzID49IHRlbnNvclJhbmspIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBheGlzIDwgMCA/IGF4aXMgKyB0ZW5zb3JSYW5rIDogYXhpcztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBub3JtYWxpemVBeGVzKGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCB0ZW5zb3JSYW5rPzogbnVtYmVyKTogbnVtYmVyW10ge1xyXG4gICAgcmV0dXJuIGF4ZXMubWFwKCh4KSA9PiB0aGlzLm5vcm1hbGl6ZUF4aXMoeCwgdGVuc29yUmFuayA/PyBheGVzLmxlbmd0aCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydHMgYSBnaXZlbiBhcnJheSBiYXNlZCBvbiB0aGUgaW5kaWNlcyBpbiB0aGUgUGVybSBhcnJheVxyXG4gICAqIFVzZWQgaW4gVHJhbnNwb3NlXHJcbiAgICogQHBhcmFtIGEgQXJyYXkgdG8gYmUgc29ydGVkIHN1Y2ggYXMgZGltcyBvciBzdHJpZGVzXHJcbiAgICogQHBhcmFtIHBlcm0gUGVybSBnaXZlbjsgaWYgbnVsbCBhIHdpbGwgYmUgcmV2ZXJzZWRcclxuICAgKi9cclxuICBzdGF0aWMgc29ydEJhc2VkT25QZXJtKGE6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtPzogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XHJcbiAgICBpZiAocGVybSkge1xyXG4gICAgICByZXR1cm4gcGVybS5tYXAoKHYpID0+IGFbdl0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGEuc2xpY2UoKS5yZXZlcnNlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYWRzIGEgZ2l2ZW4gc2hhcGUgYWNjb3JkaW5nIHRvIHRoZSBwYWRkaW5nIHZhbHVlc1xyXG4gICAqIEBwYXJhbSBkaW1zIHNoYXBlIG9mIHRoZSBUZW5zb3IgdG8gYmUgcGFkZGVkXHJcbiAgICogQHBhcmFtIHBhZCBwYWQgdmFsdWVzXHJcbiAgICovXHJcbiAgc3RhdGljIHBhZFNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBwYWQ6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xyXG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGRpbXMubWFwKCh2LCBpKSA9PiB2ICsgcGFkW2ldICsgcGFkW2kgKyByYW5rXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSB0d28gc2hhcGVzIGFyZSBpZGVudGljYWxcclxuICAgKiBAcGFyYW0gc2hhcGUxXHJcbiAgICogQHBhcmFtIHNoYXBlMlxyXG4gICAqL1xyXG4gIHN0YXRpYyBhcmVFcXVhbChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoc2hhcGUxLmxlbmd0aCAhPT0gc2hhcGUyLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhcGUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBzaGFwZTJbaV0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFBvb2xDb252VXRpbCB7XHJcbiAgLyoqXHJcbiAgICogQWRqdXN0IHRoZSBrZXJuZWwsIHN0cmlkZXMsIHBhZHMgdG8gY29ycmVjdCByYW5rLiBTZXQgdG8gZGVmYXVsdCB2YWx1ZSBpZiBub3QgcHJlc2VudFxyXG4gICAqIEBwYXJhbSBpc0dsb2JhbE9wZXJhdG9yIElmIHRydWUsIHBlcmZvcm0gZ2xvYmFsIHBvb2xpbmcuXHJcbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi5cclxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICogQHBhcmFtIHN0cmlkZXMgU3RyaWRlIGFsb25nIGVhY2ggYXhpcy5cclxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cclxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyhcclxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXHJcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxyXG4gICAgc3RyaWRlczogbnVtYmVyW10sXHJcbiAgICBkaWxhdGlvbnM6IG51bWJlcltdLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAoIWlzR2xvYmFsT3BlcmF0b3IgJiYga2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xyXG4gICAgICAvLyBhZGp1c3Qga2VybmVsIHNoYXBlIHRvIGNvdmVyIHRoZSBpbnB1dCBkaW1zXHJcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xyXG4gICAgICAgIGlmIChkaW0gPj0ga2VybmVsU2hhcGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0RGltc1tkaW0gKyAyXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0gPSBpbnB1dERpbXNbZGltICsgMl07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRqdXN0IHN0cmlkZXMgbGVuZ3RoIHRvIG1hdGNoIGtlcm5lbCBzaGFwZSBsZW5ndGhcclxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcclxuICAgICAgaWYgKGRpbSA8IHN0cmlkZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHN0cmlkZXNbZGltXSA8IDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RyaWRlcy5wdXNoKDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRqdXN0IGRpbGF0aW9uIHZhbHVlXHJcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XHJcbiAgICAgIGlmIChkaW0gPCBkaWxhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGRpbGF0aW9uc1tkaW1dIDwgMCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRpbGF0aW9ucy5wdXNoKDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRqdXN0IHBhZHMgbGVuZ3RoIHRvIG1hdGNoIDIgKiBrZXJuZWwgc2hhcGUgbGVuZ3RoXHJcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGggKiAyOyBkaW0rKykge1xyXG4gICAgICBpZiAoZGltIDwgcGFkcy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocGFkc1tkaW1dIDwgMCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhZHMucHVzaCgwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNhbml0eSBjaGVja3MgZm9yIHZhbHVlcyBpbiBrZXJuZWwgc2hhcGVzIGFuZCBwYWRzXHJcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XHJcbiAgICAgIGlmIChrZXJuZWxTaGFwZVtkaW1dIDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocGFkc1tkaW1dID49IGtlcm5lbFNoYXBlW2RpbV0gfHwgcGFkc1tkaW0gKyBrZXJuZWxTaGFwZS5sZW5ndGhdID49IGtlcm5lbFNoYXBlW2RpbV0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWwnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gYWRqdXN0IHBhZCB2YWx1ZXMgYmFzZWQgb24gJ2F1dG9QYWQnIGF0dHJpYnV0ZVxyXG4gIHN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXHJcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgICBpc0NoYW5uZWxMYXN0OiBib29sZWFuLFxyXG4gICAgYXV0b1BhZD86IHN0cmluZyxcclxuICApOiB2b2lkIHtcclxuICAgIGlmICghYXV0b1BhZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhZHMubGVuZ3RoICE9PSAyICogKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdHJpZGVzLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xyXG4gICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXHJcbiAgICAgICAgaW5wdXREaW1zW2RpbSArIChpc0NoYW5uZWxMYXN0ID8gMSA6IDIpXSxcclxuICAgICAgICBzdHJpZGVzW2RpbV0sXHJcbiAgICAgICAgZGlsYXRpb25zW2RpbV0sXHJcbiAgICAgICAga2VybmVsU2hhcGVbZGltXSxcclxuICAgICAgICBwYWRzLFxyXG4gICAgICAgIGRpbSxcclxuICAgICAgICBkaW0gKyBpbnB1dERpbXMubGVuZ3RoIC0gMixcclxuICAgICAgICBhdXRvUGFkLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcclxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxyXG4gICAqIEBwYXJhbSBpbnB1dERpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb24uIChpbnB1dHNbMF0uZGltcylcclxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqIEBwYXJhbSBrZXJuZWxTaGFwZSBUaGUgc2l6ZSBvZiB0aGUga2VybmVsIGFsb25nIGVhY2ggYXhpcy5cclxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcclxuICAgKiAgICAgZGltZW5zaW9uLiBDYW4gdGFrZSB2YWx1ZXMgTk9UU0VULCBTQU1FX1VQUEVSLCBTQU1FX0xPV0VSLCBvciBWQUxJRC5cclxuICAgKi9cclxuICBzdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShcclxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXHJcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgc3RyaWRlczogbnVtYmVyW10sXHJcbiAgICBkaWxhdGlvbnM6IG51bWJlcltdLFxyXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxyXG4gICk6IG51bWJlcltdIHtcclxuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGNoYW5uZWxzIG9mIG91dHB1dFxyXG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGlucHV0RGltc1sxXV07XHJcblxyXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihcclxuICAgICAgaXNHbG9iYWxPcGVyYXRvcixcclxuICAgICAgaW5wdXREaW1zLFxyXG4gICAgICBvdXRwdXREaW1zLFxyXG4gICAgICBzdHJpZGVzLFxyXG4gICAgICBkaWxhdGlvbnMsXHJcbiAgICAgIGtlcm5lbFNoYXBlLFxyXG4gICAgICBwYWRzLFxyXG4gICAgICBhdXRvUGFkLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBvdXRwdXREaW1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIENvbnYgb3AgYmFzZWQgb24gaW5wdXQgYXR0cmlidXRlcy4gKFNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIENvbnYgb3ApXHJcbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxyXG4gICAqIEBwYXJhbSBmaWx0ZXJEaW1zIFRoZSBmaWx0ZXIgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1sxXS5kaW1zKVxyXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxyXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXHJcbiAgICogQHBhcmFtIGF1dG9QYWQgREVQUkVDQVRFRCBhdHRyaWJ1dGUgc3VwcG9ydGVkIGZvciBsZWdhY3kgbW9kZWxzLiBTcGVjaWZpZXMgaG93IHRvIGltcGxpY2l0bHkgY2FsY3VsYXRlIHBhZHMgaW4gZWFjaFxyXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxyXG4gICAqL1xyXG4gIHN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKFxyXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgc3RyaWRlczogbnVtYmVyW10sXHJcbiAgICBkaWxhdGlvbnM6IG51bWJlcltdLFxyXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxyXG4gICk6IG51bWJlcltdIHtcclxuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDAgfHwgZmlsdGVyRGltcy5sZW5ndGggPD0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXMnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGNoYW5uZWxzIG9mIG91dHB1dFxyXG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGZpbHRlckRpbXNbMF1dO1xyXG5cclxuICAgIFBvb2xDb252VXRpbC5jb21wdXRlU2hhcGVIZWxwZXIoZmFsc2UsIGlucHV0RGltcywgb3V0cHV0RGltcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXV0b1BhZCk7XHJcbiAgICByZXR1cm4gb3V0cHV0RGltcztcclxuICB9XHJcblxyXG4gIC8vIHdpbGwgY29tcHV0ZSBvdXRwdXQgc2hhcGVzIGZvciBkYXRhIGRpbWVuc2lvbnMgT05MWSAoaS5lLikgbm8gYmF0Y2ggc2l6ZSBhbmQgY2hhbm5lbHNcclxuICAvLyBjYWxsZWQgYnkgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSgpIGFuZCBjb21wdXRlQ29udk91dHB1dFNoYXBlKClcclxuICAvLyBhZGp1c3QgcGFkcyBiYXNlZCBvbiAnYXV0b1BhZCcgYXR0cmlidXRlIHByaW9yIHRvIHNoYXBlIGNvbXB1dGF0aW9uXHJcbiAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKFxyXG4gICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcclxuICAgIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgICBvdXRwdXREaW1zOiBudW1iZXJbXSxcclxuICAgIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIHBhZHM6IG51bWJlcltdLFxyXG4gICAgYXV0b1BhZD86IHN0cmluZyxcclxuICApIHtcclxuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XHJcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xyXG4gICAgICAgIG91dHB1dERpbXMucHVzaCgxKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XHJcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKFxyXG4gICAgICAgICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxyXG4gICAgICAgICAgICBpbnB1dERpbXNbZGltICsgMl0sXHJcbiAgICAgICAgICAgIHN0cmlkZXNbZGltXSxcclxuICAgICAgICAgICAgZGlsYXRpb25zW2RpbV0sXHJcbiAgICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0sXHJcbiAgICAgICAgICAgIHBhZHMsXHJcbiAgICAgICAgICAgIGRpbSxcclxuICAgICAgICAgICAgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXHJcbiAgICAgICAgICAgIGF1dG9QYWQsXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGhlbHBlciBmb3IgY29tcHV0ZVNoYXBlSGVscGVyKCkgYW5kIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCgpXHJcbiAgLy8gYWRqdXN0cyBwYWQgdmFsdWUgZm9yIGdpdmVuICdhdXRvUGFkJyBzdHJpbmcgYW5kIGNvbXB1dGVzIG91dHB1dCBzaGFwZSBhbG9uZyBhIHBhcnRpY3VsYXIgZGltZW5zaW9uXHJcbiAgcHJpdmF0ZSBzdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXHJcbiAgICBpblNpemU6IG51bWJlcixcclxuICAgIHN0cmlkZTogbnVtYmVyLFxyXG4gICAgZGlsYXRpb246IG51bWJlcixcclxuICAgIGtlcm5lbDogbnVtYmVyLFxyXG4gICAgcGFkczogbnVtYmVyW10sXHJcbiAgICBwYWRIZWFkSW5kZXg6IG51bWJlcixcclxuICAgIHBhZFRhaWxJbmRleDogbnVtYmVyLFxyXG4gICAgYXV0b1BhZD86IHN0cmluZyxcclxuICApOiBudW1iZXIge1xyXG4gICAgY29uc3QgZGtlcm5lbCA9IGRpbGF0aW9uICogKGtlcm5lbCAtIDEpICsgMTtcclxuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XHJcbiAgICAgIHN3aXRjaCAoYXV0b1BhZCkge1xyXG4gICAgICAgIGNhc2UgJ1ZBTElEJzpcclxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XHJcbiAgICAgICAgICBwYWRzW3BhZFRhaWxJbmRleF0gPSAwO1xyXG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGluU2l6ZSAtIGRrZXJuZWwpIC8gc3RyaWRlICsgMSk7XHJcbiAgICAgICAgY2FzZSAnU0FNRV9MT1dFUic6XHJcbiAgICAgICAgY2FzZSAnU0FNRV9VUFBFUic6XHJcbiAgICAgICAgICBpZiAoZGlsYXRpb24gIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVInKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZ2FjeVRhcmdldFNpemUgPSAoaW5TaXplICsgc3RyaWRlIC0gMSkgLyBzdHJpZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZE5lZWRlZCA9IChsZWdhY3lUYXJnZXRTaXplIC0gMSkgKiBzdHJpZGUgKyBrZXJuZWwgLSBpblNpemU7XHJcbiAgICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJyA/IE1hdGguZmxvb3IoKHBhZE5lZWRlZCArIDEpIC8gMikgOiBNYXRoLmZsb29yKHBhZE5lZWRlZCAvIDIpO1xyXG4gICAgICAgICAgICBwYWRzW3BhZFRhaWxJbmRleF0gPSBwYWROZWVkZWQgLSBwYWRzW3BhZEhlYWRJbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWROZWVkZWQgLSBrZXJuZWwpIC8gc3RyaWRlICsgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSArIDEpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdlbW1VdGlsIHtcclxuICAvLyB3aWxsIG1ha2Ugc3VyZSBpbnB1dCBzaGFwZXMgYXJlIGNvbXBhdGlibGUgZm9yIHRoaXMgb3BcclxuICAvLyBhbmQgcmV0dXJuIGJhY2sgdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgaW4gdGhlIGZvcm0gb2YgYSB0dXBsZVxyXG4gIC8vIHdpbGwgdGhyb3cgZXhjZXB0aW9uIGlmIHRoZSBpbnB1dCBzaGFwZXMgYXJlIG5vdCBjb21wYXRpYmxlXHJcbiAgc3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KFxyXG4gICAgbGVmdFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICAgIHRyYW5zTGVmdDogYm9vbGVhbixcclxuICAgIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgdHJhbnNSaWdodDogYm9vbGVhbixcclxuICAgIGJpYXNTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHtcclxuICAgIGlmIChsZWZ0U2hhcGUubGVuZ3RoICE9PSAyIHx8IHJpZ2h0U2hhcGUubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDInKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgTTogbnVtYmVyO1xyXG4gICAgbGV0IEs6IG51bWJlcjtcclxuICAgIGxldCBOOiBudW1iZXI7XHJcblxyXG4gICAgaWYgKHRyYW5zTGVmdCkge1xyXG4gICAgICBNID0gbGVmdFNoYXBlWzFdO1xyXG4gICAgICBLID0gbGVmdFNoYXBlWzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgTSA9IGxlZnRTaGFwZVswXTtcclxuICAgICAgSyA9IGxlZnRTaGFwZVsxXTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQga0RpbSA9IC0xO1xyXG5cclxuICAgIGlmICh0cmFuc1JpZ2h0KSB7XHJcbiAgICAgIE4gPSByaWdodFNoYXBlWzBdO1xyXG4gICAgICBrRGltID0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIE4gPSByaWdodFNoYXBlWzFdO1xyXG4gICAgICBrRGltID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmlnaHRTaGFwZVtrRGltXSAhPT0gSykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpbWVuc2lvbiBtaXNtYXRjaCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNIDw9IDAgfHwgTiA8PSAwIHx8IEsgPD0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2hhcGUgc3BlY2lmaWVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJpYXNTaGFwZSAmJiAhQnJvYWRjYXN0VXRpbC5pc1ZhbGlkQnJvYWRjYXN0KGJpYXNTaGFwZSwgW00sIE5dKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtNLCBOLCBLXTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBNSU5fQ0xJUCA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XHJcbmV4cG9ydCBjb25zdCBNQVhfQ0xJUCA9IDMuNDAyODIzNDY2Mzg1Mjg4NmUzODtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoXHJcbiAgZGF0YUJ1ZmZlcjogQXJyYXlCdWZmZXIsXHJcbiAgdHlwZTogVGVuc29yLlR5cGUsXHJcbik6XHJcbiAgfCBJbnQzMkFycmF5XHJcbiAgfCBVaW50MzJBcnJheVxyXG4gIHwgQmlnSW50NjRBcnJheVxyXG4gIHwgQmlnVWludDY0QXJyYXlcclxuICB8IFVpbnQ4QXJyYXlcclxuICB8IEZsb2F0MzJBcnJheVxyXG4gIHwgRmxvYXQ2NEFycmF5XHJcbiAgfCBJbnQ4QXJyYXlcclxuICB8IEludDE2QXJyYXlcclxuICB8IFVpbnQxNkFycmF5ID0+IG5ldyAodGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKHR5cGUpKShkYXRhQnVmZmVyKTtcclxuXHJcbi8qKlxyXG4gKiBhIFRlbnNvclZpZXcgZG9lcyBub3Qgb3duIHRoZSBkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JWaWV3IHtcclxuICByZWFkb25seSBkYXRhOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgZGF0YVR5cGU6IG51bWJlcjtcclxuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogZ2V0IGEgRmxvYXQxNkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxyXG4gICAqL1xyXG4gIGdldFVpbnQxNkFycmF5KCk6IFVpbnQxNkFycmF5O1xyXG5cclxuICAvKipcclxuICAgKiBnZXQgYSBGbG9hdDMyQXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXHJcbiAgICovXHJcbiAgZ2V0RmxvYXQzMkFycmF5KCk6IEZsb2F0MzJBcnJheTtcclxuXHJcbiAgLyoqXHJcbiAgICogZ2V0IGEgQmlnSW50NjRBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cclxuICAgKi9cclxuICBnZXRCaWdJbnQ2NEFycmF5KCk6IEJpZ0ludDY0QXJyYXk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGdldCBhIEludDMyQXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXHJcbiAgICovXHJcbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5O1xyXG5cclxuICAvKipcclxuICAgKiBnZXQgYSBVaW50MTZBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cclxuICAgKi9cclxuICBnZXRVaW50MTZBcnJheSgpOiBVaW50MTZBcnJheTtcclxuXHJcbiAgLyoqXHJcbiAgICogY3JlYXRlIGEgbmV3IHRlbnNvciB2aWV3IHdpdGggdGhlIHNhbWUgZGF0YSBidXQgZGlmZmVyZW50IGRpbWVuc2lvbnMuXHJcbiAgICovXHJcbiAgcmVzaGFwZShuZXdEaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXc7XHJcbn1cclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBXZWJOTkJhY2tlbmQgfSBmcm9tICcuLi9iYWNrZW5kLXdlYm5uJztcclxuaW1wb3J0IHsgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi9sb2cnO1xyXG5cclxuLy8gV2ViTk4gQVBJIGN1cnJlbnRseSBkb2VzIG5vdCBoYXZlIGEgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZpbGUuIFRoaXMgZmlsZSBpcyBhIHdvcmthcm91bmQgd2l0aCB0eXBlcyBnZW5lcmF0ZWQgZnJvbVxyXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYm1hY2hpbmVsZWFybmluZy93ZWJubi9pc3N1ZXMvNjc3XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJ3ZWJubi5kLnRzXCIgLz5cclxuXHJcbi8qKlxyXG4gKiBNYXAgZnJvbSBNTE9wZXJhbmREYXRhVHlwZSB0byBzaXplIGluIGJpdHMuIFVzaW5nIGJpdHMgaW5zdGVhZCBvZiBieXRlcyB0byBhdm9pZCBwb3NzaWJsZSBwcmVjaXNpb24gbG9zcyBvbiBpbnQ0IGFuZCB1aW50NC5cclxuICovXHJcbmNvbnN0IHdlYm5uRGF0YVR5cGVUb1NpemUgPSBuZXcgTWFwPE1MT3BlcmFuZERhdGFUeXBlLCBudW1iZXI+KFtcclxuICBbJ2Zsb2F0MzInLCAzMl0sXHJcbiAgWydmbG9hdDE2JywgMTZdLFxyXG4gIFsnaW50MzInLCAzMl0sXHJcbiAgWyd1aW50MzInLCAzMl0sXHJcbiAgWydpbnQ2NCcsIDY0XSxcclxuICBbJ3VpbnQ2NCcsIDY0XSxcclxuICBbJ2ludDgnLCA4XSxcclxuICBbJ3VpbnQ4JywgOF0sXHJcbiAgWydpbnQ0JywgNF0sXHJcbiAgWyd1aW50NCcsIDRdLFxyXG5dKTtcclxuXHJcbi8vIENvbnZlcnQgaW50ZWdlciBkYXRhIHRvIGFuIEludDMyQXJyYXkgYnVmZmVyLlxyXG4vLyBTdXBwb3J0cyBjb252ZXJzaW9uIGZyb20gaW50NjQsIHVpbnQ2NCwgdWludDMyLCBpbnQ4IGFuZCB1aW50OCB0byBpbnQzMi5cclxuZXhwb3J0IGNvbnN0IGNvbnZlcnREYXRhVG9JbnQzMiA9IChkYXRhOiBVaW50OEFycmF5LCBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUpOiBVaW50OEFycmF5ID0+IHtcclxuICBpZiAoZGF0YVR5cGUgPT09ICdpbnQzMicpIHtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZGF0YVR5cGVTaXplID0gd2Vibm5EYXRhVHlwZVRvU2l6ZS5nZXQoZGF0YVR5cGUpO1xyXG4gIGlmICghZGF0YVR5cGVTaXplKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYk5OIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhIHR5cGU6ICR7ZGF0YVR5cGV9YCk7XHJcbiAgfVxyXG4gIGNvbnN0IGJ5dGVzUGVyRWxlbWVudCA9IGRhdGFUeXBlU2l6ZSAvIDg7XHJcbiAgLy8gTWFrZSBzdXJlIHRoZSBkYXRhIGxlbmd0aCBpcyBhIG11bHRpcGxlIG9mIHRoZSBkYXRhIHR5cGUgc2l6ZS5cclxuICBpZiAoZGF0YS5ieXRlTGVuZ3RoICUgYnl0ZXNQZXJFbGVtZW50ICE9PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVWludDhBcnJheSBsZW5ndGggLSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtieXRlc1BlckVsZW1lbnR9LmApO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBVaW50OEFycmF5IHRvIG9yaWdpbmFsIHR5cGVkIGFycmF5LlxyXG4gIGNvbnN0IG51bUVsZW1lbnRzID0gZGF0YS5ieXRlTGVuZ3RoIC8gYnl0ZXNQZXJFbGVtZW50O1xyXG4gIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBuZXcgKHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhVHlwZSkpKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIG51bUVsZW1lbnRzKTtcclxuXHJcbiAgc3dpdGNoIChkYXRhVHlwZSkge1xyXG4gICAgY2FzZSAnaW50NjQnOlxyXG4gICAgY2FzZSAndWludDY0Jzoge1xyXG4gICAgICAvLyBDb252ZXJ0IG9yaWdpbmFsIHR5cGVkIGFycmF5IHRvIEludDMyQXJyYXkuXHJcbiAgICAgIGNvbnN0IGludDMyQXJyYXkgPSBuZXcgSW50MzJBcnJheShudW1FbGVtZW50cyk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRWxlbWVudHM7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3JpZ2luYWxBcnJheVtpXTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJmbG93LlxyXG4gICAgICAgIGlmICh2YWx1ZSA+IDIxNDc0ODM2NDduIHx8IHZhbHVlIDwgLTIxNDc0ODM2NDhuKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgY29udmVydCBpbnQ2NCBkYXRhIHRvIGludDMyIC0gdmFsdWUgb3V0IG9mIHJhbmdlLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50MzJBcnJheVtpXSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnQzMkFycmF5LmJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBjYXNlICdpbnQ4JzpcclxuICAgIGNhc2UgJ3VpbnQ4JzpcclxuICAgIGNhc2UgJ3VpbnQzMic6IHtcclxuICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJmbG93LlxyXG4gICAgICBpZiAoZGF0YVR5cGUgPT09ICd1aW50MzInKSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsQXJyYXkuc29tZSgodmFsdWUpID0+IHZhbHVlID4gMjE0NzQ4MzY0NykpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBjb252ZXJ0IHVpbnQzMiBkYXRhIHRvIGludDMyIC0gdmFsdWUgb3V0IG9mIHJhbmdlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBDb252ZXJ0IG9yaWdpbmFsIHR5cGVkIGFycmF5IHRvIEludDMyQXJyYXkuXHJcbiAgICAgIGNvbnN0IGludDMyQXJyYXkgPSBJbnQzMkFycmF5LmZyb20ob3JpZ2luYWxBcnJheSwgTnVtYmVyKTtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGludDMyQXJyYXkuYnVmZmVyKTtcclxuICAgIH1cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSBjb252ZXJzaW9uIGZyb20gJHtkYXRhVHlwZX0gdG8gJ2ludDMyJ2ApO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIENvbnZlcnQgSW50MzJBcnJheSBkYXRhIHRvIG9yaWdpbmFsIGludGVnZXIgZGF0YSBidWZmZXIuXHJcbi8vIFN1cHBvcnRzIGNvbnZlcnNpb24gZnJvbSBpbnQzMiB0byBpbnQ2NCwgdWludDY0LCB1aW50MzIsIGludDggYW5kIHVpbnQ4LlxyXG5leHBvcnQgY29uc3QgY29udmVydEludDMyVG9EYXRhID0gKGRhdGE6IFVpbnQ4QXJyYXksIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSk6IFVpbnQ4QXJyYXkgPT4ge1xyXG4gIGlmIChkYXRhVHlwZSA9PT0gJ2ludDMyJykge1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICAvLyBNYWtlIHN1cmUgdGhlIGRhdGEgbGVuZ3RoIGlzIGEgbXVsdGlwbGUgb2YgNCBieXRlcyAoSW50MzJBcnJheSkuXHJcbiAgaWYgKGRhdGEuYnl0ZUxlbmd0aCAlIDQgIT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVaW50OEFycmF5IGxlbmd0aCAtIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0IChpbnQzMikuJyk7XHJcbiAgfVxyXG5cclxuICAvLyBDb252ZXJ0IFVpbnQ4QXJyYXkgdG8gSW50MzJBcnJheS5cclxuICBjb25zdCBudW1FbGVtZW50cyA9IGRhdGEuYnl0ZUxlbmd0aCAvIDQ7XHJcbiAgY29uc3QgaW50MzJBcnJheSA9IG5ldyBJbnQzMkFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIG51bUVsZW1lbnRzKTtcclxuXHJcbiAgc3dpdGNoIChkYXRhVHlwZSkge1xyXG4gICAgY2FzZSAnaW50NjQnOiB7XHJcbiAgICAgIGNvbnN0IGJpZ0ludDY0QXJyYXkgPSBCaWdJbnQ2NEFycmF5LmZyb20oaW50MzJBcnJheSwgQmlnSW50KTtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJpZ0ludDY0QXJyYXkuYnVmZmVyKTtcclxuICAgIH1cclxuICAgIGNhc2UgJ3VpbnQ2NCc6IHtcclxuICAgICAgaWYgKGludDMyQXJyYXkuc29tZSgodmFsdWUpID0+IHZhbHVlIDwgMCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIHVpbjY0IC0gbmVnYXRpdmUgdmFsdWUgZm91bmQuJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYmlnVWludDY0QXJyYXkgPSBCaWdVaW50NjRBcnJheS5mcm9tKGludDMyQXJyYXksIEJpZ0ludCk7XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiaWdVaW50NjRBcnJheS5idWZmZXIpO1xyXG4gICAgfVxyXG4gICAgY2FzZSAnaW50OCc6IHtcclxuICAgICAgaWYgKGludDMyQXJyYXkuc29tZSgodmFsdWUpID0+IHZhbHVlIDwgLTEyOCB8fCB2YWx1ZSA+IDEyNykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29udmVydCBpbnQzMiBkYXRhIHRvIGludDggLSB2YWx1ZSBvdXQgb2YgcmFuZ2UuJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaW50OEFycmF5ID0gSW50OEFycmF5LmZyb20oaW50MzJBcnJheSwgTnVtYmVyKTtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGludDhBcnJheS5idWZmZXIpO1xyXG4gICAgfVxyXG4gICAgY2FzZSAndWludDgnOiB7XHJcbiAgICAgIGlmIChpbnQzMkFycmF5LnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAyNTUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGNvbnZlcnQgaW50MzIgZGF0YSB0byB1aW50OCAtIHZhbHVlIG91dCBvZiByYW5nZS4nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGludDMyQXJyYXksIE51bWJlcik7XHJcbiAgICB9XHJcbiAgICBjYXNlICd1aW50MzInOiB7XHJcbiAgICAgIGlmIChpbnQzMkFycmF5LnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSA8IDApKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGNvbnZlcnQgaW50MzIgZGF0YSB0byB1aW50MzIgLSBuZWdhdGl2ZSB2YWx1ZSBmb3VuZC4nKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB1aW50MzJBcnJheSA9IFVpbnQzMkFycmF5LmZyb20oaW50MzJBcnJheSwgTnVtYmVyKTtcclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHVpbnQzMkFycmF5LmJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgY29udmVyc2lvbiBmcm9tICdpbnQzMicgdG8gJHtkYXRhVHlwZX1gKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBUZW5zb3JJZCA9IG51bWJlcjtcclxuXHJcbi8qKlxyXG4gKiBNYW5hZ2VzIFRlbnNvcklkIHRvIE1MVGVuc29yIG1hcHBpbmcuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvck1hbmFnZXIge1xyXG4gIC8qKlxyXG4gICAqIFJlc2VydmUgYSBuZXcgVGVuc29ySWQuXHJcbiAgICovXHJcbiAgcmVzZXJ2ZVRlbnNvcklkKCk6IFRlbnNvcklkO1xyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2UgYSBUZW5zb3JJZC5cclxuICAgKi9cclxuICByZWxlYXNlVGVuc29ySWQodGVuc29ySWQ6IFRlbnNvcklkKTogdm9pZDtcclxuICAvKipcclxuICAgKiBFbnN1cmUgYSBNTFRlbnNvciBpcyBjcmVhdGVkIGZvciB0aGUgVGVuc29ySWQuXHJcbiAgICovXHJcbiAgZW5zdXJlVGVuc29yKFxyXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXHJcbiAgICB0ZW5zb3JJZDogVGVuc29ySWQsXHJcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXHJcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgICBjb3B5T2xkOiBib29sZWFuLFxyXG4gICk6IFByb21pc2U8TUxUZW5zb3I+O1xyXG4gIC8qKlxyXG4gICAqIFVwbG9hZCBkYXRhIHRvIGEgTUxUZW5zb3IuXHJcbiAgICovXHJcbiAgdXBsb2FkKHRlbnNvcklkOiBUZW5zb3JJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQ7XHJcbiAgLyoqXHJcbiAgICogRG93bmxvYWQgZGF0YSBmcm9tIGEgTUxUZW5zb3IuXHJcbiAgICovXHJcbiAgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj47XHJcbiAgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkLCBkc3RUZW5zb3I6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTx1bmRlZmluZWQ+O1xyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2UgYWxsIHRlbnNvcnMgZm9yIGEgZ2l2ZW4gc2Vzc2lvbi5cclxuICAgKi9cclxuICByZWxlYXNlVGVuc29yc0ZvclNlc3Npb24oc2Vzc2lvbjogbnVtYmVyKTogdm9pZDtcclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgTUxUZW5zb3Igd2l0aCBhIGdpdmVuIHNlc3Npb24gaWQgYW5kIHJldHVybiBhIFRlbnNvcklkLlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyVGVuc29yKHNlc3Npb25JZDogbnVtYmVyLCBtbFRlbnNvcjogTUxUZW5zb3IsIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSwgc2hhcGU6IG51bWJlcltdKTogVGVuc29ySWQ7XHJcbn1cclxuXHJcbmxldCB0ZW5zb3JHdWlkID0gMTtcclxuY29uc3QgY3JlYXRlTmV3VGVuc29ySWQgPSAoKTogVGVuc29ySWQgPT4gdGVuc29yR3VpZCsrO1xyXG5cclxuLyoqXHJcbiAqIE1hcCBmcm9tIGRhdGEgdHlwZSB0byBmYWxsYmFjayBkYXRhIHR5cGUuXHJcbiAqIFdoZW4gdGhlIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgb3JpZ2luYWwgZGF0YSB0eXBlLCB1c2UgZmFsbGJhY2sgZGF0YSB0eXBlIGFzIHdvcmthcm91bmQuXHJcbiAqIE5vdGU6IEN1cnJlbnRseSwgd2Ugb25seSBzdXBwb3J0IGZhbGxiYWNrIHRvIGludDMyIGZvciBjZXJ0YWluIGludGVnZXIgZGF0YSB0eXBlcy5cclxuICovXHJcbmNvbnN0IHdlYm5uRGF0YVR5cGVUb0ZhbGxiYWNrID0gbmV3IE1hcDxNTE9wZXJhbmREYXRhVHlwZSwgTUxPcGVyYW5kRGF0YVR5cGU+KFtcclxuICBbJ2ludDgnLCAnaW50MzInXSxcclxuICBbJ3VpbnQ4JywgJ2ludDMyJ10sXHJcbiAgWyd1aW50MzInLCAnaW50MzInXSxcclxuICBbJ2ludDY0JywgJ2ludDMyJ10sXHJcbl0pO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgYnl0ZSBsZW5ndGggb2YgYSB0ZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCBzaGFwZS5cclxuICovXHJcbmNvbnN0IGNhbGN1bGF0ZUJ5dGVMZW5ndGggPSAoZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIgPT4ge1xyXG4gIGNvbnN0IGRhdGFUeXBlU2l6ZSA9IHdlYm5uRGF0YVR5cGVUb1NpemUuZ2V0KGRhdGFUeXBlKTtcclxuICBpZiAoIWRhdGFUeXBlU2l6ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJOTiBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfWApO1xyXG4gIH1cclxuICByZXR1cm4gc2hhcGUubGVuZ3RoID4gMCA/IE1hdGguY2VpbCgoc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYikgKiBkYXRhVHlwZVNpemUpIC8gOCkgOiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlbnNvcldyYXBwZXIgd3JhcHMgYW4gTUxUZW5zb3IgYW5kIHByb3ZpZGVzIGEgd2F5IHRvIHRyYWNrIHRoZSBsYXN0IHNlc3Npb24gdGhhdCB1c2VkIGl0LlxyXG4gKi9cclxuY2xhc3MgVGVuc29yV3JhcHBlciB7XHJcbiAgLy8gVGhlIGlkIG9mIHRoZSBsYXN0IHNlc3Npb24gdGhhdCB1c2VkIHRoaXMgdGVuc29yLlxyXG4gIHB1YmxpYyBzZXNzaW9uSWQ6IG51bWJlcjtcclxuICAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBkYXRhIGhhcyBiZWVuIGNvbnZlcnRlZCB0byBmYWxsYmFjayBkYXRhIHR5cGUuXHJcbiAgcHVibGljIGlzRGF0YUNvbnZlcnRlZCA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIG1sQ29udGV4dDogTUxDb250ZXh0O1xyXG4gIHByaXZhdGUgbWxUZW5zb3I6IE1MVGVuc29yO1xyXG4gIHByaXZhdGUgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlO1xyXG4gIC8vIEZhbGxiYWNrIGRhdGEgdHlwZSB0byB1c2Ugd2hlbiB0aGUgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBvcmlnaW5hbCBkYXRhIHR5cGUuXHJcbiAgcHJpdmF0ZSBmYWxsYmFja0RhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSB8IHVuZGVmaW5lZDtcclxuICBwcml2YXRlIHRlbnNvclNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcclxuXHJcbiAgY29uc3RydWN0b3IoZGVzY3JpcHRvcjoge1xyXG4gICAgc2Vzc2lvbklkOiBudW1iZXI7XHJcbiAgICBjb250ZXh0OiBNTENvbnRleHQ7XHJcbiAgICB0ZW5zb3I6IE1MVGVuc29yO1xyXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlO1xyXG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gICAgZmFsbGJhY2tEYXRhVHlwZT86IE1MT3BlcmFuZERhdGFUeXBlO1xyXG4gIH0pIHtcclxuICAgIGNvbnN0IHsgc2Vzc2lvbklkLCBjb250ZXh0LCB0ZW5zb3IsIGRhdGFUeXBlLCBzaGFwZSwgZmFsbGJhY2tEYXRhVHlwZSB9ID0gZGVzY3JpcHRvcjtcclxuICAgIHRoaXMuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gICAgdGhpcy5tbENvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5tbFRlbnNvciA9IHRlbnNvcjtcclxuICAgIHRoaXMuZGF0YVR5cGUgPSBkYXRhVHlwZTtcclxuICAgIHRoaXMudGVuc29yU2hhcGUgPSBzaGFwZTtcclxuICAgIHRoaXMuZmFsbGJhY2tEYXRhVHlwZSA9IGZhbGxiYWNrRGF0YVR5cGU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHRlbnNvcigpOiBNTFRlbnNvciB7XHJcbiAgICByZXR1cm4gdGhpcy5tbFRlbnNvcjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgdHlwZSgpOiBNTE9wZXJhbmREYXRhVHlwZSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhVHlwZTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXQgZmFsbGJhY2tUeXBlKCk6IE1MT3BlcmFuZERhdGFUeXBlIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLmZhbGxiYWNrRGF0YVR5cGU7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHNoYXBlKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcclxuICAgIHJldHVybiB0aGlzLnRlbnNvclNoYXBlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBieXRlTGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gY2FsY3VsYXRlQnl0ZUxlbmd0aCh0aGlzLmRhdGFUeXBlLCB0aGlzLnRlbnNvclNoYXBlKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xyXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gJ1tXZWJOTl0gVGVuc29yV3JhcHBlci5kZXN0cm95Jyk7XHJcbiAgICB0aGlzLm1sVGVuc29yLmRlc3Ryb3koKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyB3cml0ZShkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XHJcbiAgICB0aGlzLm1sQ29udGV4dC53cml0ZVRlbnNvcih0aGlzLm1sVGVuc29yLCBkYXRhKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyByZWFkKCk6IFByb21pc2U8QXJyYXlCdWZmZXI+O1xyXG4gIHB1YmxpYyBhc3luYyByZWFkKGRzdEJ1ZmZlcj86IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZD47XHJcbiAgcHVibGljIGFzeW5jIHJlYWQoZHN0QnVmZmVyPzogQXJyYXlCdWZmZXJWaWV3IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyIHwgdW5kZWZpbmVkPiB7XHJcbiAgICBpZiAodGhpcy5mYWxsYmFja0RhdGFUeXBlKSB7XHJcbiAgICAgIC8vIFRoaXMgdGVuc29yIGhhcyBiZWVuIGZhbGxiYWNrIHRvIGludDMyIGFzIHdvcmthcm91bmQsIHdlIG5lZWQgdG8gcmVhZCBpdCBhcyBpdHMgb3JpZ2luYWwgaW50ZWdlciBkYXRhIHR5cGUuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpO1xyXG4gICAgICBjb25zdCBvcmlnaW5hbERhdGEgPSBjb252ZXJ0SW50MzJUb0RhdGEobmV3IFVpbnQ4QXJyYXkoZGF0YSksIHRoaXMuZGF0YVR5cGUpO1xyXG5cclxuICAgICAgaWYgKGRzdEJ1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEJ1ZmZlciA9XHJcbiAgICAgICAgICBkc3RCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICA/IG5ldyBVaW50OEFycmF5KGRzdEJ1ZmZlcilcclxuICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShkc3RCdWZmZXIuYnVmZmVyLCBkc3RCdWZmZXIuYnl0ZU9mZnNldCwgZHN0QnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRhcmdldEJ1ZmZlci5zZXQob3JpZ2luYWxEYXRhKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBvcmlnaW5hbERhdGEuYnVmZmVyO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZHN0QnVmZmVyID8gdGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yLCBkc3RCdWZmZXIpIDogdGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBjYW5SZXVzZVRlbnNvcihjb250ZXh0OiBNTENvbnRleHQsIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB0aGlzLm1sQ29udGV4dCA9PT0gY29udGV4dCAmJlxyXG4gICAgICB0aGlzLmRhdGFUeXBlID09PSBkYXRhVHlwZSAmJlxyXG4gICAgICB0aGlzLnRlbnNvclNoYXBlLmxlbmd0aCA9PT0gc2hhcGUubGVuZ3RoICYmXHJcbiAgICAgIHRoaXMudGVuc29yU2hhcGUuZXZlcnkoKHYsIGkpID0+IHYgPT09IHNoYXBlW2ldKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZXRJc0RhdGFDb252ZXJ0ZWQoaXNDb252ZXJ0ZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIHRoaXMuaXNEYXRhQ29udmVydGVkID0gaXNDb252ZXJ0ZWQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGVuc29yVHJhY2tlciB0cmFja3MgdGhlIE1MVGVuc29yIGFuZCBwZW5kaW5nIHVwbG9hZCBkYXRhLlxyXG4gKlxyXG4gKiBXZSBuZWVkIHRvIHRyYWNrIHRoZSBNTFRlbnNvciBhbmQgcGVuZGluZyB1cGxvYWQgZGF0YSBiZWNhdXNlIHdlIGRlbGF5IHRoZSBjcmVhdGlvbiBvZiBNTFRlbnNvciB1bnRpbFxyXG4gKiB3ZSBrbm93IHRoZSBkYXRhIHR5cGUgYW5kIHNoYXBlLiBUaGlzIGlzIGJlY2F1c2UgV2ViTk4gb25seSBzdXBwb3J0IGNyZWF0aW5nIE1MVGVuc29ycyB3aXRoIGRhdGFUeXBlcyBhbmQgc2hhcGUuXHJcbiAqL1xyXG5jbGFzcyBUZW5zb3JJZFRyYWNrZXIge1xyXG4gIHByaXZhdGUgYWN0aXZlVXBsb2FkPzogVWludDhBcnJheTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIHRlbnNvck1hbmFnZXI6IFRlbnNvck1hbmFnZXJJbXBsLFxyXG4gICAgcHJpdmF0ZSB3cmFwcGVyPzogVGVuc29yV3JhcHBlcixcclxuICApIHt9XHJcblxyXG4gIHB1YmxpYyBnZXQgdGVuc29yV3JhcHBlcigpOiBUZW5zb3JXcmFwcGVyIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLndyYXBwZXI7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgcmVsZWFzZVRlbnNvcigpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnRlbnNvcldyYXBwZXIpIHtcclxuICAgICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy50ZW5zb3JXcmFwcGVyKTtcclxuICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGVuc3VyZVRlbnNvcihcclxuICAgIHNlc3Npb25JZDogbnVtYmVyLFxyXG4gICAgZGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlLFxyXG4gICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgY29weU9sZDogYm9vbGVhbixcclxuICApOiBQcm9taXNlPE1MVGVuc29yPiB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy50ZW5zb3JNYW5hZ2VyLmdldE1MQ29udGV4dChzZXNzaW9uSWQpO1xyXG4gICAgbGV0IGZhbGxiYWNrRGF0YVR5cGU6IE1MT3BlcmFuZERhdGFUeXBlIHwgdW5kZWZpbmVkO1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRleHQgc3VwcG9ydHMgdGhlIGRhdGEgdHlwZS4gSWYgbm90LCB0cnkgdG8gdXNlIHRoZSBmYWxsYmFjayBkYXRhIHR5cGUuXHJcbiAgICBpZiAoIWNvbnRleHQub3BTdXBwb3J0TGltaXRzKCkuaW5wdXQuZGF0YVR5cGVzLmluY2x1ZGVzKGRhdGFUeXBlKSkge1xyXG4gICAgICBmYWxsYmFja0RhdGFUeXBlID0gd2Vibm5EYXRhVHlwZVRvRmFsbGJhY2suZ2V0KGRhdGFUeXBlKTtcclxuICAgICAgaWYgKCFmYWxsYmFja0RhdGFUeXBlIHx8ICFjb250ZXh0Lm9wU3VwcG9ydExpbWl0cygpLmlucHV0LmRhdGFUeXBlcy5pbmNsdWRlcyhmYWxsYmFja0RhdGFUeXBlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2ViTk4gYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IGRhdGEgdHlwZTogJHtkYXRhVHlwZX1gKTtcclxuICAgICAgfVxyXG4gICAgICBMT0dfREVCVUcoXHJcbiAgICAgICAgJ3ZlcmJvc2UnLFxyXG4gICAgICAgICgpID0+IGBbV2ViTk5dIFRlbnNvcklkVHJhY2tlci5lbnN1cmVUZW5zb3I6IGZhbGxiYWNrIGRhdGFUeXBlIGZyb20gJHtkYXRhVHlwZX0gdG8gJHtmYWxsYmFja0RhdGFUeXBlfWAsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMud3JhcHBlcikge1xyXG4gICAgICBpZiAodGhpcy53cmFwcGVyLmNhblJldXNlVGVuc29yKGNvbnRleHQsIGRhdGFUeXBlLCBzaGFwZSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoY29weU9sZCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMud3JhcHBlci5ieXRlTGVuZ3RoICE9PSBjYWxjdWxhdGVCeXRlTGVuZ3RoKGRhdGFUeXBlLCBzaGFwZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY29weSBkYXRhIHRvIHRlbnNvciB3aXRoIGRpZmZlcmVudCBzaXplLicpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5hY3RpdmVVcGxvYWQgPSBuZXcgVWludDhBcnJheShhd2FpdCB0aGlzLndyYXBwZXIucmVhZCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy53cmFwcGVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICBjb25zdCB1c2FnZSA9IHR5cGVvZiBNTFRlbnNvclVzYWdlID09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTUxUZW5zb3JVc2FnZS5SRUFEIHwgTUxUZW5zb3JVc2FnZS5XUklURTtcclxuICAgIHRoaXMud3JhcHBlciA9IGF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5nZXRDYWNoZWRUZW5zb3IoXHJcbiAgICAgIHNlc3Npb25JZCxcclxuICAgICAgZGF0YVR5cGUsXHJcbiAgICAgIHNoYXBlLFxyXG4gICAgICB1c2FnZSxcclxuICAgICAgdHJ1ZSxcclxuICAgICAgdHJ1ZSxcclxuICAgICAgZmFsbGJhY2tEYXRhVHlwZSxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKGNvcHlPbGQgJiYgdGhpcy5hY3RpdmVVcGxvYWQpIHtcclxuICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjb252ZXJ0IHRoZSBvcmlnaW5hbCBpbnRlZ2VyIGRhdGEgdG8gaW50MzIsXHJcbiAgICAgIC8vIGJlY2F1c2UgaXQgaGFzIGJlZW4gY29udmVydGVkIHdoZW4gaXQgd2FzIHVwbG9hZGVkLlxyXG4gICAgICB0aGlzLndyYXBwZXIud3JpdGUodGhpcy5hY3RpdmVVcGxvYWQpO1xyXG4gICAgICB0aGlzLmFjdGl2ZVVwbG9hZCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtcclxuICB9XHJcblxyXG4gIHB1YmxpYyB1cGxvYWQoZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xyXG4gICAgbGV0IG5ld0RhdGEgPSBkYXRhO1xyXG4gICAgaWYgKHRoaXMud3JhcHBlcikge1xyXG4gICAgICBpZiAodGhpcy53cmFwcGVyLmZhbGxiYWNrVHlwZSkge1xyXG4gICAgICAgIGlmICh0aGlzLndyYXBwZXIuZmFsbGJhY2tUeXBlID09PSAnaW50MzInKSB7XHJcbiAgICAgICAgICAvLyBDb252ZXJ0IG9yaWdpbmFsIGludGVnZXIgZGF0YSB0byBpbnQzMi5cclxuICAgICAgICAgIG5ld0RhdGEgPSBjb252ZXJ0RGF0YVRvSW50MzIoZGF0YSwgdGhpcy53cmFwcGVyLnR5cGUpO1xyXG4gICAgICAgICAgdGhpcy53cmFwcGVyLnNldElzRGF0YUNvbnZlcnRlZCh0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBmYWxsYmFjayBkYXRhIHR5cGU6ICR7dGhpcy53cmFwcGVyLmZhbGxiYWNrVHlwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBkYXRhIHNpemUgbWF0Y2hlcyB0aGUgdGVuc29yIHNpemUuXHJcbiAgICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPT09IHRoaXMud3JhcHBlci5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gV3JpdGUgdGhlIG5ld0RhdGEgdG8gdGhlIHRlbnNvci5cclxuICAgICAgICB0aGlzLndyYXBwZXIud3JpdGUobmV3RGF0YSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+ICdEYXRhIHNpemUgZG9lcyBub3QgbWF0Y2ggdGVuc29yIHNpemUuIFJlbGVhc2luZyB0ZW5zb3IuJyk7XHJcbiAgICAgICAgdGhpcy5yZWxlYXNlVGVuc29yKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5hY3RpdmVVcGxvYWQpIHtcclxuICAgICAgdGhpcy5hY3RpdmVVcGxvYWQuc2V0KG5ld0RhdGEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5hY3RpdmVVcGxvYWQgPSBuZXcgVWludDhBcnJheShuZXdEYXRhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBkb3dubG9hZChkc3RCdWZmZXI/OiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IFByb21pc2U8QXJyYXlCdWZmZXIgfCB1bmRlZmluZWQ+IHtcclxuICAgIGlmICh0aGlzLmFjdGl2ZVVwbG9hZCkge1xyXG4gICAgICAvLyBJZiB0aGlzLmFjdGl2ZVVwbG9hZCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gaW50MzIsIHdlIG5lZWQgdG8gY29udmVydCBpdCBiYWNrIHRvIG9yaWdpbmFsIGludGVnZXIgZGF0YSB0eXBlLlxyXG4gICAgICBjb25zdCBkc3REYXRhID0gdGhpcy53cmFwcGVyPy5pc0RhdGFDb252ZXJ0ZWRcclxuICAgICAgICA/IGNvbnZlcnRJbnQzMlRvRGF0YSh0aGlzLmFjdGl2ZVVwbG9hZCwgdGhpcy53cmFwcGVyPy50eXBlKVxyXG4gICAgICAgIDogdGhpcy5hY3RpdmVVcGxvYWQ7XHJcblxyXG4gICAgICBpZiAoZHN0QnVmZmVyKSB7XHJcbiAgICAgICAgaWYgKGRzdEJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICBuZXcgVWludDhBcnJheShkc3RCdWZmZXIpLnNldChkc3REYXRhKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZHN0QnVmZmVyLmJ1ZmZlciwgZHN0QnVmZmVyLmJ5dGVPZmZzZXQsIGRzdEJ1ZmZlci5ieXRlTGVuZ3RoKS5zZXQoZHN0RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZHN0RGF0YS5idWZmZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghdGhpcy53cmFwcGVyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGhhcyBub3QgYmVlbiBjcmVhdGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZHN0QnVmZmVyKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLndyYXBwZXIucmVhZCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMud3JhcHBlci5yZWFkKGRzdEJ1ZmZlcik7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBUZW5zb3JNYW5hZ2VySW1wbCBpbXBsZW1lbnRzIFRlbnNvck1hbmFnZXIge1xyXG4gIHByaXZhdGUgdGVuc29yVHJhY2tlcnNCeUlkOiBNYXA8VGVuc29ySWQsIFRlbnNvcklkVHJhY2tlcj4gPSBuZXcgTWFwKCk7XHJcbiAgcHJpdmF0ZSBmcmVlVGVuc29yczogVGVuc29yV3JhcHBlcltdID0gW107XHJcbiAgcHJpdmF0ZSBleHRlcm5hbFRlbnNvcnM6IFNldDxUZW5zb3JXcmFwcGVyPiA9IG5ldyBTZXQoKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJOTkJhY2tlbmQpIHt9XHJcblxyXG4gIHB1YmxpYyBnZXRNTENvbnRleHQoc2Vzc2lvbklkOiBudW1iZXIpOiBNTENvbnRleHQge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuYmFja2VuZC5nZXRNTENvbnRleHQoc2Vzc2lvbklkKTtcclxuICAgIGlmICghY29udGV4dCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01MQ29udGV4dCBub3QgZm91bmQgZm9yIHNlc3Npb24uJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZXNlcnZlVGVuc29ySWQoKTogVGVuc29ySWQge1xyXG4gICAgY29uc3QgdGVuc29ySWQgPSBjcmVhdGVOZXdUZW5zb3JJZCgpO1xyXG4gICAgdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KHRlbnNvcklkLCBuZXcgVGVuc29ySWRUcmFja2VyKHRoaXMpKTtcclxuICAgIHJldHVybiB0ZW5zb3JJZDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZWxlYXNlVGVuc29ySWQodGVuc29ySWQ6IFRlbnNvcklkKTogdm9pZCB7XHJcbiAgICBjb25zdCB0ZW5zb3JUcmFja2VyID0gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHRlbnNvcklkKTtcclxuICAgIGlmICghdGVuc29yVHJhY2tlcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5kZWxldGUodGVuc29ySWQpO1xyXG4gICAgaWYgKHRlbnNvclRyYWNrZXIudGVuc29yV3JhcHBlcikge1xyXG4gICAgICB0aGlzLnJlbGVhc2VUZW5zb3IodGVuc29yVHJhY2tlci50ZW5zb3JXcmFwcGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBlbnN1cmVUZW5zb3IoXHJcbiAgICBzZXNzaW9uSWQ6IG51bWJlcixcclxuICAgIHRlbnNvcklkOiBUZW5zb3JJZCxcclxuICAgIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSxcclxuICAgIHNoYXBlOiBudW1iZXJbXSxcclxuICAgIGNvcHlPbGQ6IGJvb2xlYW4sXHJcbiAgKTogUHJvbWlzZTxNTFRlbnNvcj4ge1xyXG4gICAgTE9HX0RFQlVHKFxyXG4gICAgICAndmVyYm9zZScsXHJcbiAgICAgICgpID0+XHJcbiAgICAgICAgYFtXZWJOTl0gVGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ige3RlbnNvcklkOiAke3RlbnNvcklkfSwgZGF0YVR5cGU6ICR7XHJcbiAgICAgICAgICBkYXRhVHlwZVxyXG4gICAgICAgIH0sIHNoYXBlOiAke3NoYXBlfSwgY29weU9sZDogJHtjb3B5T2xkfX1gLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHRlbnNvciA9IHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0ZW5zb3JJZCk7XHJcbiAgICBpZiAoIXRlbnNvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBub3QgZm91bmQuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVuc29yLmVuc3VyZVRlbnNvcihzZXNzaW9uSWQsIGRhdGFUeXBlLCBzaGFwZSwgY29weU9sZCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdXBsb2FkKHRlbnNvcklkOiBUZW5zb3JJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xyXG4gICAgY29uc3QgdGVuc29yID0gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHRlbnNvcklkKTtcclxuICAgIGlmICghdGVuc29yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIG5vdCBmb3VuZC4nKTtcclxuICAgIH1cclxuICAgIHRlbnNvci51cGxvYWQoZGF0YSk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZG93bmxvYWQodGVuc29ySWQ6IFRlbnNvcklkKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj47XHJcbiAgcHVibGljIGFzeW5jIGRvd25sb2FkKHRlbnNvcklkOiBUZW5zb3JJZCwgZHN0QnVmZmVyOiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IFByb21pc2U8dW5kZWZpbmVkPjtcclxuICBhc3luYyBkb3dubG9hZCh0ZW5zb3JJZDogVGVuc29ySWQsIGRzdEJ1ZmZlcj86IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogUHJvbWlzZTxBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZD4ge1xyXG4gICAgTE9HX0RFQlVHKFxyXG4gICAgICAndmVyYm9zZScsXHJcbiAgICAgICgpID0+IGBbV2ViTk5dIFRlbnNvck1hbmFnZXIuZG93bmxvYWQge3RlbnNvcklkOiAke3RlbnNvcklkfSwgZHN0QnVmZmVyOiAke2RzdEJ1ZmZlcj8uYnl0ZUxlbmd0aH19YCxcclxuICAgICk7XHJcbiAgICBjb25zdCB0ZW5zb3JUcmFja2VyID0gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHRlbnNvcklkKTtcclxuICAgIGlmICghdGVuc29yVHJhY2tlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBub3QgZm91bmQuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVuc29yVHJhY2tlci5kb3dubG9hZChkc3RCdWZmZXIpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCB0ZW5zb3Igb2YgdGhpcy5mcmVlVGVuc29ycykge1xyXG4gICAgICBpZiAodGVuc29yLnNlc3Npb25JZCA9PT0gc2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGVuc29yLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5mcmVlVGVuc29ycyA9IHRoaXMuZnJlZVRlbnNvcnMuZmlsdGVyKCh0ZW5zb3IpID0+IHRlbnNvci5zZXNzaW9uSWQgIT09IHNlc3Npb25JZCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgcmVnaXN0ZXJUZW5zb3IoXHJcbiAgICBzZXNzaW9uSWQ6IG51bWJlcixcclxuICAgIG1sVGVuc29yOiBNTFRlbnNvcixcclxuICAgIGRhdGFUeXBlOiBNTE9wZXJhbmREYXRhVHlwZSxcclxuICAgIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICApOiBUZW5zb3JJZCB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRNTENvbnRleHQoc2Vzc2lvbklkKTtcclxuICAgIGNvbnN0IHRlbnNvcklkID0gY3JlYXRlTmV3VGVuc29ySWQoKTtcclxuICAgIC8vIERlZmF1bHRpbmcgdG8gUkVBRCB8IFdSSVRFIGlmIHVzYWdlIGlzIG5vdCBwcm92aWRlZC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICBjb25zdCB3cmFwcGVyID0gbmV3IFRlbnNvcldyYXBwZXIoe1xyXG4gICAgICBzZXNzaW9uSWQsXHJcbiAgICAgIGNvbnRleHQsXHJcbiAgICAgIHRlbnNvcjogbWxUZW5zb3IsXHJcbiAgICAgIGRhdGFUeXBlLFxyXG4gICAgICBzaGFwZSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KHRlbnNvcklkLCBuZXcgVGVuc29ySWRUcmFja2VyKHRoaXMsIHdyYXBwZXIpKTtcclxuICAgIHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmFkZCh3cmFwcGVyKTtcclxuICAgIHJldHVybiB0ZW5zb3JJZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBvciBjcmVhdGUgYW4gTUxUZW5zb3Igd2l0aCB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCBzaGFwZS5cclxuICAgKi9cclxuICBwdWJsaWMgYXN5bmMgZ2V0Q2FjaGVkVGVuc29yKFxyXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsXHJcbiAgICBkYXRhVHlwZTogTUxPcGVyYW5kRGF0YVR5cGUsXHJcbiAgICBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgICB1c2FnZTogTUxUZW5zb3JVc2FnZUZsYWdzIHwgdW5kZWZpbmVkLFxyXG4gICAgd3JpdGFibGU6IGJvb2xlYW4sXHJcbiAgICByZWFkYWJsZTogYm9vbGVhbixcclxuICAgIGZhbGxiYWNrRGF0YVR5cGU/OiBNTE9wZXJhbmREYXRhVHlwZSxcclxuICApOiBQcm9taXNlPFRlbnNvcldyYXBwZXI+IHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldE1MQ29udGV4dChzZXNzaW9uSWQpO1xyXG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHRlbnNvcl0gb2YgdGhpcy5mcmVlVGVuc29ycy5lbnRyaWVzKCkpIHtcclxuICAgICAgaWYgKHRlbnNvci5jYW5SZXVzZVRlbnNvcihjb250ZXh0LCBkYXRhVHlwZSwgc2hhcGUpKSB7XHJcbiAgICAgICAgTE9HX0RFQlVHKFxyXG4gICAgICAgICAgJ3ZlcmJvc2UnLFxyXG4gICAgICAgICAgKCkgPT5cclxuICAgICAgICAgICAgYFtXZWJOTl0gUmV1c2luZyB0ZW5zb3Ige2RhdGFUeXBlOiAke2RhdGFUeXBlfSwgJHtcclxuICAgICAgICAgICAgICBmYWxsYmFja0RhdGFUeXBlID8gYGZhbGxiYWNrRGF0YVR5cGU6ICR7ZmFsbGJhY2tEYXRhVHlwZX0sYCA6ICcnXHJcbiAgICAgICAgICAgIH0gc2hhcGU6ICR7c2hhcGV9YCxcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLmZyZWVUZW5zb3JzLnNwbGljZShpbmRleCwgMSlbMF07XHJcbiAgICAgICAgd3JhcHBlci5zZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIExPR19ERUJVRyhcclxuICAgICAgJ3ZlcmJvc2UnLFxyXG4gICAgICAoKSA9PlxyXG4gICAgICAgIGBbV2ViTk5dIE1MQ29udGV4dC5jcmVhdGVUZW5zb3Ige2RhdGFUeXBlOiAke2RhdGFUeXBlfSwgJHtcclxuICAgICAgICAgIGZhbGxiYWNrRGF0YVR5cGUgPyBgZmFsbGJhY2tEYXRhVHlwZTogJHtmYWxsYmFja0RhdGFUeXBlfSxgIDogJydcclxuICAgICAgICB9IHNoYXBlOiAke3NoYXBlfX1gLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHRlbnNvciA9IGF3YWl0IGNvbnRleHQuY3JlYXRlVGVuc29yKHtcclxuICAgICAgZGF0YVR5cGU6IGZhbGxiYWNrRGF0YVR5cGUgPz8gZGF0YVR5cGUsIC8vIElmIGZhbGxiYWNrIGRhdGEgdHlwZSBpcyBwcm92aWRlZCwgdXNlIGl0LlxyXG4gICAgICBzaGFwZSxcclxuICAgICAgZGltZW5zaW9uczogc2hhcGUsXHJcbiAgICAgIHVzYWdlLFxyXG4gICAgICB3cml0YWJsZSxcclxuICAgICAgcmVhZGFibGUsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXcgVGVuc29yV3JhcHBlcih7IHNlc3Npb25JZCwgY29udGV4dCwgdGVuc29yLCBkYXRhVHlwZSwgc2hhcGUsIGZhbGxiYWNrRGF0YVR5cGUgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWxlYXNlIHRlbnNvciBmb3IgcmV1c2UgdW5sZXNzIGV4dGVybmFsLlxyXG4gICAqL1xyXG4gIHB1YmxpYyByZWxlYXNlVGVuc29yKHRlbnNvcldyYXBwZXI6IFRlbnNvcldyYXBwZXIpIHtcclxuICAgIGlmICh0aGlzLmV4dGVybmFsVGVuc29ycy5oYXModGVuc29yV3JhcHBlcikpIHtcclxuICAgICAgdGhpcy5leHRlcm5hbFRlbnNvcnMuZGVsZXRlKHRlbnNvcldyYXBwZXIpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5mcmVlVGVuc29ycy5wdXNoKHRlbnNvcldyYXBwZXIpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRlbnNvck1hbmFnZXIgPSAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBUZW5zb3JNYW5hZ2VySW1wbD4pOiBUZW5zb3JNYW5hZ2VyID0+XHJcbiAgbmV3IFRlbnNvck1hbmFnZXJJbXBsKC4uLmFyZ3MpO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbi8vIFdlYk5OIEFQSSBjdXJyZW50bHkgZG9lcyBub3QgaGF2ZSBhIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBmaWxlLiBUaGlzIGZpbGUgaXMgYSB3b3JrYXJvdW5kIHdpdGggdHlwZXMgZ2VuZXJhdGVkIGZyb21cclxuLy8gV2ViTk4gQVBJIHNwZWNpZmljYXRpb24uXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJtYWNoaW5lbGVhcm5pbmcvd2Vibm4vaXNzdWVzLzY3N1xyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwid2Vibm4vd2Vibm4uZC50c1wiIC8+XHJcblxyXG5pbXBvcnQgeyBFbnYsIFRlbnNvciB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSwgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0gfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi4vd2FzbS1mYWN0b3J5JztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVZpZXcgfSBmcm9tICcuL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgVGVuc29ySWQsIGNyZWF0ZVRlbnNvck1hbmFnZXIsIGNvbnZlcnREYXRhVG9JbnQzMiB9IGZyb20gJy4vd2Vibm4vdGVuc29yLW1hbmFnZXInO1xyXG5pbXBvcnQgeyBjb25maWd1cmVMb2dnZXIsIExPR19ERUJVRyB9IGZyb20gJy4vbG9nJztcclxuXHJcbi8qXHJcbiAqIFRlbnNvclByb3RvOjpkYXRhX3R5cGUgdG8gV2ViTk4gT3BlcmFuZFR5cGUgbWFwcGluZy5cclxuICovXHJcbmNvbnN0IG9ubnhEYXRhVHlwZVRvV2Vibm5EYXRhVHlwZSA9IG5ldyBNYXA8RGF0YVR5cGUsIE1MT3BlcmFuZERhdGFUeXBlPihbXHJcbiAgW0RhdGFUeXBlLmZsb2F0LCAnZmxvYXQzMiddLFxyXG4gIFtEYXRhVHlwZS5mbG9hdDE2LCAnZmxvYXQxNiddLFxyXG4gIFtEYXRhVHlwZS5pbnQzMiwgJ2ludDMyJ10sXHJcbiAgW0RhdGFUeXBlLnVpbnQzMiwgJ3VpbnQzMiddLFxyXG4gIFtEYXRhVHlwZS5pbnQ2NCwgJ2ludDY0J10sXHJcbiAgW0RhdGFUeXBlLnVpbnQ2NCwgJ3VpbnQ2NCddLFxyXG4gIFtEYXRhVHlwZS5pbnQ0LCAnaW50NCddLFxyXG4gIFtEYXRhVHlwZS51aW50NCwgJ3VpbnQ0J10sXHJcbiAgW0RhdGFUeXBlLmludDgsICdpbnQ4J10sXHJcbiAgW0RhdGFUeXBlLnVpbnQ4LCAndWludDgnXSxcclxuICBbRGF0YVR5cGUuYm9vbCwgJ3VpbnQ4J10sXHJcbl0pO1xyXG5cclxudHlwZSBNTENvbnRleHRFbnRyeSA9IHtcclxuICBncHVEZXZpY2U/OiBHUFVEZXZpY2U7XHJcbiAgb3B0aW9ucz86IE1MQ29udGV4dE9wdGlvbnM7XHJcbiAgbWxDb250ZXh0OiBNTENvbnRleHQ7XHJcbn07XHJcblxyXG5jb25zdCBjb21wYXJlTUxDb250ZXh0T3B0aW9ucyA9IChhPzogTUxDb250ZXh0T3B0aW9ucywgYj86IE1MQ29udGV4dE9wdGlvbnMpOiBib29sZWFuID0+IHtcclxuICBpZiAoYSA9PT0gYikge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGlmIChhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSkuc29ydCgpIGFzIEFycmF5PGtleW9mIHR5cGVvZiBhPjtcclxuICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpLnNvcnQoKSBhcyBBcnJheTxrZXlvZiB0eXBlb2YgYj47XHJcbiAgcmV0dXJuIGFLZXlzLmxlbmd0aCA9PT0gYktleXMubGVuZ3RoICYmIGFLZXlzLmV2ZXJ5KChrZXksIGluZGV4KSA9PiBrZXkgPT09IGJLZXlzW2luZGV4XSAmJiBhW2tleV0gPT09IGJba2V5XSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV2ViTk4gYmFja2VuZCBpbXBsZW1lbnRhdGlvbi4gVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIE1MVGVuc29ycyBjcmVhdGVkIGJ5IHRoZSBiYWNrZW5kIGFuZCBrZWVwIHRyYWNrXHJcbiAqIG9mIHRoZSBjdXJyZW50IE1MQ29udGV4dCBiZWluZyB1c2VkIGJ5IHRoZSBzZXNzaW9ucy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJOTkJhY2tlbmQge1xyXG4gIC8qKlxyXG4gICAqIFRlbnNvciBtYW5hZ2VycyBmb3IgZWFjaCBzZXNzaW9uLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdGVuc29yTWFuYWdlciA9IGNyZWF0ZVRlbnNvck1hbmFnZXIodGhpcyk7XHJcbiAgLyoqXHJcbiAgICogTWFwcyBmcm9tIHNlc3Npb24gaWQgdG8gTUxDb250ZXh0cy5cclxuICAgKi9cclxuICBwcml2YXRlIG1sQ29udGV4dEJ5U2Vzc2lvbklkID0gbmV3IE1hcDxudW1iZXIsIE1MQ29udGV4dD4oKTtcclxuICAvKipcclxuICAgKiBNYXBzIGZyb20gTUxDb250ZXh0IHRvIHNlc3Npb24gaWRzLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgc2Vzc2lvbklkc0J5TUxDb250ZXh0ID0gbmV3IE1hcDxNTENvbnRleHQsIFNldDxudW1iZXI+PigpO1xyXG4gIC8qKlxyXG4gICAqIENhY2hlIG9mIE1MQ29udGV4dHMuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBtbENvbnRleHRDYWNoZTogTUxDb250ZXh0RW50cnlbXSA9IFtdO1xyXG4gIC8qKlxyXG4gICAqIEN1cnJlbnQgc2Vzc2lvbiBpZC5cclxuICAgKi9cclxuICBwcml2YXRlIGFjdGl2ZVNlc3Npb25JZD86IG51bWJlcjtcclxuICAvKipcclxuICAgKiBNYXBzIGZyb20gc2Vzc2lvbiBpZCB0byBsaXN0IG9mIGdyYXBoIGlucHV0cy5cclxuICAgKi9cclxuICBwcml2YXRlIHNlc3Npb25HcmFwaElucHV0czogTWFwPG51bWJlciwgc3RyaW5nW10+ID0gbmV3IE1hcCgpO1xyXG4gIC8qKlxyXG4gICAqIE1hcHMgZnJvbSBzZXNzaW9uIGlkIHRvIGxpc3Qgb2YgZ3JhcGggb3V0cHV0cy5cclxuICAgKi9cclxuICBwcml2YXRlIHNlc3Npb25HcmFwaE91dHB1dHM6IE1hcDxudW1iZXIsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcclxuICAvKipcclxuICAgKiBUZW1wb3JhcnkgZ3JhcGggaW5wdXRzIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLlxyXG4gICAqIFRoZXNlIGlucHV0cyB3aWxsIGJlIHJlZ2lzdGVyZWQgd2hlbiB0aGUgc2Vzc2lvbiBpcyBjcmVhdGVkLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdGVtcG9yYXJ5R3JhcGhJbnB1dHM6IHN0cmluZ1tdID0gW107XHJcbiAgLyoqXHJcbiAgICogVGVtcG9yYXJ5IGdyYXBoIG91dHB1dHMgZm9yIHRoZSBjdXJyZW50IHNlc3Npb24uXHJcbiAgICogVGhlc2Ugb3V0cHV0cyB3aWxsIGJlIHJlZ2lzdGVyZWQgd2hlbiB0aGUgc2Vzc2lvbiBpcyBjcmVhdGVkLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdGVtcG9yYXJ5R3JhcGhPdXRwdXRzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIC8qKlxyXG4gICAqIFRlbXBvcmFyeSB0ZW5zb3JzIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkczogTWFwPG51bWJlciwgVGVuc29ySWRbXT4gPSBuZXcgTWFwKCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGVudjogRW52KSB7XHJcbiAgICBjb25maWd1cmVMb2dnZXIoZW52LmxvZ0xldmVsISwgISFlbnYuZGVidWcpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBjdXJyZW50U2Vzc2lvbklkKCk6IG51bWJlciB7XHJcbiAgICBpZiAodGhpcy5hY3RpdmVTZXNzaW9uSWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBzZXNzaW9uJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTZXNzaW9uSWQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgb25SdW5TdGFydChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gb25SdW5TdGFydCB7c2Vzc2lvbklkOiAke3Nlc3Npb25JZH19YCk7XHJcbiAgICB0aGlzLmFjdGl2ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBvblJ1bkVuZChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gb25SdW5FbmQge3Nlc3Npb25JZDogJHtzZXNzaW9uSWR9fWApO1xyXG4gICAgY29uc3QgdGVuc29ySWRzID0gdGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLmdldChzZXNzaW9uSWQpO1xyXG4gICAgaWYgKCF0ZW5zb3JJZHMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCB0ZW5zb3JJZCBvZiB0ZW5zb3JJZHMpIHtcclxuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gcmVsZWFzaW5nIHRlbXBvcmFyeSB0ZW5zb3Ige3RlbnNvcklkOiAke3RlbnNvcklkfX1gKTtcclxuICAgICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICB0aGlzLmFjdGl2ZVNlc3Npb25JZCA9IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVNTENvbnRleHQob3B0aW9uc09yRGV2aWNlPzogTUxDb250ZXh0T3B0aW9ucyB8IEdQVURldmljZSk6IFByb21pc2U8TUxDb250ZXh0PiB7XHJcbiAgICBpZiAob3B0aW9uc09yRGV2aWNlIGluc3RhbmNlb2YgR1BVRGV2aWNlKSB7XHJcbiAgICAgIGNvbnN0IG1sQ29udGV4dEluZGV4ID0gdGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5ncHVEZXZpY2UgPT09IG9wdGlvbnNPckRldmljZSk7XHJcbiAgICAgIGlmIChtbENvbnRleHRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVttbENvbnRleHRJbmRleF0ubWxDb250ZXh0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1sQ29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KG9wdGlvbnNPckRldmljZSk7XHJcbiAgICAgICAgdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHsgZ3B1RGV2aWNlOiBvcHRpb25zT3JEZXZpY2UsIG1sQ29udGV4dCB9KTtcclxuICAgICAgICByZXR1cm4gbWxDb250ZXh0O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnNPckRldmljZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IG1sQ29udGV4dEluZGV4ID0gdGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgoXHJcbiAgICAgICAgKGVudHJ5KSA9PiBlbnRyeS5vcHRpb25zID09PSB1bmRlZmluZWQgJiYgZW50cnkuZ3B1RGV2aWNlID09PSB1bmRlZmluZWQsXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChtbENvbnRleHRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVttbENvbnRleHRJbmRleF0ubWxDb250ZXh0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1sQ29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KCk7XHJcbiAgICAgICAgdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHsgbWxDb250ZXh0IH0pO1xyXG4gICAgICAgIHJldHVybiBtbENvbnRleHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtbENvbnRleHRJbmRleCA9IHRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KChlbnRyeSkgPT5cclxuICAgICAgY29tcGFyZU1MQ29udGV4dE9wdGlvbnMoZW50cnkub3B0aW9ucywgb3B0aW9uc09yRGV2aWNlKSxcclxuICAgICk7XHJcbiAgICBpZiAobWxDb250ZXh0SW5kZXggIT09IC0xKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW21sQ29udGV4dEluZGV4XS5tbENvbnRleHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBtbENvbnRleHQgPSBhd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dChvcHRpb25zT3JEZXZpY2UpO1xyXG4gICAgICB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goeyBvcHRpb25zOiBvcHRpb25zT3JEZXZpY2UsIG1sQ29udGV4dCB9KTtcclxuICAgICAgcmV0dXJuIG1sQ29udGV4dDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyByZWdpc3Rlck1MQ29udGV4dChzZXNzaW9uSWQ6IG51bWJlciwgbWxDb250ZXh0OiBNTENvbnRleHQpOiB2b2lkIHtcclxuICAgIHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuc2V0KHNlc3Npb25JZCwgbWxDb250ZXh0KTtcclxuICAgIGxldCBzZXNzaW9uSWRzID0gdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KG1sQ29udGV4dCk7XHJcbiAgICBpZiAoIXNlc3Npb25JZHMpIHtcclxuICAgICAgc2Vzc2lvbklkcyA9IG5ldyBTZXQoKTtcclxuICAgICAgdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuc2V0KG1sQ29udGV4dCwgc2Vzc2lvbklkcyk7XHJcbiAgICB9XHJcbiAgICBzZXNzaW9uSWRzLmFkZChzZXNzaW9uSWQpO1xyXG5cclxuICAgIGlmICh0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuc2V0KHNlc3Npb25JZCwgdGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cyk7XHJcbiAgICAgIHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMgPSBbXTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuc2Vzc2lvbkdyYXBoT3V0cHV0cy5zZXQoc2Vzc2lvbklkLCB0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cyk7XHJcbiAgICAgIHRoaXMudGVtcG9yYXJ5R3JhcGhPdXRwdXRzID0gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgb25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICB0aGlzLnNlc3Npb25HcmFwaE91dHB1dHMuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICBjb25zdCBtbENvbnRleHQgPSB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldChzZXNzaW9uSWQpITtcclxuICAgIGlmICghbWxDb250ZXh0KSB7XHJcbiAgICAgIC8vIEN1cnJlbnQgc2Vzc2lvbiBpcyBub3QgYSBXZWJOTiBzZXNzaW9uLlxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uKHNlc3Npb25JZCk7XHJcbiAgICB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmRlbGV0ZShzZXNzaW9uSWQpO1xyXG4gICAgY29uc3Qgc2Vzc2lvbklkcyA9IHRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmdldChtbENvbnRleHQpITtcclxuICAgIHNlc3Npb25JZHMuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICBpZiAoc2Vzc2lvbklkcy5zaXplID09PSAwKSB7XHJcbiAgICAgIHRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmRlbGV0ZShtbENvbnRleHQpO1xyXG4gICAgICBjb25zdCBtbENvbnRleHRJbmRleCA9IHRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubWxDb250ZXh0ID09PSBtbENvbnRleHQpO1xyXG4gICAgICBpZiAobWxDb250ZXh0SW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgdGhpcy5tbENvbnRleHRDYWNoZS5zcGxpY2UobWxDb250ZXh0SW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0TUxDb250ZXh0KHNlc3Npb25JZDogbnVtYmVyKTogTUxDb250ZXh0IHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldChzZXNzaW9uSWQpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlc2VydmVUZW5zb3JJZCgpOiBUZW5zb3JJZCB7XHJcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZDogVGVuc29ySWQpOiB2b2lkIHtcclxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViTk5dIHJlbGVhc2VUZW5zb3JJZCB7dGVuc29ySWQ6ICR7dGVuc29ySWR9fWApO1xyXG4gICAgdGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JJZCh0ZW5zb3JJZCk7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgYXN5bmMgZW5zdXJlVGVuc29yKFxyXG4gICAgc2Vzc2lvbklkOiBudW1iZXIgfCB1bmRlZmluZWQsXHJcbiAgICB0ZW5zb3JJZDogVGVuc29ySWQsXHJcbiAgICBvbm54RGF0YVR5cGU6IERhdGFUeXBlLFxyXG4gICAgZGltZW5zaW9uczogbnVtYmVyW10sXHJcbiAgICBjb3B5T2xkOiBib29sZWFuLFxyXG4gICk6IFByb21pc2U8TUxUZW5zb3I+IHtcclxuICAgIGNvbnN0IHdlYm5uRGF0YVR5cGUgPSBvbm54RGF0YVR5cGVUb1dlYm5uRGF0YVR5cGUuZ2V0KG9ubnhEYXRhVHlwZSk7XHJcbiAgICBpZiAoIXdlYm5uRGF0YVR5cGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtvbm54RGF0YVR5cGV9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvcihcclxuICAgICAgc2Vzc2lvbklkID8/IHRoaXMuY3VycmVudFNlc3Npb25JZCxcclxuICAgICAgdGVuc29ySWQsXHJcbiAgICAgIHdlYm5uRGF0YVR5cGUsXHJcbiAgICAgIGRpbWVuc2lvbnMsXHJcbiAgICAgIGNvcHlPbGQsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGNyZWF0ZVRlbXBvcmFyeVRlbnNvcihcclxuICAgIHNlc3Npb25JZDogbnVtYmVyLFxyXG4gICAgb25ueERhdGFUeXBlOiBEYXRhVHlwZSxcclxuICAgIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICApOiBQcm9taXNlPFRlbnNvcklkPiB7XHJcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYk5OXSBjcmVhdGVUZW1wb3JhcnlUZW5zb3Ige29ubnhEYXRhVHlwZTogJHtvbm54RGF0YVR5cGV9LCBzaGFwZTogJHtzaGFwZX19YCk7XHJcbiAgICBjb25zdCBkYXRhVHlwZSA9IG9ubnhEYXRhVHlwZVRvV2Vibm5EYXRhVHlwZS5nZXQob25ueERhdGFUeXBlKTtcclxuICAgIGlmICghZGF0YVR5cGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtvbm54RGF0YVR5cGV9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0ZW5zb3JJZCA9IHRoaXMudGVuc29yTWFuYWdlci5yZXNlcnZlVGVuc29ySWQoKTtcclxuICAgIGF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCB0ZW5zb3JJZCwgZGF0YVR5cGUsIHNoYXBlLCBmYWxzZSk7XHJcbiAgICBjb25zdCB0ZW5zb3JJZHMgPSB0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuZ2V0KHNlc3Npb25JZCk7XHJcbiAgICBpZiAoIXRlbnNvcklkcykge1xyXG4gICAgICB0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHMuc2V0KHNlc3Npb25JZCwgW3RlbnNvcklkXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0ZW5zb3JJZHMucHVzaCh0ZW5zb3JJZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVuc29ySWQ7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgdXBsb2FkVGVuc29yKHRlbnNvcklkOiBUZW5zb3JJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xyXG4gICAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XHJcbiAgICBpZiAoIXdhc20uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHVwbG9hZCB0byBhIE1MVGVuc29yIHdoaWxlIHNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciBpcyBmYWxzZScpO1xyXG4gICAgfVxyXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJOTl0gdXBsb2FkVGVuc29yIHt0ZW5zb3JJZDogJHt0ZW5zb3JJZH0sIGRhdGE6ICR7ZGF0YS5ieXRlTGVuZ3RofX1gKTtcclxuICAgIHRoaXMudGVuc29yTWFuYWdlci51cGxvYWQodGVuc29ySWQsIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGFzeW5jIGRvd25sb2FkVGVuc29yKHRlbnNvcklkOiBUZW5zb3JJZCwgZHN0QnVmZmVyOiBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IFByb21pc2U8dW5kZWZpbmVkPiB7XHJcbiAgICByZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHRlbnNvcklkLCBkc3RCdWZmZXIpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0ZW5zb3JJZDogVGVuc29ySWQsIHR5cGU6IFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcyk6ICgpID0+IFByb21pc2U8VGVuc29yLkRhdGFUeXBlPiB7XHJcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHRlbnNvcklkKTtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVZpZXcoZGF0YSwgdHlwZSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlZ2lzdGVyTUxUZW5zb3Ioc2Vzc2lvbklkOiBudW1iZXIsIHRlbnNvcjogTUxUZW5zb3IsIG9ubnhEYXRhVHlwZTogRGF0YVR5cGUsIGRpbWVuc2lvbnM6IG51bWJlcltdKTogVGVuc29ySWQge1xyXG4gICAgY29uc3Qgd2Vibm5EYXRhVHlwZSA9IG9ubnhEYXRhVHlwZVRvV2Vibm5EYXRhVHlwZS5nZXQob25ueERhdGFUeXBlKTtcclxuICAgIGlmICghd2Vibm5EYXRhVHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke29ubnhEYXRhVHlwZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpZCA9IHRoaXMudGVuc29yTWFuYWdlci5yZWdpc3RlclRlbnNvcihzZXNzaW9uSWQsIHRlbnNvciwgd2Vibm5EYXRhVHlwZSwgZGltZW5zaW9ucyk7XHJcbiAgICBMT0dfREVCVUcoXHJcbiAgICAgICd2ZXJib3NlJyxcclxuICAgICAgKCkgPT5cclxuICAgICAgICBgW1dlYk5OXSByZWdpc3Rlck1MVGVuc29yIHt0ZW5zb3I6ICR7dGVuc29yfSwgZGF0YVR5cGU6ICR7d2Vibm5EYXRhVHlwZX0sIGRpbWVuc2lvbnM6ICR7XHJcbiAgICAgICAgICBkaW1lbnNpb25zXHJcbiAgICAgICAgfX0gLT4ge3RlbnNvcklkOiAke2lkfX1gLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBpZDtcclxuICB9XHJcblxyXG4gIC8vIFJlZ2lzdGVyIGEgV2ViTk4gQ29uc3RhbnQgb3BlcmFuZCBmcm9tIGV4dGVybmFsIGRhdGEuXHJcbiAgcHVibGljIHJlZ2lzdGVyTUxDb25zdGFudChcclxuICAgIGV4dGVybmFsRmlsZVBhdGg6IHN0cmluZyxcclxuICAgIGRhdGFPZmZzZXQ6IG51bWJlcixcclxuICAgIGRhdGFMZW5ndGg6IG51bWJlcixcclxuICAgIGJ1aWxkZXI6IE1MR3JhcGhCdWlsZGVyLFxyXG4gICAgZGVzYzogTUxPcGVyYW5kRGVzY3JpcHRvcixcclxuICAgIG1vdW50ZWRGaWxlczogTWFwPHN0cmluZywgVWludDhBcnJheT4gfCB1bmRlZmluZWQsXHJcbiAgICBzaG91bGRDb252ZXJ0SW50NjRUb0ludDMyID0gZmFsc2UsXHJcbiAgKTogTUxPcGVyYW5kIHtcclxuICAgIC8vIElmIGF2YWlsYWJsZSwgXCJNb2R1bGUuTW91bnRlZEZpbGVzXCIgaXMgYSBNYXAgZm9yIGFsbCBwcmVsb2FkZWQgZmlsZXMuXHJcbiAgICBpZiAoIW1vdW50ZWRGaWxlcykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVybmFsIG1vdW50ZWQgZmlsZXMgYXJlIG5vdCBhdmFpbGFibGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGZpbGVQYXRoID0gZXh0ZXJuYWxGaWxlUGF0aDtcclxuICAgIGlmIChleHRlcm5hbEZpbGVQYXRoLnN0YXJ0c1dpdGgoJy4vJykpIHtcclxuICAgICAgZmlsZVBhdGggPSBleHRlcm5hbEZpbGVQYXRoLnN1YnN0cmluZygyKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbGVEYXRhID0gbW91bnRlZEZpbGVzLmdldChmaWxlUGF0aCk7XHJcbiAgICBpZiAoIWZpbGVEYXRhKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHtmaWxlUGF0aH0gbm90IGZvdW5kIGluIHByZWxvYWRlZCBmaWxlcy5gKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0YU9mZnNldCArIGRhdGFMZW5ndGggPiBmaWxlRGF0YS5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3V0IG9mIGJvdW5kczogZGF0YSBvZmZzZXQgYW5kIGxlbmd0aCBleGNlZWQgdGhlIGV4dGVybmFsIGZpbGUgZGF0YSBzaXplLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJ1ZmZlciA9IGZpbGVEYXRhLnNsaWNlKGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBkYXRhTGVuZ3RoKS5idWZmZXI7XHJcbiAgICBsZXQgYnVmZmVyVmlldzogQXJyYXlCdWZmZXJWaWV3O1xyXG4gICAgc3dpdGNoIChkZXNjLmRhdGFUeXBlKSB7XHJcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2Zsb2F0MTYnOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPVxyXG4gICAgICAgICAgdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb20gPyBuZXcgRmxvYXQxNkFycmF5KGJ1ZmZlcikgOiBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnaW50MzInOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgSW50MzJBcnJheShidWZmZXIpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICd1aW50MzInOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnaW50NjQnOlxyXG4gICAgICAgIGlmIChzaG91bGRDb252ZXJ0SW50NjRUb0ludDMyKSB7XHJcbiAgICAgICAgICAvLyBJbnQ2NCBpcyBub3Qgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgY29udGV4dCwgdXNlIGludDMyIGluc3RlYWQuXHJcbiAgICAgICAgICBjb25zdCBpbnQzMkJ1ZmZlciA9IGNvbnZlcnREYXRhVG9JbnQzMihuZXcgVWludDhBcnJheShidWZmZXIpLCAnaW50NjQnKTtcclxuICAgICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgSW50MzJBcnJheShpbnQzMkJ1ZmZlci5idWZmZXIpO1xyXG4gICAgICAgICAgZGVzYy5kYXRhVHlwZSA9ICdpbnQzMic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgQmlnSW50NjRBcnJheShidWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndWludDY0JzpcclxuICAgICAgICBidWZmZXJWaWV3ID0gbmV3IEJpZ1VpbnQ2NEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2ludDgnOlxyXG4gICAgICAgIGJ1ZmZlclZpZXcgPSBuZXcgSW50OEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2ludDQnOlxyXG4gICAgICBjYXNlICd1aW50NCc6XHJcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcclxuICAgICAgICBidWZmZXJWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkZXNjLmRhdGFUeXBlfSBpbiBjcmVhdGluZyBXZWJOTiBDb25zdGFudCBmcm9tIGV4dGVybmFsIGRhdGEuYCk7XHJcbiAgICB9XHJcblxyXG4gICAgTE9HX0RFQlVHKFxyXG4gICAgICAndmVyYm9zZScsXHJcbiAgICAgICgpID0+XHJcbiAgICAgICAgYFtXZWJOTl0gcmVnaXN0ZXJNTENvbnN0YW50IHtkYXRhVHlwZTogJHtkZXNjLmRhdGFUeXBlfSwgc2hhcGU6ICR7ZGVzYy5zaGFwZX19fSAke1xyXG4gICAgICAgICAgc2hvdWxkQ29udmVydEludDY0VG9JbnQzMiA/ICcoTm90ZTogaXQgd2FzIGludDY0IGRhdGEgdHlwZSBhbmQgcmVnaXN0ZXJlZCB0byBpbnQzMiBhcyB3b3JrYXJvdW5kKScgOiAnJ1xyXG4gICAgICAgIH1gLFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gYnVpbGRlci5jb25zdGFudChkZXNjLCBidWZmZXJWaWV3KTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyByZWdpc3RlckdyYXBoSW5wdXQoaW5wdXROYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMucHVzaChpbnB1dE5hbWUpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHJlZ2lzdGVyR3JhcGhPdXRwdXQob3V0cHV0TmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICB0aGlzLnRlbXBvcmFyeUdyYXBoT3V0cHV0cy5wdXNoKG91dHB1dE5hbWUpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGlzR3JhcGhJbnB1dChzZXNzaW9uSWQ6IG51bWJlciwgaW5wdXROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGlucHV0TmFtZXMgPSB0aGlzLnNlc3Npb25HcmFwaElucHV0cy5nZXQoc2Vzc2lvbklkKTtcclxuICAgIGlmICghaW5wdXROYW1lcykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5wdXROYW1lcy5pbmNsdWRlcyhpbnB1dE5hbWUpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGlzR3JhcGhPdXRwdXQoc2Vzc2lvbklkOiBudW1iZXIsIG91dHB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgb3V0cHV0TmFtZXMgPSB0aGlzLnNlc3Npb25HcmFwaE91dHB1dHMuZ2V0KHNlc3Npb25JZCk7XHJcbiAgICBpZiAoIW91dHB1dE5hbWVzKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXROYW1lcy5pbmNsdWRlcyhvdXRwdXROYW1lKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBpc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkKHNlc3Npb25JZDogbnVtYmVyLCB0eXBlOiBUZW5zb3IuVHlwZSwgaXNJbnB1dCA9IHRydWUpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldChzZXNzaW9uSWQpO1xyXG4gICAgY29uc3QgZGF0YVR5cGUgPSBvbm54RGF0YVR5cGVUb1dlYm5uRGF0YVR5cGUuZ2V0KHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKHR5cGUpKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGFUeXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzSW5wdXQpIHtcclxuICAgICAgcmV0dXJuICEhY29udGV4dD8ub3BTdXBwb3J0TGltaXRzKCkuaW5wdXQuZGF0YVR5cGVzLmluY2x1ZGVzKGRhdGFUeXBlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiAhIWNvbnRleHQ/Lm9wU3VwcG9ydExpbWl0cygpLm91dHB1dC5kYXRhVHlwZXMuaW5jbHVkZXMoZGF0YVR5cGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIGZsdXNoKCk6IHZvaWQge1xyXG4gICAgLy8gVW5saWtlIHRoZSBXZWJHUFUgYmFja2VuZCwgdGhlIFdlYk5OIGJhY2tlbmQgZG9lcyBub3QgbmVlZCB0byBmbHVzaCBhbnkgcGVuZGluZyBvcGVyYXRpb25zLlxyXG4gIH1cclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vdGVuc29yLXZpZXcnO1xyXG5cclxuaW1wb3J0IHsgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9vcHMvY29tbW9uJztcclxuXHJcbmV4cG9ydCB0eXBlIFNlc3Npb25TdGF0ZSA9ICdkZWZhdWx0JyB8ICdjYXB0dXJpbmcnIHwgJ3JlcGxheWluZyc7XHJcblxyXG5leHBvcnQgZW51bSBHcHVEYXRhVHlwZSB7XHJcbiAgZGVmYXVsdCA9IDAsXHJcbiAgdXBsb2FkID0gMSxcclxuICBwcm9maWxlID0gMixcclxufVxyXG5leHBvcnQgdHlwZSBHcHVEYXRhSWQgPSBudW1iZXI7XHJcblxyXG5leHBvcnQgdHlwZSBHcHVBcmNoaXRlY3R1cmUgPSAnYW1wZXJlJyB8ICdnZW4tMTJscCc7XHJcbmV4cG9ydCB0eXBlIEdwdVZlbmRvciA9ICdhbWQnIHwgJ2ludGVsJyB8ICdudmlkaWEnO1xyXG5leHBvcnQgaW50ZXJmYWNlIEFkYXB0ZXJJbmZvIHtcclxuICBpc0FyY2hpdGVjdHVyZTogKGFyY2hpdGVjdHVyZTogR3B1QXJjaGl0ZWN0dXJlKSA9PiBib29sZWFuO1xyXG4gIGlzVmVuZG9yOiAodmVuZG9yOiBHcHVWZW5kb3IpID0+IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR3B1RGF0YSB7XHJcbiAgdHlwZTogR3B1RGF0YVR5cGU7XHJcbiAgaWQ6IEdwdURhdGFJZDtcclxuICBidWZmZXI6IEdQVUJ1ZmZlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JJbmZvIHtcclxuICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcclxuICBkYXRhVHlwZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1Vbmlmb3JtIHtcclxuICB0eXBlOiBEYXRhVHlwZTtcclxuICBkYXRhOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm8gPSBbdHlwZTogRGF0YVR5cGUsIGxlbmd0aDogbnVtYmVyXTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnQgdGhlIGRlcGVuZGVuY3kgb2YgYSBwcm9ncmFtIG9uIGEgc3BlY2lmaWMgaW5wdXQgdGVuc29yLlxyXG4gKlxyXG4gKiAtICdub25lJzogdGhlIHNoYWRlci91bmlmb3JtIGRvZXMgbm90IGRlcGVuZCBvbiB0aGlzIGlucHV0J3MgaW5mb1xyXG4gKiAtICd0eXBlJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIG9mIHRoaXMgaW5wdXRcclxuICogLSAncmFuayc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSBhbmQgdGhlIHJhbmsgb2YgdGhpcyBpbnB1dFxyXG4gKiAtICdkaW1zJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIGFuZCB0aGUgZGltcyBvZiB0aGlzIGlucHV0XHJcbiAqIC0gJ2RhdGEnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUsIHRoZSBkaW1zIGFuZCB0aGUgZGF0YSBvZiB0aGlzIGlucHV0XHJcbiAqL1xyXG5leHBvcnQgdHlwZSBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSA9ICdub25lJyB8ICd0eXBlJyB8ICdyYW5rJyB8ICdkaW1zJyB8ICdkYXRhJztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBwcm9ncmFtJ3MgY2FjaGUgZm9yIHNoYWRlci5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVNoYWRlckNhY2hlSW5mbyB7XHJcbiAgLyoqXHJcbiAgICogYW4gb3B0aW9uYWwgc3RyaW5nIGFzIGEgY2FjaGUgaGludCBpbiB0aGUgYXJ0aWZhY3QgY2FjaGUuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIGNhY2hlIGhpbnQgd2lsbCBiZSBlbXB0eS5cclxuICAgKlxyXG4gICAqIFRoaXMgaGludCBzdHJpbmcgc2hvdWxkIG9ubHkgY29udGFpbnMgaW5pdGlhbGl6aW5nLXRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIGF0dHJpYnV0ZXMgb3IgYW55IGluZm9ybWF0aW9uIG9mXHJcbiAgICogaW5pdGlhbGl6ZXJzLiBJdCBzaG91bGQgTk9UIGNvbnRhaW4gYW55IHJ1bnRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIHNoYXBlIG9mIGlucHV0cy5cclxuICAgKi9cclxuICBoaW50Pzogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBhbiBvcHRpb25hbCBsaXN0IG9mIGRlcGVuZGVuY2llcyBvZiB0aGUgcHJvZ3JhbSBvbiB0aGUgaW5wdXQgdGVuc29ycy4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgcHJvZ3JhbSBkZXBlbmRzXHJcbiAgICogb24gJ2RpbXMnIG9mIGFsbCBpbnB1dHMuXHJcbiAgICovXHJcbiAgaW5wdXREZXBlbmRlbmNpZXM/OiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IGEgcHJvZ3JhbSdzIGNhY2hlIGZvciB1bmlmb3JtLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtVW5pZm9ybUNhY2hlSW5mbyB7XHJcbiAgLyoqXHJcbiAgICogYW4gb3B0aW9uYWwgc3RyaW5nIGFzIGEgY2FjaGUgaGludCBpbiB0aGUgdW5pZm9ybSBjYWNoZS4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgY2FjaGUgaGludCB3aWxsIGJlIGVtcHR5LlxyXG4gICAqXHJcbiAgICogVGhpcyBoaW50IHN0cmluZyBzaG91bGQgb25seSBjb250YWlucyBydW50aW1lIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBzaGFwZSBvZiBpbnB1dHMuXHJcbiAgICovXHJcbiAgaGludD86IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogYW4gb3B0aW9uYWwgbGlzdCBvZiBkZXBlbmRlbmNpZXMgb2YgdGhlIHByb2dyYW0gb24gdGhlIGlucHV0IHRlbnNvcnMuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIHByb2dyYW0gZGVwZW5kc1xyXG4gICAqIG9uICdub25lJyBvZiBhbGwgaW5wdXRzLlxyXG4gICAqL1xyXG4gIGlucHV0RGVwZW5kZW5jaWVzPzogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgc2V0IG9mIGRhdGEgdGhhdCByZXByZXNlbnQgYSBzaGFkZXIgcHJvZ3JhbVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtSW5mbyB7XHJcbiAgLyoqXHJcbiAgICogdGhlIG5hbWUgb2YgdGhlIHByb2dyYW0uIHVzZWQgZm9yIGRlYnVnZ2luZyBhbmQgcHJvZmlsaW5nXHJcbiAgICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBhbiBvcHRpb25hbCBvYmplY3QgZGVzY3JpYmluZyB0aGUgY2FjaGUgaW5mb3JtYXRpb24gb2YgdGhlIHByb2dyYW0gc2hhZGVyLlxyXG4gICAqXHJcbiAgICogSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgaGludCBpcyBlbXB0eSBhbmQgaW5wdXREZXBlbmRlbmNpZXMgYXJlIFsnZGltcyddIGZvciBhbGwgaW5wdXRzLlxyXG4gICAqL1xyXG4gIHNoYWRlckNhY2hlPzogUHJvZ3JhbVNoYWRlckNhY2hlSW5mbztcclxuXHJcbiAgLyoqXHJcbiAgICogdGhlIHNoYWRlcidzIHByb2Nlc3Npbmcgc291cmNlIGNvZGUuXHJcbiAgICpcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gc2hhZGVyIGNhY2hlIG1pc3NlZC5cclxuICAgKi9cclxuICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBBIGZ1bmN0aW9uIHRvIGdldCBydW4gZGF0YSByZXF1aXJlZCB0byBydW4gdGhlIHByb2dyYW0uXHJcbiAgICpcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHByb2dyYW0gaXMgZXhlY3V0ZWQuIFNob3VsZCBrZWVwIHRoaXMgZnVuY3Rpb24gYXMgc2ltcGxlIGFzIHBvc3NpYmxlLlxyXG4gICAqL1xyXG4gIGdldFJ1bkRhdGE6IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSkgPT4ge1xyXG4gICAgb3V0cHV0czogcmVhZG9ubHkgVGVuc29ySW5mb1tdO1xyXG4gICAgZGlzcGF0Y2hHcm91cDogeyB4OiBudW1iZXI7IHk/OiBudW1iZXI7IHo/OiBudW1iZXIgfTtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcz86IHJlYWRvbmx5IFByb2dyYW1Vbmlmb3JtW107XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBcnRpZmFjdCB7XHJcbiAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvO1xyXG4gIGNvbXB1dGVQaXBlbGluZTogR1BVQ29tcHV0ZVBpcGVsaW5lO1xyXG4gIHVuaWZvcm1WYXJpYWJsZXNJbmZvOiByZWFkb25seSBQcm9ncmFtVW5pZm9ybVZhcmlhYmxlSW5mb1tdIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcge1xyXG4gIC8qKlxyXG4gICAqIHNwZWNpZnkgdGhlIG1hcHBpbmcgdG8gdGhlIHByb2dyYW0ncyBpbnB1dHMuIHRoZSB2YWx1ZSBjYW4gYmUgYSBudW1iZXIgb3IgYSB0ZW5zb3Igdmlldy5cclxuICAgKiAtIGlmIGl0J3MgYSBudW1iZXIsIGl0J3MgdGhlIGluZGV4IG9mIHRoZSBrZXJuZWwncyBpbnB1dFxyXG4gICAqIC0gaWYgaXQncyBhIHRlbnNvciB2aWV3LCBpdCdzIGFuIGV4aXN0aW5nIHRlbnNvciB2aWV3IHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbnB1dFxyXG4gICAqXHJcbiAgICogaWYgaW5wdXRzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBtYXBwaW5nIHdpbGwgYmUgdGhlIGtlcm5lbCdzIGlucHV0cyBpbiBvcmRlci5cclxuICAgKi9cclxuICByZWFkb25seSBpbnB1dHM/OiBSZWFkb25seUFycmF5PFRlbnNvclZpZXcgfCBudW1iZXI+O1xyXG4gIC8qKlxyXG4gICAqIHNwZWNpZnkgdGhlIG1hcHBpbmcgdG8gdGhlIHByb2dyYW0ncyBvdXRwdXRzLiB0aGUgdmFsdWUgbXVzdCBiZSBhIG51bWJlci5cclxuICAgKiAtIGlmIGl0J3MgYSBub24tbmVnYXRpdmUgbnVtYmVyLCBpdCdzIHRoZSBpbmRleCBvZiB0aGUga2VybmVsJ3Mgb3V0cHV0XHJcbiAgICogLSBpZiBpdCdzIC0xLCBpdCdzIGFuIG91dHB1dCB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhcyBhIHRlbXBvcmFyeSB2YWx1ZS4gdGhpcyB2YWx1ZSB3aWxsIGJlIHJlbGVhc2VkIGFmdGVyXHJcbiAgICogdGhlIGtlcm5lbCBpcyBleGVjdXRlZC5cclxuICAgKiAtIGlmIGl0J3MgLTIsIGl0J3MgYW4gb3V0cHV0IHRoYXQgd2lsbCBiZSBjcmVhdGVkIGFzIGEgcGVyc2lzdGVudCB2YWx1ZS4gdGhpcyB2YWx1ZSB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdGhlXHJcbiAgICoga2VybmVsIGlzIHJlbGVhc2VkLlxyXG4gICAqXHJcbiAgICogaWYgb3V0cHV0cyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbWFwcGluZyB3aWxsIGJlIHRoZSBrZXJuZWwncyBvdXRwdXRzIGluIG9yZGVyLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IG91dHB1dHM/OiByZWFkb25seSBudW1iZXJbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgQ29tcHV0ZUNvbnRleHQgaW5zdGFuY2UgY2FycmllcyB0aGUgc3RhdGVzIHRoYXQgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJ1bm5pbmcgb2YgYSBrZXJuZWwuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIENvbXB1dGVDb250ZXh0IHtcclxuICAvKipcclxuICAgKiBncHUgYWRhcHRlciBpbmZvXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvO1xyXG5cclxuICAvKipcclxuICAgKiBzdG9yZXMgdGhlIHBvaW50ZXIgdG8gT3BLZXJuZWxDb250ZXh0XHJcbiAgICovXHJcbiAgcmVhZG9ubHkgb3BLZXJuZWxDb250ZXh0OiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIGEgbGlzdCBvZiBpbnB1dHMsIGVhY2ggaW5wdXQgaXMgYW4gaW5zdGFuY2Ugb2YgVGVuc29yVmlld1xyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xyXG5cclxuICAvKipcclxuICAgKiBhIGN1c3RvbSBkYXRhIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFueSBkYXRhIHRoYXQgaXMgbmVlZGVkIGJ5IHRoZSBrZXJuZWxcclxuICAgKi9cclxuICByZWFkb25seSBrZXJuZWxDdXN0b21EYXRhOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfTtcclxuXHJcbiAgLyoqXHJcbiAgICogYSBidWZmZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgY3VzdG9tIGRhdGEgY3JlYXRlZCBlYWNoIHRpbWUgdGhlIGtlcm5lbCBpcyBleGVjdXRlZFxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGN1c3RvbURhdGFCdWZmZXI6IFVpbnQ4QXJyYXk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGEgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoZSBub2RlXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgb3V0cHV0Q291bnQ6IG51bWJlcjtcclxuXHJcbiAgY29tcHV0ZShwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRzT3V0cHV0c01hcHBpbmc/OiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nKTogVGVuc29yVmlld1tdO1xyXG4gIG91dHB1dChpbmRleDogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVGltZXN0YW1wUXVlcnkgPSAnbm9uZScgfCAnaW5zaWRlLXBhc3NlcycgfCAnYXQtcGFzc2VzJztcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJncHUnO1xyXG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi9sb2cnO1xyXG5cclxuaW1wb3J0IHsgR3B1RGF0YSwgR3B1RGF0YUlkLCBHcHVEYXRhVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIG1hbmFnZXMgR3B1RGF0YUlkIC0+IEdwdUJ1ZmZlclxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBHcHVEYXRhTWFuYWdlciB7XHJcbiAgLyoqXHJcbiAgICogY29weSBkYXRhIGZyb20gQ1BVIHRvIEdQVS5cclxuICAgKi9cclxuICB1cGxvYWQoaWQ6IEdwdURhdGFJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQ7XHJcbiAgLyoqXHJcbiAgICogY29weSBkYXRhIGZyb20gR1BVIHRvIEdQVS5cclxuICAgKi9cclxuICBtZW1jcHkoc291cmNlSWQ6IEdwdURhdGFJZCwgZGVzdGluYXRpb25JZDogR3B1RGF0YUlkKTogdm9pZDtcclxuICAvKipcclxuICAgKiBjcmVhdGUgbmV3IGRhdGEgb24gR1BVLlxyXG4gICAqL1xyXG4gIGNyZWF0ZShzaXplOiBudW1iZXIsIHVzYWdlPzogbnVtYmVyKTogR3B1RGF0YTtcclxuICAvKipcclxuICAgKiBnZXQgR1BVIGRhdGEgYnkgSUQuXHJcbiAgICovXHJcbiAgZ2V0KGlkOiBHcHVEYXRhSWQpOiBHcHVEYXRhIHwgdW5kZWZpbmVkO1xyXG4gIC8qKlxyXG4gICAqIHJlbGVhc2UgdGhlIGRhdGEgb24gR1BVIGJ5IElELlxyXG4gICAqXHJcbiAgICogQHJldHVybiBzaXplIG9mIHRoZSBkYXRhIHJlbGVhc2VkXHJcbiAgICovXHJcbiAgcmVsZWFzZShpZDogR3B1RGF0YUlkKTogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIGNvcHkgZGF0YSBmcm9tIEdQVSB0byBDUFUuXHJcbiAgICovXHJcbiAgZG93bmxvYWQoaWQ6IEdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgLyoqXHJcbiAgICogcmVmcmVzaCB0aGUgYnVmZmVycyB0aGF0IG1hcmtlZCBmb3IgcmVsZWFzZS5cclxuICAgKlxyXG4gICAqIHdoZW4gcmVsZWFzZSgpIGlzIGNhbGxlZCwgdGhlIGJ1ZmZlciBpcyBub3QgcmVsZWFzZWQgaW1tZWRpYXRlbHkuIHRoaXMgaXMgYmVjYXVzZSB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBjb21tYW5kc1xyXG4gICAqIHRvIGJlIHN1Ym1pdHRlZCB0byB0aGUgR1BVLiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgY29tbWFuZHMgYXJlIHN1Ym1pdHRlZCBzbyB0aGF0IHRoZSBidWZmZXJzIGNhbiBiZVxyXG4gICAqIGFjdHVhbGx5IHJlbGVhc2VkLlxyXG4gICAqL1xyXG4gIHJlZnJlc2hQZW5kaW5nQnVmZmVycygpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiByZWdpc3RlciBhbiBleHRlcm5hbCBidWZmZXIgZm9yIElPIEJpbmRpbmcuIElmIHRoZSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLCByZXR1cm4gdGhlIGV4aXN0aW5nIEdQVSBkYXRhIElELlxyXG4gICAqXHJcbiAgICogR1BVIGRhdGEgbWFuYWdlciBvbmx5IG1hbmFnZXMgYSBtYXBwaW5nIGJldHdlZW4gdGhlIGJ1ZmZlciBhbmQgdGhlIEdQVSBkYXRhIElELiBJdCB3aWxsIG5vdCBtYW5hZ2UgdGhlIGxpZmVjeWNsZSBvZlxyXG4gICAqIHRoZSBleHRlcm5hbCBidWZmZXIuXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlciwgb3JpZ2luYWxTaXplOiBudW1iZXIsIHByZXZpb3VzPzogW0dwdURhdGFJZCwgR1BVQnVmZmVyXSk6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogdW5yZWdpc3RlciBhbiBleHRlcm5hbCBidWZmZXIgZm9yIElPIEJpbmRpbmcuXHJcbiAgICovXHJcbiAgdW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGlkOiBHcHVEYXRhSWQpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgKiBkZXN0cm95IGFsbCBncHUgYnVmZmVycy5cclxuICAgKi9cclxuICBkaXNwb3NlKCk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBzZXNzaW9uIHJlbGF0ZWQgZGF0YS5cclxuICAgKi9cclxuICBvbkNyZWF0ZVNlc3Npb24oKTogdm9pZDtcclxuXHJcbiAgLyoqXHJcbiAgICogcmVsZWFzZSBzZXNzaW9uIHJlbGF0ZWQgZGF0YS5cclxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIC0gc3BlY2lmeSB0aGUgc2Vzc2lvbiBJRC5cclxuICAgKi9cclxuICBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZDtcclxufVxyXG5cclxuaW50ZXJmYWNlIFN0b3JhZ2VDYWNoZVZhbHVlIHtcclxuICBncHVEYXRhOiBHcHVEYXRhO1xyXG4gIG9yaWdpbmFsU2l6ZTogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCBidWNrZXRGcmVlbGlzdDogTWFwPG51bWJlciwgbnVtYmVyPiA9IG5ldyBNYXAoW1xyXG4gIFs2NCwgMjUwXSxcclxuICBbMTI4LCAyMDBdLFxyXG4gIFsyNTYsIDIwMF0sXHJcbiAgWzUxMiwgMjAwXSxcclxuICBbMjA0OCwgMjMwXSxcclxuICBbNDA5NiwgMjAwXSxcclxuICBbODE5MiwgNTBdLFxyXG4gIFsxNjM4NCwgNTBdLFxyXG4gIFszMjc2OCwgNTBdLFxyXG4gIFs2NTUzNiwgNTBdLFxyXG4gIFsxMzEwNzIsIDUwXSxcclxuICBbMjYyMTQ0LCA1MF0sXHJcbiAgWzUyNDI4OCwgNTBdLFxyXG4gIFsxMDQ4NTc2LCA1MF0sXHJcbiAgWzIwOTcxNTIsIDMwXSxcclxuICBbNDE5NDMwNCwgMjBdLFxyXG4gIFs4Mzg4NjA4LCAxMF0sXHJcbiAgWzEyNTgyOTEyLCAxMF0sXHJcbiAgWzE2Nzc3MjE2LCAxMF0sXHJcbiAgWzI2MjE0NDAwLCAxNV0sXHJcbiAgWzMzNTU0NDMyLCAyMl0sXHJcbiAgWzQ0MjM2ODAwLCAyXSxcclxuICBbNTg5ODI0MDAsIDZdLFxyXG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gY2FjaGUgdGhlIGJ1Y2tldCBzaXplcyBiZWxvdyBidXQgbm90IGNhY2hpbmcgdGhlbVxyXG4gIC8vIHJlc3VsdHMgaW4gc29tZSBtYWpvciBwZXJmb3JtYW5jZSBoaXRzIGZvciBtb2RlbHMgbGlrZSBzZC10dXJiby5cclxuICBbNjcxMDg4NjQsIDZdLFxyXG4gIFsxMzQyMTc3MjgsIDZdLFxyXG4gIFsxNjc3NzIxNjAsIDZdLFxyXG5dKTtcclxuXHJcbmNvbnN0IGJ1Y2tldEFycjogbnVtYmVyW10gPSBbXTtcclxuXHJcbi8qKlxyXG4gKiBub3JtYWxpemUgdGhlIGJ1ZmZlciBzaXplIHNvIHRoYXQgaXQgZml0cyB0aGUgMTI4LWJpdHMgKDE2IGJ5dGVzKSBhbGlnbm1lbnQuXHJcbiAqL1xyXG5jb25zdCBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUgPSAoc2l6ZTogbnVtYmVyKSA9PiBNYXRoLmNlaWwoTnVtYmVyKHNpemUpIC8gMTYpICogMTY7XHJcblxyXG4vKipcclxuICogY2FsY3VsYXRlIHRoZSBidWZmZXIgc2l6ZSBzbyB0aGF0IGl0IGZpdHMgaW50byBidWNrZXRzLlxyXG4gKi9cclxuY29uc3QgY2FsY0J1Y2tldEJ1ZmZlclNpemUgPSAoc2l6ZTogbnVtYmVyKSA9PiB7XHJcbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYnVja2V0QXJyLmxlbmd0aDsgaWR4KyspIHtcclxuICAgIGNvbnN0IHNpemVGb3JCdWNrZXQgPSBidWNrZXRBcnJbaWR4XTtcclxuICAgIGlmIChzaXplIDw9IHNpemVGb3JCdWNrZXQpIHtcclxuICAgICAgcmV0dXJuIHNpemVGb3JCdWNrZXQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIG5vdCBpbiBidWNrZXQgbGlzdCAtPiBjYWxsZXIgd2lsbCBub3QgY2FjaGUsIHJvdW5kIHVwIHRvIDE2LlxyXG4gIHJldHVybiBNYXRoLmNlaWwoc2l6ZSAvIDE2KSAqIDE2O1xyXG59O1xyXG5cclxubGV0IGd1aWQgPSAxO1xyXG5jb25zdCBjcmVhdGVOZXdHcHVEYXRhSWQgPSAoKSA9PiBndWlkKys7XHJcblxyXG4vKipcclxuICogZXhwb3J0ZWQgc3RhbmRhcmQgZG93bmxvYWQgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgc2Vzc2lvbiB0byBkb3dubG9hZCB0aGUgZGF0YSBmcm9tIEdQVSwgYW5kIGFsc28gYnlcclxuICogZmFjdG9yeSB0byBjcmVhdGUgR1BVIHRlbnNvcnMgd2l0aCB0aGUgY2FwYWNpdHkgb2YgZG93bmxvYWRpbmcgZGF0YSBmcm9tIEdQVS5cclxuICpcclxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgV2ViR1BVIGJhY2tlbmRcclxuICogQHBhcmFtIGdwdUJ1ZmZlciAtIHRoZSBHUFUgYnVmZmVyIHRvIGRvd25sb2FkXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFNpemUgLSB0aGUgb3JpZ2luYWwgc2l6ZSBvZiB0aGUgZGF0YVxyXG4gKiBAcGFyYW0gZ2V0VGFyZ2V0QnVmZmVyIC0gb3B0aW9uYWwuIElmIHByb3ZpZGVkLCB0aGUgZGF0YSB3aWxsIGJlIGNvcGllZCB0byB0aGUgdGFyZ2V0IGJ1ZmZlci4gT3RoZXJ3aXNlLCBhIG5ldyBidWZmZXJcclxuICogd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBkb3dubG9hZEdwdURhdGEgPSBhc3luYyAoXHJcbiAgYmFja2VuZDogV2ViR3B1QmFja2VuZCxcclxuICBncHVCdWZmZXI6IEdQVUJ1ZmZlcixcclxuICBvcmlnaW5hbFNpemU6IG51bWJlcixcclxuICBnZXRUYXJnZXRCdWZmZXI/OiAoKSA9PiBVaW50OEFycmF5LFxyXG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcclxuICBjb25zdCBidWZmZXJTaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKG9yaWdpbmFsU2l6ZSk7XHJcbiAgY29uc3QgZ3B1UmVhZEJ1ZmZlciA9IGJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICB7IHNpemU6IGJ1ZmZlclNpemUsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEIH0sXHJcbiAgKTtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSBiYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7XHJcbiAgICBiYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XHJcbiAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXHJcbiAgICAgIGdwdUJ1ZmZlciAvKiBzb3VyY2UgYnVmZmVyICovLFxyXG4gICAgICAwIC8qIHNvdXJjZSBvZmZzZXQgKi8sXHJcbiAgICAgIGdwdVJlYWRCdWZmZXIgLyogZGVzdGluYXRpb24gYnVmZmVyICovLFxyXG4gICAgICAwIC8qIGRlc3RpbmF0aW9uIG9mZnNldCAqLyxcclxuICAgICAgYnVmZmVyU2l6ZSAvKiBzaXplICovLFxyXG4gICAgKTtcclxuICAgIGJhY2tlbmQuZmx1c2goKTtcclxuXHJcbiAgICBhd2FpdCBncHVSZWFkQnVmZmVyLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCk7XHJcblxyXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBncHVSZWFkQnVmZmVyLmdldE1hcHBlZFJhbmdlKCk7XHJcbiAgICBpZiAoZ2V0VGFyZ2V0QnVmZmVyKSB7XHJcbiAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIENQVSBidWZmZXIgdG8gYWNjZXB0IHRoZSBkYXRhLCBubyBuZWVkIHRvIGNsb25lIHRoZSBBcnJheUJ1ZmZlci5cclxuICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyID0gZ2V0VGFyZ2V0QnVmZmVyKCk7XHJcbiAgICAgIHRhcmdldEJ1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIDAsIG9yaWdpbmFsU2l6ZSkpO1xyXG4gICAgICByZXR1cm4gdGFyZ2V0QnVmZmVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gdGhlIG1hcHBlZCBBcnJheUJ1ZmZlciB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdGhlIEdQVSBidWZmZXIgaXMgZGVzdHJveWVkLiBOZWVkIHRvIGNsb25lIHRoZVxyXG4gICAgICAvLyBBcnJheUJ1ZmZlci5cclxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLnNsaWNlKDAsIG9yaWdpbmFsU2l6ZSkpO1xyXG4gICAgfVxyXG4gIH0gZmluYWxseSB7XHJcbiAgICBncHVSZWFkQnVmZmVyLmRlc3Ryb3koKTtcclxuICB9XHJcbn07XHJcblxyXG5jbGFzcyBHcHVEYXRhTWFuYWdlckltcGwgaW1wbGVtZW50cyBHcHVEYXRhTWFuYWdlciB7XHJcbiAgLy8gR1BVIERhdGEgSUQgPT4gR1BVIERhdGEgKCBzdG9yYWdlIGJ1ZmZlciApXHJcbiAgcHJpdmF0ZSBzdG9yYWdlQ2FjaGU6IE1hcDxHcHVEYXRhSWQsIFN0b3JhZ2VDYWNoZVZhbHVlPjtcclxuXHJcbiAgLy8gcGVuZGluZyBidWZmZXJzIGZvciBjb21wdXRpbmdcclxuICBwcml2YXRlIGJ1ZmZlcnNQZW5kaW5nOiBHUFVCdWZmZXJbXTtcclxuXHJcbiAgLy8gVGhlIHJldXNhYmxlIHN0b3JhZ2UgYnVmZmVycyBmb3IgY29tcHV0aW5nLlxyXG4gIHByaXZhdGUgZnJlZUJ1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcclxuICAvLyBUaGUgcmV1c2FibGUgdW5pZm9ybSBidWZmZXJzXHJcbiAgcHJpdmF0ZSBmcmVlVW5pZm9ybUJ1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcclxuXHJcbiAgLy8gVGhlIHBlbmRpbmdCdWZmZXJzIGZvciBjYXB0dXJlIGdyYXBoLlxyXG4gIC8vIGEgU2Vzc2lvbklEIC0+IEdQVUJ1ZmZlcltdIG1hcHBpbmcuXHJcbiAgcHJpdmF0ZSBjYXB0dXJlZFBlbmRpbmdCdWZmZXJzOiBNYXA8bnVtYmVyLCBHUFVCdWZmZXJbXT47XHJcblxyXG4gIC8vIFRoZSBzZXNzaW9uIGNvdW50LlxyXG4gIHByaXZhdGUgc2Vzc2lvbkNvdW50OiBudW1iZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCkge1xyXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmZyZWVCdWZmZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nID0gW107XHJcbiAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgZm9yIChjb25zdCBba2V5XSBvZiBidWNrZXRGcmVlbGlzdCkge1xyXG4gICAgICBidWNrZXRBcnIucHVzaChrZXkpO1xyXG4gICAgICB0aGlzLmZyZWVCdWZmZXJzLnNldChrZXksIFtdKTtcclxuICAgICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuc2V0KGtleSwgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2Vzc2lvbkNvdW50ID0gMDtcclxuICB9XHJcblxyXG4gIHVwbG9hZChpZDogR3B1RGF0YUlkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XHJcbiAgICBjb25zdCBzcmNBcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xyXG4gICAgY29uc3Qgc3JjT2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0O1xyXG4gICAgY29uc3Qgc3JjTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgY29uc3Qgc2l6ZSA9IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZShzcmNMZW5ndGgpO1xyXG5cclxuICAgIC8vIGdldCBkZXN0aW5hdGlvbiBncHUgYnVmZmVyXHJcbiAgICBjb25zdCBncHVEYXRhQ2FjaGUgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoaWQpO1xyXG4gICAgaWYgKCFncHVEYXRhQ2FjaGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoTnVtYmVyKGdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUpICE9PSBzcmNMZW5ndGgpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQgZGF0YSBzaXplLiBncHUgZGF0YSBzaXplPSR7Z3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke3NyY0xlbmd0aH1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjcmVhdGUgZ3B1IGJ1ZmZlclxyXG4gICAgY29uc3QgZ3B1QnVmZmVyRm9yVXBsb2FkaW5nID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgIHsgbWFwcGVkQXRDcmVhdGlvbjogdHJ1ZSwgc2l6ZSwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIH0sXHJcbiAgICApO1xyXG5cclxuICAgIC8vIGNvcHkgKHVwbG9hZCkgZGF0YVxyXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBncHVCdWZmZXJGb3JVcGxvYWRpbmcuZ2V0TWFwcGVkUmFuZ2UoKTtcclxuICAgIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkoc3JjQXJyYXlCdWZmZXIsIHNyY09mZnNldCwgc3JjTGVuZ3RoKSk7XHJcbiAgICBncHVCdWZmZXJGb3JVcGxvYWRpbmcudW5tYXAoKTtcclxuXHJcbiAgICAvLyBHUFUgY29weVxyXG4gICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XHJcbiAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoZ3B1QnVmZmVyRm9yVXBsb2FkaW5nLCAwLCBncHVEYXRhQ2FjaGUuZ3B1RGF0YS5idWZmZXIsIDAsIHNpemUpO1xyXG4gICAgdGhpcy5iYWNrZW5kLmRldmljZS5xdWV1ZS5zdWJtaXQoW2NvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSk7XHJcbiAgICBncHVCdWZmZXJGb3JVcGxvYWRpbmcuZGVzdHJveSgpO1xyXG5cclxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHtpZH0pYCk7XHJcbiAgfVxyXG5cclxuICBtZW1jcHkoc291cmNlSWQ6IEdwdURhdGFJZCwgZGVzdGluYXRpb25JZDogR3B1RGF0YUlkKTogdm9pZCB7XHJcbiAgICAvLyBnZXQgc291cmNlIGdwdSBidWZmZXJcclxuICAgIGNvbnN0IHNvdXJjZUdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChzb3VyY2VJZCk7XHJcbiAgICBpZiAoIXNvdXJjZUdwdURhdGFDYWNoZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICB9XHJcbiAgICAvLyBnZXQgZGVzdGluYXRpb24gZ3B1IGJ1ZmZlclxyXG4gICAgY29uc3QgZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoZGVzdGluYXRpb25JZCk7XHJcbiAgICBpZiAoIWRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNvdXJjZUdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUgIT09IGRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemUnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNvdXJjZUdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUpO1xyXG5cclxuICAgIC8vIEdQVSBjb3B5XHJcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO1xyXG4gICAgdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XHJcbiAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXHJcbiAgICAgIHNvdXJjZUdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlcixcclxuICAgICAgMCxcclxuICAgICAgZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUuZ3B1RGF0YS5idWZmZXIsXHJcbiAgICAgIDAsXHJcbiAgICAgIHNpemUsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlciwgb3JpZ2luYWxTaXplOiBudW1iZXIsIHByZXZpb3VzPzogW0dwdURhdGFJZCwgR1BVQnVmZmVyXSk6IG51bWJlciB7XHJcbiAgICBsZXQgaWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIGlmIChwcmV2aW91cykge1xyXG4gICAgICBpZCA9IHByZXZpb3VzWzBdO1xyXG4gICAgICBpZiAoYnVmZmVyID09PSBwcmV2aW91c1sxXSkge1xyXG4gICAgICAgIExPR19ERUJVRyhcclxuICAgICAgICAgICd2ZXJib3NlJyxcclxuICAgICAgICAgICgpID0+XHJcbiAgICAgICAgICAgIGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtvcmlnaW5hbFNpemV9KSA9PiBpZD0ke2lkfSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmAsXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZ2lzdGVyaW5nIGEgZGlmZmVyZW50IGV4dGVybmFsIGJ1ZmZlciB1bmRlciBncmFwaCBjYXB0dXJlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXHJcbiAgICAgICAgICAgICBQbGVhc2UgdXNlIHRoZSBwcmV2aW91cyBleHRlcm5hbCBidWZmZXIhYCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlkID0gY3JlYXRlTmV3R3B1RGF0YUlkKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGlkLCB7IGdwdURhdGE6IHsgaWQsIHR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQsIGJ1ZmZlciB9LCBvcmlnaW5hbFNpemUgfSk7XHJcbiAgICBMT0dfREVCVUcoXHJcbiAgICAgICd2ZXJib3NlJyxcclxuICAgICAgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke29yaWdpbmFsU2l6ZX0pID0+IGlkPSR7aWR9LCByZWdpc3RlcmVkLmAsXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGlkO1xyXG4gIH1cclxuXHJcbiAgdW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGlkOiBHcHVEYXRhSWQpOiB2b2lkIHtcclxuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShpZCk7XHJcbiAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke2lkfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICBjcmVhdGUoc2l6ZTogbnVtYmVyLCB1c2FnZSA9IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTogR3B1RGF0YSB7XHJcbiAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY0J1Y2tldEJ1ZmZlclNpemUoc2l6ZSk7XHJcblxyXG4gICAgbGV0IGdwdUJ1ZmZlcjtcclxuICAgIC8vIEN1cnJlbnRseSwgb25seSBzdG9yYWdlIGJ1ZmZlcnMgYXJlIHJldXNlZC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICBjb25zdCBpc1N0b3JhZ2UgPSAodXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSA9PT0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICBjb25zdCBpc1VuaWZvcm0gPSAodXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKSA9PT0gR1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtcclxuICAgIGlmIChpc1N0b3JhZ2UgfHwgaXNVbmlmb3JtKSB7XHJcbiAgICAgIGNvbnN0IGZyZWVCdWZmZXJzID0gaXNTdG9yYWdlID8gdGhpcy5mcmVlQnVmZmVycyA6IHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzO1xyXG4gICAgICBjb25zdCBidWZmZXJzID0gZnJlZUJ1ZmZlcnMuZ2V0KGJ1ZmZlclNpemUpO1xyXG4gICAgICBpZiAoIWJ1ZmZlcnMpIHtcclxuICAgICAgICAvLyBubyBzdWNoIGJ1Y2tldC9mcmVlbGlzdCAtIGNyZWF0ZSBncHUgYnVmZmVyXHJcbiAgICAgICAgZ3B1QnVmZmVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoeyBzaXplOiBidWZmZXJTaXplLCB1c2FnZSB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYnVmZmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyBpbiBmcmVlbGlzdCwgdXNlIGl0XHJcbiAgICAgICAgICBncHVCdWZmZXIgPSBidWZmZXJzLnBvcCgpIGFzIEdQVUJ1ZmZlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gYnVja2V0IGVtcHR5LCBjcmVhdGUgZ3B1IGJ1ZmZlclxyXG4gICAgICAgICAgZ3B1QnVmZmVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoeyBzaXplOiBidWZmZXJTaXplLCB1c2FnZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGNyZWF0ZSBncHUgYnVmZmVyXHJcbiAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHsgc2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2UgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ3B1RGF0YSA9IHsgaWQ6IGNyZWF0ZU5ld0dwdURhdGFJZCgpLCB0eXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0LCBidWZmZXI6IGdwdUJ1ZmZlciB9O1xyXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGdwdURhdGEuaWQsIHsgZ3B1RGF0YSwgb3JpZ2luYWxTaXplOiBOdW1iZXIoc2l6ZSkgfSk7XHJcblxyXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7c2l6ZX0pID0+IGlkPSR7Z3B1RGF0YS5pZH1gKTtcclxuICAgIHJldHVybiBncHVEYXRhO1xyXG4gIH1cclxuXHJcbiAgZ2V0KGlkOiBHcHVEYXRhSWQpOiBHcHVEYXRhIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoaWQpPy5ncHVEYXRhO1xyXG4gIH1cclxuXHJcbiAgcmVsZWFzZShpZElucHV0OiBHcHVEYXRhSWQpOiBudW1iZXIge1xyXG4gICAgY29uc3QgaWQgPSB0eXBlb2YgaWRJbnB1dCA9PT0gJ2JpZ2ludCcgPyBOdW1iZXIoaWRJbnB1dCkgOiBpZElucHV0O1xyXG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XHJcbiAgICBpZiAoIWNhY2hlZERhdGEpIHtcclxuICAgICAgaWYgKHRoaXMuc3RvcmFnZUNhY2hlLnNpemUgPT09IDApIHtcclxuICAgICAgICAvLyBjYWNoZSB3YXMgcHJldmlvdXNseSBjbGVhcmVkLCBubyBuZWVkIHRvIHJlbGVhc2UgYW55dGhpbmcuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdCcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHtpZH0pLCBncHVEYXRhSWQ9JHtjYWNoZWREYXRhLmdwdURhdGEuaWR9YCk7XHJcblxyXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKGlkKTtcclxuICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcucHVzaChjYWNoZWREYXRhLmdwdURhdGEuYnVmZmVyKTtcclxuICAgIC8vIGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIHJldHVybiBjYWNoZWREYXRhLm9yaWdpbmFsU2l6ZTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRvd25sb2FkKGlkOiBHcHVEYXRhSWQsIGdldFRhcmdldEJ1ZmZlcjogKCkgPT4gVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChOdW1iZXIoaWQpKTtcclxuICAgIGlmICghY2FjaGVkRGF0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgZG9lcyBub3QgZXhpc3QnKTtcclxuICAgIH1cclxuICAgIGF3YWl0IGRvd25sb2FkR3B1RGF0YSh0aGlzLmJhY2tlbmQsIGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIsIGNhY2hlZERhdGEub3JpZ2luYWxTaXplLCBnZXRUYXJnZXRCdWZmZXIpO1xyXG4gIH1cclxuXHJcbiAgcmVmcmVzaFBlbmRpbmdCdWZmZXJzKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuYnVmZmVyc1BlbmRpbmcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXMgPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKSB7XHJcbiAgICAgICAgY29uc3QgbWF4SW5GcmVlTGlzdCA9IGJ1Y2tldEZyZWVsaXN0LmdldChidWZmZXIuc2l6ZSk7XHJcblxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXHJcbiAgICAgICAgaWYgKChidWZmZXIudXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSA9PT0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSkge1xyXG4gICAgICAgICAgLy8gUHV0IHRoZSBwZW5kaW5nIGJ1ZmZlciB0byBmcmVlQnVmZmVycyBsaXN0IGluc3RlYWQgb2YgcmVhbGx5IGRlc3Ryb3lpbmcgaXQgZm9yIGJ1ZmZlciByZXVzaW5nLlxyXG4gICAgICAgICAgY29uc3QgZnJlZWxpc3QgPSB0aGlzLmZyZWVCdWZmZXJzLmdldChidWZmZXIuc2l6ZSkgfHwgW107XHJcbiAgICAgICAgICBpZiAobWF4SW5GcmVlTGlzdCA9PT0gdW5kZWZpbmVkIHx8IGZyZWVsaXN0Lmxlbmd0aCA+PSBtYXhJbkZyZWVMaXN0KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmcmVlbGlzdC5wdXNoKGJ1ZmZlcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgIH0gZWxzZSBpZiAoKGJ1ZmZlci51c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pID09PSBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKSB7XHJcbiAgICAgICAgICAvLyBQdXQgdGhlIHBlbmRpbmcgYnVmZmVyIHRvIGZyZWVVbmlmb3JtQnVmZmVycyBsaXN0IGluc3RlYWQgb2YgcmVhbGx5IGRlc3Ryb3lpbmcgaXQgZm9yIGJ1ZmZlciByZXVzaW5nLlxyXG4gICAgICAgICAgY29uc3QgZnJlZWxpc3QgPSB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQoYnVmZmVyLnNpemUpIHx8IFtdO1xyXG4gICAgICAgICAgaWYgKG1heEluRnJlZUxpc3QgPT09IHVuZGVmaW5lZCB8fCBmcmVlbGlzdC5sZW5ndGggPj0gbWF4SW5GcmVlTGlzdCkge1xyXG4gICAgICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZnJlZWxpc3QucHVzaChidWZmZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nID0gW107XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBEb24ndCByZWxlYXNlIGludGVybWVkaWF0ZSB0ZW5zb3JzIGluIG5vbi1kZWZhdWx0IG1vZGUuXHJcbiAgICAgIC8vIFRPRE86IHJldXNlIHRoZSBzdG9yYWdlIGJ1ZmZlcnMgaW4gbm9uLWRlZmF1bHQgbW9kZS5cclxuICAgICAgbGV0IGNhcHR1cmVkQnVmZmVycyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhKTtcclxuICAgICAgaWYgKCFjYXB0dXJlZEJ1ZmZlcnMpIHtcclxuICAgICAgICBjYXB0dXJlZEJ1ZmZlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuc2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISwgY2FwdHVyZWRCdWZmZXJzKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKSB7XHJcbiAgICAgICAgY2FwdHVyZWRCdWZmZXJzLnB1c2goYnVmZmVyKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nID0gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaXNwb3NlKCkge1xyXG4gICAgdGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKChidWZmZXJzKSA9PiB7XHJcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XHJcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2goKGJ1ZmZlcnMpID0+IHtcclxuICAgICAgYnVmZmVycy5mb3JFYWNoKChidWZmZXIpID0+IHtcclxuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2goKHN0b3JhZ2UpID0+IHtcclxuICAgICAgc3RvcmFnZS5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZm9yRWFjaCgoYnVmZmVycykgPT4ge1xyXG4gICAgICBidWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4ge1xyXG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuZnJlZUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuICB9XHJcblxyXG4gIG9uQ3JlYXRlU2Vzc2lvbigpIHtcclxuICAgIHRoaXMuc2Vzc2lvbkNvdW50ICs9IDE7XHJcbiAgfVxyXG5cclxuICBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKSB7XHJcbiAgICAvLyByZWxlYXNlIHRoZSBjYXB0dXJlZCBwZW5kaW5nIGJ1ZmZlcnMuXHJcbiAgICBjb25zdCBwZW5kaW5nQnVmZmVycyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQoc2Vzc2lvbklkKTtcclxuICAgIGlmIChwZW5kaW5nQnVmZmVycykge1xyXG4gICAgICBwZW5kaW5nQnVmZmVycy5mb3JFYWNoKChidWZmZXIpID0+IHtcclxuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmRlbGV0ZShzZXNzaW9uSWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbGVhc2UgdGhlIHN0b3JhZ2UgY2FjaGUgaWYgbm8gYWN0aXZlIHNlc3Npb25zLlxyXG4gICAgdGhpcy5zZXNzaW9uQ291bnQgLT0gMTtcclxuICAgIGlmICh0aGlzLnNlc3Npb25Db3VudCA9PT0gMCkge1xyXG4gICAgICBMT0dfREVCVUcoJ3dhcm5pbmcnLCAoKSA9PiAnW1dlYkdQVV0gQ2xlYXJpbmcgd2ViZ3B1IGJ1ZmZlciBjYWNoZScpO1xyXG4gICAgICB0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XHJcbiAgICAgICAgc3RvcmFnZS5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVHcHVEYXRhTWFuYWdlciA9ICguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIEdwdURhdGFNYW5hZ2VySW1wbD4pOiBHcHVEYXRhTWFuYWdlciA9PlxyXG4gIG5ldyBHcHVEYXRhTWFuYWdlckltcGwoLi4uYXJncyk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuY2xhc3MgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbCB7XHJcbiAgY29uc3RydWN0b3IoYXR0cmlidXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhdHRyaWJ1dGUpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBrZXk6IHN0cmluZztcclxuICBwdWJsaWMgZ2V0IGNhY2hlS2V5KCk6IHN0cmluZyB7XHJcbiAgICBpZiAoIXRoaXMua2V5KSB7XHJcbiAgICAgIHRoaXMua2V5ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcylcclxuICAgICAgICAuc29ydCgpXHJcbiAgICAgICAgLm1hcCgobmFtZSkgPT4gYCR7KHRoaXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pW25hbWVdfWApXHJcbiAgICAgICAgLmpvaW4oJzsnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmtleTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBjYWNoZUtleTogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogY3JlYXRlIGEgbmV3IG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhdHRyaWJ1dGUsIGFuZCBhZGQgYSBjYWNoZUtleSBwcm9wZXJ0eSB0byBpdFxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSA9IDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxyXG4gIGF0dHJpYnV0ZTogVCxcclxuKTogVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSA9PiBuZXcgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbChhdHRyaWJ1dGUpIGFzIHVua25vd24gYXMgVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IFByb2dyYW1Vbmlmb3JtLCBQcm9ncmFtVW5pZm9ybVZhcmlhYmxlSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbi8qKlxyXG4gKiBjb25zdGFudCB2YWx1ZSBmb3IgYSB3b3JrZ3JvdXAgc2l6ZS5cclxuICpcclxuICogV2UgZGVmaW5pdGVseSBjYW4gZG8gZnVydGhlciBvcHRpbWl6YXRpb24gaW4gZnV0dXJlLCBidXQgZm9yIG5vdyB3ZSB1c2UgNjQuXHJcbiAqXHJcbiAqIHJ1bGUgb2YgdGh1bWI6IFVzZSBbYSB3b3JrZ3JvdXAgc2l6ZSBvZl0gNjQgdW5sZXNzIHlvdSBrbm93IHdoYXQgR1BVIHlvdSBhcmUgdGFyZ2V0aW5nIG9yIHRoYXQgeW91ciB3b3JrbG9hZFxyXG4gKiAgICAgICAgICAgICAgICBuZWVkcyBzb21ldGhpbmcgZGlmZmVyZW50LlxyXG4gKlxyXG4gKiBmcm9tOiBodHRwczovL3N1cm1hLmRldi90aGluZ3Mvd2ViZ3B1L1xyXG4gKiovXHJcbmV4cG9ydCBjb25zdCBXT1JLR1JPVVBfU0laRSA9IDY0O1xyXG5cclxuaW50ZXJmYWNlIEluZGljZXNIZWxwZXJUeXBlcyB7XHJcbiAgLyoqXHJcbiAgICogV0dTTCB0eXBlIG9mIGluZGljZXMgZXhwcmVzc2lvblxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGluZGljZXM6IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogV0dTTCB0eXBlIG9mIGEgdmFsdWVcclxuICAgKi9cclxuICByZWFkb25seSB2YWx1ZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBXR1NMIHR5cGUgb2Ygc3RvcmFnZSB0eXBlIHJlcHJlc2VudGluZyBhIHZhbHVlXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgdG8gYHZhbHVlYCwgYnV0IGZvciBzb21lIHR5cGUgKGVnLiBib29sKSwgd2UgbmVlZCB0byB1c2UgYHUzMmAgYXMgc3RvcmFnZSB0eXBlIGZvclxyXG4gICAqIHZhbHVlIHR5cGUgYHZlYzQ8Ym9vbD5gXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgc3RvcmFnZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiB0ZW5zb3IgdHlwZSBhcyByZXByZXNlbnRlZCBpbiBUZW5zb3JWaWV3XHJcbiAgICovXHJcbiAgcmVhZG9ubHkgdGVuc29yOiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGhlbHBlciBjbGFzcyBmb3IgZ2VuZXJhdGluZyBXR1NMIGNvZGUgZm9yIG1hbmlwdWxhdGluZyBpbmRpY2VzIGFuZCBkYXRhIGZvciBhIHNoYWRlcidzIGlucHV0IG9yIG91dHB1dC5cclxuICpcclxuICogVGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byBvZmZlciBhIHVuaWZpZWQgd2F5IHRvIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEgZm9yIGEgc2hhZGVyJ3NcclxuICogaW5wdXQgb3Igb3V0cHV0LlxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGlzIGEgbGlzdCBvZiB0ZXJtaW5vbG9naWVzIHVzZWQgaW4gdGhpcyBjbGFzczpcclxuICogLSBgb2Zmc2V0YDogYSB1aW50MzIgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQgb2YgYW4gZWxlbWVudCBpbiB0aGUgZGF0YSBidWZmZXIuXHJcbiAqIC0gYGluZGljZXNgOiBhbiBhYnN0cmFjdGlvbiBvZiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5J3MgaW5kaWNlcyByZXByZXNlbnRpbmcgdGhlIGRhdGEncyBpbmRleCBvbiBlYWNoIGRpbWVuc2lvbi5cclxuICogLSBgdmFsdWVgOiBhIHZhbHVlIG9mIGEgZGF0YSBlbGVtZW50LlxyXG4gKlxyXG4gKiBVc2VycyBhcmUgZXhwZWN0ZWQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZm9yIGVhY2ggc2hhZGVyJ3MgaW5wdXQgb3Igb3V0cHV0LCBhbmQgdXNlIHRoZSBpbnN0YW5jZSB0b1xyXG4gKiBnZW5lcmF0ZSBXR1NMIGNvZGUgZm9yIG1hbmlwdWxhdGluZyBpbmRpY2VzIGFuZCBkYXRhLiBUaGUgZm9sbG93aW5nIDIgZXhwb3J0ZWQgZnVuY3Rpb25zIGFyZSBmb3IgdXNlcnMgdG8gY2FsbCB0b1xyXG4gKiBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gaW5kaWNlcyBoZWxwZXI6XHJcbiAqIC0gYGlucHV0VmFyaWFibGUoKWA6IGNyZWF0ZSBhbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBmb3IgYW4gaW5wdXQuXHJcbiAqIC0gYG91dHB1dFZhcmlhYmxlKClgOiBjcmVhdGUgYW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgZm9yIGFuIG91dHB1dC5cclxuICogLSBgaW50ZXJuYWxWYXJpYWJsZSgpYDogY3JlYXRlIGFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGZvciBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cclxuICpcclxuICogQW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgY29udGFpbnMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxyXG4gKiAtIGFjY2VzcyByZWFkb25seSBiYXNpYyBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nOiBgbmFtZWAodGhlIG5hbWUgb2YgdGhlIGlucHV0IG9yIG91dHB1dCksIGB1c2FnZWAod2hldGhlciBpdCdzIGFuXHJcbiAqIGlucHV0LCBhbiBvdXRwdXQgb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUpIGFuZCBgc2hhcGVgKHRoZSBwYXNzZWQgaW4gc2hhcGUpLlxyXG4gKiAtIGB0eXBlYDogYWNjZXNzIHJlYWRvbmx5IHR5cGUgaW5mb3JtYXRpb24sIGluY2x1ZGluZzogYGluZGljZXNgKHRoZSB0eXBlIG9mIGluZGljZXMpLCBgdmFsdWVgKHRoZSB0eXBlIG9mIHZhbHVlIGF0XHJcbiAqIHJ1bnRpbWUpLCBgc3RvcmFnZWAodGhlIHR5cGUgb2YgdmFsdWUgYXQgc3RvcmFnZSkgYW5kIGB0ZW5zb3JgKHRoZSB0ZW5zb3IgdHlwZSBhcyByZXByZXNlbnRlZCBpbiBUZW5zb3JWaWV3KS5cclxuICogLSBnZW5lcmF0ZSBXR1NMIGNvZGUgZm9yIGdldHRpbmcgaW5kaWNlcyBmcm9tIG9mZnNldC4gVXNlIGBvZmZzZXRUb0luZGljZXMoKWAgZm9yIFdHU0wgY29kZSBzbmlwcGV0IHRvIGNhbGN1bGF0ZVxyXG4gKiBpbmRpY2VzIGZyb20gb2Zmc2V0LCBhbmQgdXNlIGBpbmRpY2VzVG9PZmZzZXQoKWAgZm9yIFdHU0wgY29kZSBzbmlwcGV0IHRvIGNhbGN1bGF0ZSBvZmZzZXQgZnJvbSBpbmRpY2VzLlxyXG4gKiAtIHRvIG1hbmlwdWxhdGUgYW4gaW5zdGFuY2Ugb2YgaW5kaWNlcywgdXNlIGBzZXRJbmRpY2VzKClgIGFuZCBgZ2V0SW5kaWNlcygpYCB0byBzZXQgYW5kIGdldCB0aGUgaW5kaWNlcyBvbiBhblxyXG4gKiBpbmRpY2VzIHZhcmlhYmxlLlxyXG4gKiAtIHRvIG1hbmlwdWxhdGUgZGF0YSwgdXNlIGBzZXQoKWAvYGdldCgpYCB0byBhY2Nlc3MgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyBmcm9tIHBhcmFtZXRlciBsaXN0LCB1c2VcclxuICogYHNldEJ5SW5kaWNlcygpYC9gZ2V0QnlJbmRpY2VzKClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIGZyb20gYW4gaW5kaWNlcyB2YXJpYWJsZSwgYW5kIHVzZVxyXG4gKiBgc2V0QnlPZmZzZXQoKWAvYGdldEJ5T2Zmc2V0KClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBvZmZzZXQuXHJcbiAqIC0gYGltcGxgOiBnZXQgV0dTTCBjb2RlIG9mIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgdXRpbCBmdW5jdGlvbnMgbWVudGlvbmVkIGFib3ZlLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2VzSGVscGVyIHtcclxuICAvKipcclxuICAgKiBnZXQgV0dTTCBjb2RlIG9mIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgdXRpbCBmdW5jdGlvbnMuXHJcbiAgICpcclxuICAgKi9cclxuICByZWFkb25seSBpbXBsOiAoKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIGdldCB0eXBlIGluZm9cclxuICAgKi9cclxuICByZWFkb25seSB0eXBlOiBJbmRpY2VzSGVscGVyVHlwZXM7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBvZiBhIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgaW5kaWNlcyBmcm9tIG9mZnNldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YXJPZmZzZXQgLSBhIHUzMiBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgYW4gYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvblxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IG9mZnNldFRvSW5kaWNlczogKHZhck9mZnNldDogc3RyaW5nKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIG9mZnNldCBmcm9tIGluZGljZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIGluZGljZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBhbiBgdTMyYCBleHByZXNzaW9uXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgaW5kaWNlc1RvT2Zmc2V0OiAodmFySW5kaWNlczogc3RyaW5nKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIG9yaWdpbmFsIG9mZnNldCBmcm9tIGJyb2FkY2FzdGVkIGluZGljZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIG91dHB1dCBpbmRpY2VzLlxyXG4gICAqIEBwYXJhbSBvdXRwdXQgLSBvdXRwdXQgSW5kaWNlc0hlbHBlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGFuIGB1MzJgIGV4cHJlc3Npb25cclxuICAgKi9cclxuICByZWFkb25seSBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDogKHZhckluZGljZXM6IHN0cmluZywgb3V0cHV0OiBJbmRpY2VzSGVscGVyKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBvZiBnZW5lcmF0aW5nIGFuIGluZGljZXMgbGl0ZXJhbFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGluaXQgLSBpbml0aWFsIHZhbHVlLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGluZGljZXM6ICguLi5pbml0OiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz4pID0+IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogV0dTTCBjb2RlIG9mIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGluZGljZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXHJcbiAgICogQHBhcmFtIGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgaW5kaWNlcyB0byBzZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cclxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gc2V0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBhIFdHU0wgc3RhdGVtZW50XHJcbiAgICovXHJcbiAgcmVhZG9ubHkgaW5kaWNlc1NldDogKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBudW1iZXIgfCBzdHJpbmcpID0+IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIGluZGljZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXHJcbiAgICogQHBhcmFtIGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgaW5kaWNlcyB0byBnZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGFuIGB1MzJgIGV4cHJlc3Npb25cclxuICAgKi9cclxuICByZWFkb25seSBpbmRpY2VzR2V0OiAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlciB8IHN0cmluZykgPT4gc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW5kaWNlc0FuZFZhbHVlIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcywgZm9sbG93ZWRcclxuICAgKiAgICAgYnkgdGhlIHZhbHVlIHRvIHNldC4gVGhpcyBhcnJheSBzaG91bGQgaGF2ZSBleGFjdGx5IGBzaGFwZS5sZW5ndGggKyAxYCBlbGVtZW50cy5cclxuICAgKi9cclxuICByZWFkb25seSBzZXQ6ICguLi5pbmRpY2VzQW5kVmFsdWU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgdmFyaWFibGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXHJcbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHNldC4gc2hvdWxkIGJlIGEgV0dTTCBleHByZXNzaW9uLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IHNldEJ5SW5kaWNlczogKHZhckluZGljZXM6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIG9mZnNldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cclxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gc2V0LiBzaG91bGQgYmUgYSBXR1NMIGV4cHJlc3Npb24uXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgc2V0QnlPZmZzZXQ6IChvZmZzZXQ6IG51bWJlciB8IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpbmRpY2VzIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcy5cclxuICAgKi9cclxuICByZWFkb25seSBnZXQ6ICguLi5pbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz4pID0+IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogV0dTTCBjb2RlIGZvciBhbiBleHByZXNzaW9uIGZvciBnZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgdmFyaWFibGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgZ2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nKSA9PiBzdHJpbmc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBvZmZzZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgZ2V0QnlPZmZzZXQ6IChvZmZzZXQ6IG51bWJlciB8IHN0cmluZykgPT4gc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBuYW1lIG9mIHRoZSBkYXRhIHZhcmlhYmxlXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiB3aGV0aGVyIHRoZSBoZWxwZXIgaXMgZm9yIGFuIGlucHV0LCBhbiBvdXRwdXQgb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgdXNhZ2U6ICdpbnB1dCcgfCAnb3V0cHV0JyB8ICdhdG9taWNPdXRwdXQnIHwgJ2ludGVybmFsJztcclxuXHJcbiAgLyoqXHJcbiAgICogdGhlIHJhbmsgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cclxuICAgKi9cclxuICByZWFkb25seSByYW5rOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFyaWFibGUgbmFtZSBmb3IgdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgc2hhcGU6IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgc3RyaWRlcyBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IHN0cmlkZXM6IHN0cmluZztcclxufVxyXG5cclxuY29uc3QgZ2V0V2dzbE1hcHBlZFR5cGUgPSAodHlwZTogbnVtYmVyLCBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0KTogc3RyaW5nIHwgW3N0cmluZywgc3RyaW5nXSA9PiB7XHJcbiAgaWYgKGNvbXBvbmVudHMgPT09IDMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndmVjMyBoYXMgc2FtZSBhbGlnbm1lbnQgYXMgdmVjNCwgdXNlIHZlYzQgaW5zdGVhZCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gcmV0dXJuIHR5cGUgaXMgWyBzdG9yYWdlIHR5cGUsIHJ1bnRpbWUgdHlwZSBdIG9yIGEgc2luZ2xlIHN0cmluZyBmb3IgYm90aFxyXG4gIHN3aXRjaCAoTnVtYmVyKHR5cGUpKSB7XHJcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XHJcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGYxNj5gIDogJ2YxNic7XHJcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0OlxyXG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxmMzI+YCA6ICdmMzInO1xyXG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcclxuICAgICAgcmV0dXJuIGNvbXBvbmVudHMgPiAxID8gYHZlYyR7Y29tcG9uZW50c308aTMyPmAgOiAnaTMyJztcclxuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxyXG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTx1MzI+YCA6ICd1MzInO1xyXG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ2NDpcclxuICAgICAgaWYgKGNvbXBvbmVudHMgPiAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXQnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gWyd2ZWMyPHUzMj4nLCAnaTMyJ107XHJcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ2NDpcclxuICAgICAgaWYgKGNvbXBvbmVudHMgPiAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXQnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gWyd2ZWMyPHUzMj4nLCAndTMyJ107XHJcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XHJcbiAgICAgIGlmIChjb21wb25lbnRzICE9PSA0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib29sIG11c3QgYmUgdmVjNCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbJ3UzMicsICd2ZWM0PGJvb2w+J107XHJcbiAgICBjYXNlIERhdGFUeXBlLmludDQ6XHJcbiAgICAgIHJldHVybiAnaTMyJztcclxuICAgIGNhc2UgRGF0YVR5cGUudWludDQ6XHJcbiAgICAgIHJldHVybiAndTMyJztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlID0gKHR5cGU6IERhdGFUeXBlLCBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSkgPT4ge1xyXG4gIGNvbnN0IG1hcHBlZFR5cGUgPSBnZXRXZ3NsTWFwcGVkVHlwZSh0eXBlLCBjb21wb25lbnRzKTtcclxuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMF07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSA9ICh0eXBlOiBEYXRhVHlwZSwgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEpID0+IHtcclxuICBjb25zdCBtYXBwZWRUeXBlID0gZ2V0V2dzbE1hcHBlZFR5cGUodHlwZSwgY29tcG9uZW50cyk7XHJcbiAgcmV0dXJuIHR5cGVvZiBtYXBwZWRUeXBlID09PSAnc3RyaW5nJyA/IG1hcHBlZFR5cGUgOiBtYXBwZWRUeXBlWzFdO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzID0gKC4uLmRpbXM6IFJlYWRvbmx5QXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+KTogUHJvZ3JhbVVuaWZvcm1bXSA9PiB7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XHJcbiAgZGltcy5mb3JFYWNoKChkaW0pID0+IHtcclxuICAgIGlmIChkaW0ubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkaW0gfSxcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGRpbSkgfSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcHJvZ3JhbVVuaWZvcm1zO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdldCBtYXhpbXVtIHZlY3RvciBzaXplIGZvciBzcGVjaWZpZWQgZGF0YSBsZW5ndGhcclxuICogQHBhcmFtIHNpemVcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRNYXhDb21wb25lbnRzID0gKHNpemU6IG51bWJlcikgPT4ge1xyXG4gIC8vIHdlIGNhbm5vdCB1c2UgdmVjMyB0eXBlIHNpbmNlIGl0IGhhcyBhbGlnbm1lbnQgb2YgMTYgYnl0ZXNcclxuICBpZiAoc2l6ZSAlIDQgPT09IDApIHtcclxuICAgIHJldHVybiA0O1xyXG4gIH0gZWxzZSBpZiAoc2l6ZSAlIDIgPT09IDApIHtcclxuICAgIHJldHVybiAyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB2YXJpYWJsZSBhcyBhIHNjYWxhciBvciB2ZWN0b3IuIGUuZy4gZjMyKDApIG9yIHZlYzRmKDAsMCwwLDApXHJcbiAqIEBwYXJhbSBkYXRhVHlwZVxyXG4gKiBAcGFyYW0gY29tcG9uZW50c1xyXG4gKiBAcGFyYW0gdmFsdWVcclxuICovXHJcbmV4cG9ydCBjb25zdCBmaWxsVmVjdG9yID0gKGRhdGFUeXBlID0gJ2YzMicsIGNvbXBvbmVudHM/OiBudW1iZXIsIHZhbHVlID0gJzAnKSA9PiB7XHJcbiAgaWYgKCFjb21wb25lbnRzIHx8IGNvbXBvbmVudHMgPT09IDEpIHtcclxuICAgIHJldHVybiBgJHtkYXRhVHlwZX0oJHt2YWx1ZX0pYDtcclxuICB9XHJcblxyXG4gIHJldHVybiBgdmVjJHtjb21wb25lbnRzfTwke2RhdGFUeXBlfT4oJHt2YWx1ZX0pYDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNhc3RzIHZhbHVlIG9yIHZlY3RvciB0byBmMzJcclxuICogQHBhcmFtIGRhdGFUeXBlXHJcbiAqIEBwYXJhbSBjb21wb25lbnRzXHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNhc3RUb0YzMiA9IChkYXRhVHlwZTogc3RyaW5nLCBjb21wb25lbnRzOiBudW1iZXIsIHZhbHVlOiBzdHJpbmcpID0+IHtcclxuICBpZiAoZGF0YVR5cGUgPT09ICdmMzInKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIGlmIChjb21wb25lbnRzID09PSAxKSB7XHJcbiAgICByZXR1cm4gYGYzMigke3ZhbHVlfSlgO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGB2ZWMke2NvbXBvbmVudHN9PGYzMj4oJHt2YWx1ZX0pYDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgc2NhbGFyIG9yIHN1bXMgYWxsIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3JcclxuICogQHBhcmFtIG5hbWVcclxuICogQHBhcmFtIGNvbXBvbmVudHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBzdW1WZWN0b3IgPSAobmFtZTogc3RyaW5nLCBjb21wb25lbnRzOiBudW1iZXIpID0+IHtcclxuICBpZiAoY29tcG9uZW50cyA9PT0gNCkge1xyXG4gICAgcmV0dXJuIGAoJHtuYW1lfS54ICsgJHtuYW1lfS55ICsgJHtuYW1lfS56ICsgJHtuYW1lfS53KWA7XHJcbiAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAyKSB7XHJcbiAgICByZXR1cm4gYCgke25hbWV9LnggKyAke25hbWV9LnkpYDtcclxuICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDMpIHtcclxuICAgIHJldHVybiBgKCR7bmFtZX0ueCArICR7bmFtZX0ueSArICR7bmFtZX0ueilgO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5hbWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHZhcmlhYmxlIGVsZW1lbnQgYXQgaW5kZXguXHJcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdmFyaWFibGUuXHJcbiAqIEBwYXJhbSBpbmRleCAtIHRoZSBpbmRleCBvZiB2YXJpYWJsZSBlbGVtZW50LlxyXG4gKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB2YXJpYWJsZS5cclxuICogQHBhcmFtIHR5cGUgLSB0aGUgdHlwZSBvZiB2YXJpYWJsZSwgb3B0aW9uYWwuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RWxlbWVudEF0ID0gKFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICBpbmRleDogbnVtYmVyIHwgc3RyaW5nLFxyXG4gIGxlbmd0aDogbnVtYmVyLFxyXG4gIHR5cGU/OiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLFxyXG4pOiBzdHJpbmcgPT4ge1xyXG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VuaWZvcm1zLicpICYmIGxlbmd0aCA+IDQpIHtcclxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xyXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVsoJHtpbmRleH0pIC8gOF1bKCR7aW5kZXh9KSAlIDggLyA0XVsoJHtpbmRleH0pICUgOCAlIDRdYDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYCR7bmFtZX1bKCR7aW5kZXh9KSAvIDRdWygke2luZGV4fSkgJSA0XWA7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xyXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske01hdGguZmxvb3IoaW5kZXggLyA4KX1dWyR7TWF0aC5mbG9vcigoaW5kZXggJSA4KSAvIDQpfV1bJHsoaW5kZXggJSA4KSAlIDR9XWA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7TWF0aC5mbG9vcihpbmRleCAvIDQpfV1bJHtpbmRleCAlIDR9XWA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGxlbmd0aCA+IDEgPyBgJHtuYW1lfVske2luZGV4fV1gIDogbmFtZTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgSW5kaWNlc0hlbHBlciBmb3IgYSBnaXZlbiBpbnB1dCBvciBvdXRwdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cclxuICogQHBhcmFtIHRlbnNvclR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cclxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxyXG4gKiBAcGFyYW0gdXNhZ2UgLSB0aGUgdXNhZ2Ugb2YgdGhlIGluZGljZXMgaGVscGVyLlxyXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgZWFjaCBlbGVtZW50LiAxIGZvciBzY2FsYXIsIDIgZm9yIHZlYzIsIDMgZm9yIHZlYzMsIDQgZm9yXHJcbiAqICAgIHZlYzQuXHJcbiAqL1xyXG5jb25zdCBjcmVhdGVJbmRpY2VzSGVscGVyID0gKFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICB0ZW5zb3JUeXBlOiBudW1iZXIsXHJcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHVzYWdlOiBJbmRpY2VzSGVscGVyWyd1c2FnZSddLFxyXG4gIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQsXHJcbik6IEluZGljZXNIZWxwZXIgPT4ge1xyXG4gIGNvbnN0IHVzZVVuaWZvcm0gPSB0eXBlb2Ygc2hhcGVPclJhbmsgPT09ICdudW1iZXInO1xyXG4gIGNvbnN0IHJhbmsgPSB1c2VVbmlmb3JtID8gc2hhcGVPclJhbmsgOiBzaGFwZU9yUmFuay5sZW5ndGg7XHJcbiAgY29uc3QgcmFua0lkZW50aXR5ID0gWy4uLm5ldyBBcnJheShyYW5rKS5rZXlzKCldO1xyXG4gIGNvbnN0IGluZGljZXNUeXBlID0gcmFuayA8IDIgPyAndTMyJyA6IHJhbmsgPD0gNCA/IGB2ZWMke3Jhbmt9PHUzMj5gIDogYGFycmF5PHUzMiwgJHtyYW5rfT5gO1xyXG4gIGNvbnN0IG1hcHBlZFR5cGUgPSBnZXRXZ3NsTWFwcGVkVHlwZSh0ZW5zb3JUeXBlLCBjb21wb25lbnRzKTtcclxuICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVsxXTtcclxuICBjb25zdCBzdG9yYWdlVHlwZSA9IHR5cGVvZiBtYXBwZWRUeXBlID09PSAnc3RyaW5nJyA/IG1hcHBlZFR5cGUgOiBtYXBwZWRUeXBlWzBdO1xyXG4gIGNvbnN0IHR5cGUgPSB7IGluZGljZXM6IGluZGljZXNUeXBlLCB2YWx1ZTogdmFsdWVUeXBlLCBzdG9yYWdlOiBzdG9yYWdlVHlwZSwgdGVuc29yOiB0ZW5zb3JUeXBlIH07XHJcblxyXG4gIGNvbnN0IG5vcm1hbGl6ZURpbSA9IChkaW06IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiAodHlwZW9mIGRpbSA9PT0gJ3N0cmluZycgPyBkaW0gOiBgJHtkaW19dWApO1xyXG5cclxuICBjb25zdCBpbXBsZW1lbnRhdGlvblVzZWQgPSB7XHJcbiAgICBvZmZzZXRUb0luZGljZXM6IGZhbHNlLFxyXG4gICAgaW5kaWNlc1RvT2Zmc2V0OiBmYWxzZSxcclxuICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiBmYWxzZSxcclxuICAgIHNldDogZmFsc2UsXHJcbiAgICBzZXRCeUluZGljZXM6IGZhbHNlLFxyXG4gICAgZ2V0OiBmYWxzZSxcclxuICAgIGdldEJ5SW5kaWNlczogZmFsc2UsXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdW5pZm9ybVByZWZpeCA9IHVzZVVuaWZvcm0gPyAndW5pZm9ybXMuJyA6ICcnO1xyXG4gIGNvbnN0IHNoYXBlID0gYCR7dW5pZm9ybVByZWZpeH0ke25hbWV9X3NoYXBlYDtcclxuICBjb25zdCBzdHJpZGVzID0gYCR7dW5pZm9ybVByZWZpeH0ke25hbWV9X3N0cmlkZXNgO1xyXG5cclxuICBsZXQgbzJpU25pcHBldCA9ICcnO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7IGkrKykge1xyXG4gICAgbzJpU25pcHBldCArPSBgXHJcbiAgICBsZXQgZGltJHtpfSA9IGN1cnJlbnQgLyAke2dldEVsZW1lbnRBdChzdHJpZGVzLCBpLCByYW5rKX07XHJcbiAgICBsZXQgcmVzdCR7aX0gPSBjdXJyZW50ICUgJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9O1xyXG4gICAgaW5kaWNlc1ske2l9XSA9IGRpbSR7aX07XHJcbiAgICBjdXJyZW50ID0gcmVzdCR7aX07XHJcbiAgICBgO1xyXG4gIH1cclxuICBvMmlTbmlwcGV0ICs9IGBpbmRpY2VzWyR7cmFuayAtIDF9XSA9IGN1cnJlbnQ7YDtcclxuXHJcbiAgY29uc3Qgb2Zmc2V0VG9JbmRpY2VzSW1wbGVtZW50YXRpb24gPVxyXG4gICAgcmFuayA8IDJcclxuICAgICAgPyAnJ1xyXG4gICAgICA6IGBcclxuICBmbiBvMmlfJHtuYW1lfShvZmZzZXQ6IHUzMikgLT4gJHt0eXBlLmluZGljZXN9IHtcclxuICAgIHZhciBpbmRpY2VzOiAke3R5cGUuaW5kaWNlc307XHJcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcclxuICAgICR7bzJpU25pcHBldH1cclxuICAgIHJldHVybiBpbmRpY2VzO1xyXG4gIH1gO1xyXG5cclxuICBjb25zdCBvZmZzZXRUb0luZGljZXMgPSAodmFyT2Zmc2V0OiBzdHJpbmcpID0+IHtcclxuICAgIGltcGxlbWVudGF0aW9uVXNlZC5vZmZzZXRUb0luZGljZXMgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJhbmsgPCAyID8gdmFyT2Zmc2V0IDogYG8yaV8ke25hbWV9KCR7dmFyT2Zmc2V0fSlgO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IG9mZnNldHM6IHN0cmluZ1tdID0gW107XHJcbiAgaWYgKHJhbmsgPj0gMikge1xyXG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBvZmZzZXRzLnB1c2goYCR7Z2V0RWxlbWVudEF0KHN0cmlkZXMsIGksIHJhbmspfSAqIChpbmRpY2VzWyR7aX1dKWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24gPVxyXG4gICAgcmFuayA8IDJcclxuICAgICAgPyAnJ1xyXG4gICAgICA6IGBcclxuICBmbiBpMm9fJHtuYW1lfShpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30pIC0+IHUzMiB7XHJcbiAgICByZXR1cm4gJHtvZmZzZXRzLmpvaW4oJysnKX07XHJcbiAgfWA7XHJcblxyXG4gIGNvbnN0IGluZGljZXNUb09mZnNldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHtcclxuICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJhbmsgPCAyID8gdmFySW5kaWNlcyA6IGBpMm9fJHtuYW1lfSgke3ZhckluZGljZXN9KWA7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaW5kaWNlcyA9ICguLi5pbml0OiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz4pID0+XHJcbiAgICByYW5rID09PSAwID8gJzB1JyA6IGAke3R5cGUuaW5kaWNlc30oJHtpbml0Lm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKX0pYDtcclxuXHJcbiAgY29uc3QgaW5kaWNlc0dldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyIHwgc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAocmFuayA8IDIpIHtcclxuICAgICAgcmV0dXJuIGAke3ZhckluZGljZXN9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBgJHtnZXRFbGVtZW50QXQodmFySW5kaWNlcywgaWR4LCByYW5rKX1gO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGluZGljZXNTZXQgPSAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlciB8IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKHJhbmsgPCAyKSB7XHJcbiAgICAgIHJldHVybiBgJHt2YXJJbmRpY2VzfT0ke3ZhbHVlfTtgO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGAke2dldEVsZW1lbnRBdCh2YXJJbmRpY2VzLCBpZHgsIHJhbmspfT0ke3ZhbHVlfTtgO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb246IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcclxuICBjb25zdCBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xyXG4gICAgaW1wbGVtZW50YXRpb25Vc2VkLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcclxuICAgIGNvbnN0IGltcGxLZXkgPSBgJHtvdXRwdXQubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7bmFtZX1PZmZzZXRgO1xyXG4gICAgaWYgKGltcGxLZXkgaW4gYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbikge1xyXG4gICAgICByZXR1cm4gYCR7aW1wbEtleX0oJHt2YXJJbmRpY2VzfSlgO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2Zmc2V0cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBjb25zdCBpZHggPSBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIGkgKyBvdXRwdXQucmFuayAtIHJhbmspO1xyXG4gICAgICBvZmZzZXRzLnB1c2goYCR7aW5kaWNlc0dldChzdHJpZGVzLCBpKX0gKiAoJHtpZHh9ICUgJHtpbmRpY2VzR2V0KHNoYXBlLCBpKX0pYCk7XHJcbiAgICB9XHJcbiAgICBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uW2ltcGxLZXldID0gYGZuICR7aW1wbEtleX0ob3V0cHV0SW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcclxuICAgICAgICAgICAgIHJldHVybiAke29mZnNldHMubGVuZ3RoID4gMCA/IG9mZnNldHMuam9pbignKycpIDogJzB1J307XHJcbiAgICAgICAgICAgfWA7XHJcblxyXG4gICAgcmV0dXJuIGAke2ltcGxLZXl9KCR7dmFySW5kaWNlc30pYDtcclxuICB9O1xyXG5cclxuICBjb25zdCBzZXRCeU9mZnNldCA9IChvZmZzZXQ6IG51bWJlciB8IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT5cclxuICAgICgoKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlLnN0b3JhZ2UgPT09IHR5cGUudmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT0ke3ZhbHVlfTtgO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ2kzMicpIHtcclxuICAgICAgICAvLyBpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxyXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPXZlYzI8dTMyPih1MzIoJHt2YWx1ZX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke3ZhbHVlfSA8IDApKTtgO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ3UzMicpIHtcclxuICAgICAgICAvLyB1aW50NjQsIGNvbXBvbmVudHMgPT09IDFcclxuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT12ZWMyPHUzMj4odTMyKCR7dmFsdWV9KSwgMHUpO2A7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndTMyJyAmJiB0eXBlLnZhbHVlID09PSAndmVjNDxib29sPicpIHtcclxuICAgICAgICAvLyBib29sLCBjb21wb25lbnRzID09PSA0XHJcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHt2YWx1ZX0pKTtgO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHt0eXBlLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7dHlwZS52YWx1ZX0geWV0YCk7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG4gIGNvbnN0IGdldEJ5T2Zmc2V0ID0gKG9mZnNldDogbnVtYmVyIHwgc3RyaW5nKSA9PlxyXG4gICAgKCgpID0+IHtcclxuICAgICAgaWYgKHR5cGUuc3RvcmFnZSA9PT0gdHlwZS52YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dYDtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICdpMzInKSB7XHJcbiAgICAgICAgLy8gaW50NjQsIGNvbXBvbmVudHMgPT09IDFcclxuICAgICAgICByZXR1cm4gYGkzMigke25hbWV9WyR7b2Zmc2V0fV0ueClgO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ3UzMicpIHtcclxuICAgICAgICAvLyB1aW50NjQsIGNvbXBvbmVudHMgPT09IDFcclxuICAgICAgICByZXR1cm4gYHUzMigke25hbWV9WyR7b2Zmc2V0fV0ueClgO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3UzMicgJiYgdHlwZS52YWx1ZSA9PT0gJ3ZlYzQ8Ym9vbD4nKSB7XHJcbiAgICAgICAgLy8gYm9vbCwgY29tcG9uZW50cyA9PT0gNFxyXG4gICAgICAgIHJldHVybiBgdmVjNDxib29sPihib29sKCR7bmFtZX1bJHtvZmZzZXR9XSAmIDB4RkZ1KSwgYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGMDB1KSwgYm9vbCgke25hbWV9WyR7XHJcbiAgICAgICAgICBvZmZzZXRcclxuICAgICAgICB9XSAmIDB4RkYwMDAwdSksIGJvb2woJHtuYW1lfVske29mZnNldH1dICYgMHhGRjAwMDAwMHUpKWA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3R5cGUuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHt0eXBlLnZhbHVlfSB5ZXRgKTtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcbiAgY29uc3QgZ2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24gPVxyXG4gICAgcmFuayA8IDJcclxuICAgICAgPyAnJ1xyXG4gICAgICA6IGBcclxuICBmbiBnZXRfJHtuYW1lfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30pIC0+ICR7dmFsdWVUeXBlfSB7XHJcbiAgICByZXR1cm4gJHtnZXRCeU9mZnNldChgaTJvXyR7bmFtZX0oaW5kaWNlcylgKX07XHJcbiAgfWA7XHJcblxyXG4gIGNvbnN0IGdldEltcGxlbWVudGF0aW9uID1cclxuICAgIHJhbmsgPCAyXHJcbiAgICAgID8gJydcclxuICAgICAgOiAoKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25QYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKChpKSA9PiBgZCR7aX06IHUzMmApLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICBjb25zdCBkaW1zUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcCgoaSkgPT4gYGQke2l9YCkuam9pbignLCAnKTtcclxuICAgICAgICAgIHJldHVybiBgXHJcbiAgZm4gZ2V0XyR7bmFtZX0oJHtmdW5jdGlvblBhcmFtc30pIC0+ICR7dmFsdWVUeXBlfSB7XHJcbiAgICByZXR1cm4gZ2V0XyR7bmFtZX1CeUluZGljZXMoJHtpbmRpY2VzKGRpbXNQYXJhbXMpfSk7XHJcbiAgfWA7XHJcbiAgICAgICAgfSkoKTtcclxuXHJcbiAgY29uc3QgZ2V0ID0gKC4uLmluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4ge1xyXG4gICAgaWYgKGluZGljZXMubGVuZ3RoICE9PSByYW5rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3Jhbmt9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgbm9ybWFsaXplZEluZGljZXMgPSBpbmRpY2VzLm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKTtcclxuXHJcbiAgICBpZiAocmFuayA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gZ2V0QnlPZmZzZXQoJzB1Jyk7XHJcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIGdldEJ5T2Zmc2V0KG5vcm1hbGl6ZWRJbmRpY2VzWzBdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5nZXQgPSB0cnVlO1xyXG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuZ2V0QnlJbmRpY2VzID0gdHJ1ZTtcclxuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XHJcbiAgICAgIHJldHVybiBgZ2V0XyR7bmFtZX0oJHtub3JtYWxpemVkSW5kaWNlc30pYDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBnZXRCeUluZGljZXMgPSAodmFySW5kaWNlczogc3RyaW5nKSA9PiB7XHJcbiAgICBpZiAocmFuayA8IDIpIHtcclxuICAgICAgcmV0dXJuIGdldEJ5T2Zmc2V0KHZhckluZGljZXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmdldEJ5SW5kaWNlcyA9IHRydWU7XHJcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gYGdldF8ke25hbWV9QnlJbmRpY2VzKCR7dmFySW5kaWNlc30pYDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBzZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbiA9XHJcbiAgICByYW5rIDwgMlxyXG4gICAgICA/ICcnXHJcbiAgICAgIDogYFxyXG4gIGZuIHNldF8ke25hbWV9QnlJbmRpY2VzKGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfSwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xyXG4gICAgJHtzZXRCeU9mZnNldChgaTJvXyR7bmFtZX0oaW5kaWNlcylgLCAndmFsdWUnKX1cclxuICB9YDtcclxuXHJcbiAgY29uc3Qgc2V0SW1wbGVtZW50YXRpb24gPVxyXG4gICAgcmFuayA8IDJcclxuICAgICAgPyAnJ1xyXG4gICAgICA6ICgoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBmdW5jdGlvblBhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoKGkpID0+IGBkJHtpfTogdTMyYCkuam9pbignLCAnKTtcclxuICAgICAgICAgIGNvbnN0IGRpbXNQYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKChpKSA9PiBgZCR7aX1gKS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgcmV0dXJuIGBcclxuICBmbiBzZXRfJHtuYW1lfSgke2Z1bmN0aW9uUGFyYW1zfSwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xyXG4gICAgc2V0XyR7bmFtZX1CeUluZGljZXMoJHtpbmRpY2VzKGRpbXNQYXJhbXMpfSwgdmFsdWUpO1xyXG4gIH1gO1xyXG4gICAgICAgIH0pKCk7XHJcblxyXG4gIGNvbnN0IHNldCA9ICguLi5pbmRpY2VzQW5kVmFsdWU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4ge1xyXG4gICAgaWYgKGluZGljZXNBbmRWYWx1ZS5sZW5ndGggIT09IHJhbmsgKyAxKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3Jhbmt9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWx1ZSA9IGluZGljZXNBbmRWYWx1ZVtyYW5rXTtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBzdHJpbmcnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBub3JtYWxpemVkSW5kaWNlcyA9IGluZGljZXNBbmRWYWx1ZS5zbGljZSgwLCByYW5rKS5tYXAobm9ybWFsaXplRGltKS5qb2luKCcsJyk7XHJcblxyXG4gICAgaWYgKHJhbmsgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHNldEJ5T2Zmc2V0KCcwdScsIHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gc2V0QnlPZmZzZXQobm9ybWFsaXplZEluZGljZXNbMF0sIHZhbHVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXQgPSB0cnVlO1xyXG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzID0gdHJ1ZTtcclxuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XHJcbiAgICAgIHJldHVybiBgc2V0XyR7bmFtZX0oJHtub3JtYWxpemVkSW5kaWNlc30sICR7dmFsdWV9KWA7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc2V0QnlJbmRpY2VzID0gKHZhckluZGljZXM6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xyXG4gICAgaWYgKHJhbmsgPCAyKSB7XHJcbiAgICAgIHJldHVybiBzZXRCeU9mZnNldCh2YXJJbmRpY2VzLCB2YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzID0gdHJ1ZTtcclxuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XHJcbiAgICAgIHJldHVybiBgc2V0XyR7bmFtZX1CeUluZGljZXMoJHt2YXJJbmRpY2VzfSwgJHt2YWx1ZX0pO2A7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaW1wbCA9ICgpID0+IHtcclxuICAgIGNvbnN0IGltcGxzID0gW107XHJcbiAgICBsZXQgbmVlZFNoYXBlU3RyaWRlcyA9IGZhbHNlO1xyXG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5vZmZzZXRUb0luZGljZXMpIHtcclxuICAgICAgaW1wbHMucHVzaChvZmZzZXRUb0luZGljZXNJbXBsZW1lbnRhdGlvbik7XHJcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQpIHtcclxuICAgICAgaW1wbHMucHVzaChpbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbik7XHJcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCkge1xyXG4gICAgICBPYmplY3QudmFsdWVzKGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24pLmZvckVhY2goKGltcGwpID0+IGltcGxzLnB1c2goaW1wbCkpO1xyXG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuc2V0KSB7XHJcbiAgICAgIGltcGxzLnB1c2goc2V0SW1wbGVtZW50YXRpb24pO1xyXG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzKSB7XHJcbiAgICAgIGltcGxzLnB1c2goc2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24pO1xyXG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuZ2V0KSB7XHJcbiAgICAgIGltcGxzLnB1c2goZ2V0SW1wbGVtZW50YXRpb24pO1xyXG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuZ2V0QnlJbmRpY2VzKSB7XHJcbiAgICAgIGltcGxzLnB1c2goZ2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24pO1xyXG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICghdXNlVW5pZm9ybSAmJiBuZWVkU2hhcGVTdHJpZGVzKSB7XHJcbiAgICAgIGltcGxzLnVuc2hpZnQoXHJcbiAgICAgICAgYGNvbnN0ICR7c2hhcGV9ID0gJHt0eXBlLmluZGljZXN9KCR7c2hhcGVPclJhbmsuam9pbignLCcpfSk7YCxcclxuICAgICAgICBgY29uc3QgJHtzdHJpZGVzfSA9ICR7dHlwZS5pbmRpY2VzfSgke1NoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZU9yUmFuaykuam9pbignLCcpfSk7YCxcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbXBscy5qb2luKCdcXG4nKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaW1wbCxcclxuICAgIHR5cGUsXHJcbiAgICBvZmZzZXRUb0luZGljZXMsXHJcbiAgICBpbmRpY2VzVG9PZmZzZXQsXHJcbiAgICBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldCxcclxuICAgIGluZGljZXMsXHJcbiAgICBpbmRpY2VzR2V0LFxyXG4gICAgaW5kaWNlc1NldCxcclxuICAgIHNldCxcclxuICAgIHNldEJ5T2Zmc2V0LFxyXG4gICAgc2V0QnlJbmRpY2VzLFxyXG4gICAgZ2V0LFxyXG4gICAgZ2V0QnlPZmZzZXQsXHJcbiAgICBnZXRCeUluZGljZXMsXHJcbiAgICAvLyBpc1ZlYzQsXHJcbiAgICB1c2FnZSxcclxuICAgIG5hbWUsXHJcbiAgICBzdHJpZGVzLFxyXG4gICAgc2hhcGUsXHJcbiAgICByYW5rLFxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gaW5wdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGlucHV0LlxyXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgaW5wdXQuXHJcbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIGlucHV0LlxyXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgaW5wdXQuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cclxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIGlucHV0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlucHV0VmFyaWFibGUgPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIHR5cGU6IG51bWJlcixcclxuICBzaGFwZU9yUmFuazogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEsXHJcbik6IEluZGljZXNIZWxwZXIgPT4gY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ2lucHV0JywgY29tcG9uZW50cyk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gb3V0cHV0LlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvdXRwdXQuXHJcbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSBvdXRwdXQuXHJcbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIG91dHB1dC5cclxuICogQHBhcmFtIGNvbXBvbmVudHMgLSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgdGhlIG91dHB1dC4gYXZhaWxhYmxlIHZhbHVlcyBhcmUgMSwgMiwgMywgNC4gZGVmYXVsdCBpcyAxLlxyXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgb3V0cHV0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG91dHB1dFZhcmlhYmxlID0gKFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICB0eXBlOiBudW1iZXIsXHJcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQgPSAxLFxyXG4pOiBJbmRpY2VzSGVscGVyID0+IGNyZWF0ZUluZGljZXNIZWxwZXIobmFtZSwgdHlwZSwgc2hhcGVPclJhbmssICdvdXRwdXQnLCBjb21wb25lbnRzKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBhdG9taWMgb3V0cHV0LlxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvdXRwdXQuXHJcbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSBvdXRwdXQuXHJcbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIG91dHB1dC5cclxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIG91dHB1dC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBhdG9taWNPdXRwdXRWYXJpYWJsZSA9IChcclxuICBuYW1lOiBzdHJpbmcsXHJcbiAgdHlwZTogbnVtYmVyLFxyXG4gIHNoYXBlT3JSYW5rOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXSxcclxuKTogSW5kaWNlc0hlbHBlciA9PiBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnYXRvbWljT3V0cHV0JywgMSk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlLlxyXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgdmFyaWFibGUuXHJcbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIHZhcmlhYmxlLlxyXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgdmFyaWFibGUuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cclxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGludGVybmFsVmFyaWFibGUgPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIHR5cGU6IG51bWJlcixcclxuICBzaGFwZU9yUmFuazogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEsXHJcbik6IEluZGljZXNIZWxwZXIgPT4gY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ2ludGVybmFsJywgY29tcG9uZW50cyk7XHJcblxyXG5leHBvcnQgdHlwZSBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlID0gJ3UzMicgfCAnZjE2JyB8ICdmMzInIHwgJ2kzMic7XHJcbmV4cG9ydCB0eXBlIFVuaWZvcm1zQXJyYXlUeXBlID0gQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGU7IGxlbmd0aD86IG51bWJlciB9PjtcclxuXHJcbi8qKlxyXG4gKiBBIFNoYWRlckhlbHBlciBpcyBhIGhlbHBlciBjbGFzcyBmb3IgZ2VuZXJhdGluZyBXR1NMIGNvZGUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNoYWRlckhlbHBlciB7XHJcbiAgLyoqXHJcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIHN0YXJ0IG9mIG1haW4gZnVuY3Rpb24gaW4gV0dTTCBzb3VyY2UgY29kZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgICogIC4uLlxyXG4gICAqXHJcbiAgICogICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAqICAgIC8vIHlvdXIgY29kZSBoZXJlIGluc2lkZSBtYWluKCkgZnVuY3Rpb25cclxuICAgKiAgICAuLi5cclxuICAgKiAgfVxyXG4gICAqIGA7XHJcbiAgICpcclxuICAgKiBAcGFyYW0gd29ya2dyb3VwU2l6ZSAtIGFuIG9wdGlvbmFsIHdvcmtncm91cCBzaXplLiBkZWZhdWx0IGlzIFdPUktHUk9VUF9TSVpFLlxyXG4gICAqL1xyXG4gIG1haW5TdGFydCh3b3JrZ3JvdXBTaXplPzogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgY29kZSBzbmlwcGV0IGZvciBndWFyZGluZyBhZ2FpbnN0IG91dC1vZi1ib3VuZHMgc2l6ZS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgICogIC4uLlxyXG4gICAqXHJcbiAgICogICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAqICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9XHJcbiAgICpcclxuICAgKiAgICAvLyB5b3VyIGNvZGUgaGVyZSBpbnNpZGUgbWFpbigpIGZ1bmN0aW9uXHJcbiAgICogICAgLi4uXHJcbiAgICogIH1cclxuICAgKiBgO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHNpemUgLSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSB0byBndWFyZCBhZ2FpbnN0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXHJcbiAgICovXHJcbiAgZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzaXplOiB1bmtub3duKTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgY29kZSBzbmlwcGV0IGZvciBkZWNsYXJpbmcgbXVsdGlwbGUgaW5wdXRzIG9yIG91dHB1dHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdmFyaWFibGVzIC0gYW4gYXJyYXkgb2YgSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlcy5cclxuICAgKi9cclxuICBkZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdKTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlciBvbmUgdW5pZm9ybS4gQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBtdWx0aXBsZSB1bmlmb3Jtcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgdHlwZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB0aGUgdW5pZm9ybSwgZGVmYXVsdCB0byAxIHdoZW4gaXQgaXMgbm90IHByb3ZpZGVkLlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyVW5pZm9ybShuYW1lOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgbGVuZ3RoPzogbnVtYmVyKTogU2hhZGVySGVscGVyO1xyXG5cclxuICAvKipcclxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlciBtdWx0aXBsZSB1bmlmb3Jtcy4gQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBtdWx0aXBsZSB1bmlmb3Jtcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB1bmlmb3JtcyAtIGFuIGFycmF5IG9mIHVuaWZvcm1zLiBFYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIGFuIG9iamVjdCB3aXRoIDIgcHJvcGVydGllczogYG5hbWVgIGFuZFxyXG4gICAqICAgICBgdHlwZWAuXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUpOiBTaGFkZXJIZWxwZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG11bHRpcGxlIGludGVybmFsIHZhcmlhYmxlcy4gQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBtdWx0aXBsZVxyXG4gICAqIGludGVybmFsIHZhcmlhYmxlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YXJpYWJsZXMgLSBhbiBhcnJheSBvZiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGVzLlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBTaGFkZXJIZWxwZXI7XHJcbn1cclxuXHJcbmNsYXNzIFNoYWRlckhlbHBlckltcGwgaW1wbGVtZW50cyBTaGFkZXJIZWxwZXIge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBub3JtYWxpemVkRGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gICAgcHJpdmF0ZSBsaW1pdHM6IEdQVVN1cHBvcnRlZExpbWl0cyxcclxuICApIHt9XHJcblxyXG4gIGd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoc2l6ZTogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIC8vIEd1YXJkIGFnYWluc3Qgb3V0LW9mLWJvdW5kcyB3b3JrIGdyb3VwIHNpemVzXHJcbiAgICBjb25zdCBzaXplSW5Db2RlID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gYCR7c2l6ZX11YCA6IHNpemU7XHJcbiAgICByZXR1cm4gYGlmIChnbG9iYWxfaWR4ID49ICR7c2l6ZUluQ29kZX0pIHsgcmV0dXJuOyB9YDtcclxuICB9XHJcblxyXG4gIG1haW5TdGFydCh3b3JrZ3JvdXBTaXplOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBXT1JLR1JPVVBfU0laRSkge1xyXG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVggPSB0eXBlb2Ygd29ya2dyb3VwU2l6ZSA9PT0gJ251bWJlcicgPyB3b3JrZ3JvdXBTaXplIDogd29ya2dyb3VwU2l6ZVswXTtcclxuICAgIGNvbnN0IHdvcmtncm91cFNpemVZID0gdHlwZW9mIHdvcmtncm91cFNpemUgPT09ICdudW1iZXInID8gMSA6IHdvcmtncm91cFNpemVbMV07XHJcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplWiA9IHR5cGVvZiB3b3JrZ3JvdXBTaXplID09PSAnbnVtYmVyJyA/IDEgOiB3b3JrZ3JvdXBTaXplWzJdO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgd29ya2dyb3VwU2l6ZVggPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVggfHxcclxuICAgICAgd29ya2dyb3VwU2l6ZVkgPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVkgfHxcclxuICAgICAgd29ya2dyb3VwU2l6ZVogPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVpcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYHdvcmtncm91cCBzaXplIFske3dvcmtncm91cFNpemVYfSwgJHt3b3JrZ3JvdXBTaXplWX0sICR7XHJcbiAgICAgICAgICB3b3JrZ3JvdXBTaXplWlxyXG4gICAgICAgIH1dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIHNpemUgWyR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfSwgJHtcclxuICAgICAgICAgIHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWVxyXG4gICAgICAgIH0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafV0uYCxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod29ya2dyb3VwU2l6ZVggKiB3b3JrZ3JvdXBTaXplWSAqIHdvcmtncm91cFNpemVaID4gdGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgd29ya2dyb3VwIHNpemUgWyR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHtcclxuICAgICAgICAgIHdvcmtncm91cFNpemVaXHJcbiAgICAgICAgfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgaW52b2NhdGlvbnMgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXB9LmAsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSB0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdID09PSAxICYmIHRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl0gPT09IDE7XHJcbiAgICBjb25zdCBwYXJhbUxpc3QgPSBpczFEaW1lbnNpb25EaXNwYXRjaFxyXG4gICAgICA/IGBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxyXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXHJcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXHJcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmBcclxuICAgICAgOiBgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXHJcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXHJcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcclxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmA7XHJcbiAgICBjb25zdCBnbG9iYWxJZHhEZWZpbml0aW9uID0gaXMxRGltZW5zaW9uRGlzcGF0Y2hcclxuICAgICAgPyBgbGV0IGdsb2JhbF9pZHggPSBnbG9iYWxfaWQueDtcclxuICAgICAgICAgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC54O2BcclxuICAgICAgOiBgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXHJcbiAgICAgICAgICAgICB3b3JrZ3JvdXBfaWQueSAqIG51bV93b3JrZ3JvdXBzWzBdICsgd29ya2dyb3VwX2lkLng7XHJcbiAgICAgICAgIGxldCBnbG9iYWxfaWR4ID0gd29ya2dyb3VwX2luZGV4ICogJHt3b3JrZ3JvdXBTaXplWCAqIHdvcmtncm91cFNpemVZICogd29ya2dyb3VwU2l6ZVp9dSArIGxvY2FsX2lkeDtgO1xyXG5cclxuICAgIHJldHVybiBgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHt3b3JrZ3JvdXBTaXplWn0pXHJcbiAgZm4gbWFpbigke3BhcmFtTGlzdH0pIHtcclxuICAgICR7Z2xvYmFsSWR4RGVmaW5pdGlvbn1cclxuICBgO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHZhcmlhYmxlOiBJbmRpY2VzSGVscGVyKTogdm9pZCB7XHJcbiAgICBpZiAodmFyaWFibGUucmFuayAhPT0gMCkge1xyXG4gICAgICBpZiAodmFyaWFibGUuc2hhcGUuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykpIHtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLnB1c2goeyBuYW1lOiB2YXJpYWJsZS5zaGFwZS5yZXBsYWNlKCd1bmlmb3Jtcy4nLCAnJyksIHR5cGU6ICd1MzInLCBsZW5ndGg6IHZhcmlhYmxlLnJhbmsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhcmlhYmxlLnN0cmlkZXMuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykpIHtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLnB1c2goeyBuYW1lOiB2YXJpYWJsZS5zdHJpZGVzLnJlcGxhY2UoJ3VuaWZvcm1zLicsICcnKSwgdHlwZTogJ3UzMicsIGxlbmd0aDogdmFyaWFibGUucmFuayB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkZWNsYXJlVmFyaWFibGUodmFyaWFibGU6IEluZGljZXNIZWxwZXIsIGJpbmRpbmdJbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGlmICh2YXJpYWJsZS51c2FnZSA9PT0gJ2ludGVybmFsJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB1c2UgaW50ZXJuYWwgdmFyaWFibGUgd2l0aCBkZWNsYXJlVmFyaWFibGUoKS4gdXNlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy52YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XHJcbiAgICB0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGUpO1xyXG4gICAgY29uc3QgYWNjZXNzID0gdmFyaWFibGUudXNhZ2UgPT09ICdpbnB1dCcgPyAncmVhZCcgOiAncmVhZF93cml0ZSc7XHJcbiAgICBjb25zdCBzdG9yYWdlVHlwZSA9IHZhcmlhYmxlLnVzYWdlID09PSAnYXRvbWljT3V0cHV0JyA/IGBhdG9taWM8aTMyPmAgOiB2YXJpYWJsZS50eXBlLnN0b3JhZ2U7XHJcbiAgICByZXR1cm4gYEBncm91cCgwKSBAYmluZGluZygke2JpbmRpbmdJbmRleH0pIHZhcjxzdG9yYWdlLCAke2FjY2Vzc30+ICR7dmFyaWFibGUubmFtZX06IGFycmF5PCR7c3RvcmFnZVR5cGV9PjtgO1xyXG4gIH1cclxuXHJcbiAgZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdmFyaWFibGVzLm1hcCgodikgPT4gdGhpcy5kZWNsYXJlVmFyaWFibGUodiwgdGhpcy52YXJpYWJsZUluZGV4KyspKS5qb2luKCdcXG4nKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHZhcmlhYmxlOiBJbmRpY2VzSGVscGVyKTogdm9pZCB7XHJcbiAgICBpZiAodmFyaWFibGUudXNhZ2UgIT09ICdpbnRlcm5hbCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICdjYW5ub3QgdXNlIGlucHV0IG9yIG91dHB1dCB2YXJpYWJsZSB3aXRoIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSgpLiB1c2UgZGVjbGFyZVZhcmlhYmxlcygpIGluc3RlYWQuJyxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmludGVybmFsVmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xyXG4gICAgdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHZhcmlhYmxlKTtcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBTaGFkZXJIZWxwZXIge1xyXG4gICAgdmFyaWFibGVzLmZvckVhY2goKHYpID0+IHRoaXMucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHYpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgcmVnaXN0ZXJVbmlmb3JtKG5hbWU6IHN0cmluZywgdHlwZTogVW5pZm9ybURhdGFFbGVtZW50VHlwZSwgbGVuZ3RoID0gMSk6IFNoYWRlckhlbHBlciB7XHJcbiAgICB0aGlzLnVuaWZvcm1zLnB1c2goeyBuYW1lLCB0eXBlLCBsZW5ndGggfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyVW5pZm9ybXMoYWRkaXRpb25hbFVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSk6IFNoYWRlckhlbHBlciB7XHJcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy51bmlmb3Jtcy5jb25jYXQoYWRkaXRpb25hbFVuaWZvcm1zKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbnRlcm5hbFZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdID0gW107XHJcbiAgcHJpdmF0ZSB2YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSA9IFtdO1xyXG4gIHByaXZhdGUgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW107XHJcbiAgcHJpdmF0ZSB1bmlmb3JtRGVjbGFyYXRpb24oKTogc3RyaW5nIHtcclxuICAgIGlmICh0aGlzLnVuaWZvcm1zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdW5pZm9ybVNuaXBwZXRzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgZm9yIChjb25zdCB7IG5hbWUsIHR5cGUsIGxlbmd0aCB9IG9mIHRoaXMudW5pZm9ybXMpIHtcclxuICAgICAgaWYgKGxlbmd0aCAmJiBsZW5ndGggPiA0KSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdmMTYnKSB7XHJcbiAgICAgICAgICB1bmlmb3JtU25pcHBldHMucHVzaChgQGFsaWduKDE2KSAke25hbWV9OmFycmF5PG1hdDJ4NDwke3R5cGV9PiwgJHtNYXRoLmNlaWwobGVuZ3RoIC8gOCl9PmApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB1bmlmb3JtU25pcHBldHMucHVzaChgJHtuYW1lfTphcnJheTx2ZWM0PCR7dHlwZX0+LCAke01hdGguY2VpbChsZW5ndGggLyA0KX0+YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHR5cGVUZW1wID0gbGVuZ3RoID09IG51bGwgfHwgbGVuZ3RoID09PSAxID8gdHlwZSA6IGB2ZWMke2xlbmd0aH08JHt0eXBlfT5gO1xyXG4gICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGAke25hbWV9OiR7dHlwZVRlbXB9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYFxyXG4gICAgICBzdHJ1Y3QgVW5pZm9ybXMgeyAke3VuaWZvcm1TbmlwcGV0cy5qb2luKCcsICcpfSB9O1xyXG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2A7XHJcbiAgfVxyXG4gIHByaXZhdGUgdmFyaWFibGVJbmRleCA9IDA7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhZGRpdGlvbmFsIGltcGxlbWVudGF0aW9uIHRoYXQgbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIHNoYWRlciBzb3VyY2UuXHJcbiAgICovXHJcbiAgZ2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkgK1xyXG4gICAgICB0aGlzLnZhcmlhYmxlcy5tYXAoKGkpID0+IGkuaW1wbCgpKS5qb2luKCdcXG4nKSArXHJcbiAgICAgIHRoaXMuaW50ZXJuYWxWYXJpYWJsZXMubWFwKChpKSA9PiBpLmltcGwoKSkuam9pbignXFxuJylcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHZhcmlhYmxlIGluZm8gb2YgdGhlIHNoYWRlciBwcm9ncmFtLlxyXG4gICAqL1xyXG4gIGdldCB2YXJpYWJsZXNJbmZvKCk6IFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvW10gfCB1bmRlZmluZWQge1xyXG4gICAgaWYgKHRoaXMudW5pZm9ybXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdW5pZm9ybVdnc2xUeXBlVG9EYXRhVHlwZSA9ICh0eXBlOiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlKSA9PlxyXG4gICAgICBbRGF0YVR5cGUudWludDMyLCBEYXRhVHlwZS5mbG9hdDE2LCBEYXRhVHlwZS5mbG9hdCwgRGF0YVR5cGUuaW50MzJdW1sndTMyJywgJ2YxNicsICdmMzInLCAnaTMyJ10uaW5kZXhPZih0eXBlKV07XHJcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXAoKHUpID0+IFt1bmlmb3JtV2dzbFR5cGVUb0RhdGFUeXBlKHUudHlwZSksIHUubGVuZ3RoID8/IDFdKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVTaGFkZXJIZWxwZXIgPSAoZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBsaW1pdHM6IEdQVVN1cHBvcnRlZExpbWl0cykgPT5cclxuICBuZXcgU2hhZGVySGVscGVySW1wbChkaXNwYXRjaEdyb3VwLCBsaW1pdHMpO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgcGVybTogbnVtYmVyW107XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBwZXJtOiByZWFkb25seSBudW1iZXJbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAocGVybS5sZW5ndGggIT09IDAgJiYgcGVybS5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBwZXJtIHNpemUgJHtwZXJtLmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggaW5wdXQgcmFuayAke2lucHV0c1swXS5kaW1zLmxlbmd0aH1gKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBnZXRBZGp1c3RlZFBlcm0gPSAoaW5wdXRSYW5rOiBudW1iZXIsIHBlcm06IG51bWJlcltdKTogbnVtYmVyW10gPT5cclxuICBwZXJtLmxlbmd0aCAhPT0gMCA/IHBlcm0gOiBbLi4ubmV3IEFycmF5KGlucHV0UmFuaykua2V5cygpXS5yZXZlcnNlKCk7XHJcblxyXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGVybTogbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PlxyXG4gIFNoYXBlVXRpbC5zb3J0QmFzZWRPblBlcm0oaW5wdXRTaGFwZSwgZ2V0QWRqdXN0ZWRQZXJtKGlucHV0U2hhcGUubGVuZ3RoLCBwZXJtKSk7XHJcblxyXG5jb25zdCBwZXJtRnVuY3Rpb25Cb2R5ID0gKHBlcm06IG51bWJlcltdLCByYW5rOiBudW1iZXIsIGlucHV0OiBJbmRpY2VzSGVscGVyLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpOiBzdHJpbmcgPT4ge1xyXG4gIGxldCByZXZlcnNlRnVuYyA9IGBmbiBwZXJtKGk6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7aW5wdXQudHlwZS5pbmRpY2VzfSB7XHJcbiAgICB2YXIgYTogJHtpbnB1dC50eXBlLmluZGljZXN9O2A7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcclxuICAgIC8vIGlucHV0IGluZGljZXMgYW5kIG91dHB1dCBpbmRpY2VzIHNob3VsZCBhbHdheXMgYmUgbGFyZ2VyIG9yIGVxdWFsIHRvIDIsXHJcbiAgICAvLyBzbyBpbmRleGVyIGlzIGFsd2F5cyB2YWxpZCB0byBiZSB1c2VkIG9uIGBhYCBhbmQgYGlgLlxyXG4gICAgcmV2ZXJzZUZ1bmMgKz0gYGFbJHtwZXJtW2ldfV09aVske2l9XTtgO1xyXG4gIH1cclxuICByZXR1cm4gKHJldmVyc2VGdW5jICs9ICdyZXR1cm4gYTt9Jyk7XHJcbn07XHJcblxyXG5jb25zdCBzcXVlZXplU2hhcGUgPSAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBhZGp1c3RlZFBlcm06IG51bWJlcltdKTogeyBuZXdTaGFwZTogbnVtYmVyW107IG5ld1Blcm06IG51bWJlcltdIH0gPT4ge1xyXG4gIGNvbnN0IG5ld1NoYXBlOiBudW1iZXJbXSA9IFtdO1xyXG4gIGNvbnN0IG5ld1Blcm06IG51bWJlcltdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xyXG4gICAgaWYgKHNoYXBlW2ldICE9PSAxKSB7XHJcbiAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlW2FkanVzdGVkUGVybVtpXV0gIT09IDEpIHtcclxuICAgICAgbmV3UGVybS5wdXNoKGFkanVzdGVkUGVybVtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7IG5ld1NoYXBlLCBuZXdQZXJtIH07XHJcbn07XHJcblxyXG5jb25zdCBpc1RyYW5zcG9zZVJlc2hhcGUgPSAocGVybTogbnVtYmVyW10sIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4ge1xyXG4gIC8vIEFzIGxvbmcgYXMgdGhlIGRpbXMgd2l0aCB2YWx1ZXMgPiAxIHN0YXkgaW4gdGhlIHNhbWUgb3JkZXIsIGl0J3MgYSByZXNoYXBlLlxyXG4gIC8vIEV4YW1wbGU6IFNoYXBlPSgxLDEsMTAyNCw0MDk2KSAtPiBwZXJtPSgyLDAsMywxKS5cclxuICBsZXQgbGFzdFBlcm11dGVkQXhpcyA9IDA7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJtLmxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoc2hhcGVbcGVybVtpXV0gPT09IDEpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBpZiAocGVybVtpXSA8IGxhc3RQZXJtdXRlZEF4aXMpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGFzdFBlcm11dGVkQXhpcyA9IHBlcm1baV07XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvID0gKGlucHV0VGVuc29yOiBUZW5zb3JWaWV3LCBwZXJtQXR0cjogbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaW5wdXREYXRhVHlwZSA9IGlucHV0VGVuc29yLmRhdGFUeXBlO1xyXG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0VGVuc29yLmRpbXMubGVuZ3RoO1xyXG4gIGNvbnN0IHBlcm0gPSBnZXRBZGp1c3RlZFBlcm0oaW5wdXRSYW5rLCBwZXJtQXR0cik7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBnZXRPdXRwdXRTaGFwZShpbnB1dFRlbnNvci5kaW1zLCBwZXJtKTtcclxuICBsZXQgbmV3SW5wdXRTaGFwZSA9IGlucHV0VGVuc29yLmRpbXM7XHJcbiAgbGV0IG5ld091dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XHJcbiAgY29uc3QgdHJhbnNwb3NlQXNSZXNoYXBlID0gaW5wdXRSYW5rIDwgMiB8fCBpc1RyYW5zcG9zZVJlc2hhcGUocGVybSwgaW5wdXRUZW5zb3IuZGltcyk7XHJcbiAgbGV0IGdldFNoYWRlclNvdXJjZTtcclxuICBpZiAodHJhbnNwb3NlQXNSZXNoYXBlKSB7XHJcbiAgICBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0RGF0YVR5cGUsIG5ld0lucHV0U2hhcGUsIDQpO1xyXG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgbmV3T3V0cHV0U2hhcGUsIDQpO1xyXG4gICAgICByZXR1cm4gYFxyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcclxuICB9YDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZTogJ1RyYW5zcG9zZUNvcHknLFxyXG4gICAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ10gfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUZW5zb3IuZGF0YVR5cGUgfV0sXHJcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIGNvbXBvbmVudHMgKi8pIH0sXHJcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA0KSB9XSxcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICB9O1xyXG4gIH1cclxuICBjb25zdCB7IG5ld1NoYXBlLCBuZXdQZXJtIH0gPSBzcXVlZXplU2hhcGUoaW5wdXRUZW5zb3IuZGltcywgcGVybSk7XHJcbiAgY29uc3QgY2hhbm5lbHNMYXN0ID0gU2hhcGVVdGlsLmFyZUVxdWFsKG5ld1Blcm0sIFsyLCAzLCAxXSk7XHJcbiAgY29uc3QgY2hhbm5lbHNGaXJzdCA9IFNoYXBlVXRpbC5hcmVFcXVhbChuZXdQZXJtLCBbMywgMSwgMl0pO1xyXG4gIGNvbnN0IHVzZVNoYXJlZCA9IG5ld1NoYXBlLmxlbmd0aCA9PT0gMiB8fCBjaGFubmVsc0xhc3QgfHwgY2hhbm5lbHNGaXJzdDtcclxuICBpZiAodXNlU2hhcmVkKSB7XHJcbiAgICBuZXdJbnB1dFNoYXBlID0gY2hhbm5lbHNMYXN0XHJcbiAgICAgID8gW25ld1NoYXBlWzBdLCBuZXdTaGFwZVsxXSAqIG5ld1NoYXBlWzJdXVxyXG4gICAgICA6IGNoYW5uZWxzRmlyc3RcclxuICAgICAgICA/IFtuZXdTaGFwZVswXSAqIG5ld1NoYXBlWzFdLCBuZXdTaGFwZVsyXV1cclxuICAgICAgICA6IG5ld1NoYXBlO1xyXG4gICAgbmV3T3V0cHV0U2hhcGUgPSBbbmV3SW5wdXRTaGFwZVsxXSwgbmV3SW5wdXRTaGFwZVswXV07XHJcbiAgICBjb25zdCB0aWxlU2l6ZSA9IDE2O1xyXG4gICAgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0RGF0YVR5cGUsIG5ld0lucHV0U2hhcGUubGVuZ3RoKTtcclxuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0RGF0YVR5cGUsIG5ld091dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGUgOiBhcnJheTxhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHt0aWxlU2l6ZSArIDF9PiwgJHt0aWxlU2l6ZX0+O1xyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbdGlsZVNpemUsIHRpbGVTaXplLCAxXSl9XHJcbiAgICBsZXQgc3RyaWRlID0gKHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSAtIDEpIC8gJHt0aWxlU2l6ZX0gKyAxO1xyXG4gICAgbGV0IHdvcmtncm91cF9pZF94ID0gd29ya2dyb3VwX2luZGV4ICUgc3RyaWRlO1xyXG4gICAgbGV0IHdvcmtncm91cF9pZF95ID0gd29ya2dyb3VwX2luZGV4IC8gc3RyaWRlO1xyXG4gICAgbGV0IGlucHV0X2NvbCA9IHdvcmtncm91cF9pZF95ICogJHt0aWxlU2l6ZX11ICsgbG9jYWxfaWQueDtcclxuICAgIGxldCBpbnB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeCAqICR7dGlsZVNpemV9dSArIGxvY2FsX2lkLnk7XHJcbiAgICBpZiAoaW5wdXRfcm93IDwgdW5pZm9ybXMuYV9zaGFwZVswXSAmJiBpbnB1dF9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzFdKSB7XHJcbiAgICAgIHRpbGVbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2lucHV0LmdldEJ5SW5kaWNlcyhgJHtpbnB1dC50eXBlLmluZGljZXN9KGlucHV0X3JvdywgaW5wdXRfY29sKWApfTtcclxuICAgIH1cclxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICBsZXQgb3V0cHV0X2NvbCA9IHdvcmtncm91cF9pZF94ICogJHt0aWxlU2l6ZX11ICsgbG9jYWxfaWQueDtcclxuICAgIGxldCBvdXRwdXRfcm93ID0gd29ya2dyb3VwX2lkX3kgKiAke3RpbGVTaXplfXUgKyBsb2NhbF9pZC55O1xyXG4gICAgaWYgKG91dHB1dF9yb3cgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMF0gJiYgb3V0cHV0X2NvbCA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSkge1xyXG4gICAgICAke291dHB1dC5zZXRCeUluZGljZXMoYCR7b3V0cHV0LnR5cGUuaW5kaWNlc30ob3V0cHV0X3Jvdywgb3V0cHV0X2NvbClgLCAndGlsZVtsb2NhbF9pZC54XVtsb2NhbF9pZC55XScpfVxyXG4gICAgfVxyXG4gIH1gO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6ICdUcmFuc3Bvc2VTaGFyZWQnLFxyXG4gICAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ10gfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUZW5zb3IuZGF0YVR5cGUgfV0sXHJcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChuZXdPdXRwdXRTaGFwZVsxXSAvIHRpbGVTaXplKSwgeTogTWF0aC5jZWlsKG5ld091dHB1dFNoYXBlWzBdIC8gdGlsZVNpemUpIH0sXHJcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcclxuICAgICAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMobmV3SW5wdXRTaGFwZSwgbmV3T3V0cHV0U2hhcGUpLFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dERhdGFUeXBlLCBuZXdJbnB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgbmV3T3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG5cclxuICAke3Blcm1GdW5jdGlvbkJvZHkocGVybSwgaW5wdXRSYW5rLCBpbnB1dCwgb3V0cHV0KX1cclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG5cclxuICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcclxuXHJcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKSl9XHJcbiAgfWA7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ1RyYW5zcG9zZScsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtwZXJtQXR0cn1gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+IHtcclxuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VGVuc29yLmRhdGFUeXBlIH1dLFxyXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcclxuICAgICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhuZXdJbnB1dFNoYXBlLCBuZXdPdXRwdXRTaGFwZSksXHJcbiAgICAgICAgXSxcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0cmFuc3Bvc2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcy5wZXJtKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIGF0dHJpYnV0ZXMucGVybSkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBwZXJtOiBhdHRyaWJ1dGVzLnBlcm0gYXMgbnVtYmVyW10gfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5pbXBvcnQgeyBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cywgUmVkdWNlQXR0cmlidXRlcyB9IGZyb20gJy4vcmVkdWNlJztcclxuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XHJcblxyXG5jb25zdCByZWR1Y2VPcHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgbWF4OiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpJyxcclxuICBtaW46ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSknLFxyXG4gIG1lYW46ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxyXG4gIHN1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXHJcbiAgcHJvZDogJ2Jlc3RWYWx1ZSAqIGNhbmRpZGF0ZScsXHJcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlJyxcclxuICBsb2dTdW1FeHA6ICdiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKScsXHJcbiAgbDE6ICdiZXN0VmFsdWUgKyBhYnMoY2FuZGlkYXRlKScsXHJcbiAgbDI6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGUnLFxyXG4gIGxvZ1N1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VTaGFyZWRPcHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgbWF4OiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpJyxcclxuICBtaW46ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSknLFxyXG4gIG1lYW46ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxyXG4gIHN1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXHJcbiAgcHJvZDogJ2Jlc3RWYWx1ZSAqIGNhbmRpZGF0ZScsXHJcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcclxuICBsb2dTdW1FeHA6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxyXG4gIGwxOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcclxuICBsMjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXHJcbiAgbG9nU3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcclxufTtcclxuXHJcbmNvbnN0IHJlZHVjZUluaXRWYWx1ZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgbWF4OiAnX0Fbb2Zmc2V0XScsXHJcbiAgbWluOiAnX0Fbb2Zmc2V0XScsXHJcbiAgbWVhbjogJzAnLFxyXG4gIHN1bTogJzAnLFxyXG4gIHByb2Q6ICcxJyxcclxuICBzdW1TcXVhcmU6ICcwJyxcclxuICBsb2dTdW1FeHA6ICcwJyxcclxuICBsMTogJzAnLFxyXG4gIGwyOiAnMCcsXHJcbiAgbG9nU3VtOiAnMCcsXHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VPdXRwdXRWYWx1ZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XHJcbiAgbWF4OiAnYmVzdFZhbHVlJyxcclxuICBtaW46ICdiZXN0VmFsdWUnLFxyXG4gIHN1bTogJ2Jlc3RWYWx1ZScsXHJcbiAgcHJvZDogJ2Jlc3RWYWx1ZScsXHJcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlJyxcclxuICBsb2dTdW1FeHA6ICdsb2coYmVzdFZhbHVlKScsXHJcbiAgbDE6ICdiZXN0VmFsdWUnLFxyXG4gIGwyOiAnc3FydChiZXN0VmFsdWUpJyxcclxuICBsb2dTdW06ICdsb2coYmVzdFZhbHVlKScsXHJcbn07XHJcblxyXG5jb25zdCBnZXRJbm5lck1vc3RBeGVzID0gKG51bUlubmVyQXhlczogbnVtYmVyLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XHJcbiAgY29uc3QgcmVzID0gW107XHJcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSBudW1Jbm5lckF4ZXM7IGkgPCByYW5rOyArK2kpIHtcclxuICAgIHJlcy5wdXNoKGkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuY29uc3QgY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyA9IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogW251bWJlcltdLCBudW1iZXJbXV0gPT4ge1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW107XHJcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcclxuICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xyXG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xyXG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKHNoYXBlW2RpbV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCByZWR1Y2VTaGFwZSA9IGF4ZXMubWFwKChkaW0pID0+IHNoYXBlW2RpbV0pO1xyXG4gIHJldHVybiBbb3V0cHV0U2hhcGUsIHJlZHVjZVNoYXBlXTtcclxufTtcclxuXHJcbmNvbnN0IGV4cGFuZFNoYXBlVG9LZWVwRGltID0gKHNoYXBlOiBudW1iZXJbXSwgYXhlczogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XHJcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aCArIGF4ZXMubGVuZ3RoO1xyXG4gIGNvbnN0IGV4cGFuZFNoYXBlID0gW107XHJcbiAgbGV0IHNoYXBlSWR4ID0gMDtcclxuICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xyXG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xyXG4gICAgICBleHBhbmRTaGFwZS5wdXNoKHNoYXBlW3NoYXBlSWR4KytdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGV4cGFuZFNoYXBlLnB1c2goMSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBleHBhbmRTaGFwZTtcclxufTtcclxuXHJcbmNvbnN0IGFyZUF4ZXNJbm5lck1vc3REaW1zID0gKGF4ZXM6IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBib29sZWFuID0+IHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgIGlmIChheGVzW2F4ZXMubGVuZ3RoIC0gaSAtIDFdICE9PSByYW5rIC0gMSAtIGkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbmNvbnN0IGdldEF4ZXNQZXJtdXRhdGlvbiA9IChheGVzOiBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xyXG4gIGNvbnN0IHJlcyA9IFtdO1xyXG4gIGlmICghYXJlQXhlc0lubmVyTW9zdERpbXMoYXhlcywgcmFuaykpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XHJcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaSkgPT09IC0xKSB7XHJcbiAgICAgICAgcmVzLnB1c2goaSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGF4ZXMuZm9yRWFjaCgoYXhpcykgPT4gcmVzLnB1c2goYXhpcykpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZVNoYXJlZFByb2dyYW1JbmZvID0gKFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICBjYWNoZUtleTogc3RyaW5nLFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIHJlZHVjZVR5cGU6IHN0cmluZyxcclxuICBvdXRwdXREYXRhVHlwZTogRGF0YVR5cGUsXHJcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxyXG4gIHJlZHVjZVNoYXBlOiBudW1iZXJbXSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuXHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICBjb25zdCByZWR1Y2VTaXplID0gU2hhcGVVdGlsLnNpemUocmVkdWNlU2hhcGUpO1xyXG5cclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ19BJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlKTtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0Jywgb3V0cHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcclxuXHJcbiAgbGV0IHdvcmtncm91cFNpemUgPSA2NDtcclxuICAvLyBJZiBvbmx5IG9uZSB3b3JrZ3JvdXAgaXMgZGlzcGF0Y2hlZCwgaW5jcmVhc2Ugd29ya2dyb3VwU2l6ZSB0byBpbXByb3ZlIHBhcmFsbGVsaXNtLlxyXG4gIGlmIChvdXRwdXRTaXplID09PSAxKSB7XHJcbiAgICB3b3JrZ3JvdXBTaXplID0gMjU2O1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2hhcmVkTWVtb3J5U25pcHBldCA9IGBcclxuICAgICAgICAgIHZhcjx3b3JrZ3JvdXA+IGFCZXN0VmFsdWVzIDogYXJyYXk8ZjMyLCAke3dvcmtncm91cFNpemV9PjtcclxuICAgICAgIGA7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgncmVkdWNlU2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG4gICAgICAgICR7c2hhcmVkTWVtb3J5U25pcHBldH1cclxuICAgICAgICBmbiBESVZfQ0VJTChhIDogdTMyLCBiIDogdTMyKSAtPiB1MzIge1xyXG4gICAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KHdvcmtncm91cFNpemUpfVxyXG5cclxuICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGdsb2JhbF9pZHggLyAke3dvcmtncm91cFNpemV9O1xyXG4gICAgICAgICAgbGV0IG9mZnNldCA9IG91dHB1dEluZGV4ICogdW5pZm9ybXMucmVkdWNlU2l6ZTtcclxuXHJcbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gZjMyKCR7cmVkdWNlSW5pdFZhbHVlc1tyZWR1Y2VUeXBlXX0pO1xyXG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XHJcbiAgICAgICAgICBmb3IgKHZhciBrID0gbG9jYWxfaWR4OyBrIDwgTGVuZ3RoOyBrID0gayArICR7d29ya2dyb3VwU2l6ZX0pIHtcclxuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZjMyKCR7aW5wdXQuZ2V0QnlPZmZzZXQoJ29mZnNldCArIGsnKX0pO1xyXG4gICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7cmVkdWNlT3BzW3JlZHVjZVR5cGVdfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XHJcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7d29ya2dyb3VwU2l6ZX11KTtcclxuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcclxuICAgICAgICAgICAgIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1KSB7XHJcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xyXG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xyXG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gYUJlc3RWYWx1ZXNbbG9jYWxfaWR4ICsgaW50ZXJ2YWxdO1xyXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke3JlZHVjZVNoYXJlZE9wc1tyZWR1Y2VUeXBlXX07XHJcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcclxuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcclxuICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KFxyXG4gICAgICAgICAgICAnb3V0cHV0SW5kZXgnLFxyXG4gICAgICAgICAgICBgJHtcclxuICAgICAgICAgICAgICByZWR1Y2VUeXBlID09PSAnbWVhbidcclxuICAgICAgICAgICAgICAgID8gYCR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oYmVzdFZhbHVlIC8gZjMyKHVuaWZvcm1zLnJlZHVjZVNpemUpKWBcclxuICAgICAgICAgICAgICAgIDogYCR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oJHtyZWR1Y2VPdXRwdXRWYWx1ZXNbcmVkdWNlVHlwZV19KWBcclxuICAgICAgICAgICAgfWAsXHJcbiAgICAgICAgICApfTtcclxuICAgICAgICAgfVxyXG4gICAgICAgIH1gO1xyXG5cclxuICAvLyBPbmUgd29yayBncm91cCBpcyByZXNwb25zaWJsZSBmb3Igb25seSBvbmUgZWxlbWVudCBvZiBvdXRwdXQuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWUsXHJcbiAgICAvLyBOb3RlIHRoYXQgaW4gSlNFUCwgV0cgc2l6ZSBpcyBub3QgaW5jbHVkZWQgaW4gY2FjaGUgYnkgZGVmYXVsdCwgYnV0IFdlYkdQVSBFUCBpdCBpcy5cclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NhY2hlS2V5fTske3dvcmtncm91cFNpemV9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZSddIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IG91dHB1dFNpemUgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHJlZHVjZVNpemUgfV0sXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgcmVkdWNlQ29tbW9uID0gKFxyXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxyXG4gIHJlZHVjZVR5cGU6ICdzdW0nIHwgJ3N1bVNxdWFyZScgfCAncHJvZCcgfCAnbWluJyB8ICdtYXgnIHwgJ21lYW4nIHwgJ2xvZ1N1bUV4cCcgfCAnbDEnIHwgJ2wyJyB8ICdsb2dTdW0nLFxyXG4pOiB2b2lkID0+IHtcclxuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyA9XHJcbiAgICBjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDEgPyBhdHRyaWJ1dGVzIDogY3JlYXRlUmVkdWNlQXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xyXG5cclxuICBsZXQgdXBkYXRlZEF4ZXMgPSB1cGRhdGVkQXR0cmlidXRlcy5heGVzO1xyXG4gIGlmICh1cGRhdGVkQXhlcy5sZW5ndGggPT09IDAgJiYgIXVwZGF0ZWRBdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSB7XHJcbiAgICB1cGRhdGVkQXhlcyA9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubWFwKChfZGltLCBpKSA9PiBpKTtcclxuICB9XHJcbiAgY29uc3Qgbm9ybWFsaXplQXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKHVwZGF0ZWRBeGVzLCBjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCk7XHJcblxyXG4gIGxldCBheGVzID0gbm9ybWFsaXplQXhlcztcclxuICBsZXQgaW5wdXQgPSBjb250ZXh0LmlucHV0c1swXTtcclxuICBjb25zdCBwZXJtdXRlZEF4ZXMgPSBnZXRBeGVzUGVybXV0YXRpb24oYXhlcywgY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xyXG4gIGlmIChwZXJtdXRlZEF4ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgaW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIHBlcm11dGVkQXhlcyksIHtcclxuICAgICAgaW5wdXRzOiBbMF0sXHJcbiAgICAgIG91dHB1dHM6IFstMV0sXHJcbiAgICB9KVswXTtcclxuICAgIGF4ZXMgPSBnZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCBpbnB1dC5kaW1zLmxlbmd0aCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBbb3V0cHV0U2hhcGUsIHJlZHVjZVNoYXBlXSA9IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuZGltcywgYXhlcyk7XHJcbiAgbGV0IGZpbmFsT3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcclxuICBpZiAodXBkYXRlZEF0dHJpYnV0ZXMua2VlcERpbXMpIHtcclxuICAgIGZpbmFsT3V0cHV0U2hhcGUgPSBleHBhbmRTaGFwZVRvS2VlcERpbShvdXRwdXRTaGFwZSwgbm9ybWFsaXplQXhlcyk7XHJcbiAgfVxyXG5cclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVSZWR1Y2VTaGFyZWRQcm9ncmFtSW5mbyhcclxuICAgICAgbmFtZSxcclxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMuY2FjaGVLZXksXHJcbiAgICAgIFtpbnB1dF0sXHJcbiAgICAgIHJlZHVjZVR5cGUsXHJcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLFxyXG4gICAgICBmaW5hbE91dHB1dFNoYXBlLFxyXG4gICAgICByZWR1Y2VTaGFwZSxcclxuICAgICksXHJcbiAgICB7IGlucHV0czogW2lucHV0XSB9LFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTWVhblNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWVhblNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtZWFuJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTDFTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUwxU2hhcmVkJywgYXR0cmlidXRlcywgJ2wxJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTDJTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUwyU2hhcmVkJywgYXR0cmlidXRlcywgJ2wyJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTG9nU3VtRXhwU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1FeHBTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbG9nU3VtRXhwJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTWF4U2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNYXhTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbWF4Jyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTWluU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNaW5TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbWluJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlUHJvZFNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlUHJvZFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdwcm9kJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VTdW1TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnc3VtJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtU3F1YXJlU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VTdW1TcXVhcmVTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnc3VtU3F1YXJlJyk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTG9nU3VtU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbG9nU3VtJyk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVNoYWRlckNhY2hlSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5pbXBvcnQge1xyXG4gIHJlZHVjZUwxU2hhcmVkLFxyXG4gIHJlZHVjZUwyU2hhcmVkLFxyXG4gIHJlZHVjZUxvZ1N1bUV4cFNoYXJlZCxcclxuICByZWR1Y2VMb2dTdW1TaGFyZWQsXHJcbiAgcmVkdWNlTWF4U2hhcmVkLFxyXG4gIHJlZHVjZU1lYW5TaGFyZWQsXHJcbiAgcmVkdWNlTWluU2hhcmVkLFxyXG4gIHJlZHVjZVByb2RTaGFyZWQsXHJcbiAgcmVkdWNlU3VtU2hhcmVkLFxyXG4gIHJlZHVjZVN1bVNxdWFyZVNoYXJlZCxcclxufSBmcm9tICcuL3JlZHVjZS1zaGFyZWQnO1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoID09PSAwIHx8IGlucHV0cy5sZW5ndGggPiAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDIgJiYgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXhlcyBpbnB1dCBkaW1zLicpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVkdWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAga2VlcERpbXM6IGJvb2xlYW47XHJcbiAgbm9vcFdpdGhFbXB0eUF4ZXM6IGJvb2xlYW47XHJcbiAgYXhlczogbnVtYmVyW107XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFJlZHVjZU9wID0gKFxyXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxyXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcclxuICBheGVzOiByZWFkb25seSBudW1iZXJbXSxcclxuKSA9PiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCAuLi5zdHJpbmdbXV07XHJcblxyXG5jb25zdCBub09wOiBSZWR1Y2VPcCA9IChpbnB1dCkgPT4gWycnLCAnJywgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsICcnXTtcclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvID0gKFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICBzaGFkZXJDYWNoZTogUHJvZ3JhbVNoYWRlckNhY2hlSW5mbyxcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICByZWR1Y2VPcDogUmVkdWNlT3AsXHJcbiAgYXhlc0lucHV0OiBudW1iZXJbXSxcclxuICBvdXRwdXREYXRhVHlwZTogRGF0YVR5cGUsXHJcbiAga2VlcERpbXMgPSBmYWxzZSxcclxuICBub29wV2l0aEVtcHR5QXhlcyA9IGZhbHNlLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xyXG4gIGNvbnN0IGF4ZXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyhheGVzSW5wdXQsIGlucHV0UmFuayk7XHJcbiAgY29uc3QgcmVkdWNlT25BbGxBeGVzID0gIW5vb3BXaXRoRW1wdHlBeGVzICYmIGF4ZXMubGVuZ3RoID09PSAwO1xyXG4gIGlucHV0U2hhcGUuZm9yRWFjaCgoZCwgaSkgPT4ge1xyXG4gICAgaWYgKHJlZHVjZU9uQWxsQXhlcyB8fCBheGVzLmluZGV4T2YoaSkgPj0gMCkge1xyXG4gICAgICBpZiAoa2VlcERpbXMpIHtcclxuICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKDEpO1xyXG4gICAgICB9IC8vIGVsc2UgeyAvLyBza2lwIHRoaXMgYXhpc31cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG91dHB1dFNoYXBlLnB1c2goZCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgY29uc3Qgb3V0cHV0UmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaWR4Q29weTogc3RyaW5nW10gPSBbXTsgLy8gY29weSBvdXRwdXQgaW5kZXhlcyB0byBpbnB1dCBpbmRleGVzXHJcblxyXG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdfQScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRSYW5rKTtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXREYXRhVHlwZSwgb3V0cHV0UmFuayk7XHJcbiAgICBjb25zdCBvcHMgPSByZWR1Y2VPcChpbnB1dCwgb3V0cHV0LCBheGVzKTtcclxuICAgIGxldCByZWR1Y2VPcHMgPSBvcHNbMl07XHJcblxyXG4gICAgZm9yIChsZXQgayA9IDAsIGwgPSAwOyBrIDwgaW5wdXRSYW5rOyBrKyspIHtcclxuICAgICAgLy8gaWYgdGhpcyBheGlzIGlzIHJlZHVjZWRcclxuICAgICAgaWYgKHJlZHVjZU9uQWxsQXhlcyB8fCBheGVzLmluZGV4T2YoaykgPj0gMCkge1xyXG4gICAgICAgIGlmIChrZWVwRGltcykge1xyXG4gICAgICAgICAgbCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsb29wIG92ZXIgdGhlIGQtdGggYXhpc1xyXG4gICAgICAgIHJlZHVjZU9wcyA9IGBmb3IodmFyIGoke2t9OiB1MzIgPSAwOyBqJHtrfSA8ICR7aW5wdXRTaGFwZVtrXX07IGoke2t9KyspIHtcclxuICAgICAgICAgICAgICAgICAgJHtvcHNbMl0uaW5jbHVkZXMoJ2xhc3RfaW5kZXgnKSA/IGBsZXQgbGFzdF9pbmRleCA9IGoke2t9O2AgOiAnJ31cclxuICAgICAgICAgICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgYGoke2t9YCl9XHJcbiAgICAgICAgICAgICAgICAgICR7cmVkdWNlT3BzfVxyXG4gICAgICAgICAgICAgICAgfWA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWR4Q29weS5wdXNoKGAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBrLCBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCBsKSl9O2ApO1xyXG4gICAgICAgIGwrKztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBcclxuXHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG5cclxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xyXG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG5cclxuICAgICAgICAgICR7aWR4Q29weS5qb2luKCdcXG4nKX1cclxuICAgICAgICAgICR7b3BzWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cclxuICAgICAgICAgICR7b3BzWzFdfVxyXG4gICAgICAgICAgJHtyZWR1Y2VPcHN9XHJcbiAgICAgICAgICAke29wc1szXX1cclxuICAgICAgICAgICR7b3BzLmxlbmd0aCA9PT0gNCA/IG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpIDogb3BzLnNsaWNlKDQpLmpvaW4oJ1xcbicpfVxyXG4gICAgICAgIH1gO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lLFxyXG4gICAgc2hhZGVyQ2FjaGUsXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpLFxyXG4gICAgICBdLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxyXG4pOiBSZWR1Y2VBdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBheGVzOiBudW1iZXJbXSA9IFtdO1xyXG4gIGlmIChpbnB1dHNbMV0uZGltc1swXSA+IDApIHtcclxuICAgIGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodikgPT4gYXhlcy5wdXNoKE51bWJlcih2KSkpO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcclxuICAgIGF4ZXMsXHJcbiAgICBrZWVwRGltczogYXR0cmlidXRlcy5rZWVwRGltcyxcclxuICAgIG5vb3BXaXRoRW1wdHlBeGVzOiBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzLFxyXG4gIH0pO1xyXG59O1xyXG5cclxuY29uc3QgcnVuUmVkdWNlUHJvZ3JhbSA9IChcclxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcclxuICBuYW1lOiBzdHJpbmcsXHJcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcclxuICByZWR1Y2VPcDogUmVkdWNlT3AsXHJcbik6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xyXG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzID1cclxuICAgIGlucHV0cy5sZW5ndGggPT09IDEgPyBhdHRyaWJ1dGVzIDogY3JlYXRlUmVkdWNlQXR0cmlidXRlc0Zyb21JbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuXHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIHsgaGludDogdXBkYXRlZEF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxyXG4gICAgICBbaW5wdXRzWzBdXSxcclxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMgJiYgdXBkYXRlZEF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPT09IDAgPyBub09wIDogcmVkdWNlT3AsXHJcbiAgICAgIHVwZGF0ZWRBdHRyaWJ1dGVzLmF4ZXMsXHJcbiAgICAgIGlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMua2VlcERpbXMsXHJcbiAgICAgIHVwZGF0ZWRBdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzLFxyXG4gICAgKSxcclxuICAgIHsgaW5wdXRzOiBbMF0gfSxcclxuICApO1xyXG59O1xyXG5cclxuY29uc3QgcmVkdWNlTG9nU3VtTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcclxuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXHJcbiAgICAnJyxcclxuICAgIGB2YWx1ZSArPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxyXG4gICAgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnLFxyXG4gIF07XHJcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTG9nU3VtJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xyXG59O1xyXG5cclxuY29uc3QgcmVkdWNlTDFOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xyXG4gICAgYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcclxuICAgICcnLFxyXG4gICAgYHZhbHVlICs9IGFicygke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcclxuICAgICcnLFxyXG4gIF07XHJcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTDEnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VMMk5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PiBbXHJcbiAgICBgdmFyIHQgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7YCxcclxuICAgICcnLFxyXG4gICAgYHQgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTsgdmFsdWUgKz0gKHQgKiB0KTtgLFxyXG4gICAgJ3ZhbHVlID0gc3FydCh2YWx1ZSk7JyxcclxuICBdO1xyXG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUwyJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xyXG59O1xyXG5cclxuY29uc3QgcmVkdWNlTG9nU3VtRXhwTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcclxuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXHJcbiAgICAnJyxcclxuICAgIGB2YWx1ZSArPSBleHAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXHJcbiAgICAndmFsdWUgPSBsb2codmFsdWUpOycsXHJcbiAgXTtcclxuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1FeHAnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VNYXhOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIF9vdXRwdXQsIGF4ZXMpID0+IHtcclxuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcclxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XHJcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGlkeFplcm8ucHVzaChpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgMCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxyXG4gICAgICBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcclxuICAgICAgYHZhbHVlID0gbWF4KHZhbHVlLCAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcclxuICAgICAgJycsXHJcbiAgICBdO1xyXG4gIH07XHJcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTWF4JywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xyXG59O1xyXG5cclxuY29uc3QgcmVkdWNlTWVhbk5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XHJcbiAgICBsZXQgc2l6ZSA9IDEuMDtcclxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XHJcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIC8vIFRPRE86IHRoaXMgZGVwZW5kcyBvbiB0aGUgaW5wdXQgZGltcy4gSWYgd2Ugd2FudCB0byB1c2UgdW5pZm9ybSwgdGhpcyBuZWVkIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgc2l6ZSAqPSBjb250ZXh0LmlucHV0c1swXS5kaW1zW2tdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgJ3ZhciBzdW0gPSBmMzIoMCk7JyxcclxuICAgICAgJycsXHJcbiAgICAgIGBzdW0gKz0gZjMyKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxyXG4gICAgICBgbGV0IHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oc3VtIC8gJHtzaXplfSk7YCxcclxuICAgIF07XHJcbiAgfTtcclxuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNZWFuJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xyXG59O1xyXG5cclxuY29uc3QgcmVkdWNlTWluTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBfb3V0cHV0LCBheGVzKSA9PiB7XHJcbiAgICBjb25zdCBpZHhaZXJvID0gW107XHJcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xyXG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0X2luZGljZXNbJHtrfV0gPSAwO2ApOyAvLyBmaXJzdCBlbGVtZW50XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsXHJcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxyXG4gICAgICBgdmFsdWUgPSBtaW4odmFsdWUsICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxyXG4gICAgICAnJyxcclxuICAgIF07XHJcbiAgfTtcclxuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNaW4nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VQcm9kTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcclxuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDEpO2AsXHJcbiAgICAnJyxcclxuICAgIGB2YWx1ZSAqPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxyXG4gICAgJycsXHJcbiAgXTtcclxuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VQcm9kJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xyXG59O1xyXG5cclxuY29uc3QgcmVkdWNlU3VtTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcclxuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXHJcbiAgICAnJyxcclxuICAgIGB2YWx1ZSArPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxyXG4gICAgJycsXHJcbiAgXTtcclxuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VTdW0nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XHJcbn07XHJcblxyXG5jb25zdCByZWR1Y2VTdW1TcXVhcmVOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xyXG4gICAgYHZhciB0ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO2AsXHJcbiAgICAnJyxcclxuICAgIGB0ID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07IHZhbHVlICs9IHQgKiB0O2AsXHJcbiAgICAnJyxcclxuICBdO1xyXG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVN1bVNxdWFyZScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcclxufTtcclxuXHJcbmNvbnN0IHVzZU5haXZlUmVkdWNlTWV0aG9kID0gKFxyXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBheGVzOiByZWFkb25seSBudW1iZXJbXSxcclxuICBub29wV2l0aEVtcHR5QXhlczogYm9vbGVhbixcclxuKTogYm9vbGVhbiA9PiB7XHJcbiAgaWYgKGF4ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gbm9vcFdpdGhFbXB0eUF4ZXM7XHJcbiAgfVxyXG5cclxuICBsZXQgb3V0cHV0U2l6ZSA9IDE7XHJcbiAgbGV0IHJlZHVjZVNpemUgPSAxO1xyXG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGF4ZXMubGVuZ3RoOyBkaW0rKykge1xyXG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xyXG4gICAgICBvdXRwdXRTaXplICo9IHNoYXBlW2RpbV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZWR1Y2VTaXplICo9IHNoYXBlW2RpbV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgY29uZGl0aW9uIGRhdGEgaXMgdmVyeSByb3VnaCwgYWx0aG91Z2ggY29uc2lkZXJpbmcgdGhlIGNvdW50IG9mIEV4ZWN1dGlvbiBVbml0IChFVSksIHRoZSBwb3RlbnRpYWxcclxuICAvLyB3b3JrIGdyb3VwcyBpbiBhIEVVIGFuZCB0aGUgY291bnRzIG9mIGxvb3BzIGluIHRoZSBuYWl2ZSBhbmQgc2hhcmVkIG1ldGhvZHMsIGFsc28gZG9pbmcgZXhwZXJpbWVudHNcclxuICAvLyBvbiBzb21lIG1hY2hpbmVzLlxyXG4gIHJldHVybiByZWR1Y2VTaXplIDwgMzIgJiYgb3V0cHV0U2l6ZSA+IDEwMjQ7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTWVhbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XHJcbiAgICByZWR1Y2VNZWFuTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlZHVjZU1lYW5TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlZHVjZUwxID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcclxuICAgIHJlZHVjZUwxTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlZHVjZUwxU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VMMiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XHJcbiAgICByZWR1Y2VMMk5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZWR1Y2VMMlNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTG9nU3VtRXhwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcclxuICAgIHJlZHVjZUxvZ1N1bUV4cE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZWR1Y2VMb2dTdW1FeHBTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlZHVjZU1heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XHJcbiAgICByZWR1Y2VNYXhOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVkdWNlTWF4U2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VNaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xyXG4gICAgcmVkdWNlTWluTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlZHVjZU1pblNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlUHJvZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XHJcbiAgICByZWR1Y2VQcm9kTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlZHVjZVByb2RTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XHJcbiAgICByZWR1Y2VTdW1OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVkdWNlU3VtU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TcXVhcmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xyXG4gICAgcmVkdWNlU3VtU3F1YXJlTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJlZHVjZVN1bVNxdWFyZVNoYXJlZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVkdWNlTG9nU3VtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcclxuICAgIHJlZHVjZUxvZ1N1bU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZWR1Y2VMb2dTdW1TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbi8vIFRPRE86IHRoaXMgaXMgdGhlIHNhbWUgbmFpdmUgaW1wbGVtZW50YXRpb24gd2UgdXNlIGZvciByZWR1Y2UgdGhhdCBoYXNcclxuLy8gcGVyZm9ybWFuY2UgbGltaXRhdGlvbnMgd2hlbiB0aGUgcmVkdWNlZCBheGlzIGlzIGxvbmcuIE5lZWQgdG8gYWRkXHJcbi8vIGEgb3B0aW1pemVkIGNvZGVwYXRoIGZvciB0aGlzLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbywgUmVkdWNlT3AgfSBmcm9tICcuL3JlZHVjZSc7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDAgfHwgaW5wdXRzLmxlbmd0aCA+IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy4nKTtcclxuICB9XHJcbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXJnTWluTWF4QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAga2VlcERpbXM6IGJvb2xlYW47XHJcbiAgYXhpczogbnVtYmVyO1xyXG4gIHNlbGVjdExhc3RJbmRleDogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYXJnTWluID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBcmdNaW5NYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnN0IGFyZ01pbk1heE9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XHJcbiAgICBjb25zdCBpZHhaZXJvID0gW107XHJcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xyXG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0X2luZGljZXNbJHtrfV0gPSAwO2ApOyAvLyBmaXJzdCBlbGVtZW50XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbXHJcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcclxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLFxyXG4gICAgICBgaWYgKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9ICR7YXR0cmlidXRlcy5zZWxlY3RMYXN0SW5kZXggPiAwID8gJzw9JyA6ICc8J30gdmFsdWUpIHtcclxuICAgICAgICAgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcclxuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcclxuICAgICAgIH1gLFxyXG4gICAgICAnJyxcclxuICAgICAgb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2Jlc3RfaW5kZXgnKSxcclxuICAgIF07XHJcbiAgfTtcclxuXHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXHJcbiAgICAgICdBcmdNaW4nLFxyXG4gICAgICB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxyXG4gICAgICBbY29udGV4dC5pbnB1dHNbMF1dLFxyXG4gICAgICBhcmdNaW5NYXhPcCxcclxuICAgICAgW2F0dHJpYnV0ZXMuYXhpc10sXHJcbiAgICAgIERhdGFUeXBlLmludDY0LFxyXG4gICAgICBhdHRyaWJ1dGVzLmtlZXBEaW1zLFxyXG4gICAgKSxcclxuICAgIHsgaW5wdXRzOiBbMF0gfSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFyZ01heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXJnTWluTWF4QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCBhcmdNaW5NYXhPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xyXG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xyXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcclxuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgLy8gZmlyc3QgZWxlbWVudFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsXHJcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcXG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxcclxuICAgICAgYGlmICgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSAke2F0dHJpYnV0ZXMuc2VsZWN0TGFzdEluZGV4ID4gMCA/ICc+PScgOiAnPid9IHZhbHVlKSB7XHJcbiAgICAgICAgIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XHJcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XHJcbiAgICAgICB9YCxcclxuICAgICAgJycsXHJcbiAgICAgIG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdiZXN0X2luZGV4JyksXHJcbiAgICBdO1xyXG4gIH07XHJcblxyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvKFxyXG4gICAgICAnYXJnTWF4JyxcclxuICAgICAgeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcclxuICAgICAgW2NvbnRleHQuaW5wdXRzWzBdXSxcclxuICAgICAgYXJnTWluTWF4T3AsXHJcbiAgICAgIFthdHRyaWJ1dGVzLmF4aXNdLFxyXG4gICAgICBEYXRhVHlwZS5pbnQ2NCxcclxuICAgICAgYXR0cmlidXRlcy5rZWVwRGltcyxcclxuICAgICksXHJcbiAgICB7IGlucHV0czogWzBdIH0sXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUFyZ01pbk1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBcmdNaW5NYXhBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMgT21pdDxBcmdNaW5NYXhBdHRyaWJ1dGVzLCBrZXlvZiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk+KTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBHcHVEYXRhVHlwZSwgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBnZXRNYXhDb21wb25lbnRzLFxyXG4gIEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsXHJcbiAgVW5pZm9ybURhdGFFbGVtZW50VHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgY29uc3QgZW51bSBBdHRlbnRpb25Ra3ZGb3JtYXQge1xyXG4gIHVua25vd24sIC8vIGVudW0gdmFsdWUgbm90IHNldCwgb3IgZGVwZW5kcyBvbiBxa3YgcHJvamVjdGlvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzXHJcbiAgcWt2Qk5TSCwgLy8gZm9yIG5vbi1wYWNrZWQgcWt2LCBwZXJtdXRlZFxyXG4gIHFrdkJTTkgsIC8vIGZvciBub24tcGFja2VkIHFrdiwgbm90IHBlcm11dGVkLCB1c2VkIGJ5IG1lbW9yeSBlZmZpY2llbnQgYXR0ZW50aW9uIG9yIE11bHRpSGVhZEF0dGVudGlvblxyXG4gIHFrdkJTTjNILCAvLyBmb3IgVFJUIGZ1c2VkIGF0dGVudGlvbiwgcWt2IGFyZSBwYWNrZWRcclxuICBxa3ZCTlNIcWt2QlMzTkgsIC8vIGZvciBUUlQgZnVzZWQgY2F1c2FsIGF0dGVudGlvbiwgZGF0YSBoYXMgdHdvIGZvcm1hdHMgKHFrdiBpcyAzQk5TSCwgZ2VtbV9idWZmZXIgaXMgQlMzTkgpXHJcbiAgcUt2QlNOSHhCU04ySCwgLy8gZm9yIFRSVCBmdXNlZCBjcm9zcyBhdHRlbnRpb24sIGt2IGFyZSBwYWNrZWRcclxuICBxa3ZUTkgsIC8vIGZvciBtZW1vcnkgZWZmaWNpZW50IGF0dGVudGlvbiwgcWt2IGFyZSBub3QgcGFja2VkLCBhbmQgcGFkZGluZ3MgYXJlIHJlbW92ZWQuXHJcbiAgcWt2VE4zSCwgLy8gZm9yIFRSVCBmdXNlZCBhdHRlbnRpb24sIHFrdiBhcmUgcGFja2VkIGFuZCBwYWRkaW5ncyBhcmUgcmVtb3ZlZFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZW51bSBBdHRlbnRpb25NYXNrVHlwZSB7XHJcbiAgbm9uZSwgLy8gTm8gbWFza1xyXG4gIG1hc2sxZEtleVNlcUxlbiwgLy8gW2JhdGNoX3NpemVdLCBrZXkgc2VxdWVuY2UgbGVuZ3RoXHJcbiAgbWFzazFkRW5kU3RhcnQsIC8vIFsyICogYmF0Y2hfc2l6ZV0gd2l0aCBlbmQgcG9zaXRpb25zIGFuZCBzdGFydCBwb3NpdGlvbnNcclxuICBtYXNrMURLZXlTZXFMZW5TdGFydCwgLy8gWzMgKiBiYXRjaF9zaXplICsgMl0gd2l0aCBba2V5X2xlblswXSwgLi4uLCBrZXlfbGVuW2JhdGNoX3NpemUgLSAxXSwgcXVlcnlfc3RhcnRbMF0sXHJcbiAgLy8gLi4uLCBxdWVyeV9zdGFydFtiYXRjaF9zaXplIC0gMV0sIHF1ZXJ5X2VuZFtiYXRjaF9zaXplIC0gMV0sIGtleV9zdGFydFswXSwgLi4uLFxyXG4gIC8vIGtleV9zdGFydFtiYXRjaF9zaXplIC0gMV0sIGtleV9lbmRbYmF0Y2hfc2l6ZSAtIDFdXVxyXG4gIG1hc2syZER1bW15LCAvLyBkdW1teSBtYXNrIHdpdGggc2hhcGUgWzEsIDFdIG9yIFtiYXRjaF9zaXplLCAxXS4gSXQgaGFzIHNhbWUgZWZmZWN0IGFzIG5vIG1hc2suXHJcbiAgbWFzazJkS2V5UGFkZGluZywgLy8gW2JhdGNoX3NpemUsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aF1cclxuICBtYXNrM2RBdHRlbnRpb24sIC8vIFtiYXRjaF9zaXplLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aF1cclxuICBtYXNrNGRNZWdhdHJvbiwgLy8gTWVnYXRyb24gY2F1c2FsIG1hc2sgd2l0aCBzaGFwZSBbYmF0Y2hfc2l6ZSwgMSwgbWF4X3NlcXVlbmNlX2xlbmd0aCwgbWF4X3NlcXVlbmNlX2xlbmd0aF1cclxuICBtYXNrVW5rbm93bixcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBdHRlbnRpb25QYXJhbWV0ZXJzIHtcclxuICBiYXRjaFNpemU6IG51bWJlcjtcclxuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xyXG4gIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xyXG4gIGt2U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcclxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XHJcbiAgbWF4U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcclxuICBpbnB1dEhpZGRlblNpemU6IG51bWJlcjtcclxuICBoaWRkZW5TaXplOiBudW1iZXI7XHJcbiAgdkhpZGRlblNpemU6IG51bWJlcjtcclxuICBoZWFkU2l6ZTogbnVtYmVyO1xyXG4gIHZIZWFkU2l6ZTogbnVtYmVyO1xyXG4gIG51bUhlYWRzOiBudW1iZXI7XHJcbiAga3ZOdW1IZWFkcz86IG51bWJlcjtcclxuICBuUmVwcz86IG51bWJlcjtcclxuICBpc1VuaWRpcmVjdGlvbmFsPzogYm9vbGVhbjtcclxuICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBib29sZWFuO1xyXG4gIG1hc2tGaWx0ZXJWYWx1ZT86IG51bWJlcjtcclxuICBtYXNrVHlwZTogQXR0ZW50aW9uTWFza1R5cGU7XHJcbiAgc2NhbGU6IG51bWJlcjtcclxuICBicm9hZGNhc3RSZXNQb3NCaWFzOiBib29sZWFuO1xyXG4gIHBhc3NQYXN0SW5LdjogYm9vbGVhbjtcclxuICBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdDtcclxuICBzb2Z0Y2FwPzogbnVtYmVyO1xyXG4gIGRvUm90YXJ5PzogbnVtYmVyO1xyXG4gIHJvdGFyeUludGVyTGVhdmVkPzogbnVtYmVyO1xyXG4gIHNvbW1vb3RoU29mdG1heD86IG51bWJlcjtcclxuICBsb2NhbFdpbmRvd3NTaXplPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVudGlvbkF0dHJzIHtcclxuICBudW1IZWFkczogbnVtYmVyO1xyXG4gIGlzVW5pZGlyZWN0aW9uYWw6IG51bWJlcjtcclxuICBtYXNrRmlsdGVyVmFsdWU6IG51bWJlcjtcclxuICBzY2FsZTogbnVtYmVyO1xyXG4gIGRvUm90YXJ5OiBudW1iZXI7XHJcbiAgcWt2SGlkZGVuU2l6ZXM6IG51bWJlcltdO1xyXG4gIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGJvb2xlYW47XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlQXR0ZW50aW9uSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvblBhcmFtZXRlcnMgPT4ge1xyXG4gIC8vIEFiYnJldmlhdGlvbiBhbmQgTWVhbmluZ3M6XHJcbiAgLy8gICBCOiAgICBiYXRjaF9zaXplXHJcbiAgLy8gICBTOiAgICBzZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBxdWVyeSlcclxuICAvLyAgIFA6ICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIChwYXN0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXHJcbiAgLy8gICBMOiAgICBrdl9zZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXHJcbiAgLy8gICBNOiAgICBtYXhfc2VxdWVuY2VfbGVuZ3RoXHJcbiAgLy8gICBUOiAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBwYXN0X3NlcXVlbmNlX2xlbmd0aCArIGt2X3NlcXVlbmNlX2xlbmd0aFxyXG4gIC8vICAgTjogICAgbnVtX2hlYWRzXHJcbiAgLy8gICBIOiAgICBoZWFkIHNpemUgZm9yIFEgYW5kIEssIGFrYSBxX2hlYWRfc2l6ZSBvciBrX2hlYWRfc2l6ZSBvciBxa19oZWFkX3NpemVcclxuICAvLyAgIEhfdjogIHZfaGVhZF9zaXplXHJcbiAgLy8gICBEX2k6ICBpbnB1dCBoaWRkZW4gc2l6ZVxyXG4gIC8vICAgRDogICAgaGlkZGVuIHNpemUgZm9yIFEgYW5kIEsgKEQgPSBOICogSCksIGFrYSBxX2hpZGRlbl9zaXplIG9yIGtfaGlkZGVuX3NpemUgb3IgcWtfaGlkZGVuX3NpemVcclxuICAvLyAgIERfdjogIHZfaGlkZGVuX3NpemUgPSBudW1faGVhZHMgKiB2X2hlYWRfc2l6ZVxyXG5cclxuICAvLyBXaGVuIHBhc3Qgc3RhdGUgaXMgdXNlZCwgUSwgSyBhbmQgViBzaG91bGQgaGF2ZSBzYW1lIGhpZGRlbiBzaXplICh1bmxlc3Mgd2Ugc3BsaXQgaXQgaW50byBwYXN0X2tleSBhbmQgcGFzdF92YWx1ZSkuXHJcblxyXG4gIC8vIElucHV0IHNoYXBlczpcclxuICAvLyAgIGlucHV0ICAgICAgICAoUS9LL1YpICAgIDogKEIsIFMsIERfaSlcclxuICAvLyAgIHdlaWdodHMgICAgICAoUS9LL1YpICAgIDogKERfaSwgRCArIEQgKyBEX3YpXHJcbiAgLy8gICBiaWFzICAgICAgICAgKFEvSy9WKSAgICA6IChEICsgRCArIERfdilcclxuICAvLyAgIG1hc2tfaW5kZXggICAgICAgICAgICAgIDogc2VlIGJlbG93XHJcbiAgLy8gICBwYXN0ICAgICAgICAgKEsvVikgICAgICA6ICgyLCBCLCBOLCBQLCBIKSBvciBOVUxMXHJcbiAgLy8gICBhdHRlbnRpb25fYmlhcyAgICAgICAgICA6IChCLCBOLCBTLCBUKSBvciBOVUxMXHJcblxyXG4gIC8vIEZvciBtYXNrX2luZGV4LCB0aGUgZm9sbG93aW5nIHNoYXBlcyBhcmUgc3VwcG9ydGVkOlxyXG4gIC8vICAgICBOVUxMLCAoQiwgMSksICgxLCAxKVxyXG4gIC8vICAgICAoQiksICgyICogQiksICgzICogQiArIDIpXHJcbiAgLy8gICAgIChCLCBUKVxyXG4gIC8vICAgICAoQiwgUywgVClcclxuICAvLyAgICAgKEIsIDEsIE0sIE0pXHJcbiAgLy9cclxuICAvLyBXaGVuIGEgbW9kZWwgaXMgcHJ1bmVkIChsaWtlIHNvbWUgYXR0ZW50aW9uIGhlYWRzIGFyZSByZW1vdmVkIGluIFEvSy9WKSwgaW5wdXRfaGlkZGVuX3NpemUgY291bGQgYmUgbGFyZ2VyXHJcbiAgLy8gdGhhbiBoaWRkZW4gZGltZW5zaW9uIG9mIFEsIEsgYW5kIFYuXHJcblxyXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRzWzBdO1xyXG4gIGNvbnN0IHdlaWdodHMgPSBpbnB1dHNbMV07XHJcbiAgY29uc3QgYmlhcyA9IGlucHV0c1syXTtcclxuICBjb25zdCBtYXNrSW5kZXggPSBpbnB1dHNbM107XHJcbiAgY29uc3QgcGFzdCA9IGlucHV0c1s0XTtcclxuICBjb25zdCBhdHRlbnRpb25CaWFzID0gaW5wdXRzWzVdO1xyXG5cclxuICBpZiAocGFzdCAmJiBhdHRlbnRpb25CaWFzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIGF0dGVudGlvbl9iaWFzJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IDMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0LmRpbXNbMF07XHJcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dC5kaW1zWzFdO1xyXG4gIGNvbnN0IGlucHV0SGlkZGVuU2l6ZSA9IGlucHV0LmRpbXNbMl07XHJcblxyXG4gIGlmIChiaWFzLmRpbXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zJyk7XHJcbiAgfVxyXG5cclxuICBpZiAod2VpZ2h0cy5kaW1zLmxlbmd0aCAhPT0gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcIndlaWdodHNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHdlaWdodHMuZGltc1swXSAhPT0gaW5wdXRIaWRkZW5TaXplKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGJpYXMuZGltc1swXSAhPT0gd2VpZ2h0cy5kaW1zWzFdKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAxIG9mIGlucHV0IFwid2VpZ2h0c1wiJyk7XHJcbiAgfVxyXG5cclxuICBsZXQgcUhpZGRlblNpemUgPSBiaWFzLmRpbXNbMF0gLyAzO1xyXG4gIGxldCBrSGlkZGVuU2l6ZSA9IHFIaWRkZW5TaXplO1xyXG4gIGxldCB2SGlkZGVuU2l6ZSA9IGtIaWRkZW5TaXplO1xyXG4gIGlmIChhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzLmxlbmd0aCA+IDApIHtcclxuICAgIGlmIChhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzLmxlbmd0aCAhPT0gMykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHMnKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qgc3ogb2YgYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplcykge1xyXG4gICAgICBpZiAoc3ogJSBhdHRyaWJ1dGVzLm51bUhlYWRzICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxa3ZfaGlkZGVuX3NpemVzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgbnVtX2hlYWRzJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBxSGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMF07XHJcbiAgICBrSGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMV07XHJcbiAgICB2SGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMl07XHJcbiAgfVxyXG5cclxuICBjb25zdCBrdlNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XHJcblxyXG4gIGlmIChxSGlkZGVuU2l6ZSAhPT0ga0hpZGRlblNpemUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigncWt2X2hpZGRlbl9zaXplcyBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBzYW1lIGFzIHRoZSBzZWNvbmQnKTtcclxuICB9XHJcblxyXG4gIGlmIChiaWFzLmRpbXNbMF0gIT09IHFIaWRkZW5TaXplICsga0hpZGRlblNpemUgKyB2SGlkZGVuU2l6ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBzdW0gb2YgUS9LL1YgaGlkZGVuIHNpemVzJyk7XHJcbiAgfVxyXG5cclxuICBsZXQgcGFzdFNlcXVlbmNlTGVuZ3RoID0gMDtcclxuICBpZiAocGFzdCkge1xyXG4gICAgaWYgKGtIaWRkZW5TaXplICE9PSB2SGlkZGVuU2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGV4cGVjdCBrX2hpZGRlbl9zaXplID09IHZfaGlkZGVuX3NpemUnKTtcclxuICAgIH1cclxuICAgIGlmIChwYXN0LmRpbXMubGVuZ3RoICE9PSA1KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgbXVzdCBoYXZlIDUgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhc3QuZGltc1swXSAhPT0gMikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpcnN0IGRpbWVuc2lvbiBtdXN0IGJlIDInKTtcclxuICAgIH1cclxuICAgIGlmIChwYXN0LmRpbXNbMV0gIT09IGJhdGNoU2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIHNlY29uZCBkaW1lbnNpb24gbXVzdCBiZSBiYXRjaF9zaXplJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFzdC5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgdGhpcmQgZGltZW5zaW9uIG11c3QgYmUgbnVtX2hlYWRzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFzdC5kaW1zWzRdICE9PSBrSGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaWZ0aCBkaW1lbnNpb24gbXVzdCBiZSBrX2hpZGRlbl9zaXplIC8gbnVtX2hlYWRzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhdHRyaWJ1dGVzLnBhc3RQcmVzZW50U2hhcmVCdWZmZXIpIHtcclxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdC5kaW1zWzNdO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogaGFuZGxlIHBhc3Rfc2VxX2xlblxyXG4gIH1cclxuXHJcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IGt2U2VxdWVuY2VMZW5ndGggKyBwYXN0U2VxdWVuY2VMZW5ndGg7XHJcbiAgY29uc3QgbWF4U2VxdWVuY2VMZW5ndGggPSAtMTtcclxuXHJcbiAgY29uc3QgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5ub25lO1xyXG4gIGlmIChtYXNrSW5kZXgpIHtcclxuICAgIC8vIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUuTUFTS19VTktOT1dOO1xyXG4gICAgLy8gVE9ETzogaGFuZGxlIG1hc2tcclxuICAgIHRocm93IG5ldyBFcnJvcignTWFzayBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgfVxyXG5cclxuICBpZiAocGFzdCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXN0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICB9XHJcblxyXG4gIGlmIChhdHRlbnRpb25CaWFzKSB7XHJcbiAgICBpZiAoYXR0ZW50aW9uQmlhcy5kaW1zLmxlbmd0aCAhPT0gNCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBtdXN0IGhhdmUgNCBkaW1lbnNpb25zJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogc3VwcG9ydCBicm9hZGNhc3RpbmcgdGhlIGZpcnN0IGFuZCBzZWNvbmQgZGltZW5zaW9ucyBvZiBhdHRlbnRpb25fYmlhc1xyXG4gICAgaWYgKFxyXG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMF0gIT09IGJhdGNoU2l6ZSB8fFxyXG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHxcclxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzJdICE9PSBzZXF1ZW5jZUxlbmd0aCB8fFxyXG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbM10gIT09IHRvdGFsU2VxdWVuY2VMZW5ndGhcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYmF0Y2hTaXplLFxyXG4gICAgc2VxdWVuY2VMZW5ndGgsXHJcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXHJcbiAgICBrdlNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcclxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgaW5wdXRIaWRkZW5TaXplLFxyXG4gICAgaGlkZGVuU2l6ZTogcUhpZGRlblNpemUsXHJcbiAgICB2SGlkZGVuU2l6ZSxcclxuICAgIGhlYWRTaXplOiBNYXRoLmZsb29yKHFIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyksXHJcbiAgICB2SGVhZFNpemU6IE1hdGguZmxvb3IodkhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcclxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxyXG4gICAgaXNVbmlkaXJlY3Rpb25hbDogZmFsc2UsXHJcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcclxuICAgIG1hc2tGaWx0ZXJWYWx1ZTogYXR0cmlidXRlcy5tYXNrRmlsdGVyVmFsdWUsXHJcbiAgICBtYXNrVHlwZSxcclxuICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxyXG4gICAgYnJvYWRjYXN0UmVzUG9zQmlhczogZmFsc2UsXHJcbiAgICBwYXNzUGFzdEluS3Y6IGZhbHNlLFxyXG4gICAgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2Qk5TSCxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgaW5pdFZhclN0dWIgPSAoXHJcbiAgc2VxTGVuc0lucHV0OiBJbmRpY2VzSGVscGVyIHwgdW5kZWZpbmVkLFxyXG4gIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dDogSW5kaWNlc0hlbHBlciB8IHVuZGVmaW5lZCxcclxuICBpbml0UGFzdFNlcXVlbmNlTGVuZ3RoOiBib29sZWFuLFxyXG4pID0+IHtcclxuICAvLyBJbiB0aGUgY2FzZSBvZiBHUUEsIHJlZGVmaW5lIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggYW5kIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIGJhc2VkIG9uIHNlcWxlbl9rIGlucHV0XHJcbiAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCAmJiBzZXFMZW5zSW5wdXQpIHtcclxuICAgIHJldHVybiBgXHJcbiAgICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQgPSB1MzIoJHt0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZ2V0QnlPZmZzZXQoJzAnKX0pO1xyXG4gICAgICBsZXQgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggPSBtYXgodG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0LCB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCk7XHJcbiAgICAgIGxldCBpc19zdWJzZXF1ZW50X3Byb21wdDogYm9vbCA9IHNlcXVlbmNlX2xlbmd0aCA+IDEgJiYgc2VxdWVuY2VfbGVuZ3RoICE9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dDtcclxuICAgICAgbGV0IGlzX2ZpcnN0X3Byb21wdDogYm9vbCA9IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID09IGZhbHNlICYmIHNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XHJcbiAgICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHUzMigke3NlcUxlbnNJbnB1dD8uZ2V0QnlPZmZzZXQoJ2JhdGNoSWR4Jyl9KSArIDE7XHJcbiAgICAgIHZhciBwYXN0X3NlcXVlbmNlX2xlbmd0aDogdTMyID0gMDtcclxuICAgICAgaWYgKGlzX2ZpcnN0X3Byb21wdCA9PSBmYWxzZSkge1xyXG4gICAgICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoID0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoIC0gc2VxdWVuY2VfbGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgICBgO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gYFxyXG4gICAgJHtpbml0UGFzdFNlcXVlbmNlTGVuZ3RoID8gJ2xldCBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoJyA6ICcnfTtcclxuICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcclxuICAgIGA7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlSW5QbGFjZVNvZnRtYXhQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dDogVGVuc29yVmlldyxcclxuICBiYXRjaFNpemU6IG51bWJlcixcclxuICBudW1IZWFkczogbnVtYmVyLFxyXG4gIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxyXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXHJcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxyXG4gIHNlcUxlbnM6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxyXG4pID0+IHtcclxuICAvLyBTZXQgY29tcG9uZW50cyB0byAxIGlmIHNlcUxlbnMgaXMgc3BlY2lmaWVkLCBpLmUuIEdyb3VwUXVlcnlBdHRlbnRpb24uXHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoc2VxTGVucyA/IDEgOiB0b3RhbFNlcXVlbmNlTGVuZ3RoKTtcclxuICBsZXQgV0cgPSA2NDtcclxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoQ29tcCA9IHRvdGFsU2VxdWVuY2VMZW5ndGggLyBjb21wb25lbnRzO1xyXG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoQ29tcCA8IFdHKSB7XHJcbiAgICBXRyA9IDMyO1xyXG4gIH1cclxuICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9IE1hdGguY2VpbCh0b3RhbFNlcXVlbmNlTGVuZ3RoIC8gY29tcG9uZW50cyAvIFdHKTtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmF0Y2hTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbnVtSGVhZHMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzZXF1ZW5jZUxlbmd0aCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHRvdGFsU2VxdWVuY2VMZW5ndGhDb21wIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWxlbWVudHNQZXJUaHJlYWQgfSxcclxuICBdO1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0LmRhdGFUeXBlLCBjb21wb25lbnRzKTtcclxuICBjb25zdCBmMzJUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnXTtcclxuICBpZiAoc2VxTGVucykge1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xyXG4gIH1cclxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaW5wdXRIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGlucHV0SGVscGVycyA9IFtpbnB1dEhlbHBlcl07XHJcbiAgICBjb25zdCBzZXFMZW5zSW5wdXRIZWxwZXIgPSBzZXFMZW5zID8gaW5wdXRWYXJpYWJsZSgnc2VxX2xlbnMnLCBzZXFMZW5zLmRhdGFUeXBlLCBzZXFMZW5zLmRpbXMpIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKHNlcUxlbnNJbnB1dEhlbHBlcikge1xyXG4gICAgICBpbnB1dEhlbHBlcnMucHVzaChzZXFMZW5zSW5wdXRIZWxwZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dEhlbHBlciA9IHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFxyXG4gICAgICA/IGlucHV0VmFyaWFibGUoJ3RvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCcsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dC5kYXRhVHlwZSwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRpbXMpXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dEhlbHBlcikge1xyXG4gICAgICBpbnB1dEhlbHBlcnMucHVzaCh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXRIZWxwZXIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWxlbVZhbHVlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoaW5wdXQuZGF0YVR5cGUpO1xyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdiYXRjaF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnbnVtX2hlYWRzJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAncGFzdF9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdzZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICd0b3RhbF9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdlbGVtZW50c19wZXJfdGhyZWFkJywgdHlwZTogJ3UzMicgfSxcclxuICAgIF07XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfbWF4OiBhcnJheTxmMzIsICR7V0d9PjtcclxuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfc3VtOiBhcnJheTxmMzIsICR7V0d9PjtcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0SGVscGVycyl9XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtXRywgMSwgMV0pfVxyXG4gICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XHJcbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xyXG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aDtcclxuICAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XHJcbiAgICAke2luaXRWYXJTdHViKHNlcUxlbnNJbnB1dEhlbHBlciwgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0SGVscGVyLCBmYWxzZSl9XHJcbiAgICBsZXQgbG9jYWxfb2Zmc2V0ID0gbG9jYWxfaWR4ICogdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZDtcclxuICAgIGxldCBvZmZzZXQgPSAoZ2xvYmFsX2lkeCAvICR7V0d9KSAqIHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aCArIGxvY2FsX29mZnNldDtcclxuICAgIGxldCBzZXFfY2F1c2FsX2xlbmd0aCA9ICR7c2VxTGVucyA/ICd1MzIocGFzdF9zZXF1ZW5jZV9sZW5ndGggKyB3b3JrZ3JvdXBfaWQueSArIDEpJyA6ICd0b3RhbF9zZXF1ZW5jZV9sZW5ndGgnfTtcclxuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7ZjMyVHlwZX0oLTMuNDAyODIzZSszOGYpO1xyXG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhyZWFkX21heF92ZWN0b3IgPSBtYXgoJHtmMzJUeXBlfSh4W29mZnNldCArIGldKSwgdGhyZWFkX21heF92ZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgdGhyZWFkX21heFtsb2NhbF9pZHhdID0gJHsoKCkgPT4ge1xyXG4gICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICByZXR1cm4gJ3RocmVhZF9tYXhfdmVjdG9yJztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICByZXR1cm4gJ21heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSc7XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgcmV0dXJuICdtYXgobWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpLCBtYXgodGhyZWFkX21heF92ZWN0b3IueiwgdGhyZWFkX21heF92ZWN0b3IudykpJztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2NvbXBvbmVudHN9YCk7XHJcbiAgICAgIH1cclxuICAgIH0pKCl9O1xyXG4gICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgIHZhciBtYXhfdmFsdWUgPSAgZjMyKC0zLjQwMjgyM2UrMzhmKTtcclxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7V0d9OyBpKyspIHtcclxuICAgICAgbWF4X3ZhbHVlID0gbWF4KHRocmVhZF9tYXhbaV0sIG1heF92YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN1bV92ZWN0b3IgPSAke2YzMlR5cGV9KDApO1xyXG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcclxuICAgICAgc3VtX3ZlY3RvciArPSBleHAoJHtmMzJUeXBlfSh4W29mZnNldCArIGldKSAtIG1heF92YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB0aHJlYWRfc3VtW2xvY2FsX2lkeF0gPSAkeygoKSA9PiB7XHJcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHJldHVybiAnc3VtX3ZlY3Rvcic7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnknO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIHJldHVybiAnc3VtX3ZlY3Rvci54ICsgc3VtX3ZlY3Rvci55ICsgc3VtX3ZlY3Rvci56ICsgc3VtX3ZlY3Rvci53JztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2NvbXBvbmVudHN9YCk7XHJcbiAgICAgIH1cclxuICAgIH0pKCl9O1xyXG4gICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgIHZhciBzdW06IGYzMiA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke1dHfTsgaSsrKSB7XHJcbiAgICAgIHN1bSArPSB0aHJlYWRfc3VtW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdW0gPT0gMCkge1xyXG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke2lucHV0SGVscGVyLnR5cGUudmFsdWV9KCR7ZWxlbVZhbHVlVHlwZX0oMS4wKSAvICR7ZWxlbVZhbHVlVHlwZX0oc2VxX2NhdXNhbF9sZW5ndGgpKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgZjMyaW5wdXQgPSAke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pO1xyXG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke2lucHV0SGVscGVyLnR5cGUudmFsdWV9KGV4cChmMzJpbnB1dCAtIG1heF92YWx1ZSkgLyBzdW0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAgICR7XHJcbiAgICAgICAgc2VxTGVuc1xyXG4gICAgICAgICAgPyBgXHJcbiAgICAgICAgZm9yICh2YXIgdG90YWxfc2VxX2lkOiB1MzIgPSBzZXFfY2F1c2FsX2xlbmd0aDsgdG90YWxfc2VxX2lkICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoOyB0b3RhbF9zZXFfaWQrKykge1xyXG4gICAgICAgICAgeFtvZmZzZXQgKyB0b3RhbF9zZXFfaWRdID0gJHtpbnB1dEhlbHBlci50eXBlLnZhbHVlfSgke2VsZW1WYWx1ZVR5cGV9KDApKTtcclxuICAgICAgICB9YFxyXG4gICAgICAgICAgOiAnJ1xyXG4gICAgICB9O1xyXG4gIH1gO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnQXR0ZW50aW9uUHJvYnNTb2Z0bWF4JyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke1dHfTske2RhdGFUeXBlfTske2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFtdLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IDEsIHk6IHNlcXVlbmNlTGVuZ3RoLCB6OiBiYXRjaFNpemUgKiBudW1IZWFkcyB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlQXR0ZW50aW9uUHJvYnNQcm9ncmFtSW5mbyA9IChcclxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxyXG4gIHE6IFRlbnNvclZpZXcsXHJcbiAga2V5OiBUZW5zb3JWaWV3LFxyXG4gIHBhc3RLZXk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbiAgYXR0ZW50aW9uQmlhczogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcclxuICBwYXJhbWV0ZXJzOiBBdHRlbnRpb25QYXJhbWV0ZXJzLFxyXG4gIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxyXG4gIHNlcUxlbnM6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxyXG4pID0+IHtcclxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsgcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RoO1xyXG4gIGNvbnN0IHByb2JzU2hhcGUgPSBbcGFyYW1ldGVycy5iYXRjaFNpemUsIHBhcmFtZXRlcnMubnVtSGVhZHMsIHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGgsIHRvdGFsU2VxdWVuY2VMZW5ndGhdO1xyXG4gIGNvbnN0IHByZXNlbnRLZXkgPSBvdXRwdXRDb3VudCA+IDEgJiYgcGFzdEtleTtcclxuICBjb25zdCBrdk51bUhlYWRzID0gcGFyYW1ldGVycy5rdk51bUhlYWRzID8gcGFyYW1ldGVycy5rdk51bUhlYWRzIDogcGFyYW1ldGVycy5udW1IZWFkcztcclxuICBjb25zdCBwcmVzZW50S2V5U2hhcGUgPSBwcmVzZW50S2V5XHJcbiAgICA/IFtwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwga3ZOdW1IZWFkcywgdG90YWxTZXF1ZW5jZUxlbmd0aCwgcGFyYW1ldGVycy5oZWFkU2l6ZV1cclxuICAgIDogdW5kZWZpbmVkO1xyXG4gIGNvbnN0IG5SZXBzID0gcGFyYW1ldGVycy5uUmVwcyA/IHBhcmFtZXRlcnMublJlcHMgOiAxO1xyXG4gIC8vIFRPRE86IGhhbmRsZSBtYXNrXHJcblxyXG4gIGNvbnN0IGFscGhhID0gcGFyYW1ldGVycy5zY2FsZSA9PT0gMCA/IDEuMCAvIE1hdGguc3FydChwYXJhbWV0ZXJzLmhlYWRTaXplKSA6IHBhcmFtZXRlcnMuc2NhbGU7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMocGFyYW1ldGVycy5oZWFkU2l6ZSk7XHJcbiAgY29uc3QgdmVjdG9yaXplZEhlYWRTaXplID0gcGFyYW1ldGVycy5oZWFkU2l6ZSAvIGNvbXBvbmVudHM7XHJcbiAgY29uc3QgVElMRV9TSVpFID0gMTI7XHJcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XHJcbiAgICB4OiBNYXRoLmNlaWwodG90YWxTZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXHJcbiAgICB5OiBNYXRoLmNlaWwocGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXHJcbiAgICB6OiBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHMsXHJcbiAgfTtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHZlY3Rvcml6ZWRIZWFkU2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHRvdGFsU2VxdWVuY2VMZW5ndGggfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLm51bUhlYWRzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5oZWFkU2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYWxwaGEgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmt2U2VxdWVuY2VMZW5ndGggfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBuUmVwcyB9LFxyXG4gIF07XHJcbiAgLy8gRmVlZCBwYXN0S2V5IHRvIHRoZSBzaGFkZXItY29kZSBvbmx5IGlmIGl0IGlzIG5vbi16ZXJvIGFuZCBwcmVzZW50S2V5IGlzIGJlaW5nIHByb2R1Y2VkXHJcbiAgY29uc3QgZmVlZFBhc3RLZXkgPSBwcmVzZW50S2V5ICYmIHBhc3RLZXkgJiYgU2hhcGVVdGlsLnNpemUocGFzdEtleS5kaW1zKSA+IDA7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xyXG4gIGlmIChmZWVkUGFzdEtleSkge1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xyXG4gIH1cclxuICBpZiAoYXR0ZW50aW9uQmlhcykge1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xyXG4gIH1cclxuICBpZiAoc2VxTGVucykge1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xyXG4gIH1cclxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBwcm9ic1NoYXBlLCBkYXRhVHlwZTogcS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfV07XHJcbiAgaWYgKHByZXNlbnRLZXkpIHtcclxuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IHByZXNlbnRLZXlTaGFwZSEsIGRhdGFUeXBlOiBxLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9KTtcclxuICB9XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBxSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdxJywgcS5kYXRhVHlwZSwgcS5kaW1zLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGtJbnB1dCA9IGlucHV0VmFyaWFibGUoJ2tleScsIGtleS5kYXRhVHlwZSwga2V5LmRpbXMsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3FJbnB1dCwga0lucHV0XTtcclxuICAgIGlmIChmZWVkUGFzdEtleSkge1xyXG4gICAgICBjb25zdCBwYXN0S2V5SW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdwYXN0X2tleScsIHBhc3RLZXkuZGF0YVR5cGUsIHBhc3RLZXkuZGltcywgY29tcG9uZW50cyk7XHJcbiAgICAgIGlucHV0VmFycy5wdXNoKHBhc3RLZXlJbnB1dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXR0ZW50aW9uQmlhcykge1xyXG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdhdHRlbnRpb25fYmlhcycsIGF0dGVudGlvbkJpYXMuZGF0YVR5cGUsIGF0dGVudGlvbkJpYXMuZGltcykpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VxTGVuc0lucHV0VmFyaWFibGUgPSBzZXFMZW5zID8gaW5wdXRWYXJpYWJsZSgnc2VxX2xlbnMnLCBzZXFMZW5zLmRhdGFUeXBlLCBzZXFMZW5zLmRpbXMpIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKHNlcUxlbnNJbnB1dFZhcmlhYmxlKSB7XHJcbiAgICAgIGlucHV0VmFycy5wdXNoKHNlcUxlbnNJbnB1dFZhcmlhYmxlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlID0gdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0XHJcbiAgICAgID8gaW5wdXRWYXJpYWJsZSgndG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0JywgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRhdGFUeXBlLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGltcylcclxuICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUpIHtcclxuICAgICAgaW5wdXRWYXJzLnB1c2godG90YWxTZXF1ZW5jZUxlbmd0aElucHV0VmFyaWFibGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHEuZGF0YVR5cGUsIHByb2JzU2hhcGUpO1xyXG4gICAgY29uc3Qgb3V0cHV0VmFycyA9IFtvdXRwdXRdO1xyXG4gICAgaWYgKHByZXNlbnRLZXkpIHtcclxuICAgICAgb3V0cHV0VmFycy5wdXNoKG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X2tleScsIHEuZGF0YVR5cGUsIHByZXNlbnRLZXlTaGFwZSEsIGNvbXBvbmVudHMpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGYzMlR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKERhdGFUeXBlLmZsb2F0LCBjb21wb25lbnRzKTtcclxuXHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ00nLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdLJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ251bV9oZWFkcycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2hlYWRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMicgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxyXG4gICAgICB7IG5hbWU6ICdwYXN0X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2t2X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ25fcmVwcycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGBcclxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xyXG5cclxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtxSW5wdXQudHlwZS5zdG9yYWdlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcclxuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHtxSW5wdXQudHlwZS5zdG9yYWdlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgLi4ub3V0cHV0VmFycyl9XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtUSUxFX1NJWkUsIFRJTEVfU0laRSwgMV0pfVxyXG4gICAgLy8geCBob2xkcyB0aGUgTiBhbmQgeSBob2xkcyB0aGUgTVxyXG4gICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcclxuICAgIGxldCBrdkhlYWRJZHggPSAke25SZXBzID09PSAxID8gJ2hlYWRJZHgnIDogJ2hlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHMnfTtcclxuICAgIGxldCBrdl9udW1faGVhZHMgPSAke25SZXBzID09PSAxID8gJ3VuaWZvcm1zLm51bV9oZWFkcycgOiAndW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzJ307XHJcbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcclxuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XHJcbiAgICBsZXQgbiA9IHdvcmtncm91cF9pZC54ICogVElMRV9TSVpFO1xyXG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XHJcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTjtcclxuICAgICR7aW5pdFZhclN0dWIoc2VxTGVuc0lucHV0VmFyaWFibGUsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlLCB0cnVlKX1cclxuICAgIGxldCBhYnNLdkhlYWRJZHggPSBiYXRjaElkeCAqIGt2X251bV9oZWFkcyArIGt2SGVhZElkeDtcclxuICAgIGxldCBxT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xyXG4gICAgJHtmZWVkUGFzdEtleSAmJiBwcmVzZW50S2V5ID8gJ2xldCBwYXN0S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LOycgOiAnJ307XHJcbiAgICBsZXQga09mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLks7XHJcbiAgICAke3ByZXNlbnRLZXkgPyAnbGV0IHByZXNlbnRLZXlPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSzsnIDogJyd9XHJcbiAgICB2YXIgdmFsdWUgPSAke2YzMlR5cGV9KDApO1xyXG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xyXG4gICAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xyXG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHFbcU9mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xyXG4gICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgaWYgKGZlZWRQYXN0S2V5ICYmIHByZXNlbnRLZXkpIHtcclxuICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgcGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBwYXN0X2tleVtwYXN0S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlS1tpZHhdID0ga2V5W2tPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xyXG4gICAgICAgICAgICAgIH1gO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xyXG4gICAgICAgICAgfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KSgpfVxyXG4gICAgICAke1xyXG4gICAgICAgIHByZXNlbnRLZXlcclxuICAgICAgICAgID8gYGlmIChuICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XHJcbiAgICAgICAgcHJlc2VudF9rZXlbcHJlc2VudEtleU9mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdID0gdGlsZUtbaWR4XTtcclxuICAgICAgfWBcclxuICAgICAgICAgIDogJydcclxuICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xyXG4gICAgICAgICAgdmFsdWUgKz0gJHtmMzJUeXBlfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCkge1xyXG4gICAgICBsZXQgaGVhZE9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XHJcbiAgICAgIGxldCBvdXRwdXRJZHggPSBoZWFkT2Zmc2V0ICsgZ2xvYmFsX2lkLnkgKiB1bmlmb3Jtcy5OICsgZ2xvYmFsX2lkLng7XHJcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgcmV0dXJuICd2YWx1ZSc7XHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHJldHVybiAndmFsdWUueCArIHZhbHVlLnknO1xyXG4gICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICByZXR1cm4gJ3ZhbHVlLnggKyB2YWx1ZS55ICsgdmFsdWUueiArIHZhbHVlLncnO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2NvbXBvbmVudHN9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KSgpfTtcclxuICAgICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9IChzdW0gKiB1bmlmb3Jtcy5hbHBoYSkgKyAke1xyXG4gICAgICAgICAgYXR0ZW50aW9uQmlhcyA/ICdhdHRlbnRpb25fYmlhc1tvdXRwdXRJZHhdJyA6ICcwLjAnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnQXR0ZW50aW9uUHJvYnMnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7Y29tcG9uZW50c307JHthdHRlbnRpb25CaWFzICE9PSB1bmRlZmluZWR9OyR7cGFzdEtleSAhPT0gdW5kZWZpbmVkfTske291dHB1dENvdW50fWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxyXG4gICAgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7IG91dHB1dHMsIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLCBwcm9ncmFtVW5pZm9ybXMgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZVZ4QXR0ZW50aW9uU2NvcmVQcm9ncmFtSW5mbyA9IChcclxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxyXG4gIHByb2JzOiBUZW5zb3JWaWV3LFxyXG4gIHY6IFRlbnNvclZpZXcsXHJcbiAgcGFzdFZhbHVlOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxyXG4gIHBhcmFtczogQXR0ZW50aW9uUGFyYW1ldGVycyxcclxuICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcixcclxuICBzZXFMZW5zOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxyXG4gIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcclxuKSA9PiB7XHJcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoO1xyXG4gIGNvbnN0IG5SZXBzID0gcGFyYW1zLm5SZXBzID8gcGFyYW1zLm5SZXBzIDogMTtcclxuICBjb25zdCByZXBlYXRlZFZIaWRkZW5TaXplID0gcGFyYW1zLnZIaWRkZW5TaXplICogblJlcHM7XHJcbiAgY29uc3QgcHJlc2VudFZhbHVlID0gb3V0cHV0Q291bnQgPiAxICYmIHBhc3RWYWx1ZTtcclxuICBjb25zdCBrdk51bUhlYWRzID0gcGFyYW1zLmt2TnVtSGVhZHMgPyBwYXJhbXMua3ZOdW1IZWFkcyA6IHBhcmFtcy5udW1IZWFkcztcclxuICBjb25zdCBwcmVzZW50VmFsdWVTaGFwZSA9IHByZXNlbnRWYWx1ZVxyXG4gICAgPyBbcGFyYW1zLmJhdGNoU2l6ZSwga3ZOdW1IZWFkcywgdG90YWxTZXF1ZW5jZUxlbmd0aCwgcGFyYW1zLmhlYWRTaXplXVxyXG4gICAgOiB1bmRlZmluZWQ7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLnNlcXVlbmNlTGVuZ3RoLCByZXBlYXRlZFZIaWRkZW5TaXplXTtcclxuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcclxuICBjb25zdCBkaXNwYXRjaCA9IHtcclxuICAgIHg6IE1hdGguY2VpbChwYXJhbXMudkhlYWRTaXplIC8gVElMRV9TSVpFKSxcclxuICAgIHk6IE1hdGguY2VpbChwYXJhbXMuc2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxyXG4gICAgejogcGFyYW1zLmJhdGNoU2l6ZSAqIHBhcmFtcy5udW1IZWFkcyxcclxuICB9O1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLnNlcXVlbmNlTGVuZ3RoIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy52SGVhZFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMubnVtSGVhZHMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMuaGVhZFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiByZXBlYXRlZFZIaWRkZW5TaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFzdFNlcXVlbmNlTGVuZ3RoIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGggfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBuUmVwcyB9LFxyXG4gIF07XHJcbiAgLy8gRmVlZCBwYXN0VmFsdWUgdG8gdGhlIHNoYWRlci1jb2RlIG9ubHkgaWYgaXQgaXMgbm9uLWVtcHR5IGFuZCBwcmVzZW50VmFsdWUgaXMgYmVpbmcgcHJvZHVjZWRcclxuICBjb25zdCBmZWVkUGFzdFZhbHVlID0gcHJlc2VudFZhbHVlICYmIHBhc3RWYWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0VmFsdWUuZGltcykgPiAwO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcclxuICBpZiAoZmVlZFBhc3RWYWx1ZSkge1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xyXG4gIH1cclxuICBpZiAoc2VxTGVucykge1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xyXG4gIH1cclxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XHJcbiAgfVxyXG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9XTtcclxuICBpZiAocHJlc2VudFZhbHVlKSB7XHJcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBwcmVzZW50VmFsdWVTaGFwZSEsIGRhdGFUeXBlOiBwcm9icy5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfSk7XHJcbiAgfVxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgcHJvYnNIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdwcm9icycsIHByb2JzLmRhdGFUeXBlLCBwcm9icy5kaW1zKTtcclxuICAgIGNvbnN0IHZIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCd2Jywgdi5kYXRhVHlwZSwgdi5kaW1zKTtcclxuICAgIGNvbnN0IGlucHV0VmFycyA9IFtwcm9ic0hlbHBlciwgdkhlbHBlcl07XHJcbiAgICBpZiAoZmVlZFBhc3RWYWx1ZSkge1xyXG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdwYXN0X3ZhbHVlJywgcGFzdFZhbHVlLmRhdGFUeXBlLCBwYXN0VmFsdWUuZGltcykpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VxTGVuc0lucHV0VmFyaWFibGUgPSBzZXFMZW5zID8gaW5wdXRWYXJpYWJsZSgnc2VxX2xlbnMnLCBzZXFMZW5zLmRhdGFUeXBlLCBzZXFMZW5zLmRpbXMpIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKHNlcUxlbnMpIHtcclxuICAgICAgaW5wdXRWYXJzLnB1c2goc2VxTGVuc0lucHV0VmFyaWFibGUhKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlID0gdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0XHJcbiAgICAgID8gaW5wdXRWYXJpYWJsZSgndG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0JywgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LmRhdGFUeXBlLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQuZGltcylcclxuICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XHJcbiAgICAgIGlucHV0VmFycy5wdXNoKHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlISk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcHJvYnMuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcclxuICAgIGNvbnN0IG91dHB1dFZhcnMgPSBbb3V0cHV0XTtcclxuICAgIGlmIChwcmVzZW50VmFsdWUpIHtcclxuICAgICAgb3V0cHV0VmFycy5wdXNoKG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X3ZhbHVlJywgcHJvYnMuZGF0YVR5cGUsIHByZXNlbnRWYWx1ZVNoYXBlISkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdoZWFkX3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICd2X2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAncGFzdF9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdrdl9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICduX3JlcHMnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgXTtcclxuICAgIHJldHVybiBgXHJcbiAgY29uc3QgVElMRV9TSVpFID0gJHtUSUxFX1NJWkV9dTtcclxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtwcm9ic0hlbHBlci50eXBlLnZhbHVlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcclxuICB2YXI8d29ya2dyb3VwPiB0aWxlVjogYXJyYXk8JHtwcm9ic0hlbHBlci50eXBlLnZhbHVlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcclxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgLi4ub3V0cHV0VmFycyl9XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtUSUxFX1NJWkUsIFRJTEVfU0laRSwgMV0pfVxyXG4gICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xyXG4gICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcclxuICAgbGV0IGt2SGVhZElkeCA9ICR7blJlcHMgPT09IDEgPyAnaGVhZElkeCcgOiAnaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwcyd9O1xyXG4gICBsZXQga3ZfbnVtX2hlYWRzID0gJHtuUmVwcyA9PT0gMSA/ICd1bmlmb3Jtcy5udW1faGVhZHMnIDogJ3VuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwcyd9O1xyXG4gICBsZXQgbSA9IGdsb2JhbF9pZC55O1xyXG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xyXG4gICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcclxuICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLks7XHJcbiAgICR7aW5pdFZhclN0dWIoc2VxTGVuc0lucHV0VmFyaWFibGUsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dFZhcmlhYmxlLCB0cnVlKX1cclxuICAgbGV0IG9mZnNldEEgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XHJcbiAgIGxldCBhYnNLdkhlYWRJZHggPSBiYXRjaElkeCAqIGt2X251bV9oZWFkcyArIGt2SGVhZElkeDsgLy8ga3ZIZWFkSWR4IGlzIHJlbGF0aXZlIHRvIHRoZSBiYXRjaFxyXG4gICAke2ZlZWRQYXN0VmFsdWUgJiYgcHJlc2VudFZhbHVlID8gJ2xldCBwYXN0VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBuOycgOiAnJ307XHJcbiAgIGxldCB2T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCArIG47XHJcbiAgICR7cHJlc2VudFZhbHVlID8gJ2xldCBwcmVzZW50VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyArIG47JyA6ICcnfVxyXG4gICB2YXIgdmFsdWUgPSAke3Byb2JzSGVscGVyLnR5cGUuc3RvcmFnZX0oMCk7XHJcbiAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcclxuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xyXG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHByb2JzW29mZnNldEEgKyB3ICsgbG9jYWxfaWQueF07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xyXG4gICAgICAgIHZhciBpZHggPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueDtcclxuICAgICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoZmVlZFBhc3RWYWx1ZSAmJiBwcmVzZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCBwYXN0X3NlcXVlbmNlX2xlbmd0aCkge1xyXG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xyXG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHZbdk9mZnNldCArICh3ICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLk5dO1xyXG4gICAgICAgIH1cclxuICAgICAgYDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xyXG4gICAgICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKCl9XHJcbiAgICAgICAgJHtcclxuICAgICAgICAgIHByZXNlbnRWYWx1ZVxyXG4gICAgICAgICAgICA/IGBcclxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGgpIHtcclxuICAgICAgICAgIHByZXNlbnRfdmFsdWVbcHJlc2VudFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dID0gdGlsZVZbaWR4XTtcclxuICAgICAgICB9YFxyXG4gICAgICAgICAgICA6ICcnXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgaysrKSB7XHJcbiAgICAgICB2YWx1ZSArPSB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlVltUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueF07XHJcbiAgICAgfVxyXG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuICAgfVxyXG5cclxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxyXG4gICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcclxuICAgICBsZXQgb3V0cHV0SWR4ID0gYmF0Y2hJZHggKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZSArIG0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplXHJcbiAgICAgICArIGhlYWRJZHggKiB1bmlmb3Jtcy5OICsgbjtcclxuICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9IHZhbHVlO1xyXG4gICB9XHJcbiAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdBdHRlbnRpb25TY29yZScsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtwYXN0VmFsdWUgIT09IHVuZGVmaW5lZH07JHtvdXRwdXRDb3VudH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHsgb3V0cHV0cywgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsIHByb2dyYW1Vbmlmb3JtcyB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFwcGx5QXR0ZW50aW9uID0gKFxyXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxyXG4gIHE6IFRlbnNvclZpZXcsXHJcbiAgazogVGVuc29yVmlldyxcclxuICB2OiBUZW5zb3JWaWV3LFxyXG4gIF9tYXNrSW5kZXg6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbiAgX3Bhc3Q6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbiAgcGFzdEtleTogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcclxuICBwYXN0VmFsdWU6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXHJcbiAgYXR0ZW50aW9uQmlhc0lucHV0OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxyXG4gIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsXHJcbiAgc2VxTGVuczogVGVuc29yVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcclxuICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQ6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQsXHJcbikgPT4ge1xyXG4gIC8vIEFzc3VtcHRpb24gaXMgdGhhdCBwcmVzZW50S2V5L3ByZXNlbnRWYWx1ZSBleGlzdHMgb25seSBpZiBwYXN0S2V5L3Bhc3RWYWx1ZSBleGlzdHMuXHJcbiAgY29uc3Qgb3V0cHV0Q291bnQgPSBNYXRoLm1pbihjb250ZXh0Lm91dHB1dENvdW50LCAxICsgKHBhc3RLZXkgPyAxIDogMCkgKyAocGFzdFZhbHVlID8gMSA6IDApKTtcclxuICBjb25zdCBwYXN0U2VxdWVuY2VMZW5ndGggPSBvdXRwdXRDb3VudCA+IDEgPyBwYXJhbWV0ZXJzLnBhc3RTZXF1ZW5jZUxlbmd0aCA6IDA7XHJcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtZXRlcnMua3ZTZXF1ZW5jZUxlbmd0aDtcclxuICBjb25zdCBhdHRlbnRpb25CaWFzID1cclxuICAgIGF0dGVudGlvbkJpYXNJbnB1dCAmJiBTaGFwZVV0aWwuc2l6ZShhdHRlbnRpb25CaWFzSW5wdXQuZGltcykgPiAwID8gYXR0ZW50aW9uQmlhc0lucHV0IDogdW5kZWZpbmVkO1xyXG5cclxuICBjb25zdCBpbnB1dHNLID0gW3EsIGtdO1xyXG4gIGlmIChvdXRwdXRDb3VudCA+IDEgJiYgcGFzdEtleSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpID4gMCkge1xyXG4gICAgaW5wdXRzSy5wdXNoKHBhc3RLZXkpO1xyXG4gIH1cclxuICBpZiAoYXR0ZW50aW9uQmlhcykge1xyXG4gICAgaW5wdXRzSy5wdXNoKGF0dGVudGlvbkJpYXMpO1xyXG4gIH1cclxuICBpZiAoc2VxTGVucykge1xyXG4gICAgaW5wdXRzSy5wdXNoKHNlcUxlbnMpO1xyXG4gIH1cclxuICBpZiAodG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KSB7XHJcbiAgICBpbnB1dHNLLnB1c2godG90YWxTZXF1ZW5jZUxlbmd0aElucHV0KTtcclxuICB9XHJcbiAgLy8gUnVuIEF0dGVudGlvblByb2JzXHJcbiAgY29uc3QgcHJvYnMgPSBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVBdHRlbnRpb25Qcm9ic1Byb2dyYW1JbmZvKFxyXG4gICAgICBvdXRwdXRDb3VudCxcclxuICAgICAgcSxcclxuICAgICAgayxcclxuICAgICAgcGFzdEtleSxcclxuICAgICAgYXR0ZW50aW9uQmlhcyxcclxuICAgICAgcGFyYW1ldGVycyxcclxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgICBzZXFMZW5zLFxyXG4gICAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQsXHJcbiAgICApLFxyXG4gICAgeyBpbnB1dHM6IGlucHV0c0ssIG91dHB1dHM6IG91dHB1dENvdW50ID4gMSA/IFstMSwgMV0gOiBbLTFdIH0sXHJcbiAgKVswXTtcclxuXHJcbiAgLy8gUnVuIFNvZnRtYXhcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVJblBsYWNlU29mdG1heFByb2dyYW1JbmZvKFxyXG4gICAgICBwcm9icyxcclxuICAgICAgcGFyYW1ldGVycy5iYXRjaFNpemUsXHJcbiAgICAgIHBhcmFtZXRlcnMubnVtSGVhZHMsXHJcbiAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcclxuICAgICAgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCxcclxuICAgICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcclxuICAgICAgc2VxTGVucyxcclxuICAgICAgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0LFxyXG4gICAgKSxcclxuICAgIHsgaW5wdXRzOiBzZXFMZW5zICYmIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCA/IFtwcm9icywgc2VxTGVucywgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0XSA6IFtwcm9ic10sIG91dHB1dHM6IFtdIH0sXHJcbiAgKTtcclxuXHJcbiAgLy8gUnVuIEF0dGVudGlvblNjb3JlXHJcbiAgY29uc3QgaW5wdXRzViA9IFtwcm9icywgdl07XHJcbiAgaWYgKG91dHB1dENvdW50ID4gMSAmJiBwYXN0VmFsdWUgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpID4gMCkge1xyXG4gICAgaW5wdXRzVi5wdXNoKHBhc3RWYWx1ZSk7XHJcbiAgfVxyXG4gIGlmIChzZXFMZW5zKSB7XHJcbiAgICBpbnB1dHNWLnB1c2goc2VxTGVucyk7XHJcbiAgfVxyXG4gIGlmICh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpIHtcclxuICAgIGlucHV0c1YucHVzaCh0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQpO1xyXG4gIH1cclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVWeEF0dGVudGlvblNjb3JlUHJvZ3JhbUluZm8oXHJcbiAgICAgIG91dHB1dENvdW50LFxyXG4gICAgICBwcm9icyxcclxuICAgICAgdixcclxuICAgICAgcGFzdFZhbHVlLFxyXG4gICAgICBwYXJhbWV0ZXJzLFxyXG4gICAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXHJcbiAgICAgIHNlcUxlbnMsXHJcbiAgICAgIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCxcclxuICAgICksXHJcbiAgICB7XHJcbiAgICAgIGlucHV0czogaW5wdXRzVixcclxuICAgICAgb3V0cHV0czogb3V0cHV0Q291bnQgPiAxID8gWzAsIDJdIDogWzBdLFxyXG4gICAgfSxcclxuICApO1xyXG59O1xyXG5cclxuY29uc3QgcHJlcGFyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgcGFyYW1ldGVyczogQXR0ZW50aW9uUGFyYW1ldGVycykgPT4ge1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW3BhcmFtZXRlcnMuYmF0Y2hTaXplLCBwYXJhbWV0ZXJzLm51bUhlYWRzLCBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoLCBwYXJhbWV0ZXJzLmhlYWRTaXplXTtcclxuICBjb25zdCBNID0gcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aDtcclxuICBjb25zdCBLID0gcGFyYW1ldGVycy5pbnB1dEhpZGRlblNpemU7XHJcbiAgY29uc3QgTiA9IHBhcmFtZXRlcnMuaGVhZFNpemU7XHJcbiAgY29uc3QgVElMRV9TSVpFID0gMTI7XHJcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XHJcbiAgICB4OiBNYXRoLmNlaWwocGFyYW1ldGVycy5oZWFkU2l6ZSAvIFRJTEVfU0laRSksXHJcbiAgICB5OiBNYXRoLmNlaWwocGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXHJcbiAgICB6OiBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHMsXHJcbiAgfTtcclxuICBjb25zdCBpbnB1dHMgPSBbY29udGV4dC5pbnB1dHNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLCBjb250ZXh0LmlucHV0c1syXV07XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE0gfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBLIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTiB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMubnVtSGVhZHMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhlYWRTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5oaWRkZW5TaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5oaWRkZW5TaXplICsgcGFyYW1ldGVycy5oaWRkZW5TaXplICsgcGFyYW1ldGVycy52SGlkZGVuU2l6ZSB9LFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3Qgb3V0cHV0USA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfcScsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xyXG4gICAgY29uc3Qgb3V0cHV0SyA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfaycsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xyXG4gICAgY29uc3Qgb3V0cHV0ViA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfdicsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xyXG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMpO1xyXG4gICAgY29uc3Qgd2VpZ2h0ID0gaW5wdXRWYXJpYWJsZSgnd2VpZ2h0JywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcyk7XHJcbiAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMpO1xyXG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnN0b3JhZ2U7XHJcblxyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdoZWFkX3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2xkYicsIHR5cGU6ICd1MzInIH0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGBcclxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVJbnB1dDogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XHJcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFE6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xyXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRLOiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcclxuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0VjogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgd2VpZ2h0LCBiaWFzLCBvdXRwdXRRLCBvdXRwdXRLLCBvdXRwdXRWKX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1RJTEVfU0laRSwgVElMRV9TSVpFLCAxXSl9XHJcbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xyXG4gICAgbGV0IGhlYWROdW1iZXIgPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcclxuICAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XHJcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xyXG5cclxuICAgIGxldCBpbnB1dE9mZnNldCA9IGJhdGNoSW5kZXggKiAodW5pZm9ybXMuTSAqIHVuaWZvcm1zLkspICsgbSAqIHVuaWZvcm1zLks7XHJcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xyXG4gICAgbGV0IGJpYXNPZmZzZXRLID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0UTtcclxuICAgIGxldCBiaWFzT2Zmc2V0ViA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldEs7XHJcblxyXG4gICAgdmFyIHZhbHVlUSA9ICR7ZGF0YVR5cGV9KDApO1xyXG4gICAgdmFyIHZhbHVlSyA9ICR7ZGF0YVR5cGV9KDApO1xyXG4gICAgdmFyIHZhbHVlViA9ICR7ZGF0YVR5cGV9KDApO1xyXG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xyXG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XHJcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XHJcbiAgICAgICAgdGlsZVdlaWdodFFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRRICsgb2Zmc2V0XTtcclxuICAgICAgICB0aWxlV2VpZ2h0S1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldEsgKyBvZmZzZXRdO1xyXG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XHJcbiAgICAgIH1cclxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XHJcbiAgICAgICAgbGV0IGlucHV0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrO1xyXG4gICAgICAgIGxldCB3ZWlnaHRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogayArIGxvY2FsX2lkLng7XHJcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XHJcbiAgICAgICAgdmFsdWVLICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodEtbd2VpZ2h0VGlsZU9mZnNldF07XHJcbiAgICAgICAgdmFsdWVWICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFZbd2VpZ2h0VGlsZU9mZnNldF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaGVhZE9mZnNldCA9IChtICogdW5pZm9ybXMuTiArIG4pICUgdW5pZm9ybXMuaGVhZF9zaXplO1xyXG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcclxuICAgIHZhbHVlSyArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0S107XHJcbiAgICB2YWx1ZVYgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFZdO1xyXG5cclxuICAgIGxldCBvZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xyXG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XHJcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XHJcbiAgICAgIG91dHB1dF9xW291dHB1dElkeF0gPSB2YWx1ZVE7XHJcbiAgICAgIG91dHB1dF9rW291dHB1dElkeF0gPSB2YWx1ZUs7XHJcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XHJcbiAgICB9XHJcbiAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ0F0dGVudGlvblByZXBhcmUnLFxyXG4gICAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnLCAndHlwZSddIH0sXHJcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgICAgb3V0cHV0czogW1xyXG4gICAgICAgICAgeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9LFxyXG4gICAgICAgICAgeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9LFxyXG4gICAgICAgICAgeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgICB9KSxcclxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgfSxcclxuICAgIHsgaW5wdXRzLCBvdXRwdXRzOiBbLTEsIC0xLCAtMV0gfSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiB2b2lkID0+IHtcclxuICBjb25zdCBwYXJhbXMgPSB2YWxpZGF0ZUF0dGVudGlvbklucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcblxyXG4gIGNvbnN0IFtxLCBrLCB2XSA9IHByZXBhcmUoY29udGV4dCwgcGFyYW1zKTtcclxuXHJcbiAgcmV0dXJuIGFwcGx5QXR0ZW50aW9uKFxyXG4gICAgY29udGV4dCxcclxuICAgIHEsXHJcbiAgICBrLFxyXG4gICAgdixcclxuICAgIGNvbnRleHQuaW5wdXRzWzRdLFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgY29udGV4dC5pbnB1dHNbNV0sXHJcbiAgICBwYXJhbXMsXHJcbiAgKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCYXRjaE5vcm1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBlcHNpbG9uOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgbW9tZW50dW06IG51bWJlcjtcclxuICByZWFkb25seSBzcGF0aWFsOiBib29sZWFuO1xyXG4gIHJlYWRvbmx5IHRyYWluaW5nTW9kZTogYm9vbGVhbjtcclxuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcclxuICByZWFkb25seSBvdXRwdXRDb3VudDogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQmF0Y2hOb3JtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjaGVja1NoYXBlRXF1YWwgPSAoYWN0dWFsOiByZWFkb25seSBudW1iZXJbXSwgZXhwZWN0ZWQ6IHJlYWRvbmx5IG51bWJlcltdLCBtZXNzYWdlOiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IHIgPSBleHBlY3RlZC5sZW5ndGg7XHJcbiAgICBpZiAociAhPT0gYWN0dWFsLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IG51bSBkaW1lbnNpb25zICE9ICR7cn1gKTtcclxuICAgIH1cclxuICAgIGV4cGVjdGVkLmZvckVhY2goKHYsIGkpID0+IHtcclxuICAgICAgaWYgKHYgIT09IGFjdHVhbFtpXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHttZXNzYWdlfTogZGltWyR7aX1dIGRvIG5vdCBtYXRjaGApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xyXG4gICAgY29uc3Qgc2hhcGUgPVxyXG4gICAgICBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnXHJcbiAgICAgICAgPyBhdHRyaWJ1dGVzLnNwYXRpYWxcclxuICAgICAgICAgID8gaW5wdXRzWzBdLmRpbXMuc2xpY2UoLTEpXHJcbiAgICAgICAgICA6IGlucHV0c1swXS5kaW1zLnNsaWNlKC0xKS5jb25jYXQoaW5wdXRzWzBdLmRpbXMuc2xpY2UoMSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMSkpXHJcbiAgICAgICAgOiBpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBhdHRyaWJ1dGVzLnNwYXRpYWwgPyAyIDogdW5kZWZpbmVkKTtcclxuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMV0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IHNjYWxlJyk7XHJcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzJdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBCJyk7XHJcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzNdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBtZWFuJyk7XHJcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzRdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCB2YXInKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1sxXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IHNjYWxlJyk7XHJcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzJdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgQicpO1xyXG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1szXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IG1lYW4nKTtcclxuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbNF0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCB2YXInKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVCYXRjaE5vcm1JbmZlcmVuY2VQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1BdHRyaWJ1dGVzLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgeyBlcHNpbG9uLCBzcGF0aWFsLCBmb3JtYXQgfSA9IGF0dHJpYnV0ZXM7XHJcbiAgY29uc3QgeVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IHNwYXRpYWwgPyBnZXRNYXhDb21wb25lbnRzKHlTaGFwZVt5U2hhcGUubGVuZ3RoIC0gMV0pIDogMTtcclxuICBjb25zdCBjQ29tcG9uZW50cyA9IGZvcm1hdCA9PT0gJ05IV0MnICYmIHlTaGFwZS5sZW5ndGggPiAxID8gY29tcG9uZW50cyA6IDE7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKHlTaGFwZSkgLyBjb21wb25lbnRzO1xyXG4gIC8vIE9ubHkgc3VwcG9ydCB1bmlmb3JtcyBmb3Igb3BzZXQgdmVyc2lvbiA+PSA5IChzcGF0aWFsID0gdHJ1ZSkuXHJcbiAgY29uc3QgdXNlU2hhcGVzVW5pZm9ybXMgPSBzcGF0aWFsO1xyXG4gIGNvbnN0IHNoYXBlT3JSYW5rID0gdXNlU2hhcGVzVW5pZm9ybXMgPyB5U2hhcGUubGVuZ3RoIDogeVNoYXBlO1xyXG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcywgY29tcG9uZW50cyk7XHJcbiAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMsIGNDb21wb25lbnRzKTtcclxuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNDb21wb25lbnRzKTtcclxuICBjb25zdCBpbnB1dE1lYW4gPSBpbnB1dFZhcmlhYmxlKCdpbnB1dE1lYW4nLCBpbnB1dHNbM10uZGF0YVR5cGUsIGlucHV0c1szXS5kaW1zLCBjQ29tcG9uZW50cyk7XHJcbiAgY29uc3QgaW5wdXRWYXIgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dFZhcicsIGlucHV0c1s0XS5kYXRhVHlwZSwgaW5wdXRzWzRdLmRpbXMsIGNDb21wb25lbnRzKTtcclxuICBjb25zdCB5ID0gb3V0cHV0VmFyaWFibGUoJ3knLCBpbnB1dHNbMF0uZGF0YVR5cGUsIHNoYXBlT3JSYW5rLCBjb21wb25lbnRzKTtcclxuICAvLyBUT0RPOiBzdXBwb3J0IGlucHV0cyB3aXRoIGRpZmZlcmVudCBkYXRhIHR5cGUuIEN1cnJlbnQgd2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIGlucHV0cyBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZS5cclxuICAvLyBPdGhlcndpc2UsIHRoZSBzaGFkZXIgY29tcGlsYXRpb24gd2lsbCBmYWlsLlxyXG4gIGNvbnN0IGNhbGNDT2Zmc2V0ID0gKCk6IHN0cmluZyA9PiB7XHJcbiAgICBsZXQgY09mZnNldCA9ICcnO1xyXG4gICAgaWYgKHNwYXRpYWwpIHtcclxuICAgICAgY09mZnNldCA9IGBsZXQgY09mZnNldCA9ICR7XHJcbiAgICAgICAgeVNoYXBlLmxlbmd0aCA9PT0gMVxyXG4gICAgICAgICAgPyAnMHUnXHJcbiAgICAgICAgICA6IGZvcm1hdCA9PT0gJ05IV0MnXHJcbiAgICAgICAgICAgID8gYG91dHB1dEluZGljZXNbJHt5U2hhcGUubGVuZ3RoIC0gMX1dIC8gJHtjb21wb25lbnRzfWBcclxuICAgICAgICAgICAgOiAnb3V0cHV0SW5kaWNlc1sxXSdcclxuICAgICAgfTtgO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGZvcm1hdCA9PT0gJ05DSFcnKSB7XHJcbiAgICAgICAgY09mZnNldCA9IGBcclxuICAgICAgICAgICAgJHt5LmluZGljZXNTZXQoJ291dHB1dEluZGljZXMnLCAnMCcsICcwJyl9XHJcbiAgICAgICAgICAgIGxldCBjT2Zmc2V0ID0gJHt5LmluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycpfTtgO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHVwZGF0ZSBDIGNoYW5uZWwuXHJcbiAgICAgICAgY09mZnNldCA9IGB2YXIgY0luZGljZXMgPSAke3NjYWxlLnR5cGUuaW5kaWNlc30oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XTtgO1xyXG4gICAgICAgIC8vIHVwZGF0ZSBEMSB4IC4uLiB4IERuIGNoYW5uZWxzLlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2NhbGUucmFuazsgaSsrKSB7XHJcbiAgICAgICAgICBjT2Zmc2V0ICs9IGBjSW5kaWNlc1ske2l9XSA9IG91dHB1dEluZGljZXNbJHtpfV07YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY09mZnNldCArPSBgbGV0IGNPZmZzZXQgPSAke3NjYWxlLmluZGljZXNUb09mZnNldCgnY0luZGljZXMnKX07YDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNPZmZzZXQ7XHJcbiAgfTtcclxuICBjb25zdCBnZXRJbmZlcmVuY2VNb2RlU2hhZGVyU291cmNlID0gKGhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgY29uc3QgZXBzaWxvbiA9ICR7ZXBzaWxvbn07XHJcbiAgJHtoZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoeCwgc2NhbGUsIGJpYXMsIGlucHV0TWVhbiwgaW5wdXRWYXIsIHkpfVxyXG4gICR7aGVscGVyLm1haW5TdGFydCgpfVxyXG4gICR7aGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cclxuICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c31gKX07XHJcbiAgICAke2NhbGNDT2Zmc2V0KCl9XHJcbiAgICBsZXQgc2NhbGUgPSAke3NjYWxlLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xyXG4gICAgbGV0IGJpYXMgPSAke2JpYXMuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XHJcbiAgICBsZXQgaW5wdXRNZWFuID0gJHtpbnB1dE1lYW4uZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XHJcbiAgICBsZXQgaW5wdXRWYXIgPSAke2lucHV0VmFyLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xyXG4gICAgbGV0IHggPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICBsZXQgdmFsdWUgPSAoeCAtIGlucHV0TWVhbikgKiBpbnZlcnNlU3FydChpbnB1dFZhciArIGVwc2lsb24pICogc2NhbGUgKyBiaWFzO1xyXG4gICAgJHt5LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9XHJcbiAgfWA7XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdCYXRjaE5vcm1hbGl6YXRpb24nLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5lcHNpbG9ufV8ke2F0dHJpYnV0ZXMuZm9ybWF0fV8ke3NwYXRpYWx9XyR7Y29tcG9uZW50c31gLFxyXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogdXNlU2hhcGVzVW5pZm9ybXMgPyBbJ3JhbmsnLCAndHlwZScsICd0eXBlJywgJ3R5cGUnLCAndHlwZSddIDogdW5kZWZpbmVkLFxyXG4gICAgfSxcclxuICAgIGdldFNoYWRlclNvdXJjZTogZ2V0SW5mZXJlbmNlTW9kZVNoYWRlclNvdXJjZSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogdXNlU2hhcGVzVW5pZm9ybXNcclxuICAgICAgICA/IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh5U2hhcGUpXVxyXG4gICAgICAgIDogW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH1dLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUJhdGNoTm9ybUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBCYXRjaE5vcm1BdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMgT21pdDxCYXRjaE5vcm1BdHRyaWJ1dGVzLCBrZXlvZiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk+KTtcclxuXHJcbmV4cG9ydCBjb25zdCBiYXRjaE5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZCA9PiB7XHJcbiAgY29uc3QgeyBpbnB1dHMsIG91dHB1dENvdW50IH0gPSBjb250ZXh0O1xyXG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gcGFyc2VCYXRjaE5vcm1BdHRyaWJ1dGVzKHsgLi4uYXR0cmlidXRlcywgb3V0cHV0Q291bnQgfSk7XHJcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQpIHtcclxuICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpO1xyXG4gIH1cclxuICBpZiAoYXR0cmlidXRlcy50cmFpbmluZ01vZGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHRyYWluaW5nTW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvKGlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpKTtcclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoIVszMjAsIDY0MCwgMTI4MF0uaW5jbHVkZXMoaW5wdXRzWzBdLmRpbXNbMl0pKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRpbXNbMl0gIT09IGlucHV0c1sxXS5kaW1zWzBdKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWUnKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVCaWFzQWRkUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuXHJcbiAgY29uc3QgY2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1syXTtcclxuICAvLyBzaW5jZSBjaGFubmVsIG51bWJlciBjYW4gYmUgb25seSAzMjAvNjQwLzEyODAsIGl0J3MgYWx3YXlzIGRpdmlzaWJsZSBieSA0XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQ7XHJcblxyXG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xyXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xyXG4gIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgZGF0YVR5cGUsIFtjaGFubmVsc10sIDQpO1xyXG4gIGNvbnN0IHJlc2lkdWFsID0gaW5wdXRWYXJpYWJsZSgncmVzaWR1YWwnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xyXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICBjb25zdCBjaGFubmVscyA9ICR7Y2hhbm5lbHN9dSAvIDQ7XHJcbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgYmlhcywgcmVzaWR1YWwsIG91dHB1dCl9XHJcblxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cclxuICAgIGxldCB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX1cclxuICAgICAgKyAke2JpYXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHggJSBjaGFubmVscycpfSArICR7cmVzaWR1YWwuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxyXG4gIH1gO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0JpYXNBZGQnLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYmlhc0FkZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmlhc0FkZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsXHJcbiAgVW5pZm9ybURhdGFFbGVtZW50VHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG50eXBlIEJ1aWx0aW5GdW5jdGlvbk5hbWUgPSBzdHJpbmc7XHJcbnR5cGUgRWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb246IHN0cmluZykgPT4gc3RyaW5nO1xyXG50eXBlIEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsID0gQnVpbHRpbkZ1bmN0aW9uTmFtZSB8IEVsZW1lbnR3aXNlQ3VzdG9tRXhwcmVzc2lvbjtcclxuXHJcbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbVNoYWRlciA9IChcclxuICBzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcixcclxuICBkYXRhc2l6ZTogbnVtYmVyLFxyXG4gIGlucHV0RGF0YVR5cGU6IG51bWJlcixcclxuICBvdXRwdXREYXRhVHlwZTogbnVtYmVyLFxyXG4gIGZ1bmNDYWxsOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCxcclxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXHJcbiAgYWRkaXRpb25hbFVuaWZvcm1zVHlwZT86IFVuaWZvcm1zQXJyYXlUeXBlLFxyXG4pOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IHZlY1NpemUgPSBNYXRoLmNlaWwoZGF0YXNpemUgLyA0KTtcclxuXHJcbiAgbGV0IGV4cHJlc3Npb24gPSAnJztcclxuICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xyXG4gICAgZXhwcmVzc2lvbiA9IGAke2Z1bmNDYWxsfShhKWA7XHJcbiAgfSBlbHNlIHtcclxuICAgIGV4cHJlc3Npb24gPSBmdW5jQ2FsbCgnYScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dERhdGEnLCBpbnB1dERhdGFUeXBlLCBbdmVjU2l6ZV0sIDQpO1xyXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXREYXRhJywgb3V0cHV0RGF0YVR5cGUsIFt2ZWNTaXplXSwgNCk7XHJcbiAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW3sgbmFtZTogJ3ZlY19zaXplJywgdHlwZTogJ3UzMicgfV07XHJcbiAgaWYgKGFkZGl0aW9uYWxVbmlmb3Jtc1R5cGUpIHtcclxuICAgIHVuaWZvcm1zLnB1c2goLi4uYWRkaXRpb25hbFVuaWZvcm1zVHlwZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYFxyXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG5cclxuICAke2FkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbiA/PyAnJ31cclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxyXG5cclxuICAgIGxldCBhID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcclxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgZXhwcmVzc2lvbil9XHJcbiAgfWA7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICBmdW5jQ2FsbDogRWxlbWVudHdpc2VGdW5jdGlvbkNhbGwsXHJcbiAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxyXG4gIGNhY2hlS2V5Pzogc3RyaW5nLFxyXG4gIG91dHB1dERhdGFUeXBlOiBudW1iZXIgPSBpbnB1dC5kYXRhVHlwZSxcclxuICBhZGRpdGlvbmFsVW5pZm9ybXM/OiBQcm9ncmFtVW5pZm9ybVtdLFxyXG4gIGFkZGl0aW9uYWxVbmlmb3Jtc1R5cGU/OiBVbmlmb3Jtc0FycmF5VHlwZSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcykgLyA0KSB9LFxyXG4gIF07XHJcbiAgaWYgKGFkZGl0aW9uYWxVbmlmb3Jtcykge1xyXG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uYWRkaXRpb25hbFVuaWZvcm1zKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyKSA9PlxyXG4gICAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1TaGFkZXIoXHJcbiAgICAgICAgc2hhZGVySGVscGVyLFxyXG4gICAgICAgIFNoYXBlVXRpbC5zaXplKGlucHV0LmRpbXMpLFxyXG4gICAgICAgIGlucHV0LmRhdGFUeXBlLFxyXG4gICAgICAgIG91dHB1dERhdGFUeXBlLFxyXG4gICAgICAgIGZ1bmNDYWxsLFxyXG4gICAgICAgIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbixcclxuICAgICAgICBhZGRpdGlvbmFsVW5pZm9ybXNUeXBlLFxyXG4gICAgICApLFxyXG4gICAgZ2V0UnVuRGF0YTogKGlucHV0VGVuc29ycykgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXQuZGltcywgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7XHJcbiAgICAgICAgeDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGlucHV0VGVuc29yc1swXS5kaW1zKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovIC8gNCAvKiB2ZWMgc2l6ZSAqLyksXHJcbiAgICAgIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYWJzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBYnMnLCAnYWJzJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFjb3MgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Fjb3MnLCAnYWNvcycpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhY29zaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvc2gnLCAnYWNvc2gnKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgYXNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQXNpbicsICdhc2luJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFzaW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBc2luaCcsICdhc2luaCcpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhdGFuID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBdGFuJywgJ2F0YW4nKSk7XHJcbn07XHJcbmV4cG9ydCBjb25zdCBhdGFuaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQXRhbmgnLCAnYXRhbmgnKSk7XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhc3RBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSB0bzogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IHNhdHVyYXRlPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQ2FzdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDYXN0QXR0cmlidXRlcyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHsgdG86IG51bWJlciB9KTtcclxuXHJcbmV4cG9ydCBjb25zdCBjYXN0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDYXN0QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGxldCBmdW5jOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbDtcclxuICBzd2l0Y2ggKGF0dHJpYnV0ZXMudG8pIHtcclxuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcclxuICAgICAgZnVuYyA9ICd2ZWM0PGYxNj4nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XHJcbiAgICAgIGZ1bmMgPSAndmVjNDxmMzI+JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQzMjpcclxuICAgICAgZnVuYyA9ICd2ZWM0PHUzMj4nO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XHJcbiAgICAgIGZ1bmMgPSAndmVjNDxpMzI+JztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XHJcbiAgICAgIGZ1bmMgPSAndmVjNDxib29sPic7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHthdHRyaWJ1dGVzLnRvfWApO1xyXG4gIH1cclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2FzdCcsIGZ1bmMsIHVuZGVmaW5lZCwgYXR0cmlidXRlcy5jYWNoZUtleSwgYXR0cmlidXRlcy50byksXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2xpcEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IG1pbjogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IG1heDogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCBnZW5lcmF0ZUNsaXBBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IENsaXBBdHRyaWJ1dGVzID0+IHtcclxuICBsZXQgbWluOiBudW1iZXI7XHJcbiAgbGV0IG1heDogbnVtYmVyO1xyXG4gIGNvbnN0IGhhc01pbiA9IGlucHV0cy5sZW5ndGggPj0gMiAmJiBpbnB1dHNbMV0uZGF0YSAhPT0gMDtcclxuICBjb25zdCBoYXNNYXggPSBpbnB1dHMubGVuZ3RoID49IDMgJiYgaW5wdXRzWzJdLmRhdGEgIT09IDA7XHJcblxyXG4gIHN3aXRjaCAoaW5wdXRzWzBdLmRhdGFUeXBlKSB7XHJcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0OlxyXG4gICAgICBtaW4gPSBoYXNNaW4gPyBpbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiAtMy40MDI4MjM0NjYzODUyODg2ZTM4O1xyXG4gICAgICBtYXggPSBoYXNNYXggPyBpbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiAzLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxyXG4gICAgICBtaW4gPSBoYXNNaW4gPyBpbnB1dHNbMV0uZ2V0VWludDE2QXJyYXkoKVswXSA6IDY0NTExOyAvLyB1aW50MTYoNjQ1MTEpIDwtPiBmbG9hdDE2KC02NTUwNC4wKVxyXG4gICAgICBtYXggPSBoYXNNYXggPyBpbnB1dHNbMl0uZ2V0VWludDE2QXJyYXkoKVswXSA6IDMxNzQzOyAvLyB1aW50MTYoMzE3NDMpIDwtPiBmbG9hdDE2KDY1NTA0LjApXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnQgZGF0YSB0eXBlJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgbWluLCBtYXggfSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY2xpcCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgY2xpcEF0dHJpYnV0ZXM6IENsaXBBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgYXR0cmlidXRlcyA9IGNsaXBBdHRyaWJ1dGVzID8gY2xpcEF0dHJpYnV0ZXMgOiBnZW5lcmF0ZUNsaXBBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcclxuICAgICAgJ0NsaXAnLFxyXG4gICAgICAoYSkgPT4gYGNsYW1wKCR7YX0sIHZlYzQ8JHtkYXRhVHlwZX0+KHVuaWZvcm1zLm1pbiksIHZlYzQ8JHtkYXRhVHlwZX0+KHVuaWZvcm1zLm1heCkpYCxcclxuICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxyXG4gICAgICB1bmRlZmluZWQsXHJcbiAgICAgIFtcclxuICAgICAgICB7IHR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBkYXRhOiBhdHRyaWJ1dGVzLm1pbiB9LFxyXG4gICAgICAgIHsgdHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGRhdGE6IGF0dHJpYnV0ZXMubWF4IH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIFtcclxuICAgICAgICB7IG5hbWU6ICdtaW4nLCB0eXBlOiBkYXRhVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlIH0sXHJcbiAgICAgICAgeyBuYW1lOiAnbWF4JywgdHlwZTogZGF0YVR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxyXG4gICAgICBdLFxyXG4gICAgKSxcclxuICAgIHsgaW5wdXRzOiBbMF0gfSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNlaWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0NlaWwnLCAnY2VpbCcpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb3MgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0NvcycsICdjb3MnKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29zaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ29zaCcsICdjb3NoJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBbHBoYUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUFscGhhQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEFscGhhQXR0cmlidXRlcyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHsgYWxwaGE6IG51bWJlciB9KTtcclxuXHJcbmV4cG9ydCBjb25zdCBlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcclxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXHJcbiAgICAgICdFbHUnLFxyXG4gICAgICAoYSkgPT4gYGVsdV92ZjMyKCR7YX0pYCxcclxuICAgICAgYFxyXG4gIGNvbnN0IGVsdV9hbHBoYV8gPSAke2RhdGFUeXBlfSgke2F0dHJpYnV0ZXMuYWxwaGF9KTtcclxuXHJcbiAgZm4gZWx1X2YzMihhOiAke2RhdGFUeXBlfSkgLT4gJHtkYXRhVHlwZX0ge1xyXG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XHJcbiAgfVxyXG5cclxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PCR7ZGF0YVR5cGV9PikgLT4gdmVjNDwke2RhdGFUeXBlfT4ge1xyXG4gIHJldHVybiB2ZWM0KGVsdV9mMzIodi54KSwgZWx1X2YzMih2LnkpLCBlbHVfZjMyKHYueiksIGVsdV9mMzIodi53KSk7XHJcbiAgfWAsXHJcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXHJcbiAgICApLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZXJmSW1wbCA9ICh2YXJUeXBlID0gJ2YzMicpID0+IGBcclxuY29uc3QgcjA6ICR7dmFyVHlwZX0gPSAwLjMyNzU5MTE7XHJcbmNvbnN0IHIxOiAke3ZhclR5cGV9ID0gMC4yNTQ4Mjk1OTI7XHJcbmNvbnN0IHIyOiAke3ZhclR5cGV9ID0gLTAuMjg0NDk2NzM2O1xyXG5jb25zdCByMzogJHt2YXJUeXBlfSA9IDEuNDIxNDEzNzQxO1xyXG5jb25zdCByNDogJHt2YXJUeXBlfSA9IC0xLjQ1MzE1MjAyNztcclxuY29uc3QgcjU6ICR7dmFyVHlwZX0gPSAxLjA2MTQwNTQyOTtcclxuXHJcbmZuIGVyZl92ZjMyKHY6IHZlYzQ8JHt2YXJUeXBlfT4pIC0+IHZlYzQ8JHt2YXJUeXBlfT4ge1xyXG4gIGxldCBhYnN2ID0gYWJzKHYpO1xyXG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XHJcbiAgcmV0dXJuIHNpZ24odikgKiAoMS4wIC0gKCgoKHI1ICogeCArIHI0KSAqIHggKyByMykgKiB4ICsgcjIpICogeCArIHIxKSAqIHggKiBleHAoLWFic3YgKiBhYnN2KSk7XHJcbn1gO1xyXG5cclxuZXhwb3J0IGNvbnN0IGVyZiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdFcmYnLCAoYSkgPT4gYGVyZl92ZjMyKCR7YX0pYCwgZXJmSW1wbChkYXRhVHlwZSkpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBleHAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0V4cCcsICdleHAnKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZmxvb3IgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Zsb29yJywgJ2Zsb29yJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXHJcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxyXG4gICAgICAnR2VsdScsXHJcbiAgICAgIChhKSA9PiBgMC41ICogJHthfSAqICgxLjAgKyBlcmZfdmYzMigke2F9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLFxyXG4gICAgICBlcmZJbXBsKGRhdGFUeXBlKSxcclxuICAgICksXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBsZWFreVJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcclxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXHJcbiAgICAgICdMZWFreVJlbHUnLFxyXG4gICAgICAoYSkgPT4gYHNlbGVjdChsZWFreV9yZWx1X2FscGhhXyAqICR7YX0sICR7YX0sICR7YX0gPj0gdmVjNDwke2RhdGFUeXBlfT4oMC4wKSlgLFxyXG4gICAgICBgY29uc3QgbGVha3lfcmVsdV9hbHBoYV8gPSAke2RhdGFUeXBlfSgke2F0dHJpYnV0ZXMuYWxwaGF9KTtgLFxyXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxyXG4gICAgKSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG5vdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTm90JywgKGEpID0+IGAhJHthfWApKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBuZWcgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ05lZycsIChhKSA9PiBgLSR7YX1gKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVjaXByb2NhbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnUmVjaXByb2NhbCcsIChhKSA9PiBgMS4wLyR7YX1gKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcclxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXHJcbiAgICAgICdSZWx1JyxcclxuICAgICAgKGEpID0+IGBzZWxlY3QodmVjNDwke2RhdGFUeXBlfT4oMC4wKSwgJHthfSwgJHthfSA+IHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCkpYCxcclxuICAgICksXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzaWdtb2lkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdTaWdtb2lkJywgKGEpID0+IGAoMS4wIC8gKDEuMCArIGV4cCgtJHthfSkpKWApKTtcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSGFyZFNpZ21vaWRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBhbHBoYTogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IGJldGE6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlSGFyZFNpZ21vaWRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogSGFyZFNpZ21vaWRBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KFxyXG4gICAgYXR0cmlidXRlcyBhcyB7XHJcbiAgICAgIGFscGhhOiBudW1iZXI7XHJcbiAgICAgIGJldGE6IG51bWJlcjtcclxuICAgIH0sXHJcbiAgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBoYXJkU2lnbW9pZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogSGFyZFNpZ21vaWRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcclxuICAgICAgJ0hhcmRTaWdtb2lkJyxcclxuICAgICAgKGEpID0+XHJcbiAgICAgICAgYG1heCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCBtaW4odmVjNDwke2RhdGFUeXBlfT4oMS4wKSwgJHthdHRyaWJ1dGVzLmFscGhhfSAqICR7YX0gKyB2ZWM0PCR7ZGF0YVR5cGV9Pigke2F0dHJpYnV0ZXMuYmV0YX0pKSlgLFxyXG4gICAgICB1bmRlZmluZWQsXHJcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXHJcbiAgICApLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2luID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdTaW4nLCAnc2luJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNpbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbmgnLCAnc2luaCcpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzcXJ0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdTcXJ0JywgJ3NxcnQnKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdGFuID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdUYW4nLCAndGFuJykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHRhbmhFeHByZXNzaW9uID0gKGE6IHN0cmluZykgPT4gYHNpZ24oJHthfSkgKiAoMSAtIGV4cCgtMiAqIGFicygke2F9KSkpIC8gKDEgKyBleHAoLTIgKiBhYnMoJHthfSkpKWA7XHJcblxyXG5leHBvcnQgY29uc3QgdGFuaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIC8vIFRPRE86IHJldmlzaXQgYWZ0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2dwdXdlYi9ncHV3ZWIvaXNzdWVzLzQ0NTggaXMgcmVzb2x2ZWRcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbmgnLCB0YW5oRXhwcmVzc2lvbikpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1SW1wbCA9ICh2YXJUeXBlID0gJ2YzMicpID0+IGBcclxuY29uc3QgZmFzdF9nZWx1X2E6ICR7dmFyVHlwZX0gPSAwLjU7XHJcbmNvbnN0IGZhc3RfZ2VsdV9iOiAke3ZhclR5cGV9ID0gMC43OTc4ODQ1NjA4MDI4NjU0O1xyXG5jb25zdCBmYXN0X2dlbHVfYzogJHt2YXJUeXBlfSA9IDAuMDM1Njc3NDA4MTM2MzAwMTI1O1xyXG5cclxuZm4gdGFuaF92KHY6IHZlYzQ8JHt2YXJUeXBlfT4pIC0+IHZlYzQ8JHt2YXJUeXBlfT4ge1xyXG4gIHJldHVybiAke3RhbmhFeHByZXNzaW9uKCd2Jyl9O1xyXG59XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgZmFzdEdlbHVFeHByZXNzaW9uID0gKHg6IHN0cmluZykgPT5cclxuICBgKGZhc3RfZ2VsdV9hICsgZmFzdF9nZWx1X2EgKiB0YW5oX3YoJHt4fSAqIChmYXN0X2dlbHVfYyAqICR7eH0gKiAke3h9ICsgZmFzdF9nZWx1X2IpKSkgKiAke3h9YDtcclxuXHJcbmV4cG9ydCBjb25zdCBmYXN0R2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcclxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXHJcbiAgICAgICdGYXN0R2VsdScsXHJcbiAgICAgIGZhc3RHZWx1RXhwcmVzc2lvbixcclxuICAgICAgZmFzdEdlbHVJbXBsKGRhdGFUeXBlKSxcclxuICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICksXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0aHJlc2hvbGRlZFJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IG51bWJlciA9PiB7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcclxuICAgICAgJ1RocmVzaG9sZGVkUmVsdScsXHJcbiAgICAgIChhKSA9PiBgc2VsZWN0KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksICR7YX0sICR7YX0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLFxyXG4gICAgICBgY29uc3QgdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8gPSB2ZWM0PCR7ZGF0YVR5cGV9Pigke2F0dHJpYnV0ZXMuYWxwaGF9KTtgLFxyXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxyXG4gICAgKSxcclxuICApO1xyXG4gIHJldHVybiAwO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvZyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTG9nJywgJ2xvZycpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBxdWlja0dlbHVJbXBsID0gKHZhclR5cGU6IHN0cmluZywgYWxwaGE6IG51bWJlcikgPT4gYFxyXG5jb25zdCBhbHBoYSA9IHZlYzQ8JHt2YXJUeXBlfT4oJHthbHBoYX0pO1xyXG5jb25zdCBvbmUgPSAke3ZhclR5cGV9KDEuMCk7XHJcbmNvbnN0IHplcm8gPSAke3ZhclR5cGV9KDAuMCk7XHJcblxyXG5mbiBxdWlja19nZWx1X2ltcGwoeDogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XHJcbiAgbGV0IHYgPSB4ICphbHBoYTtcclxuICB2YXIgeDEgOiB2ZWM0PCR7dmFyVHlwZX0+O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSA9IGkgKyAxKSB7XHJcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XHJcbiAgICAgIHgxW2ldID0gb25lIC8gKG9uZSArIGV4cCgtdltpXSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHggKiB4MTtcclxufVxyXG5gO1xyXG5cclxuZXhwb3J0IGNvbnN0IHF1aWNrR2VsdUV4cHJlc3Npb24gPSAoeDogc3RyaW5nKSA9PiBgcXVpY2tfZ2VsdV9pbXBsKCR7eH0pYDtcclxuXHJcbmV4cG9ydCBjb25zdCBxdWlja2dlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGRUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcclxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXHJcbiAgICAgICdRdWlja0dlbHUnLFxyXG4gICAgICBxdWlja0dlbHVFeHByZXNzaW9uLFxyXG4gICAgICBxdWlja0dlbHVJbXBsKGRUeXBlLCBhdHRyaWJ1dGVzLmFscGhhKSxcclxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcclxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXHJcbiAgICApLFxyXG4gICk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSB9IGZyb20gJy4vY29tbW9uJztcclxuaW1wb3J0IHsgZXJmSW1wbCB9IGZyb20gJy4vdW5hcnktb3AnO1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9ucycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFbMjU2MCwgNTEyMCwgMTAyNDBdLmluY2x1ZGVzKGlucHV0c1swXS5kaW1zWzJdKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdoaWRkZW4gc3RhdGUgc2hvdWxkIGJlIDI1NjAsIDUxMjAgb3IgMTAyNDAnKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1swXS5kaW1zWzJdICE9PSBpbnB1dHNbMV0uZGltc1swXSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlQmlhc1NwbGl0R2VsdVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcclxuICBvdXRwdXRTaGFwZVsyXSA9IG91dHB1dFNoYXBlWzJdIC8gMjtcclxuXHJcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIDQpO1xyXG4gIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBbaW5wdXRzWzBdLmRpbXNbMl1dLCA0KTtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XHJcblxyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA0O1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxyXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XHJcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtpbnB1dHNbMF0uZGltc1syXSAvIDQgLyAyfXU7XHJcblxyXG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGJpYXMsIG91dHB1dCl9XHJcblxyXG4gICR7ZXJmSW1wbChkYXRhVHlwZSl9XHJcblxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cclxuICAgIGxldCBiaWFzSWR4ID0gZ2xvYmFsX2lkeCAlIGhhbGZDaGFubmVscztcclxuICAgIGxldCBiYXRjaEluZGV4ID0gZ2xvYmFsX2lkeCAvIGhhbGZDaGFubmVscztcclxuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcclxuICAgIGxldCB2YWx1ZUxlZnQgPSBpbnB1dFtpbnB1dE9mZnNldF0gKyBiaWFzW2JpYXNJZHhdO1xyXG4gICAgbGV0IHZhbHVlUmlnaHQgPSBpbnB1dFtpbnB1dE9mZnNldCArIGhhbGZDaGFubmVsc10gKyBiaWFzW2JpYXNJZHggKyBoYWxmQ2hhbm5lbHNdO1xyXG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XHJcblxyXG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWVMZWZ0ICogZ2VsdVJpZ2h0Jyl9XHJcbiAgfWA7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnQmlhc1NwbGl0R2VsdScsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBiaWFzU3BsaXRHZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVCaWFzU3BsaXRHZWx1UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgQnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxudHlwZSBCdWlsdGluRnVuY3Rpb25OYW1lID0gc3RyaW5nO1xyXG50eXBlIEJpbmFyeUN1c3RvbUV4cHJlc3Npb24gPSAoZXhwcmVzc2lvbkE6IHN0cmluZywgZXhwcmVzc2lvbkI6IHN0cmluZykgPT4gc3RyaW5nO1xyXG50eXBlIEJpbmFyeUZ1bmN0aW9uQ2FsbCA9XHJcbiAgfCBCdWlsdGluRnVuY3Rpb25OYW1lXHJcbiAgfCBCaW5hcnlDdXN0b21FeHByZXNzaW9uXHJcbiAgfCB7XHJcbiAgICAgIHNjYWxhcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcclxuICAgICAgdmVjdG9yOiBCaW5hcnlDdXN0b21FeHByZXNzaW9uO1xyXG4gICAgfTtcclxuXHJcbmNvbnN0IGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbVNoYWRlciA9IChcclxuICBzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcixcclxuICBkaW1zQTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgZGltc0I6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGRpbXNPdXRwdXQ6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHZlY3Rvcml6ZTogYm9vbGVhbixcclxuICBkb0Jyb2FkY2FzdDogYm9vbGVhbixcclxuICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQ6IGJvb2xlYW4sXHJcbiAgZnVuY0NhbGw6IEJpbmFyeUZ1bmN0aW9uQ2FsbCxcclxuICB0eXBlQTogbnVtYmVyLFxyXG4gIHR5cGVCOiBudW1iZXIsXHJcbiAgdHlwZU91dHB1dDogbnVtYmVyLFxyXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcclxuKSA9PiB7XHJcbiAgbGV0IGV4cHJlc3Npb25TY2FsYXI6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XHJcbiAgbGV0IGV4cHJlc3Npb25WZWN0b3I6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XHJcbiAgaWYgKHR5cGVvZiBmdW5jQ2FsbCA9PT0gJ3N0cmluZycpIHtcclxuICAgIGV4cHJlc3Npb25TY2FsYXIgPSBleHByZXNzaW9uVmVjdG9yID0gKGEsIGIpID0+IGAke2Z1bmNDYWxsfSgoJHthfSksKCR7Yn0pKWA7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY0NhbGwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGV4cHJlc3Npb25TY2FsYXIgPSBleHByZXNzaW9uVmVjdG9yID0gZnVuY0NhbGw7XHJcbiAgfSBlbHNlIHtcclxuICAgIGV4cHJlc3Npb25TY2FsYXIgPSBmdW5jQ2FsbC5zY2FsYXI7XHJcbiAgICBleHByZXNzaW9uVmVjdG9yID0gZnVuY0NhbGwudmVjdG9yO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dERhdGEnLCB0eXBlT3V0cHV0LCBkaW1zT3V0cHV0Lmxlbmd0aCwgNCk7XHJcbiAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2FEYXRhJywgdHlwZUEsIGRpbXNBLmxlbmd0aCwgNCk7XHJcbiAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2JEYXRhJywgdHlwZUIsIGRpbXNCLmxlbmd0aCwgNCk7XHJcblxyXG4gIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XHJcbiAgaWYgKHZlY3Rvcml6ZSkge1xyXG4gICAgaWYgKGRvQnJvYWRjYXN0KSB7XHJcbiAgICAgIGNvbnN0IGlzQU9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQSkgPT09IDE7XHJcbiAgICAgIGNvbnN0IGlzQk9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQikgPT09IDE7XHJcbiAgICAgIGNvbnN0IGFMYXN0RGltRGl2aXNpYmxlQnk0ID0gZGltc0EubGVuZ3RoID4gMCAmJiBkaW1zQVtkaW1zQS5sZW5ndGggLSAxXSAlIDQgPT09IDA7XHJcbiAgICAgIGNvbnN0IGJMYXN0RGltRGl2aXNpYmxlQnk0ID0gZGltc0IubGVuZ3RoID4gMCAmJiBkaW1zQltkaW1zQi5sZW5ndGggLSAxXSAlIDQgPT09IDA7XHJcbiAgICAgIGlmIChpc0FPbmVFbGVtZW50IHx8IGlzQk9uZUVsZW1lbnQpIHtcclxuICAgICAgICBhc3NpZ25tZW50ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KFxyXG4gICAgICAgICAgJ2dsb2JhbF9pZHgnLFxyXG4gICAgICAgICAgZXhwcmVzc2lvblZlY3RvcihcclxuICAgICAgICAgICAgaXNBT25lRWxlbWVudCA/IGAke2EudHlwZS52YWx1ZX0oJHthLmdldEJ5T2Zmc2V0KCcwJyl9LngpYCA6IGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSxcclxuICAgICAgICAgICAgaXNCT25lRWxlbWVudCA/IGAke2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KCcwJyl9LngpYCA6IGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSxcclxuICAgICAgICAgICksXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhc3NpZ25tZW50ID0gYFxyXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCAqIDR1Jyl9O1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9ICR7Yi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xyXG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldChcclxuICAgICAgICAgICAgICAnZ2xvYmFsX2lkeCcsXHJcbiAgICAgICAgICAgICAgZXhwcmVzc2lvblZlY3RvcihcclxuICAgICAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCB8fCBhTGFzdERpbURpdmlzaWJsZUJ5NFxyXG4gICAgICAgICAgICAgICAgICA/IGEuZ2V0QnlPZmZzZXQoJ29mZnNldEEgLyA0dScpXHJcbiAgICAgICAgICAgICAgICAgIDogYCR7YS50eXBlLnZhbHVlfSgke2EuZ2V0QnlPZmZzZXQoJ29mZnNldEEgLyA0dScpfVtvZmZzZXRBICUgNHVdKWAsXHJcbiAgICAgICAgICAgICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgfHwgYkxhc3REaW1EaXZpc2libGVCeTRcclxuICAgICAgICAgICAgICAgICAgPyBiLmdldEJ5T2Zmc2V0KCdvZmZzZXRCIC8gNHUnKVxyXG4gICAgICAgICAgICAgICAgICA6IGAke2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KCdvZmZzZXRCIC8gNHUnKX1bb2Zmc2V0QiAlIDR1XSlgLFxyXG4gICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICBgO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhc3NpZ25tZW50ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KFxyXG4gICAgICAgICdnbG9iYWxfaWR4JyxcclxuICAgICAgICBleHByZXNzaW9uVmVjdG9yKGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFkb0Jyb2FkY2FzdCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG5lY2Vzc2FyeSB0byB1c2Ugc2NhbGFyIGltcGxlbWVudGF0aW9uIGZvciBlbGVtZW50LXdpc2UgYmluYXJ5IG9wIGltcGxlbWVudGF0aW9uLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4ge1xyXG4gICAgICBjb25zdCBleHByZXNzaW9uQSA9IGBhRGF0YVtpbmRleEEke3h9XVtjb21wb25lbnRBJHt4fV1gO1xyXG4gICAgICBjb25zdCBleHByZXNzaW9uQiA9IGBiRGF0YVtpbmRleEIke3h9XVtjb21wb25lbnRCJHt4fV1gO1xyXG4gICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7eH0gPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3h9YCwgb3V0cHV0KX07XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXRCJHt4fSA9ICR7Yi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcclxuICAgICAgICAgICAgbGV0IGluZGV4QSR7eH0gPSBvZmZzZXRBJHt4fSAvIDR1O1xyXG4gICAgICAgICAgICBsZXQgaW5kZXhCJHt4fSA9IG9mZnNldEIke3h9IC8gNHU7XHJcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRBJHt4fSA9IG9mZnNldEEke3h9ICUgNHU7XHJcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHt4fSA9IG9mZnNldEIke3h9ICUgNHU7XHJcbiAgICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7ZXhwcmVzc2lvblNjYWxhcihleHByZXNzaW9uQSwgZXhwcmVzc2lvbkIpfSk7XHJcbiAgICAgICAgICBgO1xyXG4gICAgfTtcclxuICAgIGlmICh0eXBlT3V0cHV0ID09PSBEYXRhVHlwZS5ib29sKSB7XHJcbiAgICAgIGFzc2lnbm1lbnQgPSBgXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDEsICd1MzInKX1cclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XHJcbiAgICAgICAgICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFzc2lnbm1lbnQgPSBgXHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDApfVxyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAxKX1cclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMil9XHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDMpfVxyXG4gICAgICAgICAgYDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBgXHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGEsIGIsIG91dHB1dCl9XHJcblxyXG4gICAgICAgICR7YWRkaXRpb25hbEltcGxlbWVudGF0aW9uID8/ICcnfVxyXG5cclxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxyXG4gICAgICAgICR7YXNzaWdubWVudH1cclxuICAgICAgfWA7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1JbmZvID0gKFxyXG4gIG5hbWU6IHN0cmluZyxcclxuICBjYWNoZUtleTogc3RyaW5nLFxyXG4gIGE6IFRlbnNvclZpZXcsXHJcbiAgYjogVGVuc29yVmlldyxcclxuICBmdW5jQ2FsbDogQmluYXJ5RnVuY3Rpb25DYWxsLFxyXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcclxuICBvdXRwdXREYXRhVHlwZTogbnVtYmVyID0gYS5kYXRhVHlwZSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGFEaW1zID0gYS5kaW1zLm1hcCgoeCkgPT4gTnVtYmVyKHgpID8/IDEpO1xyXG4gIGNvbnN0IGJEaW1zID0gYi5kaW1zLm1hcCgoeCkgPT4gTnVtYmVyKHgpID8/IDEpO1xyXG4gIGNvbnN0IGlzQnJvYWRjYXN0ID0gIVNoYXBlVXRpbC5hcmVFcXVhbChhRGltcywgYkRpbXMpO1xyXG4gIGxldCBvdXRwdXRTaGFwZSA9IGFEaW1zO1xyXG4gIGxldCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoYURpbXMpO1xyXG5cclxuICBsZXQgdmVjdG9yaXplID0gZmFsc2U7XHJcbiAgbGV0IHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCA9IGZhbHNlO1xyXG5cclxuICAvLyBUT0RPOiBkZWFsIHdpdGggemVyby1zaXplZCB0ZW5zb3JzIChlZy4gZGltcz1bMSwwXSlcclxuICBjb25zdCBjYWNoZUtleUF1eCA9IFtpc0Jyb2FkY2FzdF07XHJcbiAgaWYgKGlzQnJvYWRjYXN0KSB7XHJcbiAgICBjb25zdCBjYWxjdWxhdGVkU2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhRGltcywgYkRpbXMsIGZhbHNlKTtcclxuICAgIGlmICghY2FsY3VsYXRlZFNoYXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xyXG4gICAgfVxyXG4gICAgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVkU2hhcGUuc2xpY2UoKTtcclxuICAgIG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgICBjb25zdCBpc0FPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoYURpbXMpID09PSAxO1xyXG4gICAgY29uc3QgaXNCT25lRWxlbWVudCA9IFNoYXBlVXRpbC5zaXplKGJEaW1zKSA9PT0gMTtcclxuICAgIGNvbnN0IGFMYXN0RGltRGl2aXNpYmxlQnk0ID0gYURpbXMubGVuZ3RoID4gMCAmJiBhRGltc1thRGltcy5sZW5ndGggLSAxXSAlIDQgPT09IDA7XHJcbiAgICBjb25zdCBiTGFzdERpbURpdmlzaWJsZUJ5NCA9IGJEaW1zLmxlbmd0aCA+IDAgJiYgYkRpbXNbYkRpbXMubGVuZ3RoIC0gMV0gJSA0ID09PSAwO1xyXG4gICAgY2FjaGVLZXlBdXgucHVzaChpc0FPbmVFbGVtZW50KTtcclxuICAgIGNhY2hlS2V5QXV4LnB1c2goaXNCT25lRWxlbWVudCk7XHJcbiAgICBjYWNoZUtleUF1eC5wdXNoKGFMYXN0RGltRGl2aXNpYmxlQnk0KTtcclxuICAgIGNhY2hlS2V5QXV4LnB1c2goYkxhc3REaW1EaXZpc2libGVCeTQpO1xyXG4gICAgLy8gY2hlY2sgd2hldGhlciB2ZWN0b3JpemUgY2FuIGJlIGVuYWJsZWRcclxuICAgIGxldCBzaGFyZWREaW1lbnNpb24gPSAxO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBkaW1BID0gYURpbXNbYURpbXMubGVuZ3RoIC0gaV07XHJcbiAgICAgIGNvbnN0IGRpbUIgPSBiRGltc1tiRGltcy5sZW5ndGggLSBpXTtcclxuICAgICAgaWYgKGRpbUEgPT09IGRpbUIpIHtcclxuICAgICAgICBzaGFyZWREaW1lbnNpb24gKj0gZGltQTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNoYXJlZERpbWVuc2lvbiAlIDQgPT09IDApIHtcclxuICAgICAgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0ID0gdHJ1ZTtcclxuICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoaXNBT25lRWxlbWVudCB8fCBpc0JPbmVFbGVtZW50IHx8IGFMYXN0RGltRGl2aXNpYmxlQnk0IHx8IGJMYXN0RGltRGl2aXNpYmxlQnk0KSB7XHJcbiAgICAgIHZlY3Rvcml6ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGVsZW1lbnQtd2lzZVxyXG4gICAgdmVjdG9yaXplID0gdHJ1ZTtcclxuICB9XHJcbiAgY2FjaGVLZXlBdXgucHVzaCh2ZWN0b3JpemUpO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZSxcclxuICAgIHNoYWRlckNhY2hlOiB7XHJcbiAgICAgIGhpbnQ6IGNhY2hlS2V5ICsgY2FjaGVLZXlBdXgubWFwKCh4KSA9PiB4LnRvU3RyaW5nKCkpLmpvaW4oJ18nKSxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJ10sXHJcbiAgICB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyKSA9PlxyXG4gICAgICBjcmVhdGVCaW5hcnlPcFByb2dyYW1TaGFkZXIoXHJcbiAgICAgICAgc2hhZGVySGVscGVyLFxyXG4gICAgICAgIGFEaW1zLFxyXG4gICAgICAgIGJEaW1zLFxyXG4gICAgICAgIG91dHB1dFNoYXBlLFxyXG4gICAgICAgIHZlY3Rvcml6ZSxcclxuICAgICAgICBpc0Jyb2FkY2FzdCxcclxuICAgICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQsXHJcbiAgICAgICAgZnVuY0NhbGwsXHJcbiAgICAgICAgYS5kYXRhVHlwZSxcclxuICAgICAgICBiLmRhdGFUeXBlLFxyXG4gICAgICAgIG91dHB1dERhdGFUeXBlLFxyXG4gICAgICAgIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbixcclxuICAgICAgKSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogY29tcG9uZW50IHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNCkgfSxcclxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhhRGltcywgYkRpbXMsIG91dHB1dFNoYXBlKSxcclxuICAgICAgXSxcclxuICAgIH0pLFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCBydW5CaW5hcnlPcCA9IChcclxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcclxuICBuYW1lOiBzdHJpbmcsXHJcbiAgZnVuY0NhbGw6IEJpbmFyeUZ1bmN0aW9uQ2FsbCxcclxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXHJcbiAgY2FjaGVLZXk/OiBzdHJpbmcsXHJcbiAgb3V0cHV0RGF0YVR5cGU/OiBudW1iZXIsXHJcbik6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShcclxuICAgIGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbUluZm8oXHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGNhY2hlS2V5ID8/ICcnLFxyXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcclxuICAgICAgY29udGV4dC5pbnB1dHNbMV0sXHJcbiAgICAgIGZ1bmNDYWxsLFxyXG4gICAgICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24sXHJcbiAgICAgIG91dHB1dERhdGFUeXBlLFxyXG4gICAgKSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFkZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIHJ1bkJpbmFyeU9wKGNvbnRleHQsICdBZGQnLCAoYSwgYikgPT4gYCR7YX0rJHtifWApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRpdiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIHJ1bkJpbmFyeU9wKGNvbnRleHQsICdEaXYnLCAoYSwgYikgPT4gYCR7YX0vJHtifWApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgcnVuQmluYXJ5T3AoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgJ0VxdWFsJyxcclxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9PT0ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT09JHtifSlgIH0sXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICBEYXRhVHlwZS5ib29sLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbXVsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ011bCcsIChhLCBiKSA9PiBgJHthfSoke2J9YCk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcG93ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgY29uc3QgdHlwZSA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMpLnR5cGUudmFsdWU7XHJcbiAgY29uc3Qgcm91bmRTdHIgPSB0eXBlID09PSAnaTMyJyA/ICdyb3VuZCcgOiAnJztcclxuICBydW5CaW5hcnlPcChcclxuICAgIGNvbnRleHQsXHJcbiAgICAnUG93JyxcclxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHBvd19jdXN0b20oJHthfSwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGBwb3dfdmVjdG9yX2N1c3RvbSgke2F9LCR7Yn0pYCB9LFxyXG4gICAgYFxyXG4gICAgZm4gcG93X2N1c3RvbShhIDogJHt0eXBlfSwgYiA6ICR7dHlwZX0pIC0+ICR7dHlwZX0ge1xyXG4gICAgICBpZiAoYiA9PSAke3R5cGV9KDAuMCkpIHtcclxuICAgICAgICByZXR1cm4gJHt0eXBlfSgxLjApO1xyXG4gICAgICB9IGVsc2UgaWYgKGEgPCAke3R5cGV9KDAuMCkgJiYgZjMyKGIpICE9IGZsb29yKGYzMihiKSkpIHtcclxuICAgICAgICByZXR1cm4gJHt0eXBlfShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlbGVjdChzaWduKGEpLCAke3R5cGV9KDEuMCksIHJvdW5kKGYzMihhYnMoYikgJSAke3R5cGV9KDIuMCkpKSAhPSAxLjApICogJHt0eXBlfSgke3JvdW5kU3RyfShwb3coZjMyKGFicyhhKSksIGYzMihiKSkpKTtcclxuICAgIH1cclxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dHlwZX0+LCBiIDogdmVjNDwke3R5cGV9PikgLT4gdmVjNDwke3R5cGV9PiB7XHJcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCB2ZWN0b3JpemVkIHBvd1xyXG4gICAgICByZXR1cm4gdmVjNDwke3R5cGV9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XHJcbiAgICB9XHJcbiAgICAgIGAsXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzdWIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBydW5CaW5hcnlPcChjb250ZXh0LCAnU3ViJywgKGEsIGIpID0+IGAke2F9LSR7Yn1gKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBncmVhdGVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgcnVuQmluYXJ5T3AoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgJ0dyZWF0ZXInLFxyXG4gICAgeyBzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX0+JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX0+JHtifSlgIH0sXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICBEYXRhVHlwZS5ib29sLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbGVzcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIHJ1bkJpbmFyeU9wKFxyXG4gICAgY29udGV4dCxcclxuICAgICdMZXNzJyxcclxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9PCR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9PCR7Yn0pYCB9LFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgRGF0YVR5cGUuYm9vbCxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdyZWF0ZXJPckVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgcnVuQmluYXJ5T3AoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgJ0dyZWF0ZXJPckVxdWFsJyxcclxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9Pj0ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT49JHtifSlgIH0sXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICB1bmRlZmluZWQsXHJcbiAgICBEYXRhVHlwZS5ib29sLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbGVzc09yRXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBydW5CaW5hcnlPcChcclxuICAgIGNvbnRleHQsXHJcbiAgICAnTGVzc09yRXF1YWwnLFxyXG4gICAgeyBzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX08PSR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9PD0ke2J9KWAgfSxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIERhdGFUeXBlLmJvb2wsXHJcbiAgKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uY2F0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXhpczogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcclxuICB9XHJcbiAgY29uc3QgcmVmZXJlbmNlSW5kZXggPSAwO1xyXG4gIGNvbnN0IHJlZmVyZW5jZUlucHV0ID0gaW5wdXRzW3JlZmVyZW5jZUluZGV4XTtcclxuICBjb25zdCBpbnB1dFR5cGUgPSByZWZlcmVuY2VJbnB1dC5kYXRhVHlwZTtcclxuICBjb25zdCBpbnB1dFJhbmsgPSByZWZlcmVuY2VJbnB1dC5kaW1zLmxlbmd0aDtcclxuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcclxuICAgIGlmIChpID09PSByZWZlcmVuY2VJbmRleCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBtYWtlIHN1cmUgdHlwZXMgb2YgYWxsIGlucHV0cyBtYXRjaFxyXG4gICAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBpbnB1dFR5cGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZScpO1xyXG4gICAgfVxyXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBkaW1lbnNpb25hbGl0eSBvZiBhbGwgaW5wdXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSBpbnB1dFJhbmspIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlJyk7XHJcbiAgICB9XHJcbiAgICBpbnB1dC5kaW1zLmZvckVhY2goKGRpbSwgaSkgPT4ge1xyXG4gICAgICBpZiAoaSAhPT0gYXhpcyAmJiBkaW0gIT09IHJlZmVyZW5jZUlucHV0LmRpbXNbaV0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuY29uc3QgY2FsY3VsYXRlSW5wdXRJbmRleEltcGwgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHNpemVJbkNvbmNhdEF4aXNTdHI6IHN0cmluZyk6IHN0cmluZyA9PiBgXHJcbiAgZm4gY2FsY3VsYXRlSW5wdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xyXG4gICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7bnVtYmVyT2ZUZW5zb3JzfXU+KCR7c2l6ZUluQ29uY2F0QXhpc1N0cn0pO1xyXG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc307IGkgKz0gMXUgKSB7XHJcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcclxuICAgICAgICByZXR1cm4gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICR7bnVtYmVyT2ZUZW5zb3JzfXU7XHJcbiAgfWA7XHJcblxyXG5jb25zdCBhc3NpZ25PdXRwdXREYXRhID0gKGlucHV0czogcmVhZG9ubHkgSW5kaWNlc0hlbHBlcltdLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpID0+IHtcclxuICBjb25zdCBudW1iZXJPZlRlbnNvcnMgPSBpbnB1dHMubGVuZ3RoO1xyXG5cclxuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xyXG4gICAgY29uc3QgcmV0dXJuU25pcHBldCA9IG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0c1tpXS5nZXRCeUluZGljZXMoJ2luZGljZXMnKSk7XHJcbiAgICBpZiAobnVtYmVyT2ZUZW5zb3JzID09PSAxKSB7XHJcbiAgICAgIGNvZGVMaW5lcy5wdXNoKHJldHVyblNuaXBwZXQpO1xyXG4gICAgfSBlbHNlIGlmIChpID09PSAwKSB7XHJcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke2l9dSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcclxuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xyXG4gICAgICBjb2RlTGluZXMucHVzaChgZWxzZSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtpfSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGFkanVzdGVkQXhpczogbnVtYmVyLFxyXG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcclxuICBkYXRhVHlwZTogRGF0YVR5cGUsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG5cclxuICBjb25zdCBzaXplSW5Db25jYXRBeGlzID0gbmV3IEFycmF5PG51bWJlcj4oaW5wdXRzLmxlbmd0aCk7XHJcbiAgY29uc3QgaW5wdXRWYXJzID0gbmV3IEFycmF5PEluZGljZXNIZWxwZXI+KGlucHV0cy5sZW5ndGgpO1xyXG5cclxuICBsZXQgcHJldmlvdXNTdW0gPSAwO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gW107XHJcbiAgY29uc3QgaW5wdXRSYW5rcyA9IFtdO1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9XTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgcHJldmlvdXNTdW0gKz0gaW5wdXRzW2ldLmRpbXNbYWRqdXN0ZWRBeGlzXTtcclxuICAgIHNpemVJbkNvbmNhdEF4aXNbaV0gPSBwcmV2aW91c1N1bTtcclxuICAgIGlucHV0UmFua3MucHVzaChpbnB1dHNbaV0uZGltcy5sZW5ndGgpO1xyXG4gICAgaW5wdXRWYXJzW2ldID0gaW5wdXRWYXJpYWJsZShgaW5wdXQke2l9YCwgZGF0YVR5cGUsIGlucHV0UmFua3NbaV0pO1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xyXG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNpemVJbkNvbmNhdEF4aXNbaV0gfSk7XHJcbiAgfVxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbaV0uZGltcykpO1xyXG4gIH1cclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xyXG5cclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgY29uc3QgaW5kaWNlc0F4aXMgPSBvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGFkanVzdGVkQXhpcyk7XHJcbiAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpc1N0ciA9IEFycmF5LmZyb20oQXJyYXkoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgpLmtleXMoKSlcclxuICAgIC5tYXAoKGkpID0+IGB1bmlmb3Jtcy5zaXplSW5Db25jYXRBeGlzJHtpfWApXHJcbiAgICAuam9pbignLCcpO1xyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxyXG5cclxuICAkeygoKSA9PiB7XHJcbiAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybShgc2l6ZUluQ29uY2F0QXhpcyR7aX1gLCAndTMyJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCBvdXRwdXQpO1xyXG4gIH0pKCl9XHJcblxyXG4gICR7Y2FsY3VsYXRlSW5wdXRJbmRleEltcGwoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgsIHNpemVJbkNvbmNhdEF4aXNTdHIpfVxyXG5cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cclxuXHJcbiAgICB2YXIgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuXHJcbiAgICBsZXQgaW5wdXRJbmRleCA9IGNhbGN1bGF0ZUlucHV0SW5kZXgoJHtpbmRpY2VzQXhpc30pO1xyXG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcclxuICAgICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7c2l6ZUluQ29uY2F0QXhpcy5sZW5ndGh9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XHJcbiAgICAgICR7aW5kaWNlc0F4aXN9IC09IHNpemVJbkNvbmNhdEF4aXNbaW5wdXRJbmRleCAtIDF1XTtcclxuICAgIH1cclxuXHJcbiAgICAke2Fzc2lnbk91dHB1dERhdGEoaW5wdXRWYXJzLCBvdXRwdXQpfVxyXG4gIH1gO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0NvbmNhdCcsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHthZGp1c3RlZEF4aXN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbmNhdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29uY2F0QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBhZGp1c3RlZEF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcclxuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGFkanVzdGVkQXhpcyk7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XHJcbiAgb3V0cHV0U2hhcGVbYWRqdXN0ZWRBeGlzXSA9IGlucHV0cy5yZWR1Y2UoXHJcbiAgICAoc3VtLCBpbnB1dCkgPT4gc3VtICsgKGlucHV0LmRpbXMubGVuZ3RoID4gYWRqdXN0ZWRBeGlzID8gaW5wdXQuZGltc1thZGp1c3RlZEF4aXNdIDogMCksXHJcbiAgICAwLFxyXG4gICk7XHJcbiAgLy8gMCBsZW5ndGggdGVuc29ycyBhcmUgdmFsaWQgZm9yIGNvbmNhdCwgcmVtb3ZlIHRoZW1cclxuICBjb25zdCBub25FbXB0eUlucHV0cyA9IGlucHV0cy5maWx0ZXIoKGlucHV0KSA9PiBTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSA+IDApO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVDb25jYXRQcm9ncmFtSW5mbyhub25FbXB0eUlucHV0cywgYWRqdXN0ZWRBeGlzLCBvdXRwdXRTaGFwZSwgaW5wdXRzWzBdLmRhdGFUeXBlKSwge1xyXG4gICAgaW5wdXRzOiBub25FbXB0eUlucHV0cyxcclxuICB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb25jYXRBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlciB9KTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgTUFYX0NMSVAsIE1JTl9DTElQIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgVW5pZm9ybXNBcnJheVR5cGUgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMge1xyXG4gIHJlYWRvbmx5IGFjdGl2YXRpb246IHN0cmluZztcclxuICByZWFkb25seSBjbGlwTWluPzogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IGNsaXBNYXg/OiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgYWxwaGE/OiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgYmV0YT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGdldEFjdGl2YXRpb25TbmlwcGV0ID0gKFxyXG4gIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXHJcbiAgdmFsdWVUeXBlOiBzdHJpbmcsXHJcbiAgYmFzZVR5cGUgPSAnZjMyJyxcclxuKTogc3RyaW5nID0+IHtcclxuICBzd2l0Y2ggKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbikge1xyXG4gICAgY2FzZSAnUmVsdSc6XHJcbiAgICAgIHJldHVybiBgdmFsdWUgPSBtYXgodmFsdWUsICR7dmFsdWVUeXBlfSgwLjApKTtgO1xyXG4gICAgY2FzZSAnU2lnbW9pZCc6XHJcbiAgICAgIHJldHVybiBgdmFsdWUgPSAoJHt2YWx1ZVR5cGV9KDEuMCkgLyAoJHt2YWx1ZVR5cGV9KDEuMCkgKyBleHAoLXZhbHVlKSkpO2A7XHJcbiAgICBjYXNlICdDbGlwJzpcclxuICAgICAgcmV0dXJuIGB2YWx1ZSA9IGNsYW1wKHZhbHVlLCAke3ZhbHVlVHlwZX0oJHtiYXNlVHlwZX0odW5pZm9ybXMuY2xpcF9taW4pKSwgJHt2YWx1ZVR5cGV9KCR7XHJcbiAgICAgICAgYmFzZVR5cGVcclxuICAgICAgfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO1xyXG4gICAgY2FzZSAnSGFyZFNpZ21vaWQnOlxyXG4gICAgICByZXR1cm4gYHZhbHVlID0gbWF4KCR7dmFsdWVUeXBlfSgwLjApLCBtaW4oJHt2YWx1ZVR5cGV9KDEuMCksICR7YmFzZVR5cGV9KHVuaWZvcm1zLmFscGhhKSAqIHZhbHVlICsgJHtcclxuICAgICAgICBiYXNlVHlwZVxyXG4gICAgICB9KHVuaWZvcm1zLmJldGEpKSk7YDtcclxuICAgIGNhc2UgJ0xlYWt5UmVsdSc6XHJcbiAgICAgIHJldHVybiBgdmFsdWUgPSBzZWxlY3QoJHtiYXNlVHlwZX0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUsIHZhbHVlLCB2YWx1ZSA+PSAke3ZhbHVlVHlwZX0oMC4wKSk7YDtcclxuICAgIGNhc2UgJ1RhbmgnOlxyXG4gICAgICByZXR1cm4gYGxldCBlMnggPSBleHAoLTIuMCAqIGFicyh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xyXG4gICAgICAgIGA7XHJcbiAgICBjYXNlICcnOlxyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICAvLyBUT0RPOiBhZGRpbmcgb3RoZXIgYWN0aXZhdGlvbnMgdGhhdCBjYW4gYmUgZnVzZWQuXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHthdHRyaWJ1dGVzLmFjdGl2YXRpb259YCk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEgPSAoXHJcbiAgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcclxuICBwcm9ncmFtVW5pZm9ybTogUHJvZ3JhbVVuaWZvcm1bXSxcclxuKSA9PiB7XHJcbiAgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybS5wdXNoKFxyXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmNsaXBNYXghIH0sXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuY2xpcE1pbiEgfSxcclxuICAgICk7XHJcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcclxuICAgIHByb2dyYW1Vbmlmb3JtLnB1c2goXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEhIH0sXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYmV0YSEgfSxcclxuICAgICk7XHJcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybS5wdXNoKHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEhIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMgPSAoYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlKSA9PiB7XHJcbiAgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XHJcbiAgICB1bmlmb3Jtcy5wdXNoKHsgbmFtZTogJ2NsaXBfbWF4JywgdHlwZTogJ2YzMicgfSwgeyBuYW1lOiAnY2xpcF9taW4nLCB0eXBlOiAnZjMyJyB9KTtcclxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0hhcmRTaWdtb2lkJykge1xyXG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0sIHsgbmFtZTogJ2JldGEnLCB0eXBlOiAnZjMyJyB9KTtcclxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0xlYWt5UmVsdScpIHtcclxuICAgIHVuaWZvcm1zLnB1c2goeyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJyB9KTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzID0gKFxyXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5kZWZpbmVkLFxyXG4pOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBhY3RpdmF0aW9uID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb24gYXMgc3RyaW5nKSB8fCAnJztcclxuICBpZiAoYWN0aXZhdGlvbiA9PT0gJ0hhcmRTaWdtb2lkJykge1xyXG4gICAgY29uc3QgW2FscGhhLCBiZXRhXSA9IChhdHRyaWJ1dGVzPy5hY3RpdmF0aW9uX3BhcmFtcyBhcyBbbnVtYmVyLCBudW1iZXJdKSB8fCBbMC4yLCAwLjVdO1xyXG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgYWxwaGEsIGJldGEgfTtcclxuICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdDbGlwJykge1xyXG4gICAgY29uc3QgW2NsaXBNaW4sIGNsaXBNYXhdID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb25fcGFyYW1zIGFzIFtudW1iZXIsIG51bWJlcl0pIHx8IFtNSU5fQ0xJUCwgTUFYX0NMSVBdO1xyXG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgY2xpcE1heCwgY2xpcE1pbiB9O1xyXG4gIH0gZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ0xlYWt5UmVsdScpIHtcclxuICAgIGNvbnN0IFthbHBoYV0gPSAoYXR0cmlidXRlcz8uYWN0aXZhdGlvbl9wYXJhbXMgYXMgW251bWJlcl0pIHx8IFswLjAxXTtcclxuICAgIHJldHVybiB7IGFjdGl2YXRpb24sIGFscGhhIH07XHJcbiAgfVxyXG4gIHJldHVybiB7IGFjdGl2YXRpb24gfTtcclxufTtcclxuIiwgIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKi9cclxuXHJcbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvYWN0aXZhdGlvbl91dGlsLnRzXHJcbi8vXHJcbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcclxuXHJcbmV4cG9ydCBjb25zdCB0eXBlU25pcHBldCA9IChjb21wb25lbnQ6IG51bWJlciwgZGF0YVR5cGU6IHN0cmluZykgPT4ge1xyXG4gIHN3aXRjaCAoY29tcG9uZW50KSB7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgIHJldHVybiBkYXRhVHlwZTtcclxuICAgIGNhc2UgMjpcclxuICAgICAgcmV0dXJuIGB2ZWMyPCR7ZGF0YVR5cGV9PmA7XHJcbiAgICBjYXNlIDM6XHJcbiAgICAgIHJldHVybiBgdmVjMzwke2RhdGFUeXBlfT5gO1xyXG4gICAgY2FzZSA0OlxyXG4gICAgICByZXR1cm4gYHZlYzQ8JHtkYXRhVHlwZX0+YDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb21wb25lbnR9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBiaWFzU25pcHBldCA9IChoYXNCaWFzOiBib29sZWFuKTogc3RyaW5nID0+IGBcclxuICAgICAgJHtoYXNCaWFzID8gJ3ZhbHVlID0gdmFsdWUgKyBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzKTsnIDogJyd9XHJcbiAgICAgIGA7XHJcbiIsICIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcblxyXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtY29yZS9zcmMvb3BzL2NvbnZfdXRpbC50c1xyXG4vL1xyXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XHJcblxyXG5leHBvcnQgY29uc3QgdXRpbEZ1bmN0aW9ucyA9IChzdHJpZGVTdHI6IHN0cmluZykgPT4gYFxyXG5mbiBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBpMzIge1xyXG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXHJcbiAgICAgIHNoYXBlLnkgKiBzaGFwZS56ICogc2hhcGUudywgc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLncsIDEpKTtcclxufVxyXG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xyXG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXHJcbiAgICBpMzIoJHtzdHJpZGVTdHJ9LngpLCBpMzIoJHtzdHJpZGVTdHJ9LnkpLCBpMzIoJHtzdHJpZGVTdHJ9LnopLCAxKSk7XHJcbn1cclxuYDtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgZ2V0RWxlbWVudEF0LFxyXG4gIGdldE1heENvbXBvbmVudHMsXHJcbiAgSW5kaWNlc0hlbHBlcixcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIGludGVybmFsVmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcbmltcG9ydCB7XHJcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLFxyXG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsXHJcbiAgZ2V0QWN0aXZhdGlvblNuaXBwZXQsXHJcbiAgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcclxufSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xyXG5cclxuLy8gSGVscGVyIHRoYXQgY29udmVydCBvdXRwdXQgYmF0Y2ggaW5kaWNlcyB0byBpbnB1dCBiYXRjaCBpbmRpY2VzIHVzaW5nIG9ubHkgdGhlIHJhbmsgYW5kXHJcbi8vIHRoZSBzaGFwZSBpbmZvcm1hdGlvbiBpbiB1bmlmb3JtXHJcbmV4cG9ydCBjb25zdCBjb252ZXJ0T3V0cHV0QmF0Y2hJbmRpY2VzVG9JbnB1dEJhdGNoSW5kaWNlcyA9IChcclxuICB0YXJnZXRJbmRpY2VzTmFtZTogc3RyaW5nLFxyXG4gIGlucHV0VmFyaWFibGU6IEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRCYXRjaFJhbms6IG51bWJlcixcclxuICBvdXRwdXRCYXRjaFJhbms6IG51bWJlcixcclxuICBiYXRjaEluZGljZXNOYW1lOiBzdHJpbmcsXHJcbikgPT4ge1xyXG4gIC8vIEFzc3VtZSBvdXRwdXRCYXRjaFJhbmsgPj0gaW5wdXRCYXRjaFJhbmssIHRoZSBmaXJzdCBvdXRwdXRCYXRjaFJhbmsgLSBpbnB1dEJhdGNoUmFuayBvZlxyXG4gIC8vIG91dHB1dEJhdGNoUmFuayBzaG91bGQgYmUgaWdub3JlZC5cclxuICBjb25zdCBleHRlbmRpbmdJbnB1dFJhbmsgPSBvdXRwdXRCYXRjaFJhbmsgLSBpbnB1dEJhdGNoUmFuaztcclxuICByZXR1cm4gYFxyXG4gICAgICAke0FycmF5LmZyb20oeyBsZW5ndGg6IGlucHV0QmF0Y2hSYW5rIH0pXHJcbiAgICAgICAgLm1hcChcclxuICAgICAgICAgIChfLCBpKSA9PiBgXHJcbiAgICAgIGlmICgke2dldEVsZW1lbnRBdChpbnB1dFZhcmlhYmxlLnNoYXBlLCBpLCBpbnB1dFZhcmlhYmxlLnJhbmspfSAhPSAxKSB7XHJcbiAgICAgICAgJHtpbnB1dFZhcmlhYmxlLmluZGljZXNTZXQodGFyZ2V0SW5kaWNlc05hbWUsIGksIGdldEVsZW1lbnRBdChiYXRjaEluZGljZXNOYW1lLCBpICsgZXh0ZW5kaW5nSW5wdXRSYW5rLCBvdXRwdXRCYXRjaFJhbmspKX1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAke2lucHV0VmFyaWFibGUuaW5kaWNlc1NldCh0YXJnZXRJbmRpY2VzTmFtZSwgaSwgMCl9XHJcbiAgICAgIH1gLFxyXG4gICAgICAgIClcclxuICAgICAgICAuam9pbignJyl9XHJcbmA7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcclxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgcmVzaGFwZWRPdXRwdXRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGlzQ2hhbm5lbHNMYXN0ID0gZmFsc2UgLyogb25seSB1c2VkIGZvciBjb252MmRCeU1hdE11bCovLFxyXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBiU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcclxuXHJcbiAgY29uc3QgTSA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMl07XHJcbiAgY29uc3QgTiA9IGJTaGFwZVtiU2hhcGUubGVuZ3RoIC0gMV07XHJcbiAgY29uc3QgSyA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoTik7XHJcbiAgY29uc3QgYUNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEspO1xyXG4gIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMoTSk7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMgLyBvdXRwdXROdW1iZXI7XHJcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xyXG4gIGNvbnN0IG91dGVyRGltcyA9IHJlc2hhcGVkT3V0cHV0U2hhcGUgPyByZXNoYXBlZE91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKSA6IG91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKTtcclxuICBjb25zdCBiYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRlckRpbXMpO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlSW5TaGFkZXIgPSBbYmF0Y2hTaXplLCBNLCBOXTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTiB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEsgfSxcclxuICBdO1xyXG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0ZXJEaW1zLCBhU2hhcGUsIGJTaGFwZSkpO1xyXG4gIGlmIChoYXNCaWFzKSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xyXG4gIH1cclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZUluU2hhZGVyKSk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgYmF0Y2hEaW1zID0gaW50ZXJuYWxWYXJpYWJsZSgnYmF0Y2hfZGltcycsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0ZXJEaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgYVNoYXBlLmxlbmd0aCwgYUNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGJTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGVJblNoYWRlci5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcclxuICAgIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xyXG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbYSwgYl07XHJcbiAgICBsZXQgcHJvY2Vzc0JpYXMgPSAnJztcclxuICAgIGlmIChoYXNCaWFzKSB7XHJcbiAgICAgIGNvbnN0IGJpYXNDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBjb21wb25lbnRzIDogMTtcclxuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGJpYXNDb21wb25lbnRzKSk7XHJcbiAgICAgIHByb2Nlc3NCaWFzID0gYCR7XHJcbiAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBgdmFsdWUgKz0gYmlhc1tjb2wgLyAke2JpYXNDb21wb25lbnRzfV07YCA6IGB2YWx1ZSArPSAke291dHB1dC50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgXHJcbiAgICAgIH1gO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgXTtcclxuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhY3RpdmF0aW9uQXR0cmlidXRlcywgdW5pZm9ybXMpO1xyXG5cclxuICAgIGNvbnN0IGNhbGNSZXN1bHQgPSAoKTogc3RyaW5nID0+IHtcclxuICAgICAgbGV0IGNhbGNTdHIgPSBgdmFyIGFfZGF0YTogJHthLnR5cGUudmFsdWV9O2A7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUNvbXBvbmVudHM7IGkrKykge1xyXG4gICAgICAgIGNhbGNTdHIgKz0gYFxyXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke2l9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7aX0pICogdW5pZm9ybXMuTiArIGNvbCkgLyAke2NvbXBvbmVudHN9XTtgO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0TnVtYmVyOyBpKyspIHtcclxuICAgICAgICBjYWxjU3RyICs9IGBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke2l9KSAqIHVuaWZvcm1zLksgKyBrKSAvICR7YUNvbXBvbmVudHN9XTtgO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFDb21wb25lbnRzOyBqKyspIHtcclxuICAgICAgICAgIGNhbGNTdHIgKz0gYFxyXG4gICAgICAgICAgICB2YWx1ZXNbJHtpfV0gPSBmbWEoJHtiLnR5cGUudmFsdWV9KGFfZGF0YSR7YUNvbXBvbmVudHMgPT09IDEgPyAnJyA6IGBbJHtqfV1gfSksIGJfZGF0YSR7an0sIHZhbHVlc1ske2l9XSk7XFxuYDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNhbGNTdHI7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXJcclxuICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKVxyXG4gICAgLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoYmF0Y2hEaW1zKVxyXG4gICAgLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG4gICAgbGV0IGNvbCA9IChnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLk4gLyAke2NvbXBvbmVudHN9KSkgKiAke2NvbXBvbmVudHN9O1xyXG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuTiAvICR7Y29tcG9uZW50c30pO1xyXG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHtvdXRwdXROdW1iZXJ9O1xyXG4gICAgbGV0IHJvdyA9IChpbmRleDEgJSBzdHJpZGUxKSAqICR7b3V0cHV0TnVtYmVyfTtcclxuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHN0cmlkZTE7XHJcblxyXG4gICAgJHtvdXRwdXRTaGFwZS5sZW5ndGggPT09IDIgPyAnJyA6IGBsZXQgYmF0Y2hfaW5kaWNlcyA9ICR7YmF0Y2hEaW1zLm9mZnNldFRvSW5kaWNlcygnYmF0Y2gnKX07YH1cclxuXHJcbiAgICB2YXIgYV9pbmRpY2VzOiAke2EudHlwZS5pbmRpY2VzfTtcclxuICAgICR7Y29udmVydE91dHB1dEJhdGNoSW5kaWNlc1RvSW5wdXRCYXRjaEluZGljZXMoJ2FfaW5kaWNlcycsIGEsIGEucmFuayAtIDIsIGJhdGNoRGltcy5yYW5rLCAnYmF0Y2hfaW5kaWNlcycpfVxyXG4gICAgJHthLmluZGljZXNTZXQoJ2FfaW5kaWNlcycsIGEucmFuayAtIDIsIDApfVxyXG4gICAgJHthLmluZGljZXNTZXQoJ2FfaW5kaWNlcycsIGEucmFuayAtIDEsIDApfVxyXG4gICAgbGV0IGFfb2Zmc2V0ID0gJHthLmluZGljZXNUb09mZnNldCgnYV9pbmRpY2VzJyl9O1xyXG5cclxuICAgIHZhciBiX2luZGljZXM6ICR7Yi50eXBlLmluZGljZXN9O1xyXG4gICAgJHtjb252ZXJ0T3V0cHV0QmF0Y2hJbmRpY2VzVG9JbnB1dEJhdGNoSW5kaWNlcygnYl9pbmRpY2VzJywgYiwgYi5yYW5rIC0gMiwgYmF0Y2hEaW1zLnJhbmssICdiYXRjaF9pbmRpY2VzJyl9XHJcbiAgICAke2IuaW5kaWNlc1NldCgnYl9pbmRpY2VzJywgYi5yYW5rIC0gMiwgMCl9XHJcbiAgICAke2IuaW5kaWNlc1NldCgnYl9pbmRpY2VzJywgYi5yYW5rIC0gMSwgMCl9XHJcbiAgICBsZXQgYl9vZmZzZXQgPSAke2IuaW5kaWNlc1RvT2Zmc2V0KCdiX2luZGljZXMnKX07XHJcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXJ9PjtcclxuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgayA9IGsgKyAke2FDb21wb25lbnRzfSkge1xyXG4gICAgICAke2NhbGNSZXN1bHQoKX1cclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xyXG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XHJcbiAgICAgICR7cHJvY2Vzc0JpYXN9XHJcbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxyXG4gICAgICBsZXQgY3VyX2luZGljZXMgPSAke291dHB1dC50eXBlLmluZGljZXN9KGJhdGNoLCByb3cgKyBpLCBjb2wpO1xyXG4gICAgICBsZXQgb2Zmc2V0ID0gJHtvdXRwdXQuaW5kaWNlc1RvT2Zmc2V0KCdjdXJfaW5kaWNlcycpfTtcclxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoYG9mZnNldCAvICR7Y29tcG9uZW50c31gLCAndmFsdWUnKX07XHJcbiAgICB9XHJcbiAgfVxyXG4gIGA7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ01hdE11bE5haXZlJyxcclxuICAgIHNoYWRlckNhY2hlOiB7XHJcbiAgICAgIGhpbnQ6IGAke2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259OyR7Y29tcG9uZW50c307JHthQ29tcG9uZW50c307JHtvdXRwdXROdW1iZXJ9OyR7aXNDaGFubmVsc0xhc3R9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IGhhc0JpYXMgPyBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ10gOiBbJ3JhbmsnLCAncmFuayddLFxyXG4gICAgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcbiIsICIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcblxyXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL21hdG11bF9wYWNrZWRfd2ViZ3B1LnRzXHJcbi8vXHJcbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcclxuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uLy4uL3R5cGVzJztcclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgaW50ZXJuYWxWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4uL2NvbW1vbic7XHJcbmltcG9ydCB7XHJcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLFxyXG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsXHJcbiAgZ2V0QWN0aXZhdGlvblNuaXBwZXQsXHJcbiAgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyxcclxufSBmcm9tICcuLi9mdXNlLXV0aWxzJztcclxuaW1wb3J0IHsgY29udmVydE91dHB1dEJhdGNoSW5kaWNlc1RvSW5wdXRCYXRjaEluZGljZXMgfSBmcm9tICcuLi9tYXRtdWwtc2hhZGVycyc7XHJcblxyXG5pbXBvcnQgeyB0eXBlU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcclxuXHJcbmNvbnN0IHdyaXRlRGF0YVRvU3ViQVZlYzRTbmlwcGV0ID0gKHRyYW5zcG9zZTogYm9vbGVhbiwgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcikgPT4ge1xyXG4gIGlmICh0cmFuc3Bvc2UpIHtcclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXHJcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcclxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcclxuICAgICAgICBgO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxyXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXHJcbiAgICAgICAgICBrU3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xyXG4gICAgICAgIGA7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY2FsY3VsYXRlUmVzdWx0U25pcHBldCA9ICh0cmFuc3Bvc2VBOiBib29sZWFuLCBpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcclxuICBpZiAodHJhbnNwb3NlQSkge1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XHJcbiAgICAgICAgbGV0IEFDYWNoZWQxID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW2xvY2FsUm93XTtcclxuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xyXG4gICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2xldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107J31cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XHJcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xyXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcclxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZDJbaV0gKyBhY2NbaV07XHJcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldOyd9XHJcbiAgICAgICAgfWA7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xyXG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcclxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xyXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XHJcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcclxuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2FjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldOyd9XHJcbiAgICAgICAgfWA7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlID0gKFxyXG4gIHdvcmtQZXJUaHJlYWQ6IG51bWJlcltdLFxyXG4gIHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICB0eXBlID0gJ2YzMicsXHJcbiAgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcixcclxuICB0cmFuc3Bvc2VBID0gZmFsc2UsXHJcbiAgdGlsZUlubmVyID0gMzIsXHJcbiAgc3BsaXRLID0gZmFsc2UsXHJcbiAgc3BsaXRlZERpbUlubmVyID0gMzIsXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtncm91cFNpemVbMV0gKiB3b3JrUGVyVGhyZWFkWzFdO1xyXG4gIGNvbnN0IHRpbGVCT3V0ZXIgPSB3b3JrZ3JvdXBTaXplWzBdICogd29ya1BlclRocmVhZFswXTtcclxuICBjb25zdCB0aWxlQVdpZHRoID0gdHJhbnNwb3NlQSA/IHRpbGVBT3V0ZXIgOiB0aWxlSW5uZXI7XHJcbiAgY29uc3QgdGlsZUFIaWdodCA9IHRyYW5zcG9zZUEgPyB0aWxlSW5uZXIgOiB0aWxlQU91dGVyO1xyXG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSB0aWxlQVdpZHRoIC8gd29ya2dyb3VwU2l6ZVswXTtcclxuICBjb25zdCByb3dQZXJUaHJlYWRCID0gdGlsZUlubmVyIC8gd29ya2dyb3VwU2l6ZVsxXTtcclxuXHJcbiAgaWYgKFxyXG4gICAgIShcclxuICAgICAgKCh0cmFuc3Bvc2VBICYmIGlubmVyRWxlbWVudFNpemUgPT09IDQgJiYgd29ya1BlclRocmVhZFsxXSA9PT0gNCkgfHxcclxuICAgICAgICAoIXRyYW5zcG9zZUEgJiYgKGlubmVyRWxlbWVudFNpemUgPT09IDMgfHwgaW5uZXJFbGVtZW50U2l6ZSA9PT0gNCkpKSAmJlxyXG4gICAgICB0aWxlQVdpZHRoICUgd29ya2dyb3VwU2l6ZVswXSA9PT0gMCAmJlxyXG4gICAgICB0aWxlSW5uZXIgJSB3b3JrZ3JvdXBTaXplWzFdID09PSAwICYmXHJcbiAgICAgIHdvcmtQZXJUaHJlYWRbMF0gPT09IDRcclxuICAgIClcclxuICApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgSWYgdHJhbnNwb3NlQSAke3RyYW5zcG9zZUF9IGlzIHRydWUsIGlubmVyRWxlbWVudFNpemUgJHtpbm5lckVsZW1lbnRTaXplfSBhbmQgd29ya1BlclRocmVhZFsxXSAke3dvcmtQZXJUaHJlYWRbMV19IG11c3QgYmUgNC5cclxuICAgICAgT3RoZXJ3aXNlLCBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gbXVzdCBiZSAzIG9yIDQuXHJcbiAgdGlsZUFXaWR0aCAke3RpbGVBV2lkdGh9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3dvcmtncm91cFNpemVbMF19LiB0aWxlSW5uZXIgJHt0aWxlSW5uZXJ9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0gJHt3b3JrZ3JvdXBTaXplWzFdfS4gY29sUGVyVGhyZWFkICR7d29ya1BlclRocmVhZFswXX0gbXVzdCBiZSA0LmApO1xyXG4gIH1cclxuICByZXR1cm4gYFxyXG52YXI8d29ya2dyb3VwPiBtbV9Bc3ViOiBhcnJheTxhcnJheTx2ZWMke2lubmVyRWxlbWVudFNpemV9PCR7dHlwZX0+LCAke3RpbGVBV2lkdGggLyBpbm5lckVsZW1lbnRTaXplfT4sICR7dGlsZUFIaWdodH0+O1xyXG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7dHlwZX0+LCAke3RpbGVCT3V0ZXIgLyB3b3JrUGVyVGhyZWFkWzBdfT4sICR7dGlsZUlubmVyfT47XHJcblxyXG5jb25zdCByb3dQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMV19O1xyXG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMF19O1xyXG5jb25zdCBpbm5lckVsZW1lbnRTaXplID0gJHtpbm5lckVsZW1lbnRTaXplfTtcclxuY29uc3QgdGlsZUlubmVyID0gJHt0aWxlSW5uZXJ9O1xyXG5cclxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7d29ya2dyb3VwU2l6ZVswXX0sICR7d29ya2dyb3VwU2l6ZVsxXX0sICR7d29ya2dyb3VwU2l6ZVsyXX0pXHJcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcclxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXHJcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xyXG4gIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xyXG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XHJcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcclxuXHJcbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xyXG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XHJcbiAgbGV0IGJhdGNoID0gJHtzcGxpdEsgPyAnMCcgOiAnaTMyKGdsb2JhbElkLnopJ307XHJcbiAgJHtiYXRjaERpbXMgPyBgbGV0IGJhdGNoSW5kaWNlcyA9ICR7YmF0Y2hEaW1zLm9mZnNldFRvSW5kaWNlcygndTMyKGJhdGNoKScpfTtgIDogJyd9XHJcbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHt0aWxlQU91dGVyfTtcclxuXHJcbiAgbGV0IG51bV90aWxlcyA9ICR7c3BsaXRLID8gYCR7TWF0aC5jZWlsKHNwbGl0ZWREaW1Jbm5lciAvIHRpbGVJbm5lcil9YCA6ICcodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxJ307XHJcbiAgdmFyIGtTdGFydCA9ICR7c3BsaXRLID8gYGkzMihnbG9iYWxJZC56KSAqICR7c3BsaXRlZERpbUlubmVyfWAgOiAnMCd9O1xyXG5cclxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7dHlwZX0+LCByb3dQZXJUaHJlYWQ+O1xyXG5cclxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cclxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7cm93UGVyVGhyZWFkQn07XHJcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xyXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXHJcbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XHJcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XHJcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xyXG4gICAgICAgICAgJHt3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXHJcbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3Jvd1BlclRocmVhZEJ9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xyXG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcclxuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XHJcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCwga1N0YXJ0ICsgaW5wdXRSb3csIGdsb2JhbENvbCR7XHJcbiAgICAgICAgICAgIGJhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xyXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cclxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcclxuICAgICAgICAgIGxldCBCQ2FjaGVkMCA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW3RpbGVDb2xdO1xyXG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xyXG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xyXG4gICAgICAgICAgJHtpbm5lckVsZW1lbnRTaXplID09PSAzID8gJycgOiAnbGV0IEJDYWNoZWQzID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW3RpbGVDb2xdOyd9XHJcblxyXG4gICAgICAgICAgJHtjYWxjdWxhdGVSZXN1bHRTbmlwcGV0KHRyYW5zcG9zZUEsIGlubmVyRWxlbWVudFNpemUpfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xyXG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XHJcbiAgfVxyXG59YDtcclxufTtcclxuXHJcbmNvbnN0IHdyaXRlRGF0YVRvU3ViQVNuaXBwZXQgPSAodHJhbnNwb3NlOiBib29sZWFuLCBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyKSA9PiB7XHJcbiAgaWYgKHRyYW5zcG9zZSkge1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXHJcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXHJcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XHJcbiAgICAgICAgICAgIGA7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxyXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRSb3csXHJcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xyXG4gICAgICAgICAgICBgO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IHJlYWREYXRhRnJvbVN1YkFTbmlwcGV0ID0gKHRyYW5zcG9zZUE6IGJvb2xlYW4pID0+XHJcbiAgdHJhbnNwb3NlQSA/ICdsZXQgQUNhY2hlZCA9IG1tX0FzdWJba11bdGlsZVJvdyArIGlubmVyUm93XTsnIDogJ2xldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaW5uZXJSb3ddW2tdOyc7XHJcblxyXG4vLyBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzIG1lYW5zIHNlcXVlbnRpYWwgZGF0YSBpbiBtZW1vcnkgaXMgYWNjZXNzZWQgYnlcclxuLy8gdGhyZWFkcywgaW5zdGVhZCBvZiBhIHNpbmdsZSB0aHJlYWQgKGRlZmF1bHQgYmVoYXZpb3IpLlxyXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFNvdXJjZSA9IChcclxuICB3b3JrUGVyVGhyZWFkOiBudW1iZXJbXSxcclxuICB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgdHlwZSA9ICdmMzInLFxyXG4gIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIsXHJcbiAgdHJhbnNwb3NlQSA9IGZhbHNlLFxyXG4gIHRpbGVJbm5lciA9IDMyLFxyXG4gIHNwbGl0SyA9IGZhbHNlLFxyXG4gIHNwbGl0ZWREaW1Jbm5lciA9IDMyLFxyXG4gIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgPSBmYWxzZSxcclxuKTogc3RyaW5nID0+IHtcclxuICBjb25zdCB0aWxlQU91dGVyID0gd29ya1BlclRocmVhZFsxXSAqIHdvcmtncm91cFNpemVbMV07XHJcbiAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtQZXJUaHJlYWRbMF0gKiB3b3JrZ3JvdXBTaXplWzBdO1xyXG4gIGNvbnN0IHRpbGVBV2lkdGggPSB0cmFuc3Bvc2VBID8gdGlsZUFPdXRlciA6IHRpbGVJbm5lcjtcclxuICBjb25zdCB0aWxlQUhpZ2h0ID0gdHJhbnNwb3NlQSA/IHRpbGVJbm5lciA6IHRpbGVBT3V0ZXI7XHJcblxyXG4gIGlmIChcclxuICAgICEodGlsZUFIaWdodCAlIHdvcmtncm91cFNpemVbMV0gPT09IDAgJiYgdGlsZUFXaWR0aCAlIHdvcmtncm91cFNpemVbMF0gPT09IDAgJiYgdGlsZUlubmVyICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMClcclxuICApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYHRpbGVBSGlnaHQgJHt0aWxlQUhpZ2h0fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt3b3JrZ3JvdXBTaXplWzFdfSwgdGlsZUFXaWR0aCAke3RpbGVBV2lkdGh9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3dvcmtncm91cFNpemVbMF19LCB0aWxlSW5uZXIgJHt0aWxlSW5uZXJ9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3dvcmtncm91cFNpemVbMV19YCxcclxuICAgICk7XHJcbiAgfVxyXG4gIGNvbnN0IHJvd1BlclRocmVhZEEgPSB0aWxlQUhpZ2h0IC8gd29ya2dyb3VwU2l6ZVsxXTtcclxuICBjb25zdCBjb2xQZXJUaHJlYWRBID0gdGlsZUFXaWR0aCAvIHdvcmtncm91cFNpemVbMF07XHJcbiAgY29uc3Qgcm93UGVyVGhyZWFkQiA9IHRpbGVJbm5lciAvIHdvcmtncm91cFNpemVbMV07XHJcbiAgY29uc3QgbWF0bXVsU25pcHBldCA9IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHNcclxuICAgID8gYFxyXG4gICAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XHJcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcclxuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XHJcbiAgICBsZXQgZ2xvYmFsQ29sU3RhcnQgPSBpMzIod29ya2dyb3VwSWQueCkgKiAke3RpbGVCT3V0ZXJ9O1xyXG5cclxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxyXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xyXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXHJcbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHt0aWxlQUhpZ2h0fTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7d29ya2dyb3VwU2l6ZVsxXX0pIHtcclxuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7dGlsZUFXaWR0aH07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3dvcmtncm91cFNpemVbMF19KSB7XHJcbiAgICAgICAgICAke3dyaXRlRGF0YVRvU3ViQVNuaXBwZXQodHJhbnNwb3NlQSwgYmF0Y2hEaW1zKX1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxyXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7dGlsZUlubmVyfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7d29ya2dyb3VwU2l6ZVsxXX0pIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke3RpbGVCT3V0ZXJ9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt3b3JrZ3JvdXBTaXplWzBdfSkge1xyXG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXHJcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxyXG4gICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xyXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cclxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+O1xyXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcclxuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt3b3JrZ3JvdXBTaXplWzBdfV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XHJcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7XHJcbiAgICAgICAgICAgIHRyYW5zcG9zZUFcclxuICAgICAgICAgICAgICA/IGBtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19XTtgXHJcbiAgICAgICAgICAgICAgOiBgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfV1ba107YFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcclxuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXHJcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XHJcbiAgICAgIGxldCBnUm93ID0gZ2xvYmFsUm93U3RhcnQgKyBsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfTtcclxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcclxuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7d29ya2dyb3VwU2l6ZVswXX07XHJcbiAgICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdSb3csIGdDb2wsIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYFxyXG4gICAgOiBgXHJcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XHJcbmxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XHJcblxyXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xyXG5sZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogY29sUGVyVGhyZWFkO1xyXG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xyXG5cclxubGV0IHRpbGVSb3dBID0gaTMyKGxvY2FsSWQueSkgKiAke3Jvd1BlclRocmVhZEF9O1xyXG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7Y29sUGVyVGhyZWFkQX07XHJcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHtyb3dQZXJUaHJlYWRCfTtcclxuLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXHJcbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcclxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXHJcbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7cm93UGVyVGhyZWFkQX07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XHJcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHtjb2xQZXJUaHJlYWRBfTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcclxuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcclxuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcclxuICAgICAgJHt3cml0ZURhdGFUb1N1YkFTbmlwcGV0KHRyYW5zcG9zZUEsIGJhdGNoRGltcyl9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXHJcbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7cm93UGVyVGhyZWFkQn07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XHJcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xyXG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xyXG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sICsgaW5uZXJDb2w7XHJcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxyXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxyXG4gICAgICAgIGdsb2JhbENvbCArIGlubmVyQ29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcclxuICAgIH1cclxuICB9XHJcbiAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xyXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXHJcbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+O1xyXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcclxuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XHJcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XHJcbiAgICAgICR7cmVhZERhdGFGcm9tU3ViQVNuaXBwZXQodHJhbnNwb3NlQSl9XHJcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XHJcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgd29ya2dyb3VwQmFycmllcigpO1xyXG59XHJcblxyXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xyXG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XHJcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxyXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcclxuICB9XHJcbn1cclxuYDtcclxuXHJcbiAgcmV0dXJuIGBcclxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHt0eXBlfSwgJHt0aWxlQVdpZHRofT4sICR7dGlsZUFIaWdodH0+O1xyXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTwke3R5cGV9LCAke3RpbGVCT3V0ZXJ9PiwgJHt0aWxlSW5uZXJ9PjtcclxuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMV19O1xyXG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFswXX07XHJcbiAgY29uc3QgdGlsZUlubmVyID0gJHt0aWxlSW5uZXJ9O1xyXG5cclxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7d29ya2dyb3VwU2l6ZVswXX0sICR7d29ya2dyb3VwU2l6ZVsxXX0sICR7d29ya2dyb3VwU2l6ZVsyXX0pXHJcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcclxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXHJcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xyXG4gICAgbGV0IGJhdGNoID0gJHtzcGxpdEsgPyAnMCcgOiAnaTMyKGdsb2JhbElkLnopJ307XHJcbiAgICAke2JhdGNoRGltcyA/IGBsZXQgYmF0Y2hJbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCd1MzIoYmF0Y2gpJyl9O2AgOiAnJ31cclxuICAgIGxldCBudW1fdGlsZXMgPSAke1xyXG4gICAgICBzcGxpdEsgPyBgJHtNYXRoLmNlaWwoc3BsaXRlZERpbUlubmVyIC8gdGlsZUlubmVyKX1gIDogJyh1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDEnXHJcbiAgICB9O1xyXG4gICAgdmFyIGtTdGFydCA9ICR7c3BsaXRLID8gYGkzMihnbG9iYWxJZC56KSAqICR7c3BsaXRlZERpbUlubmVyfWAgOiAnMCd9O1xyXG5cclxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xyXG4gICAgJHttYXRtdWxTbmlwcGV0fVxyXG4gIH1cclxuYDtcclxufTtcclxuXHJcbmNvbnN0IG1hdE11bFJlYWRXcml0ZUZuU291cmNlID0gKFxyXG4gIGNvbXBvbmVudDogbnVtYmVyLFxyXG4gIGhhc0JpYXM6IGJvb2xlYW4sXHJcbiAgYXBwbHlBY3RpdmF0aW9uOiBzdHJpbmcsXHJcbiAgdmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10sXHJcbiAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSxcclxuKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBbYmF0Y2hWYXJpYWJsZSwgYVZhcmlhYmxlLCBiVmFyaWFibGUsIG91dHB1dFZhcmlhYmxlXSA9IHZhcmlhYmxlcztcclxuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSh2YXJpYWJsZXNbMF0udHlwZS50ZW5zb3IpO1xyXG5cclxuICBjb25zdCBzb3VyY2UgPSBgXHJcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2JhdGNoVmFyaWFibGUudHlwZS5pbmRpY2VzfSkgLT4gJHt0eXBlU25pcHBldChcclxuICAgICAgY29tcG9uZW50LFxyXG4gICAgICBkYXRhVHlwZSxcclxuICAgICl9IHtcclxuICAgICAgdmFyIHZhbHVlID0gJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0oMC4wKTtcclxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjb21wb25lbnR9O1xyXG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpXHJcbiAgICAgIHtcclxuICAgICAgICB2YXIgYUluZGljZXM6ICR7YVZhcmlhYmxlLnR5cGUuaW5kaWNlc307XHJcbiAgICAgICAgJHtjb252ZXJ0T3V0cHV0QmF0Y2hJbmRpY2VzVG9JbnB1dEJhdGNoSW5kaWNlcyhcclxuICAgICAgICAgICdhSW5kaWNlcycsXHJcbiAgICAgICAgICBhVmFyaWFibGUsXHJcbiAgICAgICAgICBhVmFyaWFibGUucmFuayAtIDIsXHJcbiAgICAgICAgICBiYXRjaFZhcmlhYmxlLnJhbmssXHJcbiAgICAgICAgICAnYmF0Y2hJbmRpY2VzJyxcclxuICAgICAgICApfVxyXG4gICAgICAgICR7YVZhcmlhYmxlLmluZGljZXNTZXQoJ2FJbmRpY2VzJywgYVZhcmlhYmxlLnJhbmsgLSAyLCAndTMyKHJvdyknKX1cclxuICAgICAgICAke2FWYXJpYWJsZS5pbmRpY2VzU2V0KCdhSW5kaWNlcycsIGFWYXJpYWJsZS5yYW5rIC0gMSwgJ3UzMihjb2xJbiknKX1cclxuICAgICAgICB2YWx1ZSA9ICR7YVZhcmlhYmxlLmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7YmF0Y2hWYXJpYWJsZS50eXBlLmluZGljZXN9KSAtPiAke3R5cGVTbmlwcGV0KFxyXG4gICAgICBjb21wb25lbnQsXHJcbiAgICAgIGRhdGFUeXBlLFxyXG4gICAgKX0ge1xyXG4gICAgICB2YXIgdmFsdWUgPSAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSgwLjApO1xyXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XHJcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcclxuICAgICAge1xyXG4gICAgICAgIHZhciBiSW5kaWNlczogJHtiVmFyaWFibGUudHlwZS5pbmRpY2VzfTtcclxuICAgICAgICAke2NvbnZlcnRPdXRwdXRCYXRjaEluZGljZXNUb0lucHV0QmF0Y2hJbmRpY2VzKFxyXG4gICAgICAgICAgJ2JJbmRpY2VzJyxcclxuICAgICAgICAgIGJWYXJpYWJsZSxcclxuICAgICAgICAgIGJWYXJpYWJsZS5yYW5rIC0gMixcclxuICAgICAgICAgIGJhdGNoVmFyaWFibGUucmFuayxcclxuICAgICAgICAgICdiYXRjaEluZGljZXMnLFxyXG4gICAgICAgICl9XHJcbiAgICAgICAgJHtiVmFyaWFibGUuaW5kaWNlc1NldCgnYkluZGljZXMnLCBiVmFyaWFibGUucmFuayAtIDIsICd1MzIocm93KScpfVxyXG4gICAgICAgICR7YlZhcmlhYmxlLmluZGljZXNTZXQoJ2JJbmRpY2VzJywgYlZhcmlhYmxlLnJhbmsgLSAxLCAndTMyKGNvbEluKScpfVxyXG4gICAgICAgIHZhbHVlID0gJHtiVmFyaWFibGUuZ2V0QnlJbmRpY2VzKCdiSW5kaWNlcycpfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KSB7XHJcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcclxuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcclxuICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbEluKTtcclxuICAgICAgICAke1xyXG4gICAgICAgICAgaGFzQmlhc1xyXG4gICAgICAgICAgICA/IGB2YWx1ZSA9IHZhbHVlICsgJHtpc0NoYW5uZWxzTGFzdCA/ICdiaWFzW2NvbEluXScgOiBgJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0oYmlhc1tyb3ddKWB9O2BcclxuICAgICAgICAgICAgOiAnJ1xyXG4gICAgICAgIH1cclxuICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cclxuICAgICAgICAke291dHB1dFZhcmlhYmxlLnNldEJ5SW5kaWNlcygndmVjMzx1MzI+KGNvb3JkcyknLCAndmFsdWUnKX1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYDtcclxuICByZXR1cm4gc291cmNlO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxyXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICByZXNoYXBlZE91dHB1dFNoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSAvKiBvbmx5IHVzZWQgZm9yIGNvbnYyZEJ5TWF0TXVsKi8sXHJcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xyXG4gIGNvbnN0IG91dGVyRGltc0EgPSBhU2hhcGUuc2xpY2UoMCwgLTIpO1xyXG4gIGNvbnN0IG91dGVyRGltc0IgPSBiU2hhcGUuc2xpY2UoMCwgLTIpO1xyXG4gIGNvbnN0IG91dGVyRGltcyA9IHJlc2hhcGVkT3V0cHV0U2hhcGUgPyByZXNoYXBlZE91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKSA6IG91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKTtcclxuICBjb25zdCBiYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRlckRpbXMpO1xyXG4gIGNvbnN0IGRpbUFPdXRlciA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMl07XHJcbiAgY29uc3QgZGltSW5uZXIgPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xyXG4gIGNvbnN0IGRpbUJPdXRlciA9IGJTaGFwZVtiU2hhcGUubGVuZ3RoIC0gMV07XHJcbiAgY29uc3QgaXNWZWM0ID0gZGltSW5uZXIgJSA0ID09PSAwICYmIGRpbUJPdXRlciAlIDQgPT09IDA7XHJcblxyXG4gIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXHJcbiAgY29uc3QgZWxlbWVudHNQZXJUaHJlYWQgPSBkaW1BT3V0ZXIgPD0gOCA/IFs0LCAxLCAxXSA6IFs0LCA0LCAxXTtcclxuICBjb25zdCB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XHJcbiAgY29uc3QgZGlzcGF0Y2ggPSBbXHJcbiAgICBNYXRoLmNlaWwoZGltQk91dGVyIC8gd29ya2dyb3VwU2l6ZVswXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzBdKSxcclxuICAgIE1hdGguY2VpbChkaW1BT3V0ZXIgLyB3b3JrZ3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxyXG4gICAgTWF0aC5jZWlsKGJhdGNoU2l6ZSAvIHdvcmtncm91cFNpemVbMl0gLyBlbGVtZW50c1BlclRocmVhZFsyXSksXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xyXG4gIGNvbnN0IGFTaGFwZVRlbXAgPSBbLi4ub3V0ZXJEaW1zQSwgZGltQU91dGVyLCBkaW1Jbm5lciAvIGNvbXBvbmVudHNdO1xyXG4gIGNvbnN0IGFSYW5rID0gYVNoYXBlVGVtcC5sZW5ndGg7XHJcbiAgY29uc3QgYlNoYXBlVGVtcCA9IFsuLi5vdXRlckRpbXNCLCBkaW1Jbm5lciwgZGltQk91dGVyIC8gY29tcG9uZW50c107XHJcbiAgY29uc3QgYlJhbmsgPSBiU2hhcGVUZW1wLmxlbmd0aDtcclxuICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUFPdXRlciB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQk91dGVyIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1Jbm5lciB9LFxyXG4gIF07XHJcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhY3RpdmF0aW9uQXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRlckRpbXMsIGFTaGFwZVRlbXAsIGJTaGFwZVRlbXApKTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XHJcblxyXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcclxuICBpZiAoaGFzQmlhcykge1xyXG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcclxuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcclxuICB9XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgYmF0Y2hSYW5rID0gb3V0ZXJEaW1zLmxlbmd0aDtcclxuICAgIGNvbnN0IGJhdGNoRGltcyA9IGludGVybmFsVmFyaWFibGUoJ2JhdGNoRGltcycsIGlucHV0c1swXS5kYXRhVHlwZSwgYmF0Y2hSYW5rLCAxKTtcclxuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XHJcblxyXG4gICAgY29uc3QgQSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGFSYW5rLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IEIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBiUmFuaywgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZVRlbXAubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW0EsIEJdO1xyXG4gICAgaWYgKGhhc0JpYXMpIHtcclxuICAgICAgY29uc3QgYmlhc0NvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGNvbXBvbmVudHMgOiAxO1xyXG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgYmlhc0NvbXBvbmVudHMpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnZGltX2Ffb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdkaW1fYl9vdXRlcicsIHR5cGU6ICdpMzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2RpbV9pbm5lcicsIHR5cGU6ICdpMzInIH0sXHJcbiAgICBdO1xyXG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XHJcbiAgICBjb25zdCBiYXNlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShvdXRwdXQudHlwZS50ZW5zb3IpO1xyXG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlLCBiYXNlVHlwZSk7XHJcbiAgICBjb25zdCBkZWNsYXJlRnVuY3Rpb25zID0gbWF0TXVsUmVhZFdyaXRlRm5Tb3VyY2UoXHJcbiAgICAgIGNvbXBvbmVudHMsXHJcbiAgICAgIGhhc0JpYXMsXHJcbiAgICAgIGFwcGx5QWN0aXZhdGlvbixcclxuICAgICAgW2JhdGNoRGltcywgQSwgQiwgb3V0cHV0XSxcclxuICAgICAgaXNDaGFubmVsc0xhc3QsXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGBcclxuICAke3NoYWRlckhlbHBlclxyXG4gICAgLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpXHJcbiAgICAucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyhiYXRjaERpbXMpXHJcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cclxuICAke2RlY2xhcmVGdW5jdGlvbnN9XHJcbiAgJHtcclxuICAgIGlzVmVjNFxyXG4gICAgICA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrZ3JvdXBTaXplLCBkYXRhVHlwZSwgYmF0Y2hEaW1zKVxyXG4gICAgICA6IG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UoZWxlbWVudHNQZXJUaHJlYWQsIHdvcmtncm91cFNpemUsIGRhdGFUeXBlLCBiYXRjaERpbXMpXHJcbiAgfVxyXG4gICAgICAgICAgICAgICAgICAgYDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnTWF0TXVsJyxcclxuICAgIHNoYWRlckNhY2hlOiB7XHJcbiAgICAgIGhpbnQ6IGAke2VsZW1lbnRzUGVyVGhyZWFkfTske2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259OyR7aXNWZWM0fTske2lzQ2hhbm5lbHNMYXN0fWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxyXG4gICAgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuIiwgIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKi9cclxuXHJcbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udjJkX21tX3dlYmdwdS50c1xyXG4vL1xyXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vLi4vLi4vbG9nJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uLy4uL3R5cGVzJztcclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgQ29udkF0dHJpYnV0ZXMgfSBmcm9tICcuLi9jb252JztcclxuaW1wb3J0IHsgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhLCBnZXRBY3RpdmF0aW9uU25pcHBldCB9IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xyXG5cclxuaW1wb3J0IHsgYmlhc1NuaXBwZXQsIHR5cGVTbmlwcGV0IH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xyXG5pbXBvcnQgeyB1dGlsRnVuY3Rpb25zIH0gZnJvbSAnLi9jb252X3V0aWwnO1xyXG5pbXBvcnQgeyBtYWtlTWF0TXVsUGFja2VkU291cmNlLCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSB9IGZyb20gJy4vbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xyXG5cclxuY29uc3QgY29udjJkQ29tbW9uU25pcHBldCA9IChcclxuICBpc0NoYW5uZWxzTGFzdDogYm9vbGVhbixcclxuICBmaXRBT3V0ZXI6IGJvb2xlYW4sXHJcbiAgZml0Qk91dGVyOiBib29sZWFuLFxyXG4gIGZpdElubmVyOiBib29sZWFuLFxyXG4gIGFkZEJpYXMgPSBmYWxzZSxcclxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcclxuICBpbm5lckVsZW1lbnRTaXplWCA9IDQsXHJcbiAgaW5uZXJFbGVtZW50U2l6ZVcgPSA0LFxyXG4gIGlubmVyRWxlbWVudFNpemUgPSA0LFxyXG4gIGRhdGFUeXBlID0gJ2YzMicsXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3QgZ2V0WFNuaXBwZXQgPSAoaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGlubmVyRWxlbWVudFNpemUpIHtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIHJldHVybiAncmVzRGF0YSA9IHhbeEluZGV4XTsnO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgcmV0dXJuIGByZXNEYXRhID0gdmVjMzwke2RhdGFUeXBlfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO1xyXG4gICAgICBjYXNlIDQ6XHJcbiAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXggLyA0XTsnO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBnZXRXU25pcHBldCA9IChpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcclxuICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgcmV0dXJuICdyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgKyBjb2xJbl07JztcclxuICAgICAgY2FzZSA0OlxyXG4gICAgICAgIHJldHVybiAncmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pIC8gNCArIGNvbEluXTsnO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBjb29yZEFTbmlwcGV0ID0gaXNDaGFubmVsc0xhc3RcclxuICAgID8gYFxyXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Um93LCB4Q29sLCB4Q2gpO1xyXG4gICAgYFxyXG4gICAgOiBgXHJcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XHJcbiAgICBgO1xyXG5cclxuICBjb25zdCBjb29yZFJlc1NuaXBwZXQgPSBpc0NoYW5uZWxzTGFzdFxyXG4gICAgPyBgXHJcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxyXG4gICAgICBiYXRjaCxcclxuICAgICAgcm93IC8gb3V0V2lkdGgsXHJcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxyXG4gICAgICBjb2wpO1xyXG4gICAgYFxyXG4gICAgOiBgXHJcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxyXG4gICAgICBiYXRjaCxcclxuICAgICAgcm93LFxyXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcclxuICAgICAgY29sICUgb3V0V2lkdGgpO1xyXG4gICAgYDtcclxuXHJcbiAgY29uc3QgeEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzFdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJztcclxuICBjb25zdCB4V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMueF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzNdKSc7XHJcbiAgY29uc3Qgcm93ID0gaXNDaGFubmVsc0xhc3QgPyAncm93JyA6ICdjb2wnO1xyXG4gIGNvbnN0IGNvbCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2NvbCcgOiAncm93JztcclxuICBjb25zdCByZWFkWFNuaXBwZXQgPSBgXHJcbiAgICBsZXQgaW5DaGFubmVscyA9IGkzMih1bmlmb3Jtcy53X3NoYXBlWzJdKTtcclxuICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XHJcbiAgICBsZXQgb3V0Um93ID0gJHtyb3d9IC8gb3V0V2lkdGg7XHJcbiAgICBsZXQgb3V0Q29sID0gJHtyb3d9ICUgb3V0V2lkdGg7XHJcblxyXG4gICAgbGV0IFdSb3cgPSAke2NvbH0gLyAoaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pICogaW5DaGFubmVscyk7XHJcbiAgICBsZXQgV0NvbCA9ICR7Y29sfSAvIGluQ2hhbm5lbHMgJSBpMzIodW5pZm9ybXMud19zaGFwZVsxXSk7XHJcbiAgICBsZXQgeFJvdyA9IG91dFJvdyAqIHVuaWZvcm1zLnN0cmlkZVswXSArIHVuaWZvcm1zLmRpbGF0aW9uWzBdICogV1JvdyAtIHVuaWZvcm1zLnBhZFswXTtcclxuICAgIGxldCB4Q29sID0gb3V0Q29sICogdW5pZm9ybXMuc3RyaWRlWzFdICsgdW5pZm9ybXMuZGlsYXRpb25bMV0gKiBXQ29sIC0gdW5pZm9ybXMucGFkWzFdO1xyXG4gICAgbGV0IHhDaCA9ICR7Y29sfSAlIGluQ2hhbm5lbHM7XHJcbiAgICB2YXIgcmVzRGF0YSA9ICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKX0oMC4wKTtcclxuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXHJcbiAgICAvLyB0aGUgJ3NhbWUnIHBhZGRpbmcgdHlwZS5cclxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7eEhlaWdodH0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke3hXaWR0aH0pIHtcclxuICAgICAgJHtjb29yZEFTbmlwcGV0fVxyXG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy54X3NoYXBlKSk7XHJcbiAgICAgICR7Z2V0WFNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgpfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc0RhdGE7YDtcclxuXHJcbiAgY29uc3Qgc2FtcGxlWCA9IGlzQ2hhbm5lbHNMYXN0XHJcbiAgICA/IGZpdEFPdXRlciAmJiBmaXRJbm5lclxyXG4gICAgICA/IGBcclxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xyXG4gICAgJHtyZWFkWFNuaXBwZXR9YFxyXG4gICAgICA6IGBcclxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xyXG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xyXG4gICAgICAke3JlYWRYU25pcHBldH1cclxuICAgIH1cclxuICAgIHJldHVybiAke3R5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSl9KDAuMCk7YFxyXG4gICAgOiBmaXRJbm5lciAmJiBmaXRCT3V0ZXJcclxuICAgICAgPyBgXHJcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcclxuICAgICR7cmVhZFhTbmlwcGV0fWBcclxuICAgICAgOiBgXHJcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcclxuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcclxuICAgICAgJHtyZWFkWFNuaXBwZXR9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO2A7XHJcblxyXG4gIGNvbnN0IHNhbXBsZVcgPSBpc0NoYW5uZWxzTGFzdFxyXG4gICAgPyBmaXRJbm5lciAmJiBmaXRCT3V0ZXJcclxuICAgICAgPyBnZXRXU25pcHBldChpbm5lckVsZW1lbnRTaXplVylcclxuICAgICAgOiBgXHJcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVXfTtcclxuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcclxuICAgICAgJHtnZXRXU25pcHBldChpbm5lckVsZW1lbnRTaXplVyl9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplVywgZGF0YVR5cGUpfSgwLjApO2BcclxuICAgIDogYFxyXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplV307XHJcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9hX291dGVyKSB7XHJcbiAgICAgICR7Z2V0V1NuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcpfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKX0oMC4wKTtgO1xyXG5cclxuICBjb25zdCByZXNUeXBlID0gdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSwgZGF0YVR5cGUpO1xyXG4gIGNvbnN0IGFUeXBlID0gaXNDaGFubmVsc0xhc3QgPyB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpIDogdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKTtcclxuICBjb25zdCBiVHlwZSA9IGlzQ2hhbm5lbHNMYXN0ID8gdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKSA6IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSk7XHJcbiAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgcmVzVHlwZSwgZGF0YVR5cGUpO1xyXG4gIGNvbnN0IHVzZXJDb2RlID0gYFxyXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHthVHlwZX0ge1xyXG4gICAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlWCA6IHNhbXBsZVd9XHJcbiAgICB9XHJcblxyXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtiVHlwZX0ge1xyXG4gICAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlVyA6IHNhbXBsZVh9XHJcbiAgICB9XHJcblxyXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7cmVzVHlwZX0pIHtcclxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcclxuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxyXG4gICAgICB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XHJcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XHJcbiAgICAgICR7Y29vcmRSZXNTbmlwcGV0fVxyXG4gICAgICAke2JpYXNTbmlwcGV0KGFkZEJpYXMpfVxyXG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cclxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1gO1xyXG4gIHJldHVybiB1c2VyQ29kZTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcclxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgZGltQU91dGVyOiBudW1iZXIsXHJcbiAgZGltQk91dGVyOiBudW1iZXIsXHJcbiAgZGltSW5uZXI6IG51bWJlcixcclxuICBoYXNCaWFzOiBib29sZWFuLFxyXG4gIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHM6IGJvb2xlYW4sXHJcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcclxuICBjb25zdCBpbkNoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBpbnB1dHNbMF0uZGltc1szXSA6IGlucHV0c1swXS5kaW1zWzFdO1xyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IG91dHB1dFNoYXBlWzBdO1xyXG4gIGNvbnN0IG91dFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVsyXSA6IG91dHB1dFNoYXBlWzNdO1xyXG4gIGNvbnN0IG91dEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMV0gOiBvdXRwdXRTaGFwZVsyXTtcclxuICBjb25zdCBvdXRDaGFubmVscyA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbM10gOiBvdXRwdXRTaGFwZVsxXTtcclxuICAvLyBUT0RPOiBlbmFibGUgdmVjNCBmb3IgTkNIV1xyXG4gIGNvbnN0IGlzVmVjNCA9IGlzQ2hhbm5lbHNMYXN0ICYmIChpbkNoYW5uZWxzICUgNCA9PT0gMCB8fCBpbkNoYW5uZWxzICUgMyA9PT0gMCkgJiYgb3V0Q2hhbm5lbHMgJSA0ID09PSAwO1xyXG5cclxuICAvLyBUT0RPOiBmaW5lIHR1bmUgc2l6ZVxyXG4gIGNvbnN0IGRpc3BhdGNoWCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRXaWR0aCAqIG91dEhlaWdodDtcclxuICBjb25zdCBkaXNwYXRjaFkgPSBpc0NoYW5uZWxzTGFzdCA/IG91dFdpZHRoICogb3V0SGVpZ2h0IDogb3V0Q2hhbm5lbHM7XHJcbiAgY29uc3Qgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzgsIDgsIDFdO1xyXG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XHJcbiAgY29uc3QgZGlzcGF0Y2ggPSBbXHJcbiAgICBNYXRoLmNlaWwoZGlzcGF0Y2hYIC8gd29ya0dyb3VwU2l6ZVswXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzBdKSxcclxuICAgIE1hdGguY2VpbChkaXNwYXRjaFkgLyB3b3JrR3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxyXG4gICAgTWF0aC5jZWlsKGJhdGNoU2l6ZSAvIHdvcmtHcm91cFNpemVbMl0gLyBlbGVtZW50c1BlclRocmVhZFsyXSksXHJcbiAgXTtcclxuXHJcbiAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252MmRfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7ZGlzcGF0Y2h9YCk7XHJcblxyXG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSBpc1ZlYzQgPyAoaXNDaGFubmVsc0xhc3QgJiYgaW5DaGFubmVscyAlIDQgIT09IDAgPyAzIDogNCkgOiAxO1xyXG4gIGNvbnN0IHRpbGVBT3V0ZXIgPSB3b3JrR3JvdXBTaXplWzFdICogZWxlbWVudHNQZXJUaHJlYWRbMV07XHJcbiAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtHcm91cFNpemVbMF0gKiBlbGVtZW50c1BlclRocmVhZFswXTtcclxuICBjb25zdCB0aWxlSW5uZXIgPSBNYXRoLm1heCh3b3JrR3JvdXBTaXplWzBdICogaW5uZXJFbGVtZW50U2l6ZSwgd29ya0dyb3VwU2l6ZVsxXSk7XHJcbiAgY29uc3QgZml0QU91dGVyID0gZGltQU91dGVyICUgdGlsZUFPdXRlciA9PT0gMDtcclxuICBjb25zdCBmaXRCT3V0ZXIgPSBkaW1CT3V0ZXIgJSB0aWxlQk91dGVyID09PSAwO1xyXG4gIGNvbnN0IGZpdElubmVyID0gZGltSW5uZXIgJSB0aWxlSW5uZXIgPT09IDA7XHJcbiAgY29uc3QgZWxlbWVudHNTaXplID0gaXNWZWM0ID8gW2lubmVyRWxlbWVudFNpemUsIDQsIDRdIDogWzEsIDEsIDFdO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1BT3V0ZXIgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUJPdXRlciB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltSW5uZXIgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV0gfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5kaWxhdGlvbnMgfSxcclxuICBdO1xyXG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpKTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XHJcbiAgaWYgKGhhc0JpYXMpIHtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XHJcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XHJcbiAgfVxyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdkaW1fYV9vdXRlcicsIHR5cGU6ICdpMzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2RpbV9iX291dGVyJywgdHlwZTogJ2kzMicgfSxcclxuICAgICAgeyBuYW1lOiAnZGltX2lubmVyJywgdHlwZTogJ2kzMicgfSxcclxuICAgICAgeyBuYW1lOiAncGFkJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxyXG4gICAgICB7IG5hbWU6ICdzdHJpZGUnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXHJcbiAgICAgIHsgbmFtZTogJ2RpbGF0aW9uJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxyXG4gICAgXTtcclxuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XHJcblxyXG4gICAgLy8gVE9ETzogc3VwcG9ydCBjb21wb25lbnQgMiwgMy5cclxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcclxuICAgIGNvbnN0IHQgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICAgIGxldCBkZWNsYXJlRnVuY3Rpb25zID0gYFxyXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KSB7XHJcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KSB7XHJcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyh2ZWM0PGkzMj4oZDAsIGQxLCBkMiwgZDMpKTtcclxuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke2lzVmVjNCA/ICcvIDQnIDogJyd9LCB2YWx1ZSk7XHJcbiAgICAgIH1gO1xyXG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoXHJcbiAgICAgICd4JyxcclxuICAgICAgaW5wdXRzWzBdLmRhdGFUeXBlLFxyXG4gICAgICBpbnB1dHNbMF0uZGltcy5sZW5ndGgsXHJcbiAgICAgIGlubmVyRWxlbWVudFNpemUgPT09IDMgPyAxIDogaW5uZXJFbGVtZW50U2l6ZSxcclxuICAgICk7XHJcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW3gsIHddO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGlmIChoYXNCaWFzKSB7XHJcbiAgICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGJpYXMpO1xyXG4gICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcclxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9IHtcclxuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xyXG4gICAgICAgIH1gO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgJHt1dGlsRnVuY3Rpb25zKCd1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlcycpfVxyXG4gICAgICAgIC8vc3RydWN0IFVuaWZvcm1zIHsgeFNoYXBlIDogdmVjNDxpMzI+LCB3U2hhcGUgOiB2ZWM0PGkzMj4sIG91dFNoYXBlIDogdmVjNDxpMzI+LFxyXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXHJcbiAgICAgICAgLy8gIGRpbGF0aW9uIDogdmVjMjxpMzI+LCBkaW1BT3V0ZXIgOiBpMzIsIGRpbUJPdXRlciA6IGkzMiwgZGltSW5uZXIgOiBpMzIgfTtcclxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxyXG4gICAgICAgICR7ZGVjbGFyZUZ1bmN0aW9uc31cclxuICAgICAgICAke2NvbnYyZENvbW1vblNuaXBwZXQoXHJcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCxcclxuICAgICAgICAgIGZpdEFPdXRlcixcclxuICAgICAgICAgIGZpdEJPdXRlcixcclxuICAgICAgICAgIGZpdElubmVyLFxyXG4gICAgICAgICAgaGFzQmlhcyxcclxuICAgICAgICAgIGF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICBlbGVtZW50c1NpemVbMF0sXHJcbiAgICAgICAgICBlbGVtZW50c1NpemVbMV0sXHJcbiAgICAgICAgICBlbGVtZW50c1NpemVbMl0sXHJcbiAgICAgICAgICB0LFxyXG4gICAgICAgICl9XHJcbiAgICAgICAgJHtcclxuICAgICAgICAgIGlzVmVjNFxyXG4gICAgICAgICAgICA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrR3JvdXBTaXplLCB0LCB1bmRlZmluZWQsICFpc0NoYW5uZWxzTGFzdCwgdGlsZUlubmVyKVxyXG4gICAgICAgICAgICA6IG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UoXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1BlclRocmVhZCxcclxuICAgICAgICAgICAgICAgIHdvcmtHcm91cFNpemUsXHJcbiAgICAgICAgICAgICAgICB0LFxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgIWlzQ2hhbm5lbHNMYXN0LFxyXG4gICAgICAgICAgICAgICAgdGlsZUlubmVyLFxyXG4gICAgICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzLFxyXG4gICAgICAgICAgICAgIClcclxuICAgICAgICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnQ29udjJETWF0TXVsJyxcclxuICAgIHNoYWRlckNhY2hlOiB7XHJcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aW5uZXJFbGVtZW50U2l6ZX07JHtpc1ZlYzR9OyR7Zml0QU91dGVyfTske2ZpdEJPdXRlcn07JHtmaXRJbm5lcn07JHt0aWxlQU91dGVyfTske3RpbGVCT3V0ZXJ9OyR7dGlsZUlubmVyfWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxyXG4gICAgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuIiwgIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKi9cclxuXHJcbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udjNkX25haXZlX3dlYmdwdS50c1xyXG4vL1xyXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vLi4vLi4vbG9nJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgZ2V0RWxlbWVudEF0LFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuLi9jb21tb24nO1xyXG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4uL2NvbnYnO1xyXG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi4vZnVzZS11dGlscyc7XHJcblxyXG5pbXBvcnQgeyB0eXBlU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcclxuXHJcbmNvbnN0IGFycmF5UHJvZHVjdCA9IChhcnI6IG51bWJlcltdKSA9PiB7XHJcbiAgbGV0IHByb2R1Y3QgPSAxO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBwcm9kdWN0ICo9IGFycltpXTtcclxuICB9XHJcbiAgcmV0dXJuIHByb2R1Y3Q7XHJcbn07XHJcblxyXG5jb25zdCBwYXJzZTNUdXBsZVBhcmFtID0gKHBhcmFtOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPT5cclxuICB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInID8gW3BhcmFtLCBwYXJhbSwgcGFyYW1dIDogcGFyYW07XHJcblxyXG5jb25zdCBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplID0gKGZpbHRlclNpemU6IG51bWJlciwgZGlsYXRpb246IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgaWYgKGRpbGF0aW9uIDw9IDEpIHtcclxuICAgIHJldHVybiBmaWx0ZXJTaXplO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZpbHRlclNpemUgKyAoZmlsdGVyU2l6ZSAtIDEpICogKGRpbGF0aW9uIC0gMSk7XHJcbn07XHJcblxyXG5jb25zdCBjb21wdXRlRGVmYXVsdFBhZCA9IChcclxuICBpbnB1dFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgZmllbGRTaXplOiBudW1iZXIsXHJcbiAgc3RyaWRlOiBudW1iZXIsXHJcbiAgZGlsYXRpb24gPSAxLFxyXG4pOiBudW1iZXIgPT4ge1xyXG4gIGNvbnN0IGVmZmVjdGl2ZUZpZWxkU2l6ZSA9IGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmllbGRTaXplLCBkaWxhdGlvbik7XHJcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGlucHV0U2hhcGVbMF0gKiAoc3RyaWRlIC0gMSkgLSBzdHJpZGUgKyBlZmZlY3RpdmVGaWVsZFNpemUpIC8gMik7XHJcbn07XHJcblxyXG5jb25zdCBjb21wdXRlT3V0cHV0U2hhcGU0RCA9IChcclxuICBpblNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICBmaWx0ZXJTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gIG91dENoYW5uZWxzOiBudW1iZXIsXHJcbiAgc3RyaWRlczogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gIHplcm9QYWQ/OiBudW1iZXIsXHJcbik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0+IHtcclxuICBpZiAoemVyb1BhZCA9PSBudWxsKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cclxuICAgIHplcm9QYWQgPSBjb21wdXRlRGVmYXVsdFBhZChpblNoYXBlLCBmaWx0ZXJTaGFwZVswXSwgc3RyaWRlc1swXSk7XHJcbiAgfVxyXG4gIGNvbnN0IG91dFNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwLCBvdXRDaGFubmVsc107XHJcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDM7IGluZGV4KyspIHtcclxuICAgIGlmIChpblNoYXBlW2luZGV4XSArIDIgKiB6ZXJvUGFkID49IGZpbHRlclNoYXBlW2luZGV4XSkge1xyXG4gICAgICBvdXRTaGFwZVtpbmRleF0gPSBNYXRoLnRydW5jKChpblNoYXBlW2luZGV4XSAtIGZpbHRlclNoYXBlW2luZGV4XSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZXNbaW5kZXhdICsgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBvdXRTaGFwZTtcclxufTtcclxuXHJcbmNvbnN0IGdldDNEUGFkQW5kT3V0SW5mbyA9IChcclxuICBwYWQ6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdLFxyXG4gIGluRGVwdGg6IG51bWJlcixcclxuICBpbkhlaWdodDogbnVtYmVyLFxyXG4gIGluV2lkdGg6IG51bWJlcixcclxuICBzdHJpZGVEZXB0aDogbnVtYmVyLFxyXG4gIHN0cmlkZUhlaWdodDogbnVtYmVyLFxyXG4gIHN0cmlkZVdpZHRoOiBudW1iZXIsXHJcbiAgZmlsdGVyRGVwdGg6IG51bWJlcixcclxuICBmaWx0ZXJIZWlnaHQ6IG51bWJlcixcclxuICBmaWx0ZXJXaWR0aDogbnVtYmVyLFxyXG4pOiB7IHBhZEluZm86IFBhZEluZm8zRDsgb3V0RGVwdGg6IG51bWJlcjsgb3V0SGVpZ2h0OiBudW1iZXI7IG91dFdpZHRoOiBudW1iZXIgfSA9PiB7XHJcbiAgbGV0IHBhZEluZm86IFBhZEluZm8zRDtcclxuICBsZXQgb3V0RGVwdGg6IG51bWJlcjtcclxuICBsZXQgb3V0SGVpZ2h0OiBudW1iZXI7XHJcbiAgbGV0IG91dFdpZHRoOiBudW1iZXI7XHJcblxyXG4gIGlmIChwYWQgPT09ICdWQUxJRCcpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxyXG4gICAgcGFkID0gMDtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgcGFkID09PSAnbnVtYmVyJykge1xyXG4gICAgcGFkSW5mbyA9IHsgdG9wOiBwYWQsIGJvdHRvbTogcGFkLCBsZWZ0OiBwYWQsIHJpZ2h0OiBwYWQsIGZyb250OiBwYWQsIGJhY2s6IHBhZCB9O1xyXG4gICAgY29uc3Qgb3V0U2hhcGUgPSBjb21wdXRlT3V0cHV0U2hhcGU0RChcclxuICAgICAgW2luRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCAxXSxcclxuICAgICAgW2ZpbHRlckRlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoXSxcclxuICAgICAgMSxcclxuICAgICAgW3N0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoXSxcclxuICAgICAgcGFkLFxyXG4gICAgKTtcclxuICAgIG91dERlcHRoID0gb3V0U2hhcGVbMF07XHJcbiAgICBvdXRIZWlnaHQgPSBvdXRTaGFwZVsxXTtcclxuICAgIG91dFdpZHRoID0gb3V0U2hhcGVbMl07XHJcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhZCkpIHtcclxuICAgIGlmICghcGFkLmV2ZXJ5KCh2YWwsIF8sIGFycikgPT4gdmFsID09PSBhcnJbMF0pKSB7XHJcbiAgICAgIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBwYWRkaW5nIHBhcmFtZXRlcjogJHtwYWR9YCk7XHJcbiAgICB9XHJcbiAgICBwYWRJbmZvID0geyB0b3A6IHBhZFswXSwgYm90dG9tOiBwYWRbMV0sIGxlZnQ6IHBhZFsyXSwgcmlnaHQ6IHBhZFszXSwgZnJvbnQ6IHBhZFs0XSwgYmFjazogcGFkWzVdIH07XHJcbiAgICBjb25zdCBvdXRTaGFwZSA9IGNvbXB1dGVPdXRwdXRTaGFwZTREKFxyXG4gICAgICBbaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIDFdLFxyXG4gICAgICBbZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGhdLFxyXG4gICAgICAxLFxyXG4gICAgICBbc3RyaWRlRGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGhdLFxyXG4gICAgICBwYWRbMF0sXHJcbiAgICApO1xyXG4gICAgb3V0RGVwdGggPSBvdXRTaGFwZVswXTtcclxuICAgIG91dEhlaWdodCA9IG91dFNoYXBlWzFdO1xyXG4gICAgb3V0V2lkdGggPSBvdXRTaGFwZVsyXTtcclxuICB9IGVsc2UgaWYgKHBhZCA9PT0gJ1NBTUVfVVBQRVInKSB7XHJcbiAgICAvLyBUT0RPOiBzdXBwb3J0ICdTQU1FX0xPV0VSJy5cclxuICAgIG91dERlcHRoID0gTWF0aC5jZWlsKGluRGVwdGggLyBzdHJpZGVEZXB0aCk7XHJcbiAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoaW5IZWlnaHQgLyBzdHJpZGVIZWlnaHQpO1xyXG4gICAgb3V0V2lkdGggPSBNYXRoLmNlaWwoaW5XaWR0aCAvIHN0cmlkZVdpZHRoKTtcclxuICAgIGNvbnN0IHBhZEFsb25nRGVwdGggPSAob3V0RGVwdGggLSAxKSAqIHN0cmlkZURlcHRoICsgZmlsdGVyRGVwdGggLSBpbkRlcHRoO1xyXG4gICAgY29uc3QgcGFkQWxvbmdIZWlnaHQgPSAob3V0SGVpZ2h0IC0gMSkgKiBzdHJpZGVIZWlnaHQgKyBmaWx0ZXJIZWlnaHQgLSBpbkhlaWdodDtcclxuICAgIGNvbnN0IHBhZEFsb25nV2lkdGggPSAob3V0V2lkdGggLSAxKSAqIHN0cmlkZVdpZHRoICsgZmlsdGVyV2lkdGggLSBpbldpZHRoO1xyXG4gICAgY29uc3QgZnJvbnQgPSBNYXRoLmZsb29yKHBhZEFsb25nRGVwdGggLyAyKTtcclxuICAgIGNvbnN0IGJhY2sgPSBwYWRBbG9uZ0RlcHRoIC0gZnJvbnQ7XHJcbiAgICBjb25zdCB0b3AgPSBNYXRoLmZsb29yKHBhZEFsb25nSGVpZ2h0IC8gMik7XHJcbiAgICBjb25zdCBib3R0b20gPSBwYWRBbG9uZ0hlaWdodCAtIHRvcDtcclxuICAgIGNvbnN0IGxlZnQgPSBNYXRoLmZsb29yKHBhZEFsb25nV2lkdGggLyAyKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcGFkQWxvbmdXaWR0aCAtIGxlZnQ7XHJcblxyXG4gICAgcGFkSW5mbyA9IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCBmcm9udCwgYmFjayB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtwYWR9YCk7XHJcbiAgfVxyXG4gIHJldHVybiB7IHBhZEluZm8sIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoIH07XHJcbn07XHJcblxyXG50eXBlIFBhZEluZm8zRCA9IHtcclxuICB0b3A6IG51bWJlcjtcclxuICBsZWZ0OiBudW1iZXI7XHJcbiAgcmlnaHQ6IG51bWJlcjtcclxuICBib3R0b206IG51bWJlcjtcclxuICBmcm9udDogbnVtYmVyO1xyXG4gIGJhY2s6IG51bWJlcjtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIENvbnYzREluZm8gPSB7XHJcbiAgYmF0Y2hTaXplOiBudW1iZXI7XHJcbiAgaW5EZXB0aDogbnVtYmVyO1xyXG4gIGluSGVpZ2h0OiBudW1iZXI7XHJcbiAgaW5XaWR0aDogbnVtYmVyO1xyXG4gIGluQ2hhbm5lbHM6IG51bWJlcjtcclxuICBvdXREZXB0aDogbnVtYmVyO1xyXG4gIG91dEhlaWdodDogbnVtYmVyO1xyXG4gIG91dFdpZHRoOiBudW1iZXI7XHJcbiAgb3V0Q2hhbm5lbHM6IG51bWJlcjtcclxuICBkYXRhRm9ybWF0OiAnY2hhbm5lbHNGaXJzdCcgfCAnY2hhbm5lbHNMYXN0JztcclxuICBzdHJpZGVEZXB0aDogbnVtYmVyO1xyXG4gIHN0cmlkZUhlaWdodDogbnVtYmVyO1xyXG4gIHN0cmlkZVdpZHRoOiBudW1iZXI7XHJcbiAgZGlsYXRpb25EZXB0aDogbnVtYmVyO1xyXG4gIGRpbGF0aW9uSGVpZ2h0OiBudW1iZXI7XHJcbiAgZGlsYXRpb25XaWR0aDogbnVtYmVyO1xyXG4gIGZpbHRlckRlcHRoOiBudW1iZXI7XHJcbiAgZmlsdGVySGVpZ2h0OiBudW1iZXI7XHJcbiAgZmlsdGVyV2lkdGg6IG51bWJlcjtcclxuICBlZmZlY3RpdmVGaWx0ZXJEZXB0aDogbnVtYmVyO1xyXG4gIGVmZmVjdGl2ZUZpbHRlckhlaWdodDogbnVtYmVyO1xyXG4gIGVmZmVjdGl2ZUZpbHRlcldpZHRoOiBudW1iZXI7XHJcbiAgcGFkSW5mbzogUGFkSW5mbzNEO1xyXG4gIGluU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgb3V0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbiAgZmlsdGVyU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29tcHV0ZUNvbnYzREluZm8gPSAoXHJcbiAgaW5TaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICBmaWx0ZXJTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICBzdHJpZGVzOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgZGlsYXRpb25zOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgcGFkOiBudW1iZXIgfCBzdHJpbmcgfCBudW1iZXJbXSxcclxuICBkZXB0aHdpc2UgPSBmYWxzZSxcclxuICBkYXRhRm9ybWF0OiAnY2hhbm5lbHNGaXJzdCcgfCAnY2hhbm5lbHNMYXN0JyA9ICdjaGFubmVsc0xhc3QnLFxyXG4pOiBDb252M0RJbmZvID0+IHtcclxuICBsZXQgYmF0Y2hTaXplLCBpbkRlcHRoLCBpbkhlaWdodCwgaW5XaWR0aCwgaW5DaGFubmVscztcclxuICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcclxuICAgIFtiYXRjaFNpemUsIGluRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCBpbkNoYW5uZWxzXSA9IGluU2hhcGU7XHJcbiAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcclxuICAgIFtiYXRjaFNpemUsIGluQ2hhbm5lbHMsIGluRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoXSA9IGluU2hhcGU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7ZGF0YUZvcm1hdH1gKTtcclxuICB9XHJcbiAgY29uc3QgW2ZpbHRlckNoYW5uZWxzLCAsIGZpbHRlckRlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoXSA9IGZpbHRlclNoYXBlO1xyXG5cclxuICBjb25zdCBbc3RyaWRlRGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGhdID0gcGFyc2UzVHVwbGVQYXJhbShzdHJpZGVzKTtcclxuICBjb25zdCBbZGlsYXRpb25EZXB0aCwgZGlsYXRpb25IZWlnaHQsIGRpbGF0aW9uV2lkdGhdID0gcGFyc2UzVHVwbGVQYXJhbShkaWxhdGlvbnMpO1xyXG5cclxuICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEZXB0aCA9IGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmlsdGVyRGVwdGgsIGRpbGF0aW9uRGVwdGgpO1xyXG4gIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmlsdGVySGVpZ2h0LCBkaWxhdGlvbkhlaWdodCk7XHJcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlcldpZHRoLCBkaWxhdGlvbldpZHRoKTtcclxuICBjb25zdCB7IHBhZEluZm8sIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoIH0gPSBnZXQzRFBhZEFuZE91dEluZm8oXHJcbiAgICBwYWQsXHJcbiAgICBpbkRlcHRoLFxyXG4gICAgaW5IZWlnaHQsXHJcbiAgICBpbldpZHRoLFxyXG4gICAgc3RyaWRlRGVwdGgsXHJcbiAgICBzdHJpZGVIZWlnaHQsXHJcbiAgICBzdHJpZGVXaWR0aCxcclxuICAgIGVmZmVjdGl2ZUZpbHRlckRlcHRoLFxyXG4gICAgZWZmZWN0aXZlRmlsdGVySGVpZ2h0LFxyXG4gICAgZWZmZWN0aXZlRmlsdGVyV2lkdGgsXHJcbiAgKTtcclxuXHJcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBkZXB0aHdpc2UgPyBmaWx0ZXJDaGFubmVscyAqIGluQ2hhbm5lbHMgOiBmaWx0ZXJDaGFubmVscztcclxuXHJcbiAgbGV0IG91dFNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIDAsIDAsIDBdO1xyXG4gIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcclxuICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0Q2hhbm5lbHMsIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoXTtcclxuICB9IGVsc2UgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XHJcbiAgICBvdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoLCBvdXRDaGFubmVsc107XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYmF0Y2hTaXplLFxyXG4gICAgZGF0YUZvcm1hdCxcclxuICAgIGluRGVwdGgsXHJcbiAgICBpbkhlaWdodCxcclxuICAgIGluV2lkdGgsXHJcbiAgICBpbkNoYW5uZWxzLFxyXG4gICAgb3V0RGVwdGgsXHJcbiAgICBvdXRIZWlnaHQsXHJcbiAgICBvdXRXaWR0aCxcclxuICAgIG91dENoYW5uZWxzLFxyXG4gICAgcGFkSW5mbyxcclxuICAgIHN0cmlkZURlcHRoLFxyXG4gICAgc3RyaWRlSGVpZ2h0LFxyXG4gICAgc3RyaWRlV2lkdGgsXHJcbiAgICBmaWx0ZXJEZXB0aCxcclxuICAgIGZpbHRlckhlaWdodCxcclxuICAgIGZpbHRlcldpZHRoLFxyXG4gICAgZWZmZWN0aXZlRmlsdGVyRGVwdGgsXHJcbiAgICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQsXHJcbiAgICBlZmZlY3RpdmVGaWx0ZXJXaWR0aCxcclxuICAgIGRpbGF0aW9uRGVwdGgsXHJcbiAgICBkaWxhdGlvbkhlaWdodCxcclxuICAgIGRpbGF0aW9uV2lkdGgsXHJcbiAgICBpblNoYXBlLFxyXG4gICAgb3V0U2hhcGUsXHJcbiAgICBmaWx0ZXJTaGFwZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbnYzRE5haXZlUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXHJcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHBhZHM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGRhdGFGb3JtYXQ6IHN0cmluZyxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0JztcclxuICBjb25zdCBpbkNoYW5uZWxzID0gaXNDaGFubmVsTGFzdCA/IGlucHV0c1swXS5kaW1zWzNdIDogaW5wdXRzWzBdLmRpbXNbMV07XHJcbiAgLy8gVE9ETzogZW5hYmxlIHZlYzQuXHJcbiAgY29uc3QgaXNWZWM0ID0gZmFsc2U7XHJcbiAgY29uc3Qgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzY0LCAxLCAxXTtcclxuICBjb25zdCBkaXNwYXRjaExheW91dCA9IHsgeDogb3V0cHV0U2hhcGUubWFwKChfLCBpKSA9PiBpKSB9O1xyXG4gIGNvbnN0IGRpc3BhdGNoID0gW01hdGguY2VpbChhcnJheVByb2R1Y3QoZGlzcGF0Y2hMYXlvdXQueC5tYXAoKGQpID0+IG91dHB1dFNoYXBlW2RdKSkgLyB3b3JrR3JvdXBTaXplWzBdKSwgMSwgMV07XHJcblxyXG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xyXG5cclxuICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gaXNWZWM0ID8gKGlzQ2hhbm5lbExhc3QgJiYgaW5DaGFubmVscyAlIDQgIT09IDAgPyAzIDogNCkgOiAxO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBmaWx0ZXJEaW1zIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFkcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zIH0sXHJcbiAgXTtcclxuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKSk7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xyXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID09PSAzO1xyXG4gIGlmIChoYXNCaWFzKSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xyXG4gIH1cclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdmaWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RoIH0sXHJcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBwYWRzLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggfSxcclxuICAgIF07XHJcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYXR0cmlidXRlcywgdW5pZm9ybXMpO1xyXG4gICAgLy8gVE9ETzogc3VwcG9ydCBjb21wb25lbnQgMiwgMy5cclxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcclxuICAgIGNvbnN0IHQgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuXHJcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZShcclxuICAgICAgJ3gnLFxyXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXHJcbiAgICAgIGlucHV0c1swXS5kaW1zLmxlbmd0aCxcclxuICAgICAgaW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/IDEgOiBpbm5lckVsZW1lbnRTaXplLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IHcgPSBpbnB1dFZhcmlhYmxlKCdXJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbeCwgd107XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSAnJztcclxuICAgIGlmIChoYXNCaWFzKSB7XHJcbiAgICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGJpYXMpO1xyXG4gICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcclxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogYXJyYXk8dTMyLCA1PikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XHJcbiAgICAgICAgICByZXR1cm4gYmlhc1ske2lzQ2hhbm5lbExhc3QgPyBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDQsIDUpIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAxLCA1KX0ke1xyXG4gICAgICAgICAgICBpc1ZlYzQgPyAnLyA0JyA6ICcnXHJcbiAgICAgICAgICB9XTtcclxuICAgICAgICB9YDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCB0KTtcclxuICAgIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMsIHJlc1R5cGUsIHQpO1xyXG5cclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgICR7ZGVjbGFyZUZ1bmN0aW9uc31cclxuICAgICAgICAgICAgZm4gZ2V0WChkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XHJcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xyXG4gICAgICAgICAgICAgIHJldHVybiAke3guZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmbiBnZXRXKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcclxuICAgICAgICAgICAgICBsZXQgYUluZGljZXMgPSBhcnJheTx1MzIsIDU+KGQwLCBkMSwgZDIsIGQzLCBkNCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICR7dy5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxyXG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG4gICAgICAgICAgICAgIGxldCBjb29yZHMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICAgICAgICAgICAgbGV0IGJhdGNoID0gJHtnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDAsIHgucmFuayl9O1xyXG4gICAgICAgICAgICAgIGxldCBkMiA9ICR7XHJcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCB4LnJhbmsgLSAxLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAxLCB4LnJhbmspXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICBsZXQgeEZSQ0Nvcm5lciA9IHZlYzM8dTMyPigke1xyXG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMSwgeC5yYW5rKSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMiwgeC5yYW5rKVxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgJHtpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAyLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspfSxcclxuICAgICAgICAgICAgICAke1xyXG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMywgeC5yYW5rKSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgNCwgeC5yYW5rKVxyXG4gICAgICAgICAgICAgIH0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XHJcbiAgICAgICAgICAgICAgbGV0IHhGQ29ybmVyID0geEZSQ0Nvcm5lci54O1xyXG4gICAgICAgICAgICAgIGxldCB4UkNvcm5lciA9IHhGUkNDb3JuZXIueTtcclxuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XHJcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVkgPSAke1xyXG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxyXG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDEsIHgucmFuaylcclxuICAgICAgICAgICAgICAgICAgOiBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAyLCB4LnJhbmspXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICBsZXQgeFNoYXBlWiA9ICR7XHJcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XHJcbiAgICAgICAgICAgICAgICAgID8gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMiwgeC5yYW5rKVxyXG4gICAgICAgICAgICAgICAgICA6IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDMsIHgucmFuaylcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGxldCB4U2hhcGVXID0gJHtcclxuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcclxuICAgICAgICAgICAgICAgICAgPyBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAzLCB4LnJhbmspXHJcbiAgICAgICAgICAgICAgICAgIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgNCwgeC5yYW5rKVxyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVUgPSAke1xyXG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxyXG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDQsIHgucmFuaylcclxuICAgICAgICAgICAgICAgICAgOiBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAxLCB4LnJhbmspXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gKHhTaGFwZVUgLyA0KSAqIDQ7XHJcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID0geFNoYXBlVSAlIDQ7XHJcblxyXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IDAuMDtcclxuICAgICAgICAgICAgICBmb3IgKHZhciB3RiA9IDB1OyB3RiA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzBdOyB3RisrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeEYgPSB4RkNvcm5lciArIHdGICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSB4U2hhcGVZKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHdSID0gMHU7IHdSIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV07IHdSKyspIHtcclxuICAgICAgICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UiAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSB4U2hhcGVaKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMHU7IHdDIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMl07IHdDKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDICogdW5pZm9ybXMuZGlsYXRpb25zWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0geFNoYXBlVykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkMSA9IDB1OyBkMSA8IGlucHV0RGVwdGhOZWFyZXN0VmVjNDsgZDEgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgJHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gYGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4RiwgeFIsIHhDKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeEYsIHhSLCB4QyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDIsIHhGLCB4UiwgeEMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4RiwgeFIsIHhDKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzQ8ZjMyPihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEsIHdGLCB3Uiwgd0MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDEsIHdGLCB3Uiwgd0MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDIsIHdGLCB3Uiwgd0MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDMsIHdGLCB3Uiwgd0MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGB2YWx1ZSArPSBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYHZhbHVlICs9IGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzI8ZjMyPihcclxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXHJcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAke1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICBgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB4RiwgeFIsIHhDKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYFxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMzxmMzI+KFxyXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcclxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgd0YsIHdSLCB3QykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAke2hhc0JpYXMgPyAndmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpJyA6ICcnfTtcclxuICAgICAgICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cclxuICAgICAgICAgICAgICByZXN1bHRbZ2xvYmFsX2lkeF0gPSBmMzIodmFsdWUpO1xyXG4gICAgICAgICAgfWA7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0NvbnYzRE5haXZlJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aXNDaGFubmVsTGFzdH07JHtpbm5lckVsZW1lbnRTaXplfTske2hhc0JpYXN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIGdldE1heENvbXBvbmVudHMsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuaW1wb3J0IHsgQ29udkF0dHJpYnV0ZXMgfSBmcm9tICcuL2NvbnYnO1xyXG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBuYWl2ZSBncm91cGVkIGNvbnYgaW1wbGVtZW50YXRpb24sIHN1cHBvcnRzIDFkLzJkIGNvbnZcclxuICogQHBhcmFtIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uIC0gYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gc3F1ZWV6ZSB0aGUgb3V0cHV0IHNoYXBlLCBvbmx5IHVzZWQgaW4gY29udjFkXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcclxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcclxuICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07JyA6ICcnO1xyXG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IHdTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xyXG5cclxuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcclxuICBjb25zdCBvdXRwdXRDaGFubmVscyA9IGlzQ2hhbm5lbExhc3QgPyBvdXRwdXRTaGFwZVszXSA6IG91dHB1dFNoYXBlWzFdO1xyXG4gIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSBvdXRwdXRDaGFubmVscyAvIGF0dHJpYnV0ZXMuZ3JvdXA7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGlzQ2hhbm5lbExhc3QgJiYgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA+PSA0ID8gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRDaGFubmVscykgOiAxO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV0gfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRDaGFubmVsc1Blckdyb3VwIH0sXHJcbiAgXTtcclxuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh4U2hhcGUsIFt3U2hhcGVbMF0sIHdTaGFwZVsxXSwgd1NoYXBlWzJdLCB3U2hhcGVbM10gLyBjb21wb25lbnRzXSksXHJcbiAgKTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IGhhc0JpYXMgPyBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ10gOiBbJ3JhbmsnLCAncmFuayddO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxyXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdIC8gY29tcG9uZW50c10pLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XHJcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xyXG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIHhTaGFwZS5sZW5ndGgpO1xyXG4gICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIHdTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3gsIHddO1xyXG4gICAgaWYgKGhhc0JpYXMpIHtcclxuICAgICAgaW5wdXRWYXJzLnB1c2goaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNvbXBvbmVudHMpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RoIH0sXHJcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiAyIH0sXHJcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiAyIH0sXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9jaGFubmVsc19wZXJfZ3JvdXAnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgXTtcclxuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XHJcblxyXG4gICAgY29uc3QgY2FsY3VsYXRlUmVzdWx0ID0gaXNDaGFubmVsTGFzdFxyXG4gICAgICA/IGBcclxuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzBdOyB3SGVpZ2h0KyspIHtcclxuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcclxuXHJcbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd1dpZHRoKyspIHtcclxuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcclxuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdJbkNoYW5uZWwrKykge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcclxuICAgICAgICAgICAgbGV0IHhWYWwgPSAke3guZ2V0KCdiYXRjaCcsICd4SGVpZ2h0JywgJ3hXaWR0aCcsICdpbnB1dF9jaGFubmVsJyl9O1xyXG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7dy5nZXQoJ3dIZWlnaHQnLCAnd1dpZHRoJywgJ3dJbkNoYW5uZWwnLCAnb3V0cHV0X2NoYW5uZWwnKX07XHJcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBgXHJcbiAgICAgIDogYFxyXG4gICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xyXG4gICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xyXG4gICAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0hlaWdodCsrKSB7XHJcbiAgICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcclxuXHJcbiAgICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xyXG4gICAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XHJcbiAgICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVszXSkge1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7eC5nZXQoJ2JhdGNoJywgJ2lucHV0X2NoYW5uZWwnLCAneEhlaWdodCcsICd4V2lkdGgnKX07XHJcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHt3LmdldCgnb3V0cHV0X2NoYW5uZWwnLCAnd0luQ2hhbm5lbCcsICd3SGVpZ2h0JywgJ3dXaWR0aCcpfTtcclxuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGA7XHJcbiAgICByZXR1cm4gYFxyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCBvdXRwdXQpfVxyXG5cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcblxyXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICBsZXQgYmF0Y2g6IHUzMiA9IG91dHB1dEluZGljZXNbMF07XHJcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHtpc0NoYW5uZWxMYXN0ID8gMyA6IDF9XTtcclxuICAgIGxldCB4UkNDb3JuZXI6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPihvdXRwdXRJbmRpY2VzWyR7aXNDaGFubmVsTGFzdCA/IDEgOiAyfV0sIG91dHB1dEluZGljZXNbJHtcclxuICAgICAgaXNDaGFubmVsTGFzdCA/IDIgOiAzXHJcbiAgICB9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcclxuICAgIGxldCBncm91cF9pZDogdTMyID0gb3V0cHV0X2NoYW5uZWwgKiAke2NvbXBvbmVudHN9IC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcclxuICAgIHZhciBpbl9jaGFubmVsX29mZnNldCA9IGdyb3VwX2lkICogdW5pZm9ybXMud19zaGFwZVske2lzQ2hhbm5lbExhc3QgPyAyIDogMX1dO1xyXG5cclxuICAgIHZhciB2YWx1ZTogJHtvdXRwdXQudHlwZS52YWx1ZX0gPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtcclxuICAgICR7Y2FsY3VsYXRlUmVzdWx0fVxyXG4gICAgJHtwcm9jZXNzQmlhc31cclxuICAgICR7YXBwbHlBY3RpdmF0aW9ufVxyXG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cclxuICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnR3JvdXBlZENvbnYnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1fJHtjb21wb25lbnRzfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgZGltczogc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gPyBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbihvdXRwdXRTaGFwZSkgOiBvdXRwdXRTaGFwZSxcclxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdyb3VwZWRDb252VmVjdG9yaXplUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXHJcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMob3V0cHV0U2hhcGVbM10pO1xyXG4gIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMob3V0cHV0U2hhcGVbMl0pO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzIC8gb3V0cHV0TnVtYmVyO1xyXG4gIGNvbnN0IHhTaGFwZSA9IFtpbnB1dHNbMF0uZGltc1swXSwgaW5wdXRzWzBdLmRpbXNbMV0sIGlucHV0c1swXS5kaW1zWzJdLCBpbnB1dHNbMF0uZGltc1szXSAvIGNvbXBvbmVudHNdO1xyXG4gIGNvbnN0IHdTaGFwZSA9IFtpbnB1dHNbMV0uZGltc1swXSwgaW5wdXRzWzFdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzJdLCBpbnB1dHNbMV0uZGltc1szXSAvIGNvbXBvbmVudHNdO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlSW5TaGFkZXIgPSBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzFdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM10gLyBjb21wb25lbnRzXTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnN0cmlkZXNbMF0sIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXV0gfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV0gfSxcclxuICBdO1xyXG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh4U2hhcGUsIHdTaGFwZSwgb3V0cHV0U2hhcGVJblNoYWRlcikpO1xyXG4gIGNvbnN0IHhOdW1iZXIgPSAob3V0cHV0TnVtYmVyIC0gMSkgKiBhdHRyaWJ1dGVzLnN0cmlkZXNbMV0gKyB3U2hhcGVbMV07XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBiYXNlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShvdXRwdXQudHlwZS50ZW5zb3IpO1xyXG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUsIGJhc2VUeXBlKTtcclxuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IHcgPSBpbnB1dFZhcmlhYmxlKCd3JywgaW5wdXRzWzFdLmRhdGFUeXBlLCB3U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGlucHV0VmFycyA9IFt4LCB3XTtcclxuICAgIGlmIChoYXNCaWFzKSB7XHJcbiAgICAgIGlucHV0VmFycy5wdXNoKGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLCBjb21wb25lbnRzKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07JyA6ICcnO1xyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXHJcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXHJcbiAgICBdO1xyXG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG4gICAgbGV0IHdpZHRoMCA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVszXTtcclxuICAgIGxldCBvdXRwdXRfY2hhbm5lbCA9IGdsb2JhbF9pZHggJSB3aWR0aDA7XHJcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvIHdpZHRoMDtcclxuICAgIGxldCB3aWR0aDEgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0gLyAke291dHB1dE51bWJlcn11O1xyXG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHtvdXRwdXROdW1iZXJ9dTtcclxuICAgIGluZGV4MSA9IGluZGV4MSAvIHdpZHRoMTtcclxuICAgIGxldCByb3cgPSBpbmRleDEgJSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XHJcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XHJcblxyXG4gICAgbGV0IHhfY29ybmVyID0gdmVjMjxpMzI+KGkzMihyb3cpLCBpMzIoY29sKSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcclxuXHJcbiAgICB2YXIgeF92YWxzOiBhcnJheTwke3gudHlwZS52YWx1ZX0sICR7eE51bWJlcn0+O1xyXG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0TnVtYmVyfT47XHJcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xyXG4gICAgLy8gVXNlIGNvbnN0YW50IGluc3RlYWQgb2YgdW5pZm9ybSBjYW4gZ2l2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UgZm9yIHcncyBoZWlnaHQvd2lkdGguXHJcbiAgICBmb3IgKHZhciB3X2hlaWdodDogdTMyID0gMHU7IHdfaGVpZ2h0IDwgJHt3U2hhcGVbMF19OyB3X2hlaWdodCsrKSB7XHJcbiAgICAgIGxldCB4X2hlaWdodCA9IHhfY29ybmVyLnggKyBpMzIod19oZWlnaHQpO1xyXG4gICAgICBpZiAoeF9oZWlnaHQgPj0gMCAmJiB1MzIoeF9oZWlnaHQpIDwgdW5pZm9ybXMueF9zaGFwZVsxXSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt4TnVtYmVyfTsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgeF93aWR0aCA9IHhfY29ybmVyLnkgKyBpO1xyXG4gICAgICAgICAgaWYgKHhfd2lkdGggPj0gMCAmJiB1MzIoeF93aWR0aCkgPCB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XHJcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7eC5nZXQoJ2JhdGNoJywgJ3UzMih4X2hlaWdodCknLCAndTMyKHhfd2lkdGgpJywgJ2lucHV0X2NoYW5uZWwnKX07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4X3ZhbHNbaV0gPSAke3gudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIHdfd2lkdGg6IHUzMiA9IDB1OyB3X3dpZHRoIDwgJHt3U2hhcGVbMV19OyB3X3dpZHRoKyspIHtcclxuICAgICAgICAgIGxldCB3X3ZhbCA9ICR7dy5nZXQoJ3dfaGVpZ2h0JywgJ3dfd2lkdGgnLCAnMCcsICdvdXRwdXRfY2hhbm5lbCcpfTtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSBmbWEoeF92YWxzW2kgKiB1MzIodW5pZm9ybXMuc3RyaWRlc1sxXSkgKyB3X3dpZHRoXSwgd192YWwsIHZhbHVlc1tpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtvdXRwdXROdW1iZXJ9dTsgaSsrKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcclxuICAgICAgJHtwcm9jZXNzQmlhc31cclxuICAgICAgJHthcHBseUFjdGl2YXRpb259XHJcbiAgICAgICR7b3V0cHV0LnNldCgnYmF0Y2gnLCAncm93JywgJ2NvbCArIGknLCAnb3V0cHV0X2NoYW5uZWwnLCAndmFsdWUnKX07XHJcbiAgICB9XHJcbiAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdHcm91cGVkQ29udi1WZWN0b3JpemUnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtjb21wb25lbnRzfTske291dHB1dE51bWJlcn07JHt4TnVtYmVyfTske3dTaGFwZVswXX07JHt3U2hhcGVbMV19YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IGhhc0JpYXMgPyBbJ3JhbmsnLCAncmFuaycsICd0eXBlJ10gOiBbJ3JhbmsnLCAncmFuayddLFxyXG4gICAgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgUG9vbENvbnZVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9jb252MmRfbW1fd2ViZ3B1JztcclxuaW1wb3J0IHsgY29tcHV0ZUNvbnYzREluZm8sIGNyZWF0ZUNvbnYzRE5haXZlUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9jb252M2RfbmFpdmVfd2ViZ3B1JztcclxuaW1wb3J0IHsgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XHJcbmltcG9ydCB7IGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8sIGNyZWF0ZUdyb3VwZWRDb252VmVjdG9yaXplUHJvZ3JhbUluZm8gfSBmcm9tICcuL2NvbnYtZ3JvdXBlZCc7XHJcbmltcG9ydCB7IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vZnVzZS11dGlscyc7XHJcbmltcG9ydCB7IGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8gfSBmcm9tICcuL21hdG11bC1zaGFkZXJzJztcclxuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XHJcblxyXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGUgPSAoXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgYWRqdXN0UGFkczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgaXNDaGFubmVsTGFzdDogYm9vbGVhbixcclxuKTogbnVtYmVyW10gPT4ge1xyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XHJcbiAgY29uc3QgaW5wdXRTcGF0aWFsU2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKGlzQ2hhbm5lbExhc3QgPyAxIDogMiwgaXNDaGFubmVsTGFzdCA/IDMgOiA0KTtcclxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0U3BhdGlhbFNoYXBlLmxlbmd0aDtcclxuICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlWzBdO1xyXG4gIGNvbnN0IGtlcm5lbFNwYXRpYWxTaGFwZSA9IGtlcm5lbFNoYXBlLnNsaWNlKDIpO1xyXG4gIGNvbnN0IGRpbGF0ZWRLZXJuZWxTaGFwZSA9IGtlcm5lbFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyAodiAtIDEpICogKGRpbGF0aW9uc1tpXSAtIDEpKTtcclxuICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQgPSBpbnB1dFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyBhZGp1c3RQYWRzW2ldICsgYWRqdXN0UGFkc1tpICsgc3BhdGlhbFJhbmtdKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U3BhdGlhbFNoYXBlV2l0aFBhZC5tYXAoKHYsIGkpID0+XHJcbiAgICBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSxcclxuICApO1xyXG4gIG91dHB1dFNoYXBlLnNwbGljZSgwLCAwLCBiYXRjaFNpemUpO1xyXG4gIG91dHB1dFNoYXBlLnNwbGljZShpc0NoYW5uZWxMYXN0ID8gMyA6IDEsIDAsIG91dENoYW5uZWxzKTtcclxuICByZXR1cm4gb3V0cHV0U2hhcGU7XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbnZBdHRyaWJ1dGVzIGV4dGVuZHMgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XHJcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXTtcclxuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcclxuICByZWFkb25seSBncm91cDogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcclxuICByZWFkb25seSBwYWRzOiByZWFkb25seSBudW1iZXJbXTtcclxuICByZWFkb25seSBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcclxuICByZWFkb25seSB3SXNDb25zdDogYm9vbGVhbjtcclxufVxyXG5cclxuLy8gZm9yIHRyYW5zcG9zaW5nIHdlaWdodCB0ZW5zb3IgZnJvbSBbTSwgQy9ncm91cCwgS0gsIEtXXSB0byBbS0gsIEtXLCBDL2dyb3VwLCBNXVxyXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUgPSBbMiwgMywgMSwgMF07XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICAvLyBSZWZlciB0byB0aGUgYmVsb3cgbGluayBmb3IgYWxsIGlucHV0IGNoZWNrc1xyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYXN0ZXIvZG9jcy9PcGVyYXRvcnMubWQjQ29udlxyXG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCA+IDUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignZ3JlYXRlciB0aGFuIDVEIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxyXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDEgOiAxXTtcclxuICBjb25zdCBmaWx0ZXJJbkNoYW5uZWwgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XHJcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgKGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBpbnB1dHNbMV0uZGltc1swXSAhPT0gaW5wdXRzWzJdLmRpbXNbMF0pKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xyXG4gIC8vIHdyb25nIGRpbGF0aW9ucyBkaW1lbnNpb25cclxuICBpZiAoYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xyXG4gIH1cclxuXHJcbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cclxuICBpZiAoYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XHJcbiAgfVxyXG5cclxuICAvLyBXcm9uZyBwYWRzIGRpbWVuc2lvblxyXG4gIGlmIChhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xyXG4gIH1cclxuXHJcbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXHJcbiAgLy8gKHRoZSBmaXJzdCAyIGRpbXMgYXJlIGJhdGNoX3NpemUgYW5kIGNoYW5uZWxzKVxyXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZBdHRyaWJ1dGVzPihhdHRyaWJ1dGVzOiBULCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFQgPT4ge1xyXG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xyXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCB3ZWxsIHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlcywgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXHJcbiAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDIpIHtcclxuICAgIGtlcm5lbFNoYXBlLnB1c2goLi4uQXJyYXkoaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMiAtIGtlcm5lbFNoYXBlLmxlbmd0aCkuZmlsbCgwKSk7XHJcbiAgfVxyXG4gIGZvciAobGV0IGkgPSAyOyBpIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoOyArK2kpIHtcclxuICAgIGlmIChrZXJuZWxTaGFwZVtpIC0gMl0gPT09IDApIHtcclxuICAgICAga2VybmVsU2hhcGVbaSAtIDJdID0gaW5wdXRzWzFdLmRpbXNbaV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcclxuICBQb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxyXG4gICAgaW5wdXRzWzBdLmRpbXMsXHJcbiAgICBhdHRyaWJ1dGVzLnN0cmlkZXMsXHJcbiAgICBhdHRyaWJ1dGVzLmRpbGF0aW9ucyxcclxuICAgIGtlcm5lbFNoYXBlLFxyXG4gICAgcGFkcyxcclxuICAgIGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycsXHJcbiAgICBhdHRyaWJ1dGVzLmF1dG9QYWQsXHJcbiAgKTtcclxuXHJcbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXHJcbiAgY29uc3QgbmV3QXR0cmlidXRlczogVCA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpO1xyXG4gIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgcGFkcyB9KTtcclxuICByZXR1cm4gbmV3QXR0cmlidXRlcztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29udkF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVzID0gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xyXG4gIC8vIFRPRE8gOiBNYWtlIHRoaXMgZ2VuZXJpYyBlbm91Z2ggdG8gY29tcHV0ZSBkZWZhdWx0IGF0dHJpYnV0ZXMgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcclxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVyc7XHJcbiAgY29uc3QgYXV0b1BhZCA9IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW2F0dHJpYnV0ZXMuYXV0b19wYWQgYXMgbnVtYmVyXTtcclxuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBudW1iZXJbXTtcclxuICBjb25zdCBncm91cCA9IGF0dHJpYnV0ZXMuZ3JvdXAgYXMgbnVtYmVyO1xyXG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxfc2hhcGUgYXMgbnVtYmVyW107XHJcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcyBhcyBudW1iZXJbXTtcclxuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzIGFzIG51bWJlcltdO1xyXG4gIGNvbnN0IHdJc0NvbnN0ID0gKGF0dHJpYnV0ZXMud19pc19jb25zdCBhcyAoKSA9PiBib29sZWFuKSgpO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgYXV0b1BhZCxcclxuICAgIGZvcm1hdCxcclxuICAgIGRpbGF0aW9ucyxcclxuICAgIGdyb3VwLFxyXG4gICAga2VybmVsU2hhcGUsXHJcbiAgICBwYWRzLFxyXG4gICAgc3RyaWRlcyxcclxuICAgIHdJc0NvbnN0LFxyXG4gICAgLi4uYWN0aXZhdGlvbkF0dHJpYnV0ZXMsXHJcbiAgICBjYWNoZUtleTogYCR7YXR0cmlidXRlcy5mb3JtYXR9OyR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07YCxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgY29udjJkID0gKFxyXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxyXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXHJcbik6IHZvaWQgPT4ge1xyXG4gIC8vIGNoZWNrIGF0dHJpYnV0ZXNcclxuXHJcbiAgLy8gY29uc3QgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IGZhbHNlOyAvKiBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgcHJlbHUgYWN0aXZhdGlvbiB3ZWlnaHRzICovXHJcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoXHJcbiAgICBpbnB1dHNbMF0uZGltcyxcclxuICAgIGlucHV0c1sxXS5kaW1zLFxyXG4gICAgYXR0cmlidXRlcy5kaWxhdGlvbnMsXHJcbiAgICBhdHRyaWJ1dGVzLnBhZHMsXHJcbiAgICBhdHRyaWJ1dGVzLnN0cmlkZXMsXHJcbiAgICBpc0NoYW5uZWxzTGFzdCxcclxuICApO1xyXG4gIGlmIChhdHRyaWJ1dGVzLmdyb3VwICE9PSAxKSB7XHJcbiAgICBjb25zdCBjb252SW5wdXRzID0gW2lucHV0c1swXV07XHJcbiAgICBpZiAoaXNDaGFubmVsc0xhc3QpIHtcclxuICAgICAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9XHJcbiAgICAgICAgKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xyXG4gICAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSksIHtcclxuICAgICAgICAgIGlucHV0czogWzFdLFxyXG4gICAgICAgICAgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXSxcclxuICAgICAgICB9KVswXTtcclxuICAgICAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xyXG4gICAgICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XHJcbiAgICAgIH1cclxuICAgICAgY29udklucHV0cy5wdXNoKHRyYW5zcG9zZWRXZWlnaHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udklucHV0cy5wdXNoKGlucHV0c1sxXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICBjb252SW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcclxuICAgIH1cclxuICAgIC8vIE5WSURJQSBHUFUgd2l0aCBhbXBlcmUgYXJjaGl0ZWN0dXJlIGZhaWxzIHdpdGggYmVsb3cgMiBjYXNlcywgYnV0IHdlIGNvdWxkbid0IHJlcHJvIHRoZW0gd2l0aCBhbnkgb3RoZXJcclxuICAgIC8vIEdQVXMuIFNvIGp1c3QgZGlzYWJsZSB2ZWN0b3JpemUgb24gTlZJRElBIGFtcGVyZSB0byBlbnN1cmUgYWx3YXlzIGNvcnJlY3Qgb3V0cHV0cy5cclxuICAgIC8vIFt3ZWJncHVdQ29udiAtIGNvbnYgLSB2ZWN0b3JpemUgZ3JvdXAgLSBCXHJcbiAgICAvLyBbd2ViZ3B1XUNvbnYgLSBjb252IC0gdmVjdG9yaXplIGdyb3VwIC0gRFxyXG4gICAgY29uc3QgZW5hYmxlR3JvdXBlZENvbnZWZWN0b3JpemUgPSAhY29udGV4dC5hZGFwdGVySW5mby5pc0FyY2hpdGVjdHVyZSgnYW1wZXJlJyk7XHJcbiAgICBpZiAoXHJcbiAgICAgIGVuYWJsZUdyb3VwZWRDb252VmVjdG9yaXplICYmXHJcbiAgICAgIGlzQ2hhbm5lbHNMYXN0ICYmXHJcbiAgICAgIGlucHV0c1sxXS5kaW1zWzBdID09PSBhdHRyaWJ1dGVzLmdyb3VwICYmXHJcbiAgICAgIGlucHV0c1sxXS5kaW1zWzFdID09PSAxICYmXHJcbiAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdID09PSAxICYmXHJcbiAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdID09PSAxXHJcbiAgICApIHtcclxuICAgICAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgICAgIGNyZWF0ZUdyb3VwZWRDb252VmVjdG9yaXplUHJvZ3JhbUluZm8oY29udklucHV0cywgYXR0cmlidXRlcywgb3V0cHV0U2hhcGUsIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKSxcclxuICAgICAgICB7IGlucHV0czogY29udklucHV0cyB9LFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8oY29udklucHV0cywgYXR0cmlidXRlcywgb3V0cHV0U2hhcGUsIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKSwge1xyXG4gICAgICAgIGlucHV0czogY29udklucHV0cyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA9PT0gMztcclxuICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdO1xyXG4gIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXTtcclxuICBjb25zdCBpbnB1dENoYW5uZWxzID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XHJcbiAgY29uc3Qgd2VpZ2h0SGVpZ2h0ID0gaW5wdXRzWzFdLmRpbXNbMl07XHJcbiAgY29uc3Qgd2VpZ2h0V2lkdGggPSBpbnB1dHNbMV0uZGltc1szXTtcclxuXHJcbiAgY29uc3Qgb3V0SGVpZ2h0ID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XHJcbiAgY29uc3Qgb3V0V2lkdGggPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXTtcclxuICBjb25zdCBvdXRDaGFubmVscyA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xyXG5cclxuICBjb25zdCBzYW1lU2l6ZSA9XHJcbiAgICBpc0NoYW5uZWxzTGFzdCAmJlxyXG4gICAgd2VpZ2h0SGVpZ2h0ID09PSBpbnB1dEhlaWdodCAmJlxyXG4gICAgd2VpZ2h0V2lkdGggPT09IGlucHV0V2lkdGggJiZcclxuICAgIGF0dHJpYnV0ZXMucGFkc1swXSA9PT0gMCAmJlxyXG4gICAgYXR0cmlidXRlcy5wYWRzWzFdID09PSAwO1xyXG4gIGlmIChcclxuICAgIHNhbWVTaXplIHx8XHJcbiAgICAod2VpZ2h0SGVpZ2h0ID09PSAxICYmXHJcbiAgICAgIHdlaWdodFdpZHRoID09PSAxICYmXHJcbiAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdID09PSAxICYmXHJcbiAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdID09PSAxICYmXHJcbiAgICAgIGF0dHJpYnV0ZXMuc3RyaWRlc1swXSA9PT0gMSAmJlxyXG4gICAgICBhdHRyaWJ1dGVzLnN0cmlkZXNbMV0gPT09IDEgJiZcclxuICAgICAgYXR0cmlidXRlcy5wYWRzWzBdID09PSAwICYmXHJcbiAgICAgIGF0dHJpYnV0ZXMucGFkc1sxXSA9PT0gMClcclxuICApIHtcclxuICAgIC8vIGNvbnYyZEJ5TWF0TXVsXHJcbiAgICBjb25zdCBiYXRjaCA9IG91dHB1dFNoYXBlWzBdO1xyXG4gICAgbGV0IHhSZXNoYXBlZCwgd1Jlc2hhcGVkLCBtYXRtdWxPdXRwdXRTaGFwZTtcclxuICAgIGNvbnN0IG1hdG11bElucHV0cyA9IFtdO1xyXG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XHJcbiAgICAgIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPVxyXG4gICAgICAgIChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cclxuICAgICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLCB7XHJcbiAgICAgICAgICBpbnB1dHM6IFsxXSxcclxuICAgICAgICAgIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV0sXHJcbiAgICAgICAgfSlbMF07XHJcbiAgICAgIGlmIChhdHRyaWJ1dGVzLndJc0NvbnN0ICYmICFjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QpIHtcclxuICAgICAgICBjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgPSB0cmFuc3Bvc2VkV2VpZ2h0O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzYW1lU2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IHNoYXJlZERpbSA9IGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XHJcbiAgICAgICAgeFJlc2hhcGVkID0gaW5wdXRzWzBdLnJlc2hhcGUoWzEsIGJhdGNoLCBzaGFyZWREaW1dKTtcclxuICAgICAgICB3UmVzaGFwZWQgPSB0cmFuc3Bvc2VkV2VpZ2h0LnJlc2hhcGUoWzEsIHNoYXJlZERpbSwgb3V0Q2hhbm5lbHNdKTtcclxuICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFsxLCBiYXRjaCwgb3V0Q2hhbm5lbHNdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHhSZXNoYXBlZCA9IGlucHV0c1swXS5yZXNoYXBlKFtiYXRjaCwgaW5wdXRIZWlnaHQgKiBpbnB1dFdpZHRoLCBpbnB1dENoYW5uZWxzXSk7XHJcbiAgICAgICAgd1Jlc2hhcGVkID0gdHJhbnNwb3NlZFdlaWdodC5yZXNoYXBlKFsxLCBpbnB1dENoYW5uZWxzLCBvdXRDaGFubmVsc10pO1xyXG4gICAgICAgIG1hdG11bE91dHB1dFNoYXBlID0gW2JhdGNoLCBvdXRIZWlnaHQgKiBvdXRXaWR0aCwgb3V0Q2hhbm5lbHNdO1xyXG4gICAgICB9XHJcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHhSZXNoYXBlZCk7XHJcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHdSZXNoYXBlZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4UmVzaGFwZWQgPSBpbnB1dHNbMF0ucmVzaGFwZShbYmF0Y2gsIGlucHV0Q2hhbm5lbHMsIGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aF0pO1xyXG4gICAgICB3UmVzaGFwZWQgPSBpbnB1dHNbMV0ucmVzaGFwZShbMSwgb3V0Q2hhbm5lbHMsIGlucHV0Q2hhbm5lbHNdKTtcclxuICAgICAgbWF0bXVsT3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG91dENoYW5uZWxzLCBvdXRIZWlnaHQgKiBvdXRXaWR0aF07XHJcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHdSZXNoYXBlZCk7XHJcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHhSZXNoYXBlZCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzQmlhcykge1xyXG4gICAgICBtYXRtdWxJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgTiA9IG1hdG11bE91dHB1dFNoYXBlWzJdO1xyXG4gICAgY29uc3QgSyA9IG1hdG11bElucHV0c1swXS5kaW1zW21hdG11bElucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdO1xyXG4gICAgLy8gVHVuZSB0aGUgdGhyZXNob2xkLlxyXG4gICAgaWYgKE4gPCA4ICYmIEsgPCA4KSB7XHJcbiAgICAgIGNvbnRleHQuY29tcHV0ZShcclxuICAgICAgICBjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvKFxyXG4gICAgICAgICAgbWF0bXVsSW5wdXRzLFxyXG4gICAgICAgICAgYXR0cmlidXRlcyxcclxuICAgICAgICAgIG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgbWF0bXVsT3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCxcclxuICAgICAgICAgIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBpbnB1dHM6IG1hdG11bElucHV0cyB9LFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgICAgIGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKFxyXG4gICAgICAgICAgbWF0bXVsSW5wdXRzLFxyXG4gICAgICAgICAgYXR0cmlidXRlcyxcclxuICAgICAgICAgIG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgbWF0bXVsT3V0cHV0U2hhcGUsXHJcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCxcclxuICAgICAgICAgIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgeyBpbnB1dHM6IG1hdG11bElucHV0cyB9LFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogaW1wbGVtZW50IGNvbnYyZFdpdGhJbTJDb2woKVxyXG5cclxuICBjb25zdCBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzID0gLyogYmFja2VuZC5hZGFwdGVySW5mby5pc0ludGVsKCkgKi8gdHJ1ZTtcclxuXHJcbiAgLy8gU1RFUC4xOiB0cmFuc3Bvc2Ugd2VpZ2h0XHJcbiAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9XHJcbiAgICAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XHJcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLCB7XHJcbiAgICAgIGlucHV0czogWzFdLFxyXG4gICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxyXG4gICAgfSlbMF07XHJcbiAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xyXG4gICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcclxuICB9XHJcblxyXG4gIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcclxuICBjb25zdCBjb252SW5wdXRzID0gW2lucHV0c1swXSwgdHJhbnNwb3NlZFdlaWdodF07XHJcbiAgaWYgKGhhc0JpYXMpIHtcclxuICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xyXG4gIH1cclxuXHJcbiAgLy8gU1RFUC4zOiBjb21wdXRlIG1hdG11bFxyXG4gIGNvbnN0IGRpbUFPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0SGVpZ2h0ICogb3V0V2lkdGggOiBvdXRDaGFubmVscztcclxuICBjb25zdCBkaW1CT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dENoYW5uZWxzIDogb3V0SGVpZ2h0ICogb3V0V2lkdGg7XHJcbiAgY29uc3QgZGltSW5uZXIgPSB3ZWlnaHRIZWlnaHQgKiB3ZWlnaHRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm8oXHJcbiAgICAgIGNvbnZJbnB1dHMsXHJcbiAgICAgIGF0dHJpYnV0ZXMsXHJcbiAgICAgIG91dHB1dFNoYXBlLFxyXG4gICAgICBkaW1BT3V0ZXIsXHJcbiAgICAgIGRpbUJPdXRlcixcclxuICAgICAgZGltSW5uZXIsXHJcbiAgICAgIGhhc0JpYXMsXHJcbiAgICAgIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMsXHJcbiAgICAgIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uLFxyXG4gICAgKSxcclxuICAgIHsgaW5wdXRzOiBjb252SW5wdXRzIH0sXHJcbiAgKTtcclxufTtcclxuXHJcbmNvbnN0IGNvbnYxZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICAvLyBleHRlbmQgdGhlIGlucHV0IHRvIDJEIGJ5IGFkZGluZyBIIGRpbWVuc2lvblxyXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xyXG4gIGNvbnN0IGlucHV0cyA9IFtcclxuICAgIGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoXHJcbiAgICAgIGlzQ2hhbm5lbExhc3RcclxuICAgICAgICA/IC8vIFtOLCBXLCBDXSAtPiBbTiwgSD0xLCBXLCBDXVxyXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dXHJcbiAgICAgICAgOiAvLyBbTiwgQywgV10gLT4gW04sIEMsIEg9MSwgV11cclxuICAgICAgICAgIFtjb250ZXh0LmlucHV0c1swXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzJdXSxcclxuICAgICksXHJcbiAgICAvL1tGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrV10gLT4gW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtIPTEsIGtXXVxyXG4gICAgY29udGV4dC5pbnB1dHNbMV0ucmVzaGFwZShbY29udGV4dC5pbnB1dHNbMV0uZGltc1swXSwgY29udGV4dC5pbnB1dHNbMV0uZGltc1sxXSwgMSwgY29udGV4dC5pbnB1dHNbMV0uZGltc1syXV0pLFxyXG4gIF07XHJcbiAgaWYgKGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgaW5wdXRzLnB1c2goY29udGV4dC5pbnB1dHNbMl0pO1xyXG4gIH1cclxuICBjb25zdCBwYWRzID0gWzAsIGF0dHJpYnV0ZXMucGFkc1swXSwgMCwgYXR0cmlidXRlcy5wYWRzWzFdXTtcclxuICBjb25zdCBzdHJpZGVzID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLnN0cmlkZXMpO1xyXG4gIGNvbnN0IGRpbGF0aW9ucyA9IFsxXS5jb25jYXQoYXR0cmlidXRlcy5kaWxhdGlvbnMpO1xyXG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcclxuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKFxyXG4gICAgeyAuLi5hdHRyaWJ1dGVzLCBwYWRzLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlIH0sXHJcbiAgICBpbnB1dHMsXHJcbiAgKTtcclxuICBjb252MmQoY29udGV4dCwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIChvdXRwdXRTaGFwZSkgPT5cclxuICAgIGlzQ2hhbm5lbExhc3QgPyBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXV0gOiBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzFdLCBvdXRwdXRTaGFwZVszXV0sXHJcbiAgKTtcclxufTtcclxuXHJcbmNvbnN0IGNvbnYzZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgZm9ybWF0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/ICdjaGFubmVsc0xhc3QnIDogJ2NoYW5uZWxzRmlyc3QnO1xyXG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMoYXR0cmlidXRlcywgaW5wdXRzKTtcclxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5hdXRvUGFkID09PSAnTk9UU0VUJyA/IGF0dHJpYnV0ZXMucGFkcyA6IGF0dHJpYnV0ZXMuYXV0b1BhZDtcclxuICBjb25zdCBjb252SW5mbyA9IGNvbXB1dGVDb252M0RJbmZvKFxyXG4gICAgaW5wdXRzWzBdLmRpbXMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICAgIGlucHV0c1sxXS5kaW1zIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbiAgICBhdHRyaWJ1dGVzLnN0cmlkZXMgYXMgbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gICAgYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxyXG4gICAgcGFkcyBhcyBzdHJpbmcgfCBudW1iZXJbXSxcclxuICAgIGZhbHNlLFxyXG4gICAgZm9ybWF0LFxyXG4gICk7XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mbyhcclxuICAgICAgaW5wdXRzLFxyXG4gICAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXHJcbiAgICAgIGNvbnZJbmZvLm91dFNoYXBlLFxyXG4gICAgICBbY29udkluZm8uZmlsdGVyRGVwdGgsIGNvbnZJbmZvLmZpbHRlckhlaWdodCwgY29udkluZm8uZmlsdGVyV2lkdGhdLFxyXG4gICAgICBbY29udkluZm8ucGFkSW5mby5mcm9udCwgY29udkluZm8ucGFkSW5mby50b3AsIGNvbnZJbmZvLnBhZEluZm8ubGVmdF0sXHJcbiAgICAgIGZvcm1hdCxcclxuICAgICksXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb252ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcclxuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMpIHtcclxuICAgIGNvbnYxZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxuICB9IGVsc2UgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA1KSB7XHJcbiAgICBjb252M2QoY29udGV4dCwgY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGNvbnRleHQuaW5wdXRzKTtcclxuICAgIGNvbnYyZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzKTtcclxuICB9XHJcbn07XHJcbiIsICIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICovXHJcblxyXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL2NvbnZfYmFja3Byb3Bfd2ViZ3B1LnRzXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vLi4vLi4vbG9nJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG4gIGdldE1heENvbXBvbmVudHMsXHJcbn0gZnJvbSAnLi4vY29tbW9uJztcclxuaW1wb3J0IHsgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgfSBmcm9tICcuLi9jb252LXRyYW5zcG9zZSc7XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXHJcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMub3V0cHV0U2hhcGU7XHJcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xyXG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5ncm91cDtcclxuICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcztcclxuICBjb25zdCBpbnB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMl0gLyBncm91cDtcclxuICBjb25zdCBvdXRwdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzNdO1xyXG4gIGNvbnN0IGFDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBnZXRNYXhDb21wb25lbnRzKGlucHV0Q2hhbm5lbHNQZXJHcm91cCkgOiAxO1xyXG4gIGNvbnN0IHBhY2tJbnB1dEFzNCA9IGlzQ2hhbm5lbHNMYXN0ICYmIG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPT09IDEgJiYgaW5wdXRDaGFubmVsc1Blckdyb3VwID49IDQ7XHJcbiAgY29uc3QgaW5wdXRDaGFubmVsc1Blckdyb3VwSW50ID0gcGFja0lucHV0QXM0XHJcbiAgICA/IE1hdGguZmxvb3IoaW5wdXRDaGFubmVsc1Blckdyb3VwIC8gNCkgKiA0XHJcbiAgICA6IE1hdGguZmxvb3IoaW5wdXRDaGFubmVsc1Blckdyb3VwIC8gYUNvbXBvbmVudHMpICogYUNvbXBvbmVudHM7XHJcbiAgY29uc3QgaW5wdXRDaGFubmVsc1JlbWFpbmRlciA9IGlucHV0Q2hhbm5lbHNQZXJHcm91cCAtIGlucHV0Q2hhbm5lbHNQZXJHcm91cEludDtcclxuICBjb25zdCBjb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBnZXRNYXhDb21wb25lbnRzKG91dHB1dENoYW5uZWxzUGVyR3JvdXApIDogMTtcclxuICBjb25zdCBiQ29tcG9uZW50cyA9IGlzQ2hhbm5lbHNMYXN0ID8gKG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPT09IDEgPyBhQ29tcG9uZW50cyA6IGNvbXBvbmVudHMpIDogMTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cztcclxuICBjb25zdCBkaXNwYXRjaCA9IFtNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0KSwgMSwgMV07XHJcbiAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7ZGlzcGF0Y2h9YCk7XHJcblxyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcclxuICBjb25zdCBzdHJpZGVzID0gW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXTtcclxuICBjb25zdCBmaWx0ZXJEaW1zID0gW2F0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0sIGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM11dO1xyXG4gIGNvbnN0IGRpbGF0aW9ucyA9IFthdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSwgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV1dO1xyXG4gIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRpbXMgPSBbXHJcbiAgICBmaWx0ZXJEaW1zWzBdICtcclxuICAgICAgKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdIDw9IDFcclxuICAgICAgICA/IDBcclxuICAgICAgICA6IChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdIC0gMSkgKiAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gLSAxKSksXHJcbiAgICBmaWx0ZXJEaW1zWzFdICtcclxuICAgICAgKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIDw9IDFcclxuICAgICAgICA/IDBcclxuICAgICAgICA6IChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdIC0gMSkgKiAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gLSAxKSksXHJcbiAgXTtcclxuICBjb25zdCBwYWRzID0gW1xyXG4gICAgZWZmZWN0aXZlRmlsdGVyRGltc1swXSAtIDEgLSBNYXRoLmZsb29yKChhdHRyaWJ1dGVzLnBhZHNbMF0gKyBhdHRyaWJ1dGVzLnBhZHNbMl0pIC8gMiksXHJcbiAgICBlZmZlY3RpdmVGaWx0ZXJEaW1zWzFdIC0gMSAtIE1hdGguZmxvb3IoKGF0dHJpYnV0ZXMucGFkc1sxXSArIGF0dHJpYnV0ZXMucGFkc1szXSkgLyAyKSxcclxuICBdO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0cmlkZXMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBmaWx0ZXJEaW1zIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZGlsYXRpb25zIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWZmZWN0aXZlRmlsdGVyRGltcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogcGFkcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0Q2hhbm5lbHNQZXJHcm91cEludCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0Q2hhbm5lbHNQZXJHcm91cCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgfSxcclxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcyksXHJcbiAgXTtcclxuICBpZiAoaGFzQmlhcykge1xyXG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcclxuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcclxuICB9XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHN0cmlkZXMubGVuZ3RoIH0sXHJcbiAgICAgIHsgbmFtZTogJ2ZpbHRlcl9kaW1zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZmlsdGVyRGltcy5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZmlsdGVyRGltcy5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAnZWZmZWN0aXZlX2ZpbHRlcl9kaW1zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZWZmZWN0aXZlRmlsdGVyRGltcy5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IHBhZHMubGVuZ3RoIH0sXHJcbiAgICAgIHsgbmFtZTogJ2lucHV0X2NoYW5uZWxzX3Blcl9ncm91cF9pbnQnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdpbnB1dF9jaGFubmVsc19wZXJfZ3JvdXAnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwJywgdHlwZTogJ3UzMicgfSxcclxuICAgIF07XHJcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG4gICAgY29uc3Qgcm93RGltID0gaXNDaGFubmVsc0xhc3QgPyAxIDogMjtcclxuICAgIGNvbnN0IGNvbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDM7XHJcbiAgICBjb25zdCBjaGFubmVsRGltID0gaXNDaGFubmVsc0xhc3QgPyAzIDogMTtcclxuXHJcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgnVycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBiQ29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBkeSA9IGlucHV0VmFyaWFibGUoJ0R5JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIGFDb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2R5LCB3XTtcclxuICAgIGlmIChoYXNCaWFzKSB7XHJcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgW291dHB1dFNoYXBlW2NoYW5uZWxEaW1dXS5sZW5ndGgsIGNvbXBvbmVudHMpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcblxyXG4gICAgY29uc3QgY2FsY3VsYXRlUmVzdWx0ID0gKCk6IHN0cmluZyA9PiB7XHJcbiAgICAgIGxldCBjYWxjU3RyID0gJyc7XHJcbiAgICAgIGlmIChwYWNrSW5wdXRBczQpIHtcclxuICAgICAgICBpZiAoYUNvbXBvbmVudHMgPT09IDQpIHtcclxuICAgICAgICAgIGNhbGNTdHIgKz0gYFxyXG4gICAgICAgIGxldCB4VmFsdWUgPSAke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCcpfTtcclxuICAgICAgICBsZXQgd1ZhbHVlID0gJHt3LmdldEJ5T2Zmc2V0KCd3X29mZnNldCcpfTtcclxuICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh4VmFsdWUsIHdWYWx1ZSk7XHJcbiAgICAgICAgeF9vZmZzZXQgKz0gMXU7XHJcbiAgICAgICAgd19vZmZzZXQgKz0gMXU7YDtcclxuICAgICAgICB9IGVsc2UgaWYgKGFDb21wb25lbnRzID09PSAyKSB7XHJcbiAgICAgICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHZlYzQ8JHtkYXRhVHlwZX0+KCR7ZHkuZ2V0QnlPZmZzZXQoJ3hfb2Zmc2V0Jyl9LCAke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCArIDF1Jyl9KSwgdmVjNDwke2RhdGFUeXBlfT4oJHt3LmdldEJ5T2Zmc2V0KCd3X29mZnNldCcpfSwgJHt3LmdldEJ5T2Zmc2V0KCd3X29mZnNldCArIDF1Jyl9KSk7XHJcbiAgICAgICAgICB4X29mZnNldCArPSAydTtcclxuICAgICAgICAgIHdfb2Zmc2V0ICs9IDJ1O2A7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhQ29tcG9uZW50cyA9PT0gMSkge1xyXG4gICAgICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh2ZWM0PCR7ZGF0YVR5cGV9Pigke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCcpfSwgJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQgKyAxdScpfSwgJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQgKyAydScpfSwgJHtkeS5nZXRCeU9mZnNldCgneF9vZmZzZXQgKyAzdScpfSksIHZlYzQ8JHtkYXRhVHlwZX0+KCR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQnKX0sICR7dy5nZXRCeU9mZnNldCgnd19vZmZzZXQgKyAxdScpfSwgJHt3LmdldEJ5T2Zmc2V0KCd3X29mZnNldCArIDJ1Jyl9LCAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0ICsgM3UnKX0pKTtcclxuICAgICAgICAgIHhfb2Zmc2V0ICs9IDR1O1xyXG4gICAgICAgICAgd19vZmZzZXQgKz0gNHU7YDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICA/IGR5LmdldEJ5T2Zmc2V0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGAke2R5LmluZGljZXNUb09mZnNldChgJHtkeS50eXBlLmluZGljZXN9KGJhdGNoLCBpZHlSLCBpZHlDLCBpbnB1dENoYW5uZWwpYCl9IC8gJHthQ29tcG9uZW50c31gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IGR5LmdldCgnYmF0Y2gnLCAnaW5wdXRDaGFubmVsJywgJ2lkeVInLCAnaWR5QycpXHJcbiAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgYDtcclxuICAgICAgICBpZiAoYUNvbXBvbmVudHMgPT09IDEpIHtcclxuICAgICAgICAgIGNhbGNTdHIgKz0gYFxyXG4gICAgICAgICAgbGV0IHdfb2Zmc2V0ID0gJHt3LmluZGljZXNUb09mZnNldChgJHt3LnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfTtcclxuICAgICAgICAgIGxldCB3VmFsdWUgPSAke3cuZ2V0QnlPZmZzZXQoYHdfb2Zmc2V0IC8gJHtiQ29tcG9uZW50c31gKX07XHJcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtgO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGFDb21wb25lbnRzOyBjKyspIHtcclxuICAgICAgICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgICAgIGxldCB3VmFsdWUke2N9ID0gJHt3LmdldEJ5T2Zmc2V0KGAke3cuaW5kaWNlc1RvT2Zmc2V0KGAke3cudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCArICR7Y30sIHdPdXRDaGFubmVsKWApfSAvICR7YkNvbXBvbmVudHN9YCl9O1xyXG4gICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZVske2N9XSAqIHdWYWx1ZSR7Y307YDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNhbGNTdHI7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgY2FsY3VsYXRlUmVtYWluZGVyID0gKCk6IHN0cmluZyA9PiB7XHJcbiAgICAgIGlmIChpbnB1dENoYW5uZWxzUmVtYWluZGVyID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghcGFja0lucHV0QXM0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWNrSW5wdXRBczQgJHtwYWNrSW5wdXRBczR9IGlzIG5vdCB0cnVlLmApO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBjYWxjU3RyID0gJyc7XHJcbiAgICAgIGlmIChhQ29tcG9uZW50cyA9PT0gMSkge1xyXG4gICAgICAgIGNhbGNTdHIgKz0gJ2RvdFByb2QgPSBkb3RQcm9kJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q2hhbm5lbHNSZW1haW5kZXI7IGkrKykge1xyXG4gICAgICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgICAgICsgJHtkeS5nZXRCeU9mZnNldChgeF9vZmZzZXQgKyAke2l9YCl9ICogJHt3LmdldEJ5T2Zmc2V0KGB3X29mZnNldCArICR7aX1gKX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxjU3RyICs9ICc7JztcclxuICAgICAgfSBlbHNlIGlmIChhQ29tcG9uZW50cyA9PT0gMikge1xyXG4gICAgICAgIGlmIChpbnB1dENoYW5uZWxzUmVtYWluZGVyICE9PSAyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW5wdXRDaGFubmVsc1JlbWFpbmRlciAke2lucHV0Q2hhbm5lbHNSZW1haW5kZXJ9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgIGxldCB4VmFsdWUgPSAke2R5LmdldEJ5T2Zmc2V0KCd4X29mZnNldCcpfTtcclxuICAgICAgICAgIGxldCB3VmFsdWUgPSAke3cuZ2V0QnlPZmZzZXQoJ3dfb2Zmc2V0Jyl9O1xyXG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyBkb3QoeFZhbHVlLCB3VmFsdWUpO2A7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNhbGNTdHI7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgY29kZVNuaXBwZXQgPSBgXHJcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfWApfTtcclxuICAgICAgICAgICAgbGV0IGJhdGNoID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIDApfTtcclxuICAgICAgICAgICAgbGV0IGQxID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIGNoYW5uZWxEaW0pfTtcclxuICAgICAgICAgICAgbGV0IHIgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgcm93RGltKX07XHJcbiAgICAgICAgICAgIGxldCBjID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIGNvbERpbSl9O1xyXG4gICAgICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdW5pZm9ybXMucGFkcztcclxuICAgICAgICAgICAgbGV0IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XHJcbiAgICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xyXG4gICAgICAgICAgICBsZXQgZ3JvdXBJZCA9IGQxIC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcclxuICAgICAgICAgICAgbGV0IHdPdXRDaGFubmVsID0gZDEgLSBncm91cElkICogdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcclxuICAgICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXHJcbiAgICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxyXG4gICAgICAgICAgICB2YXIgZG90UHJvZCA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDAuMCk7XHJcbiAgICAgICAgICAgIHZhciB3UjogdTMyID0gMDtcclxuICAgICAgICAgICAgaWYgKHVuaWZvcm1zLmRpbGF0aW9ucy54ID09IDEpIHtcclxuICAgICAgICAgICAgICAvLyBNaW5pbXVtIHdSID49IDAgdGhhdCBzYXRpc2ZpZXMgKGR5UkNvcm5lciArIHdSKSAlICh1bmlmb3Jtcy5zdHJpZGVzLngpID09IDBcclxuICAgICAgICAgICAgICB3UiA9IHUzMigoKGR5UkNvcm5lciArIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpIC0gMSkgLyBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSkgKiBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSAtIGR5UkNvcm5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICg7IHdSIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLng7IHdSID0gd1IgKyAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGxldCBkeVIgPSAoJHtkYXRhVHlwZX0oZHlSQ29ybmVyKSArICR7ZGF0YVR5cGV9KHdSKSkgLyAke2RhdGFUeXBlfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcclxuICAgICAgICAgICAgICBsZXQgd1JQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueCAtIDEgLSB3UiAvIHVuaWZvcm1zLmRpbGF0aW9ucy54O1xyXG4gICAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLkR5X3NoYXBlWyR7cm93RGltfV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcclxuICAgICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcclxuICAgICAgICAgICAgICB2YXIgd0M6IHUzMiA9IDA7XHJcbiAgICAgICAgICAgICAgaWYgKHVuaWZvcm1zLmRpbGF0aW9ucy55ID09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1pbmltdW0gd0MgPj0gMCB0aGF0IHNhdGlzZmllcyAoZHlDQ29ybmVyICsgd0MpICUgKHVuaWZvcm1zLnN0cmlkZXMueSkgPT0gMFxyXG4gICAgICAgICAgICAgICAgd0MgPSB1MzIoKChkeUNDb3JuZXIgKyBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSAtIDEpIC8gaTMyKHVuaWZvcm1zLnN0cmlkZXMueSkpICogaTMyKHVuaWZvcm1zLnN0cmlkZXMueSkgLSBkeUNDb3JuZXIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBmb3IgKDsgd0MgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueTsgd0MgPSB3QyArIDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3QyAlIHVuaWZvcm1zLmRpbGF0aW9ucy55ICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7ZGF0YVR5cGV9KGR5Q0Nvcm5lcikgKyAke2RhdGFUeXBlfSh3QykpIC8gJHtkYXRhVHlwZX0odW5pZm9ybXMuc3RyaWRlcy55KTtcclxuICAgICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy55IC0gMSAtIHdDIC8gdW5pZm9ybXMuZGlsYXRpb25zLnk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2RhdGFUeXBlfSh1bmlmb3Jtcy5EeV9zaGFwZVske2NvbERpbX1dKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xyXG4gICAgICAgICAgICAgICAgJHtcclxuICAgICAgICAgICAgICAgICAgcGFja0lucHV0QXM0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBgXHJcbiAgICAgICAgICAgICAgICB2YXIgeF9vZmZzZXQgPSAke2R5LmluZGljZXNUb09mZnNldChgJHtkeS50eXBlLmluZGljZXN9KGJhdGNoLCBpZHlSLCBpZHlDLCBpbnB1dENoYW5uZWwpYCl9IC8gJHthQ29tcG9uZW50c307XHJcbiAgICAgICAgICAgICAgICB2YXIgd19vZmZzZXQgPSAke3cuaW5kaWNlc1RvT2Zmc2V0KGAke3cudHlwZS5pbmRpY2VzfSh3UlBlcm0sIHdDUGVybSwgaW5wdXRDaGFubmVsLCB3T3V0Q2hhbm5lbClgKX0gLyAke2JDb21wb25lbnRzfTtcclxuICAgICAgICAgICAgICAgICAgYFxyXG4gICAgICAgICAgICAgICAgICAgIDogJydcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cF9pbnQ7IGQyID0gZDIgKyAke3BhY2tJbnB1dEFzNCA/IDQgOiBhQ29tcG9uZW50c30pIHtcclxuICAgICAgICAgICAgICAgICAgJHtjYWxjdWxhdGVSZXN1bHQoKX1cclxuICAgICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsID0gaW5wdXRDaGFubmVsICsgJHtwYWNrSW5wdXRBczQgPyA0IDogYUNvbXBvbmVudHN9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgJHtjYWxjdWxhdGVSZW1haW5kZXIoKX1cclxuICAgICAgICAgICAgICAgIHdDID0gd0MgKyB1bmlmb3Jtcy5zdHJpZGVzLnkgLSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB3UiA9IHdSICsgdW5pZm9ybXMuc3RyaWRlc1swXSAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCR7aGFzQmlhcyA/IGAgKyBiaWFzW2QxIC8gJHtjb21wb25lbnRzfV1gIDogJyd9O1xyXG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcclxuICAgICAgICAgIGA7XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XHJcbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfTtcclxuICAgICR7Y29kZVNuaXBwZXR9fWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdDb252VHJhbnNwb3NlMkQnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHthQ29tcG9uZW50c30ke2JDb21wb25lbnRzfSR7Y29tcG9uZW50c30ke3BhY2tJbnB1dEFzNH0ke2lucHV0Q2hhbm5lbHNSZW1haW5kZXJ9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXMsXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdIH0sXHJcbiAgICAgIG91dHB1dHM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9jb252X2JhY2twcm9wX3dlYmdwdSc7XHJcbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi9jb252JztcclxuaW1wb3J0IHsgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcclxuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XHJcblxyXG5jb25zdCBjb21wdXRlVG90YWxQYWQgPSAoXHJcbiAgaW5EaW06IG51bWJlcixcclxuICBzdHJpZGU6IG51bWJlcixcclxuICBhZGo6IG51bWJlcixcclxuICBrZXJuZWw6IG51bWJlcixcclxuICBkaWxhdGlvbjogbnVtYmVyLFxyXG4gIG91dFNpemU6IG51bWJlcixcclxuKSA9PiAoaW5EaW0gLSAxKSAqIHN0cmlkZSArIGFkaiArIChrZXJuZWwgLSAxKSAqIGRpbGF0aW9uICsgMSAtIG91dFNpemU7XHJcblxyXG5jb25zdCBkaXN0cmlidXRlUGFkZGluZyA9ICh0b3RhbFBhZDogbnVtYmVyLCBhdXRvUGFkOiBzdHJpbmcsIHBhZHM6IG51bWJlcltdLCBoZWFkOiBudW1iZXIsIHRhaWw6IG51bWJlcikgPT4ge1xyXG4gIGNvbnN0IHNtYWxsUGFkID0gTWF0aC5mbG9vcih0b3RhbFBhZCAvIDIpO1xyXG4gIGlmIChhdXRvUGFkID09PSAnU0FNRV9VUFBFUicpIHtcclxuICAgIHBhZHNbaGVhZF0gPSBzbWFsbFBhZDtcclxuICAgIHBhZHNbdGFpbF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xyXG4gIH0gZWxzZSBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfTE9XRVInKSB7XHJcbiAgICBwYWRzW2hlYWRdID0gdG90YWxQYWQgLSBzbWFsbFBhZDtcclxuICAgIHBhZHNbdGFpbF0gPSBzbWFsbFBhZDtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMgPSAoXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgYXV0b1BhZDogc3RyaW5nLFxyXG4gIGdyb3VwOiBudW1iZXIsXHJcbiAgcGFkczogbnVtYmVyW10sXHJcbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgaXNDaGFubmVsTGFzdDogYm9vbGVhbixcclxuICBvdXRwdXRQYWRkaW5nOiBudW1iZXJbXSxcclxuICBvdXRwdXRTaGFwZTogbnVtYmVyW10sXHJcbikgPT4ge1xyXG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGggLSAyO1xyXG4gIGNvbnN0IHVwZGF0ZU91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUubGVuZ3RoID09PSAwO1xyXG4gIGlmIChvdXRwdXRQYWRkaW5nLmxlbmd0aCA8IHNwYXRpYWxSYW5rKSB7XHJcbiAgICBvdXRwdXRQYWRkaW5nLnB1c2goLi4uQXJyYXkoc3BhdGlhbFJhbmsgLSBvdXRwdXRQYWRkaW5nLmxlbmd0aCkuZmlsbCgwKSk7XHJcbiAgfVxyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XHJcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBrZXJuZWxTaGFwZVtpc0NoYW5uZWxMYXN0ID8gMyA6IDFdICogZ3JvdXA7XHJcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBpbnB1dFNoYXBlLmxlbmd0aCAtIHNwYXRpYWxSYW5rIC0gKGlzQ2hhbm5lbExhc3QgPyAxIDogMCk7IGkgPCBzcGF0aWFsUmFuazsgKytpLCArK2opIHtcclxuICAgIGNvbnN0IGluU2l6ZSA9IGlucHV0U2hhcGVbal07XHJcbiAgICBjb25zdCBvdXRTaXplID0gdXBkYXRlT3V0cHV0U2hhcGUgPyBpblNpemUgKiBzdHJpZGVzW2ldIDogb3V0cHV0U2hhcGVbaV07XHJcbiAgICBjb25zdCB0b3RhbFBhZCA9IGNvbXB1dGVUb3RhbFBhZChpblNpemUsIHN0cmlkZXNbaV0sIHBhZHNbaV0sIGtlcm5lbFNoYXBlW2pdLCBkaWxhdGlvbnNbaV0sIG91dFNpemUpO1xyXG4gICAgZGlzdHJpYnV0ZVBhZGRpbmcodG90YWxQYWQsIGF1dG9QYWQsIHBhZHMsIGksIGkgKyBzcGF0aWFsUmFuayk7XHJcbiAgICBpZiAodXBkYXRlT3V0cHV0U2hhcGUpIHtcclxuICAgICAgb3V0cHV0U2hhcGUucHVzaChcclxuICAgICAgICBzdHJpZGVzW2ldICogKGluU2l6ZSAtIDEpICtcclxuICAgICAgICAgIG91dHB1dFBhZGRpbmdbaV0gK1xyXG4gICAgICAgICAgKGtlcm5lbFNoYXBlW2pdIC0gMSkgKiBkaWxhdGlvbnNbaV0gK1xyXG4gICAgICAgICAgMSAtXHJcbiAgICAgICAgICBwYWRzW2ldIC1cclxuICAgICAgICAgIHBhZHNbaSArIHNwYXRpYWxSYW5rXSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKDAsIDAsIGJhdGNoU2l6ZSk7XHJcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGlzQ2hhbm5lbExhc3QgPyAzIDogMSwgMCwgb3V0Q2hhbm5lbHMpO1xyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb252VHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIENvbnZBdHRyaWJ1dGVzIHtcclxuICByZWFkb25seSBvdXRwdXRQYWRkaW5nOiByZWFkb25seSBudW1iZXJbXTtcclxuICByZWFkb25seSBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XHJcbn1cclxuXHJcbmNvbnN0IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPihcclxuICBhdHRyaWJ1dGVzOiBULFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4pOiBUID0+IHtcclxuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcclxuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xyXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpID09PSAwKSB7XHJcbiAgICBrZXJuZWxTaGFwZS5sZW5ndGggPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBpbnB1dHNbMV0uZGltcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0c1sxXS5kaW1zW2ldKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xyXG4gIGtlcm5lbFNoYXBlLnNwbGljZSgwLCAwLCBpbnB1dHNbMV0uZGltc1swXSk7XHJcbiAga2VybmVsU2hhcGUuc3BsaWNlKGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDEsIDAsIGlucHV0c1sxXS5kaW1zWzFdKTtcclxuXHJcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5zbGljZSgpO1xyXG4gIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcuc2xpY2UoKTtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgbGV0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zLnNsaWNlKCk7XHJcbiAgaWYgKGRpbGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA9PT0gMCkge1xyXG4gICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xyXG4gICAgZGlsYXRpb25zID0gbmV3IEFycmF5KHNwYXRpYWxSYW5rKS5maWxsKDEpO1xyXG4gIH1cclxuICBsZXQgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5zbGljZSgpO1xyXG4gIGlmIChzdHJpZGVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID09PSAwKSB7XHJcbiAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XHJcbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHNwYXRpYWxSYW5rKS5maWxsKDEpO1xyXG4gIH1cclxuICAvLyBJZiBvdXRwdXRTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHBhcmFtZXRlcnNcclxuICAvLyBTaW1pbGFybHksIGF1dG9tYXRpY2FsbHkgaW5mZXIgcGFkcyBpZiBub3Qgc3BlY2lmaWVkXHJcbiAgY2FsY3VsYXRlT3V0cHV0U2hhcGVBbmRQYWRzKFxyXG4gICAgaW5wdXRTaGFwZSxcclxuICAgIGtlcm5lbFNoYXBlLFxyXG4gICAgZGlsYXRpb25zLFxyXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxyXG4gICAgYXR0cmlidXRlcy5ncm91cCxcclxuICAgIHBhZHMsXHJcbiAgICBzdHJpZGVzLFxyXG4gICAgaXNDaGFubmVsc0xhc3QsXHJcbiAgICBvdXRwdXRQYWRkaW5nLFxyXG4gICAgb3V0cHV0U2hhcGUsXHJcbiAgKTtcclxuXHJcbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXHJcbiAgY29uc3QgbmV3QXR0cmlidXRlczogVCA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpO1xyXG4gIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgcGFkcywgb3V0cHV0UGFkZGluZywgb3V0cHV0U2hhcGUsIGRpbGF0aW9ucywgc3RyaWRlcyB9KTtcclxuICByZXR1cm4gbmV3QXR0cmlidXRlcztcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVzID0gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xyXG4gIC8vIFRPRE8gOiBNYWtlIHRoaXMgZ2VuZXJpYyBlbm91Z2ggdG8gY29tcHV0ZSBkZWZhdWx0IGF0dHJpYnV0ZXMgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcclxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVyc7XHJcbiAgY29uc3QgYXV0b1BhZCA9IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW1xyXG4gICAgdHlwZW9mIGF0dHJpYnV0ZXMuYXV0b1BhZCA9PSAndW5kZWZpbmVkJyA/IDAgOiAoYXR0cmlidXRlcy5hdXRvUGFkIGFzIG51bWJlcilcclxuICBdO1xyXG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIFtudW1iZXIsIG51bWJlcl07XHJcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwIGFzIG51bWJlcjtcclxuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcclxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xyXG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMgYXMgW251bWJlciwgbnVtYmVyXTtcclxuICBjb25zdCB3SXNDb25zdCA9IChhdHRyaWJ1dGVzLndJc0NvbnN0IGFzICgpID0+IGJvb2xlYW4pKCk7XHJcbiAgY29uc3Qgb3V0cHV0UGFkZGluZyA9IGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcclxuICByZXR1cm4ge1xyXG4gICAgYXV0b1BhZCxcclxuICAgIGZvcm1hdCxcclxuICAgIGRpbGF0aW9ucyxcclxuICAgIGdyb3VwLFxyXG4gICAga2VybmVsU2hhcGUsXHJcbiAgICBvdXRwdXRQYWRkaW5nLFxyXG4gICAgb3V0cHV0U2hhcGUsXHJcbiAgICBwYWRzLFxyXG4gICAgc3RyaWRlcyxcclxuICAgIHdJc0NvbnN0LFxyXG4gICAgLi4uYWN0aXZhdGlvbkF0dHJpYnV0ZXMsXHJcbiAgICBjYWNoZUtleTogYCR7YXR0cmlidXRlcy5mb3JtYXR9OyR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07YCxcclxuICB9O1xyXG59O1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgLy8gUmVmZXIgdG8gdGhlIGJlbG93IGxpbmsgZm9yIGFsbCBpbnB1dCBjaGVja3NcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL09wZXJhdG9ycy5tZCNDb252VHJhbnNwb3NlXHJcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzJyk7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXQnKTtcclxuICB9XHJcblxyXG4gIC8vIEZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcclxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxIDogMV07XHJcbiAgY29uc3QgZmlsdGVySW5DaGFubmVsID0gaW5wdXRzWzFdLmRpbXNbMF07XHJcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZmVhdHVyZU1hcHMgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XHJcblxyXG4gIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xyXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzJdLmRpbXNbMF0gIT09IGZlYXR1cmVNYXBzKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpYXMnKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcclxuICBjb25zdCBkaWxhdGlvbnNTZXQgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XHJcbiAgLy8gd3JvbmcgZGlsYXRpb25zIGRpbWVuc2lvblxyXG4gIGlmIChkaWxhdGlvbnNTZXQgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RyaWRlc1NldCA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XHJcbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cclxuICBpZiAoc3RyaWRlc1NldCAmJiBhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcclxuICB9XHJcblxyXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXHJcbiAgY29uc3QgcGFkc1NldCA9IGF0dHJpYnV0ZXMucGFkcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XHJcbiAgaWYgKHBhZHNTZXQgJiYgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmsgKiAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmsgKiAyfURgKTtcclxuICB9XHJcblxyXG4gIC8vIFdyb25nIG91dHB1dCBwYWRkaW5nIGRpbWVuc2lvblxyXG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAmJiBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dF9wYWRkaW5nIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcclxuICB9XHJcblxyXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxyXG4gIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcclxuICBjb25zdCBrZXJuZWxTaGFwZVNldCA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xyXG4gIGlmIChcclxuICAgIGtlcm5lbFNoYXBlU2V0ICYmXHJcbiAgICBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJlxyXG4gICAgYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDJcclxuICApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcclxuICB9XHJcblxyXG4gIC8vIGFzIHdpdGgga2VybmVsU2hhcGUsIG11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBzcGF0aWFsIGRpbXMgYXMgaW5wdXRcclxuICBpZiAoYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvdXRwdXQgc2hhcGUnKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjb252VHJhbnNwb3NlMmQgPSAoXHJcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXHJcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcclxuKTogdm9pZCA9PiB7XHJcbiAgLy8gU1RFUC4xOiB0cmFuc3Bvc2Ugd2VpZ2h0XHJcbiAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9XHJcbiAgICAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XHJcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCBbMiwgMywgMCwgMV0pLCB7XHJcbiAgICAgIGlucHV0czogWzFdLFxyXG4gICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxyXG4gICAgfSlbMF07XHJcbiAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xyXG4gICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcclxuICB9XHJcblxyXG4gIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcclxuICBjb25zdCBjb252VHJhbnNwb3NlSW5wdXRzID0gW2lucHV0c1swXSwgdHJhbnNwb3NlZFdlaWdodF07XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcclxuICAgIGNvbnZUcmFuc3Bvc2VJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xyXG4gIH1cclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8oY29udlRyYW5zcG9zZUlucHV0cywgYXR0cmlidXRlcywgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24pLCB7XHJcbiAgICBpbnB1dHM6IGNvbnZUcmFuc3Bvc2VJbnB1dHMsXHJcbiAgfSk7XHJcbn07XHJcblxyXG5jb25zdCBjb252VHJhbnNwb3NlMWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgLy8gZXh0ZW5kIHRoZSBpbnB1dCB0byAyRCBieSBhZGRpbmcgSCBkaW1lbnNpb25cclxuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcclxuXHJcbiAgY29uc3QgaW5wdXRzID0gW1xyXG4gICAgY29udGV4dC5pbnB1dHNbMF0ucmVzaGFwZShcclxuICAgICAgaXNDaGFubmVsTGFzdFxyXG4gICAgICAgID8gLy8gW04sIFcsIENdIC0+IFtOLCBIPTEsIFcsIENdXHJcbiAgICAgICAgICBbY29udGV4dC5pbnB1dHNbMF0uZGltc1swXSwgMSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1sxXSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1syXV1cclxuICAgICAgICA6IC8vIFtOLCBDLCBXXSAtPiBbTiwgQywgSD0xLCBXXVxyXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dLFxyXG4gICAgKSxcclxuICAgIC8vW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtXXSAtPiBbRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga0g9MSwga1ddXHJcbiAgICBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXSksXHJcbiAgXTtcclxuICBpZiAoY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICBpbnB1dHMucHVzaChjb250ZXh0LmlucHV0c1syXSk7XHJcbiAgfVxyXG4gIGxldCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGU7XHJcbiAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBrZXJuZWxTaGFwZVswXSA9PT0gMCkge1xyXG4gICAga2VybmVsU2hhcGUgPSBbY29udGV4dC5pbnB1dHNbMV0uZGltc1syXV07XHJcbiAgfVxyXG4gIGxldCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucztcclxuICBpZiAoZGlsYXRpb25zLmxlbmd0aCA9PT0gMCB8fCBkaWxhdGlvbnNbMF0gPT09IDApIHtcclxuICAgIGRpbGF0aW9ucyA9IFsxXTtcclxuICB9XHJcbiAgbGV0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXM7XHJcbiAgaWYgKHN0cmlkZXMubGVuZ3RoID09PSAwIHx8IHN0cmlkZXNbMF0gPT09IDApIHtcclxuICAgIHN0cmlkZXMgPSBbMV07XHJcbiAgfVxyXG4gIGxldCBwYWRzID0gYXR0cmlidXRlcy5wYWRzO1xyXG4gIGlmIChwYWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcGFkcyA9IFswLCAwXTtcclxuICB9XHJcbiAgcGFkcyA9IFswLCBwYWRzWzBdLCAwLCBwYWRzWzFdXTtcclxuICBzdHJpZGVzID0gWzFdLmNvbmNhdChzdHJpZGVzKTtcclxuICBkaWxhdGlvbnMgPSBbMV0uY29uY2F0KGRpbGF0aW9ucyk7XHJcbiAga2VybmVsU2hhcGUgPSBbMV0uY29uY2F0KGtlcm5lbFNoYXBlKTtcclxuICBsZXQgb3V0cHV0UGFkZGluZyA9IGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZztcclxuICBvdXRwdXRQYWRkaW5nID0gWzBdLmNvbmNhdChvdXRwdXRQYWRkaW5nKTtcclxuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKFxyXG4gICAgeyAuLi5hdHRyaWJ1dGVzLCBwYWRzLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBvdXRwdXRQYWRkaW5nIH0sXHJcbiAgICBpbnB1dHMsXHJcbiAgKTtcclxuXHJcbiAgY29udlRyYW5zcG9zZTJkKGNvbnRleHQsIGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzLCAob3V0cHV0U2hhcGUpID0+XHJcbiAgICBpc0NoYW5uZWxMYXN0ID8gW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM11dIDogW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbM11dLFxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29udlRyYW5zcG9zZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzKSB7XHJcbiAgICBjb252VHJhbnNwb3NlMWQoY29udGV4dCwgYXR0cmlidXRlcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgY29udGV4dC5pbnB1dHMpO1xyXG4gICAgY29udlRyYW5zcG9zZTJkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldEVsZW1lbnRBdCwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ3VtU3VtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgZXhjbHVzaXZlOiBib29sZWFuO1xyXG4gIHJlYWRvbmx5IHJldmVyc2U6IGJvb2xlYW47XHJcbn1cclxuY29uc3QgY3JlYXRlQ3Vtc3VtUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRUeXBlOiBudW1iZXIsXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgYXhpc0lucHV0OiBUZW5zb3JWaWV3LFxyXG4gIGF0dHJpYnV0ZXM6IEN1bVN1bUF0dHJpYnV0ZXMsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7IC8vIG91dHB1dFNoYXBlIGlzIHNhbWUgYXMgaW5wdXRTaGFwZS5cclxuICBjb25zdCByYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7IC8vIGlucHV0L291dHB1dCByYW5rXHJcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0VHlwZSwgcmFuayk7XHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0VHlwZSwgcmFuayk7XHJcbiAgY29uc3QgYXhpc1ZhbHVlID1cclxuICAgIGF4aXNJbnB1dC5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIgPyBheGlzSW5wdXQuZ2V0SW50MzJBcnJheSgpWzBdIDogTnVtYmVyKGF4aXNJbnB1dC5nZXRCaWdJbnQ2NEFycmF5KClbMF0pO1xyXG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhheGlzVmFsdWUsIHJhbmspO1xyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaW5kZXggPSBgIGkzMigke2lucHV0LmluZGljZXNHZXQoJ2lucHV0SW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJyl9KSBgO1xyXG4gICAgY29uc3QgbWF4ID0gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICd1bmlmb3Jtcy5heGlzJywgcmFuayk7XHJcbiAgICBjb25zdCBsb3dlckxpbWl0ID0gYXR0cmlidXRlcy5yZXZlcnNlID8gaW5kZXggKyAoYXR0cmlidXRlcy5leGNsdXNpdmUgPyAnICsgMScgOiAnJykgOiAnMCc7XHJcbiAgICBjb25zdCB1cHBlckxpbWl0ID0gYXR0cmlidXRlcy5yZXZlcnNlID8gbWF4IDogaW5kZXggKyAoYXR0cmlidXRlcy5leGNsdXNpdmUgPyAnJyA6ICcgKyAxJyk7XHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXJcclxuICAgICAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxyXG4gICAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdheGlzJywgJ3UzMicpXHJcbiAgICAgICAgICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxyXG4gICAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cclxuICAgICAgICAgICAgICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xyXG4gICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgOiBpMzIgPSAke2xvd2VyTGltaXR9O1xyXG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7dXBwZXJMaW1pdH07XHJcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgOiBpMzIgPSBmaXJzdDsgaSA8IGxhc3Q7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRJbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnLCAndTMyKGkpJyl9O1xyXG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dEluZGljZXMnKX07XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnc3VtJyl9O1xyXG4gICAgICAgICAgICAgICAgfWA7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0N1bVN1bScsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXhpcyB9LFxyXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIGlucHV0U2hhcGUpLFxyXG4gICAgICBdLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjdW1zdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEN1bVN1bUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gY29udGV4dC5pbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBpbnB1dFR5cGUgPSBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZTtcclxuICBjb25zdCBheGlzID0gY29udGV4dC5pbnB1dHNbMV07XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUN1bXN1bVByb2dyYW1JbmZvKGlucHV0VHlwZSwgaW5wdXRTaGFwZSwgYXhpcywgYXR0cmlidXRlcyksIHsgaW5wdXRzOiBbMF0gfSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ3VtU3VtQXR0cmlidXRlcyA9PiB7XHJcbiAgY29uc3QgZXhjbHVzaXZlID0gKGF0dHJpYnV0ZXMuZXhjbHVzaXZlIGFzIG51bWJlcikgPT09IDE7XHJcbiAgY29uc3QgcmV2ZXJzZSA9IChhdHRyaWJ1dGVzLnJldmVyc2UgYXMgbnVtYmVyKSA9PT0gMTtcclxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgZXhjbHVzaXZlLCByZXZlcnNlIH0pO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0QXR0cmlidXRlcyB7XHJcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQycgfCAnTkNIVyc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGVwdGhUb1NwYWNlQXR0cmlidXRlcyBleHRlbmRzIEZvcm1hdEF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgYmxvY2tzaXplOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgbW9kZTogc3RyaW5nO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XHJcbiAgfVxyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDREIGlucHV0LicpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IHBlcm1GdW5jdGlvbkJvZHkgPSAocGVybTogbnVtYmVyW10sIHJhbms6IG51bWJlciwgaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlcik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3QgcmV2ZXJzZUZ1bmMgPSBbXTtcclxuICByZXZlcnNlRnVuYy5wdXNoKGBmbiBwZXJtKGk6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7aW5wdXQudHlwZS5pbmRpY2VzfSB7XHJcbiAgICB2YXIgYTogJHtpbnB1dC50eXBlLmluZGljZXN9O2ApO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XHJcbiAgICByZXZlcnNlRnVuYy5wdXNoKGlucHV0LmluZGljZXNTZXQoJ2EnLCBwZXJtW2ldLCBgaVske2l9XWApKTtcclxuICB9XHJcbiAgcmV2ZXJzZUZ1bmMucHVzaCgncmV0dXJuIGE7fScpO1xyXG4gIHJldHVybiByZXZlcnNlRnVuYy5qb2luKCdcXG4nKTtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZURlcHRoVG9TcGFjZVByb2dyYW1JbmZvID0gKGlucHV0VGVuc29yOiBUZW5zb3JWaWV3LCBhdHRyaWJ1dGVzOiBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGxldCBuOiBudW1iZXIsIGg6IG51bWJlciwgdzogbnVtYmVyLCBjOiBudW1iZXI7XHJcbiAgbGV0IHNoYXBlOiBudW1iZXJbXTtcclxuICBsZXQgcGVybTogbnVtYmVyW107XHJcbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XHJcbiAgY29uc3QgYmxvY2tzaXplID0gYXR0cmlidXRlcy5ibG9ja3NpemU7XHJcbiAgY29uc3QgaXNEQ1Jtb2RlID0gYXR0cmlidXRlcy5tb2RlID09PSAnRENSJztcclxuICBpZiAoaXNDaGFubmVsTGFzdCkge1xyXG4gICAgW24sIGgsIHcsIGNdID0gaW5wdXRUZW5zb3IuZGltcztcclxuICAgIHNoYXBlID0gaXNEQ1Jtb2RlXHJcbiAgICAgID8gW24sIGgsIHcsIGJsb2Nrc2l6ZSwgYmxvY2tzaXplLCBjIC8gYmxvY2tzaXplICoqIDJdXHJcbiAgICAgIDogW24sIGgsIHcsIGMgLyBibG9ja3NpemUgKiogMiwgYmxvY2tzaXplLCBibG9ja3NpemVdO1xyXG4gICAgcGVybSA9IGlzRENSbW9kZSA/IFswLCAxLCAzLCAyLCA0LCA1XSA6IFswLCAxLCA0LCAyLCA1LCAzXTtcclxuICB9IGVsc2Uge1xyXG4gICAgW24sIGgsIHcsIGNdID0gW2lucHV0VGVuc29yLmRpbXNbMF0sIGlucHV0VGVuc29yLmRpbXNbMl0sIGlucHV0VGVuc29yLmRpbXNbM10sIGlucHV0VGVuc29yLmRpbXNbMV1dO1xyXG4gICAgc2hhcGUgPSBpc0RDUm1vZGVcclxuICAgICAgPyBbbiwgYmxvY2tzaXplLCBibG9ja3NpemUsIGMgLyBibG9ja3NpemUgKiogMiwgaCwgd11cclxuICAgICAgOiBbbiwgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgaCwgd107XHJcbiAgICBwZXJtID0gaXNEQ1Jtb2RlID8gWzAsIDMsIDQsIDEsIDUsIDJdIDogWzAsIDEsIDQsIDIsIDUsIDNdO1xyXG4gIH1cclxuICBjb25zdCByZXNoYXBlZElucHV0VGVuc29yID0gaW5wdXRUZW5zb3IucmVzaGFwZShzaGFwZSk7XHJcbiAgY29uc3QgcmVzaGFwZWRJbnB1dFJhbmsgPSByZXNoYXBlZElucHV0VGVuc29yLmRpbXMubGVuZ3RoO1xyXG4gIGNvbnN0IGlucHV0RGF0YVR5cGUgPSBpbnB1dFRlbnNvci5kYXRhVHlwZTtcclxuXHJcbiAgY29uc3QgcmVzaGFwZWRJbnB1dCA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dERhdGFUeXBlLCByZXNoYXBlZElucHV0UmFuayk7XHJcbiAgY29uc3QgcGVybWVkT3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0RGF0YVR5cGUsIHJlc2hhcGVkSW5wdXRSYW5rKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKHJlc2hhcGVkSW5wdXQsIHBlcm1lZE91dHB1dCl9XHJcblxyXG4gICR7cGVybUZ1bmN0aW9uQm9keShwZXJtLCByZXNoYXBlZElucHV0UmFuaywgcmVzaGFwZWRJbnB1dCwgcGVybWVkT3V0cHV0KX1cclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG5cclxuICAgIGxldCBpbmRpY2VzID0gJHtwZXJtZWRPdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcclxuXHJcbiAgICAke3Blcm1lZE91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIHJlc2hhcGVkSW5wdXQuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpKX1cclxuICB9YDtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdEZXB0aFRvU3BhY2UnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7aW5wdXRUZW5zb3IuZGltc307JHthdHRyaWJ1dGVzLmJsb2Nrc2l6ZX07JHthdHRyaWJ1dGVzLm1vZGV9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddLFxyXG4gICAgfSxcclxuICAgIGdldFJ1bkRhdGE6IChpbnB1dHMpID0+IHtcclxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpc0NoYW5uZWxMYXN0XHJcbiAgICAgICAgPyBbbiwgaCAqIGJsb2Nrc2l6ZSwgdyAqIGJsb2Nrc2l6ZSwgYyAvIGJsb2Nrc2l6ZSAqKiAyXVxyXG4gICAgICAgIDogW24sIGMgLyBibG9ja3NpemUgKiogMiwgaCAqIGJsb2Nrc2l6ZSwgdyAqIGJsb2Nrc2l6ZV07XHJcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgICAgIGNvbnN0IHNoYXBlQmVmb3JlUGVybSA9IHJlc2hhcGVkSW5wdXRUZW5zb3IuZGltcztcclxuICAgICAgY29uc3Qgc2hhcGVBZnRlclBlcm0gPSBTaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKHNoYXBlQmVmb3JlUGVybSwgcGVybSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHNoYXBlQmVmb3JlUGVybSwgc2hhcGVBZnRlclBlcm0pLFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVwdGhUb1NwYWNlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVEZXB0aFRvU3BhY2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcykpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xyXG4gICAgYmxvY2tzaXplOiBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZSBhcyBudW1iZXIsXHJcbiAgICBtb2RlOiBhdHRyaWJ1dGVzLm1vZGUgYXMgc3RyaW5nLFxyXG4gICAgZm9ybWF0OiBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVycsXHJcbiAgfSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRWluc3VtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgZXF1YXRpb246IHN0cmluZztcclxufVxyXG4vLyBUaGUgZXF1YXRpb24gYXR0cmlidXRlIHZhbHVlIGlzIGEgc3RyaW5nIHdoaWNoIGNvbnNpc3RzIG9mIGxlZnQgaGFuZCBzaWRlIChMSFMpIGFuZCBvcHRpb25hbGx5IHJpZ2h0IGhhbmQgc2lkZSAoUkhTKVxyXG4vLyBzZXBhcmF0ZWQgYnkgJy0+Jy4gRXguIFwiaWosamsgLT4gaWtcIiBleHByZXNzZXMgbWF0cml4IG11bHRpcGxpY2F0aW9uXHJcbi8vICAgICBcImlqLT5qaVwiIGV4cHJlc3NlcyBtYXRyaXggdHJhbnNwb3NlXHJcbi8vICAgICAgXCJpaS0+aVwiIGRpYWdvbmFsIGVsZW1lbnRzIG9mIGEgc3F1YXJlIG1hdHJpeFxyXG4vLyBMSFMgY29uc2lzdHMgb2YgYSBzZXF1ZW5jZSBvZiB0ZXJtcyBzZXBhcmF0ZWQgYnkgY29tbWFzLiBFYWNoIHRlcm0gY29ycmVzcG9uZHMgdG8gYW4gaW5wdXQgdmFyaWFibGUuXHJcbi8vIEVhY2ggc3ltYm9sIGNvcnJlc3BvbmRzIHRvIGEgZGltZW5zaW9uIGluIHRoZSBpbnB1dCB2YXJpYWJsZS4gVGhlIHN5bWJvbCBjYW4gYmUgZWl0aGVyIGEgbGV0dGVyLCAnYScgdG8gJ3onIG9yICdBJyB0b1xyXG4vLyAnWicgb3IgJy4uLicgdG8gcmVwcmVzZW50IGFyYml0cmFyeSBkaW1lbnNpb25zLlxyXG5cclxuY29uc3Qgc3ltYm9sUGF0dGVybiA9ICdbYS16QS1aXXxcXFxcLlxcXFwuXFxcXC4nOyAvLyBUaGUgcGF0dGVybiBlYWNoIHN5bWJvbCBpbiBlYWNoIHRlcm0gaW4gdGhlIHN5bWJvbGljIGVxdWF0aW9uIHNob3VsZCBtYXRjaFxyXG5jb25zdCB0ZXJtUGF0dGVybiA9ICcoJyArIHN5bWJvbFBhdHRlcm4gKyAnKSsnOyAvLyBUaGUgcGF0dGVybiBlYWNoIHRlcm0gaW4gdGhlIHN5bWJvbGljIGVxdWF0aW9uIHNob3VsZCBtYXRjaFxyXG5jb25zdCB0ZXJtUGF0dGVybk9ubHkgPSAnXicgKyB0ZXJtUGF0dGVybiArICckJzsgLy8gVGhlIHBhdHRlcm5zIG9ubHkgbWF0Y2hlcyBhIHRlcm0gYmVnaW4gdG8gZW5kLlxyXG5jb25zdCBsaHNQYXR0ZXJuID0gJygnICsgdGVybVBhdHRlcm4gKyAnLCkqJyArIHRlcm1QYXR0ZXJuOyAvLyBUaGUgcGF0dGVybiB0aGUgTEhTIHNob3VsZCBtYXRjaFxyXG5jb25zdCBsaHNQYXR0ZXJuT25seSA9ICdeJyArIGxoc1BhdHRlcm4gKyAnJCc7IC8vIFRoZSBwYXR0ZXJucyBvbmx5IG1hdGNoZXMgYSBMSFMgYmVnaW4gdG8gZW5kLlxyXG5cclxuaW50ZXJmYWNlIFN5bWJvbEluZm8ge1xyXG4gIGNvdW50OiBudW1iZXI7IC8vIFN5bWJvbCBjb3JyZXNwb25kaW5nIHRvIGEgZGltZW5zaW9uIG9mIGFuIGlucHV0XHJcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXTsgLy8gTnVtYmVyIG9mIGlucHV0IHZhcmlhYmxlcyB0aGUgc3ltYm9sIGNvcnJlc3BvbmRzIHRvXHJcbiAgZGltVmFsdWU6IG51bWJlcjsgLy8gTnVtYmVyIG9mIGRpbWVuc2lvbnMgdGhlIHN5bWJvbCBjb3JyZXNwb25kcyB0b1xyXG59XHJcblxyXG5jbGFzcyBFaW5zdW1UZXJtIHtcclxuICBjb25zdHJ1Y3RvcihpbnB1dEluZGV4ID0gLTEpIHtcclxuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcltdPigpO1xyXG4gICAgdGhpcy5pbnB1dEluZGV4ID0gaW5wdXRJbmRleDtcclxuICB9XHJcblxyXG4gIC8vIEFkZCBhIHN5bWJvbCB0byB0aGUgdGVybVxyXG4gIGFkZFN5bWJvbChzeW1ib2w6IHN0cmluZywgaW5kZXg6IG51bWJlcikge1xyXG4gICAgbGV0IHZhbHVlID0gdGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YWx1ZSA9IFtpbmRleF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWx1ZS5wdXNoKGluZGV4KTtcclxuICAgIH1cclxuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldChzeW1ib2wsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIHN5bWJvbFRvSW5kaWNlczogTWFwPHN0cmluZywgbnVtYmVyW10+OyAvLyBNYXAgZnJvbSBzeW1ib2wgdG8gZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgY29ycmVzcG9uZGluZyB0byB0aGUgdGVybVxyXG4gIGlucHV0SW5kZXg6IG51bWJlcjsgLy8gLTEgZm9yIG91dHB1dCBhbmQgMCwgMSwgMiwgLi4uIGZvciBpbnB1dHNcclxufVxyXG5cclxuY2xhc3MgRWluc3VtRXF1YXRpb24ge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgZXF1YXRpb246IHN0cmluZyxcclxuICApIHtcclxuICAgIHRoaXMuaGFzRWxsaXBzaXMgPSBmYWxzZTtcclxuICAgIHRoaXMuc3ltYm9sVG9JbmZvID0gbmV3IE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+KCk7XHJcbiAgICB0aGlzLmxocyA9IG5ldyBBcnJheTxFaW5zdW1UZXJtPigpO1xyXG4gICAgdGhpcy5vdXRwdXREaW1zID0gW107XHJcbiAgICAvLyBBcyByaHMgbmVlZHMgdG8gYmUgdXBkYXRlZCBhbGxvdyB1c2luZyBsZXQgaW5zdGVhZCBvZiBjb25zdCBmb3IgYm90aCBsaHMgYW5kIHJocy5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcclxuICAgIGxldCBbbGhzLCByaHNdID0gZXF1YXRpb24uaW5jbHVkZXMoJy0+JykgPyBlcXVhdGlvbi5zcGxpdCgnLT4nLCAyKSA6IFtlcXVhdGlvbiwgJyddO1xyXG4gICAgaWYgKCFsaHMubWF0Y2goUmVnRXhwKGxoc1BhdHRlcm5Pbmx5KSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExIUyB0ZXJtJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnB1dFRlcm1zID0gbGhzLnNwbGl0KCcsJyk7XHJcbiAgICBpbnB1dFRlcm1zLmZvckVhY2goKGlucHV0VGVybSwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgZGltcyA9IGlucHV0c1tpbmRleF0uZGltcy5zbGljZSgpO1xyXG4gICAgICBpZiAoIWlucHV0VGVybS5tYXRjaChSZWdFeHAodGVybVBhdHRlcm5Pbmx5KSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTEhTIHRlcm0nKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlaW5zdW1UZXJtID0gdGhpcy5wcm9jZXNzVGVybShpbnB1dFRlcm0sIHRydWUsIGRpbXMsIGluZGV4KTtcclxuICAgICAgdGhpcy5saHMucHVzaChlaW5zdW1UZXJtKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgdGhlIFJIUyBpZiBub3Qgc3BlY2lmaWVkXHJcbiAgICBpZiAocmhzID09PSAnJykge1xyXG4gICAgICAvLyBDb25zdHJ1Y3QgUkhTIGZyb20gTEhTIHRlcm1zL3N5bWJvbHNcclxuICAgICAgcmhzICs9IFsuLi50aGlzLnN5bWJvbFRvSW5mby5lbnRyaWVzKCldXHJcbiAgICAgICAgLmZpbHRlcigoW3N5bSwgaW5mb10pID0+IGluZm8uY291bnQgPT09IDEgfHwgc3ltID09PSAnLi4uJylcclxuICAgICAgICAubWFwKChbc3ltXSkgPT4gc3ltKVxyXG4gICAgICAgIC5qb2luKCcnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICghcmhzLm1hdGNoKFJlZ0V4cCh0ZXJtUGF0dGVybikpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJIUycpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBvdXRwdXQgZGltc1xyXG4gICAgY29uc3QgcmhzU3ltYm9scyA9IHJocy5tYXRjaChSZWdFeHAoc3ltYm9sUGF0dGVybiwgJ2cnKSk7XHJcbiAgICByaHNTeW1ib2xzPy5mb3JFYWNoKChzeW1ib2wpID0+IHtcclxuICAgICAgaWYgKHN5bWJvbCA9PT0gJy4uLicpIHtcclxuICAgICAgICB0aGlzLm91dHB1dERpbXMgPSB0aGlzLm91dHB1dERpbXMuY29uY2F0KHRoaXMuZWxsaXBzaXNEaW1zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XHJcbiAgICAgICAgaWYgKGluZm8gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJIUyBzeW1ib2wnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vdXRwdXREaW1zLnB1c2goaW5mby5kaW1WYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5yaHMgPSB0aGlzLnByb2Nlc3NUZXJtKHJocywgZmFsc2UsIHRoaXMub3V0cHV0RGltcyk7XHJcbiAgfSAvLyBFbmQgb2YgRWluc3VtRXFhdGlvbiBjb25zdHJ1Y3RvclxyXG5cclxuICAvLyBBZGQgYSBzeW1ib2wgdG8gdGhlIGVxdWF0aW9uXHJcbiAgYWRkU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBkaW1WYWx1ZTogbnVtYmVyLCBpbnB1dEluZGV4OiBudW1iZXIpIHtcclxuICAgIGxldCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XHJcbiAgICBpZiAoaW5mbyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChpbmZvLmRpbVZhbHVlICE9PSBkaW1WYWx1ZSAmJiBpbmZvLmNvdW50ICE9PSAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2gnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbmZvLmNvdW50Kys7XHJcbiAgICAgICAgaW5mby5pbnB1dEluZGljZXMucHVzaChpbnB1dEluZGV4KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5mbyA9IHsgY291bnQ6IDEsIGRpbVZhbHVlLCBpbnB1dEluZGljZXM6IFtpbnB1dEluZGV4XSB9O1xyXG4gICAgfVxyXG4gICAgdGhpcy5zeW1ib2xUb0luZm8uc2V0KHN5bWJvbCwgaW5mbyk7XHJcbiAgfVxyXG5cclxuICAvLyBQcm9jZXNzIG9uZSBpbnB1dC9vdXRwdXQgdGVybVxyXG4gIHByb2Nlc3NUZXJtKHRlcm06IHN0cmluZywgaXNJbnB1dDogYm9vbGVhbiwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGluZGV4ID0gLTEpOiBFaW5zdW1UZXJtIHtcclxuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcclxuICAgIGxldCBlbGxpcHNpcyA9IGZhbHNlO1xyXG4gICAgbGV0IGVsbGlwc2lzRGltcyA9IFtdO1xyXG4gICAgbGV0IG5leHREaW0gPSAwO1xyXG4gICAgLy8gRm9yIG91dHB1dCBlbXB0eSBzdHJpbmcgaXMgYWxsb3dlZCBiZWNhdXNlIHRoZSBvdXRwdXQgbWF5IGJlIHJlZHVjZWQgdG8gYSBzY2FsYXIgdmFsdWVcclxuICAgIGlmICghdGVybS5tYXRjaChSZWdFeHAodGVybVBhdHRlcm5Pbmx5KSkgJiYgIWlzSW5wdXQgJiYgdGVybSAhPT0gJycpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExIUyB0ZXJtJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleFN5bWJvbHMgPSB0ZXJtLm1hdGNoKFJlZ0V4cChzeW1ib2xQYXR0ZXJuLCAnZycpKTtcclxuICAgIGNvbnN0IGVpbnN1bVRlcm0gPSBuZXcgRWluc3VtVGVybShpbmRleCk7XHJcbiAgICAvLyBzeW1ib2wgY2FuIGJlIGVpdGhlciBhIGxldHRyZSwgJ2EnIHRvICd6JyBvciAnQScgdG8gJ1onLCBvciAnLi4uJ1xyXG4gICAgaW5kZXhTeW1ib2xzPy5mb3JFYWNoKChzeW1ib2w6IHN0cmluZywgaTogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGlmIChzeW1ib2wgPT09ICcuLi4nKSB7XHJcbiAgICAgICAgaWYgKGVsbGlwc2lzKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxsaXBzaXMgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGVsbGlwc2lzRGltTGVuZ3RoID0gcmFuayAtIGluZGV4U3ltYm9scy5sZW5ndGggKyAxO1xyXG4gICAgICAgIGlmIChlbGxpcHNpc0RpbUxlbmd0aCA8IDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxsaXBzaXMgb3V0IG9mIGJvdW5kcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbGxpcHNpc0RpbXMgPSBkaW1zLnNsaWNlKG5leHREaW0sIG5leHREaW0gKyBlbGxpcHNpc0RpbUxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzRWxsaXBzaXMpIHtcclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoICE9PSBlbGxpcHNpc0RpbXMubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIHRoaXMuZWxsaXBzaXNEaW1zLnRvU3RyaW5nKCkgIT09IGVsbGlwc2lzRGltcy50b1N0cmluZygpXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0lucHV0KSB7XHJcbiAgICAgICAgICB0aGlzLmhhc0VsbGlwc2lzID0gdHJ1ZTtcclxuICAgICAgICAgIHRoaXMuZWxsaXBzaXNEaW1zID0gZWxsaXBzaXNEaW1zO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsbGlwc2lzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSBMSFMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkICcwJywgJzEnLCAnMicsICczJywgJzQnLCBldGMgdG8gcmVwcmVzZW50IGVsbGlwc2lzIGRpbWVuc2lvbnMgdG8gYXZvaWQgc3BlY2lhbCBoYW5kbGluZ1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZWxsaXBzaXNEaW1zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICBjb25zdCBzeW1ib2wgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCcwJy5jaGFyQ29kZUF0KDApICsgaik7XHJcbiAgICAgICAgICBlaW5zdW1UZXJtLmFkZFN5bWJvbChzeW1ib2wsIGkgKyBqKTtcclxuICAgICAgICAgIHRoaXMuYWRkU3ltYm9sKHN5bWJvbCwgZGltc1tuZXh0RGltKytdLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVpbnN1bVRlcm0uYWRkU3ltYm9sKHN5bWJvbCwgaSArICh0aGlzLmhhc0VsbGlwc2lzID8gdGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoIC0gMSA6IDApKTtcclxuICAgICAgICB0aGlzLmFkZFN5bWJvbChzeW1ib2wsIGRpbXNbbmV4dERpbSsrXSwgaW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBlaW5zdW1UZXJtO1xyXG4gIH1cclxuXHJcbiAgc3ltYm9sVG9JbmZvOiBNYXA8c3RyaW5nLCBTeW1ib2xJbmZvPjsgLy8gQWxsIHN5bWJvbHMgaW4gdGhlIGVxdWF0aW9uXHJcbiAgaGFzRWxsaXBzaXM6IGJvb2xlYW47IC8vIFRoZSBlcXVhdGlvbiBoYXMgZWxsaXBzaXMgb3Igbm90XHJcbiAgZWxsaXBzaXNEaW1zOiBudW1iZXJbXTsgLy8gVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGVxdWF0aW9uIGVsbGlwc2lzIGNvcnJlc3BvbmRzIHRvLlxyXG4gIGxoczogRWluc3VtVGVybVtdOyAvLyBUZXJtcyBvbiB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIGVxdWF0aW9uXHJcbiAgcmhzOiBFaW5zdW1UZXJtOyAvLyBUZXJtIG9uIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgdGhlIGVxdWF0aW9uXHJcbiAgb3V0cHV0RGltczogbnVtYmVyW107IC8vIE91dHB1dCBkaW1lbnNpb25zIG9mIHRoZSBlcXVhdGlvblxyXG59IC8vIEVuZCBvZiBjbGFzcyBFaW5zdW1FcXVhdGlvblxyXG5cclxuY29uc3QgYXBwZW5kTWF4ID0gKG5hbWU6IHN0cmluZyk6IHN0cmluZyA9PiBuYW1lICsgJ19tYXgnO1xyXG5cclxuY29uc3QgY3JlYXRlRWluc3VtUHJvZ3JhbUluZm8gPSAoXHJcbiAgaW5wdXRTaGFwZXM6IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPixcclxuICBkYXRhVHlwZTogbnVtYmVyLFxyXG4gIGVpbnN1bUVxdWF0aW9uOiBFaW5zdW1FcXVhdGlvbixcclxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCByYW5rcyA9IGlucHV0U2hhcGVzLm1hcCgoZGltcykgPT4gZGltcy5sZW5ndGgpO1xyXG4gIGNvbnN0IGlucHV0VmFycyA9IHJhbmtzLm1hcCgocmFuaywgaW5kZXgpID0+IGlucHV0VmFyaWFibGUoYGlucHV0JHtpbmRleH1gLCBkYXRhVHlwZSwgcmFuaykpO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG4gIGNvbnN0IHVuaWZvcm1zU3ltYm9scyA9IFsuLi5laW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8ua2V5cygpXS5maWx0ZXIoXHJcbiAgICAoc3ltYm9sKSA9PiAhZWluc3VtRXF1YXRpb24ucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoc3ltYm9sKSxcclxuICApO1xyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaWR4Q29weTogc3RyaW5nW10gPSBbXTtcclxuICAgIGNvbnN0IGluaXRQcm9kID0gJ3ZhciBwcm9kID0gMS4wOyc7XHJcbiAgICBjb25zdCBpbml0U3VtID0gJ3ZhciBzdW0gPSAwLjA7JztcclxuICAgIGNvbnN0IHVwZGF0ZVN1bSA9ICdzdW0gKz0gcHJvZDsnO1xyXG4gICAgY29uc3QgcmVkdWNlT3BzU2V0SW5kaWNlczogc3RyaW5nW10gPSBbXTtcclxuICAgIGNvbnN0IHJlZHVjZU9wc0xvb3BIZWFkZXJzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgY29uc3QgcmVkdWNlT3BzTG9vcEZvb3RlcnM6IHN0cmluZ1tdID0gW107XHJcbiAgICBjb25zdCByZWR1Y2VPcENvbXB1dGU6IHN0cmluZ1tdID0gW107XHJcbiAgICBjb25zdCBpc1JlZHVjZU9wc1dpdGhvdXRMb29wID0gZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLnNpemUgPT09IGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuc2l6ZTtcclxuICAgIGVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5mb3JFYWNoKChpbmZvLCBzeW1ib2wpID0+IHtcclxuICAgICAgaWYgKGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKHN5bWJvbCkpIHtcclxuICAgICAgICBjb25zdCBvdXRwdXRJbmRleCA9IGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk/LlswXTtcclxuICAgICAgICBpZiAob3V0cHV0SW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgZWluc3VtRXF1YXRpb24ubGhzLmZvckVhY2goKHRlcm0sIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGluZm8uaW5wdXRJbmRpY2VzLmluY2x1ZGVzKGkpKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRlcm0uc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzeW1ib2wgZXJyb3InKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWR4Q29weS5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICBgJHtpbnB1dFZhcnNbaV0uaW5kaWNlc1NldChcclxuICAgICAgICAgICAgICAgICAgICBgaW5wdXQke2l9SW5kaWNlc2AsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXRJbmRleCksXHJcbiAgICAgICAgICAgICAgICAgICl9YCxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlaW5zdW1FcXVhdGlvbi5saHMuZm9yRWFjaCgodGVybSwgaSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGluZm8uaW5wdXRJbmRpY2VzLmluY2x1ZGVzKGkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0ZXJtLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcclxuICAgICAgICAgICAgaWYgKGluZGljZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzeW1ib2wgZXJyb3InKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmRpY2VzLmZvckVhY2goKGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgcmVkdWNlT3BzU2V0SW5kaWNlcy5wdXNoKGAke2lucHV0VmFyc1tpXS5pbmRpY2VzU2V0KGBpbnB1dCR7aX1JbmRpY2VzYCwgaW5kZXgsIGAke3N5bWJvbH1gKX1gKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlZHVjZU9wQ29tcHV0ZS5wdXNoKGBwcm9kICo9ICR7aW5wdXRWYXJzW2ldLmdldEJ5SW5kaWNlcyhgaW5wdXQke2l9SW5kaWNlc2ApfTtgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZWR1Y2VPcHNMb29wSGVhZGVycy5wdXNoKFxyXG4gICAgICAgICAgYGZvcih2YXIgJHtzeW1ib2x9OiB1MzIgPSAwOyAke3N5bWJvbH0gPCB1bmlmb3Jtcy4ke2FwcGVuZE1heChzeW1ib2wpfTsgJHtzeW1ib2x9KyspIHtgLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmVkdWNlT3BzTG9vcEZvb3RlcnMucHVzaCgnfScpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJlZHVjZU9wcyA9IGlzUmVkdWNlT3BzV2l0aG91dExvb3BcclxuICAgICAgPyBbXHJcbiAgICAgICAgICAuLi5pZHhDb3B5LFxyXG4gICAgICAgICAgYGxldCBzdW0gPSAke2lucHV0VmFycy5tYXAoKGlucHV0VmFyLCBpKSA9PiBpbnB1dFZhci5nZXRCeUluZGljZXMoYGlucHV0JHtpfUluZGljZXNgKSkuam9pbignICogJyl9O2AsXHJcbiAgICAgICAgXVxyXG4gICAgICA6IFtcclxuICAgICAgICAgIC4uLmlkeENvcHksXHJcbiAgICAgICAgICBpbml0U3VtLFxyXG4gICAgICAgICAgLi4ucmVkdWNlT3BzTG9vcEhlYWRlcnMsXHJcbiAgICAgICAgICAuLi5yZWR1Y2VPcHNTZXRJbmRpY2VzLFxyXG4gICAgICAgICAgaW5pdFByb2QsXHJcbiAgICAgICAgICAuLi5yZWR1Y2VPcENvbXB1dGUsXHJcbiAgICAgICAgICB1cGRhdGVTdW0sXHJcbiAgICAgICAgICAuLi5yZWR1Y2VPcHNMb29wRm9vdGVycyxcclxuICAgICAgICBdO1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXJcclxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3Jtc1N5bWJvbHMubWFwKChzeW1ib2wpID0+ICh7IG5hbWU6IGAke2FwcGVuZE1heChzeW1ib2wpfWAsIHR5cGU6ICd1MzInIH0pKSlcclxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXHJcbiAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCBvdXRwdXQpfVxyXG5cclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cclxuICAgICAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICAgICAgICAgICR7aW5wdXRWYXJzLm1hcCgoX3ZhciwgaSkgPT4gYHZhciBpbnB1dCR7aX1JbmRpY2VzOiAke2lucHV0VmFyc1tpXS50eXBlLmluZGljZXN9O2ApLmpvaW4oJ1xcbicpfVxyXG4gICAgICAgICAgICAke3JlZHVjZU9wcy5qb2luKCdcXG4nKX07XHJcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3N1bScpfTtcclxuICAgICAgICAgIH1gO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdFaW5zdW0nLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogZWluc3VtRXF1YXRpb24uZXF1YXRpb24sIGlucHV0RGVwZW5kZW5jaWVzOiBpbnB1dFNoYXBlcy5tYXAoKCkgPT4gJ3JhbmsnKSB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xyXG4gICAgICAvLyBUaGUgc3ltYm9scyBmcm9tIHVuaWZvcm1TeW1ib2xzIGFycmF5IGFyZSBndWFyYW50ZWVkIHRvIGV4aXN0IGluIGVpbnN1bUVxdWF0aW9ucy5zeW1ib2xUb0luZm8gbWFwLiBUaGVcclxuICAgICAgLy8gZmlsdGVyIGlzIGFkZGVkIHRvIG1ha2Ugc3VyZSB0aGF0IGRpbVZhbHVlIGlzIG5ldmVyIDAuXHJcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3Jtc0luaXQ6IFByb2dyYW1Vbmlmb3JtW10gPSB1bmlmb3Jtc1N5bWJvbHNcclxuICAgICAgICAuZmlsdGVyKChzeW1ib2wpID0+IGVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5oYXMoc3ltYm9sKSlcclxuICAgICAgICAubWFwKChzeW1ib2wpID0+ICh7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmdldChzeW1ib2wpPy5kaW1WYWx1ZSB8fCAwIH0pKTtcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zSW5pdC5wdXNoKHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0pO1xyXG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBpbnB1dFNoYXBlc1xyXG4gICAgICAgIC5tYXAoKGRpbXMsIF8pID0+IFsuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhkaW1zKV0pXHJcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBpbnB1dFByb2dyYW1Vbmlmb3JtcykgPT4gYWNjLmNvbmNhdChpbnB1dFByb2dyYW1Vbmlmb3JtcyksIHByb2dyYW1Vbmlmb3Jtc0luaXQpO1xyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcclxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGVpbnN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogRWluc3VtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGVpbnN1bUVxdWF0aW9uID0gbmV3IEVpbnN1bUVxdWF0aW9uKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLmVxdWF0aW9uKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGVpbnN1bUVxdWF0aW9uLm91dHB1dERpbXM7XHJcbiAgY29uc3QgaW5wdXRTaGFwZXMgPSBjb250ZXh0LmlucHV0cy5tYXAoKGlucHV0LCBfKSA9PiBpbnB1dC5kaW1zKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWluc3VtUHJvZ3JhbUluZm8oaW5wdXRTaGFwZXMsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBlaW5zdW1FcXVhdGlvbiwgb3V0cHV0U2hhcGUpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBFaW5zdW1BdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBlcXVhdGlvbiA9IChhdHRyaWJ1dGVzLmVxdWF0aW9uIGFzIHN0cmluZykucmVwbGFjZSgvXFxzKy9nLCAnJyk7XHJcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGVxdWF0aW9uIH0pO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGFuZCByZXF1aXJlcyAyIGlucHV0LicpO1xyXG4gIH1cclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3Qgc2hhcGUgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCksIE51bWJlcik7XHJcblxyXG4gIGxldCBzaGFwZUluZGV4ID0gc2hhcGUubGVuZ3RoIDwgaW5wdXRTaGFwZS5sZW5ndGggPyAwIDogc2hhcGUubGVuZ3RoIC0gaW5wdXRTaGFwZS5sZW5ndGg7XHJcbiAgbGV0IGlucHV0U2hhcGVJbmRleCA9IGlucHV0U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoID8gMCA6IGlucHV0U2hhcGUubGVuZ3RoIC0gc2hhcGUubGVuZ3RoO1xyXG4gIGZvciAoOyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGVJbmRleCA8IGlucHV0U2hhcGUubGVuZ3RoOyArK3NoYXBlSW5kZXgsICsraW5wdXRTaGFwZUluZGV4KSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHNoYXBlW3NoYXBlSW5kZXhdICE9PSBpbnB1dFNoYXBlW2lucHV0U2hhcGVJbmRleF0gJiZcclxuICAgICAgc2hhcGVbc2hhcGVJbmRleF0gIT09IDEgJiZcclxuICAgICAgaW5wdXRTaGFwZVtpbnB1dFNoYXBlSW5kZXhdICE9PSAxXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dCcpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGdldEFkanVzdGVkU2hhcGUgPSAoc2hhcGUxOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGUyOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcclxuICBjb25zdCBkaWZmID0gc2hhcGUxLmxlbmd0aCAtIHNoYXBlMi5sZW5ndGg7XHJcbiAgY29uc3Qgc2hhcGU6IG51bWJlcltdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmOyArK2kpIHtcclxuICAgIHNoYXBlLnB1c2goc2hhcGUxW2ldKTtcclxuICB9XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZTIubGVuZ3RoOyArK2kpIHtcclxuICAgIHNoYXBlLnB1c2goc2hhcGUyW2ldID09PSAxID8gc2hhcGUxW2kgKyBkaWZmXSA6IHNoYXBlMltpXSk7XHJcbiAgfVxyXG4gIHJldHVybiBzaGFwZTtcclxufTtcclxuXHJcbmNvbnN0IGNhbGN1bGF0ZU91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSA9PlxyXG4gIGlucHV0U2hhcGUubGVuZ3RoID4gc2hhcGUubGVuZ3RoID8gZ2V0QWRqdXN0ZWRTaGFwZShpbnB1dFNoYXBlLCBzaGFwZSkgOiBnZXRBZGp1c3RlZFNoYXBlKHNoYXBlLCBpbnB1dFNoYXBlKTtcclxuXHJcbmNvbnN0IGNyZWF0ZUV4cGFuZFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBjYWxjdWxhdGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCBzaGFwZSk7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XHJcbiAgY29uc3QgaXNCb29sT3JTY2FsYXIgPSBkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCB8fCBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKSA9PT0gMTtcclxuICBjb25zdCBpQ29tcG9uZW50cyA9XHJcbiAgICBkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCA/IDQgOiBpbnB1dFNoYXBlLmxlbmd0aCA+IDAgJiYgaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdICUgNCA9PT0gMCA/IDQgOiAxO1xyXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpc0Jvb2xPclNjYWxhclxyXG4gICAgPyA0XHJcbiAgICA6IG91dHB1dFNoYXBlLmxlbmd0aCA+IDAgJiYgb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV0gJSA0ID09PSAwXHJcbiAgICAgID8gNFxyXG4gICAgICA6IDE7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoLCBpQ29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xyXG4gICAgaWYgKGRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sKSB7XHJcbiAgICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4gYFxyXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke3h9dWApfTtcclxuICAgICAgICAgIGxldCBvZmZzZXQke3h9ID0gJHtpbnB1dC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcclxuICAgICAgICAgIGxldCBpbmRleCR7eH0gPSBvZmZzZXQke3h9IC8gNHU7XHJcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHt4fSA9IG9mZnNldCR7eH0gJSA0dTtcclxuICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7aW5wdXQuZ2V0QnlPZmZzZXQoYGluZGV4JHt4fWApfVtjb21wb25lbnQke3h9XSk7XHJcbiAgICAgICAgYDtcclxuICAgICAgYXNzaWdubWVudCA9IGBcclxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c307XHJcbiAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XHJcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxyXG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDEsICd1MzInKX1cclxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAyLCAndTMyJyl9XHJcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxyXG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2RhdGEnKX1cclxuICAgICAgfWA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhc3NpZ25tZW50ID0gYFxyXG4gICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfWApfTtcclxuICAgICAgICBsZXQgaW5wdXRPZmZzZXQgPSAke2lucHV0LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJywgb3V0cHV0KX07XHJcbiAgICAgICAgbGV0IGRhdGEgPSAke291dHB1dC50eXBlLnZhbHVlfSgke2lucHV0LmdldEJ5T2Zmc2V0KGBpbnB1dE9mZnNldCAvICR7aUNvbXBvbmVudHN9YCl9KTtcclxuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdkYXRhJyl9XHJcbiAgICAgIH1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGBcclxuICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgndmVjX3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cclxuICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cclxuICAgICR7YXNzaWdubWVudH1gO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSksXHJcbiAgXTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0V4cGFuZCcsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtvdXRwdXRTaGFwZS5sZW5ndGh9OyR7aUNvbXBvbmVudHN9JHtjb21wb25lbnRzfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBleHBhbmQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUV4cGFuZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSwgeyBpbnB1dHM6IFswXSB9KTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxuICBXT1JLR1JPVVBfU0laRSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcbmltcG9ydCAqIGFzIHVuYXJ5IGZyb20gJy4vdW5hcnktb3AnO1xyXG5cclxuLy8gR0VMVSBpcyBkZWZpbmVkIGFzIFk9MC41KlgqKDErdGFuaCgwLjc5Nzg4NSpYKzAuMDM1Njc3KlgqWCpYKSksIHdoZXJlIFggbWF5IHByZS1hZGQgYSBiaWFzLlxyXG5cclxuY29uc3QgY3JlYXRlRmFzdEdlbHVQcm9ncmFtSW5mbyA9IChpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0VGVuc29yc1swXS5kYXRhVHlwZTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzBdLmRpbXMpO1xyXG4gIGNvbnN0IGJpYXNMZW5ndGggPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFRlbnNvcnNbMV0uZGltcyk7XHJcbiAgLy8gY2FuIG9ubHkgdXNlIHZlYzQgd2hlbiBiaWFzIGxlbmd0aCBpcyBtdWx0aXBsZSBvZiA0XHJcbiAgY29uc3QgdXNlVmVjNCA9IGJpYXNMZW5ndGggJSA0ID09PSAwO1xyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcik6IHN0cmluZyA9PiB7XHJcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGRhdGFUeXBlLCBbMV0sIDQpO1xyXG4gICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBkYXRhVHlwZSwgWzFdLCA0KTtcclxuICAgIGNvbnN0IHkgPSBvdXRwdXRWYXJpYWJsZSgneScsIGRhdGFUeXBlLCBbMV0sIDQpO1xyXG5cclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3ZlY19zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYmlhc19zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgIF07XHJcblxyXG4gICAgY29uc3Qgc2luZ2xlRWxlbWVudEJpYXMgPSAoaTogMCB8IDEgfCAyIHwgMykgPT4gYFxyXG4gICAgICBsZXQgYmlhcyR7aX1fb2Zmc2V0OiB1MzIgPSAoZ2xvYmFsX2lkeCAqIDQgKyAke2l9KSAlIHVuaWZvcm1zLmJpYXNfc2l6ZTtcclxuICAgICAgbGV0IGJpYXMke2l9ID0gJHtiaWFzLmdldEJ5T2Zmc2V0KGBiaWFzJHtpfV9vZmZzZXQgLyA0YCl9W2JpYXMke2l9X29mZnNldCAlIDRdO2A7XHJcbiAgICBjb25zdCBiaWFzR2V0RXhwcmVzc2lvbiA9IHVzZVZlYzRcclxuICAgICAgPyBgXHJcbiAgICAgIGxldCBiaWFzID0gJHtiaWFzLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLmJpYXNfc2l6ZSAvIDQpJyl9O2BcclxuICAgICAgOiBgJHtzaW5nbGVFbGVtZW50QmlhcygwKX0ke3NpbmdsZUVsZW1lbnRCaWFzKDEpfSR7c2luZ2xlRWxlbWVudEJpYXMoMil9JHtzaW5nbGVFbGVtZW50QmlhcygzKX1cclxuICAgICAgbGV0IGJpYXMgPSAke3gudHlwZS52YWx1ZX0oYmlhczAsIGJpYXMxLCBiaWFzMiwgYmlhczMpO2A7XHJcblxyXG4gICAgcmV0dXJuIGAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHgsIGJpYXMsIHkpfVxyXG5cclxuICAgICR7dW5hcnkuZmFzdEdlbHVJbXBsKHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoZGF0YVR5cGUpKX1cclxuXHJcbiAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoV09SS0dST1VQX1NJWkUpfVxyXG4gICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfdmVjX3NpemUnKX1cclxuXHJcbiAgICAgIGxldCB4ID0gJHt4LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgICAke2JpYXNHZXRFeHByZXNzaW9ufVxyXG4gICAgICBsZXQgeF9pbiA9IHggKyBiaWFzO1xyXG4gICAgICAke3kuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCB1bmFyeS5mYXN0R2VsdUV4cHJlc3Npb24oJ3hfaW4nKSl9XHJcbiAgICB9YDtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0Zhc3RHZWx1V2l0aEJpYXMnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7dXNlVmVjNH1gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXSB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgZ2V0UnVuRGF0YTogKGlucHV0cykgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXRzWzBdLmRpbXMsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDQpIH0sXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJpYXNMZW5ndGggfSxcclxuICAgICAgXSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIFdPUktHUk9VUF9TSVpFIC8gNCkgfSxcclxuICAgIH0pLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZmFzdEdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICBpZiAoY29udGV4dC5pbnB1dHMubGVuZ3RoIDwgMiB8fCBTaGFwZVV0aWwuc2l6ZShjb250ZXh0LmlucHV0c1sxXS5kaW1zKSA9PT0gMCkge1xyXG4gICAgdW5hcnkuZmFzdEdlbHUoY29udGV4dCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVGYXN0R2VsdVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdhdGhlckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIGF4aXM6IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlciByZXF1aXJlcyAyIGlucHV0cy4nKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVHYXRoZXJQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR2F0aGVyQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XHJcblxyXG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xyXG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0UmFuayk7XHJcblxyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcclxuICBvdXRwdXRTaGFwZS5zcGxpY2UoYXhpcywgMSwgLi4uaW5kaWNlc1NoYXBlKTtcclxuXHJcbiAgY29uc3QgYXhpc0RpbUxpbWl0ID0gaW5wdXRTaGFwZVtheGlzXTtcclxuICBjb25zdCBjb21wb25lbnRzID0gaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sID8gNCA6IDE7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzKTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF4aXNEaW1MaW1pdCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXMgfSxcclxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgb3V0cHV0U2hhcGUpLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgZGF0YSA9IGlucHV0VmFyaWFibGUoJ2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5wdXRJbmRpY2VzJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgpO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuXHJcbiAgICBjb25zdCBjYWxjRGF0YUluZGljZXMgPSAoeDogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICAgICAgY29uc3QgaW5kaWNlc1JhbmsgPSBpbmRpY2VzU2hhcGUubGVuZ3RoO1xyXG4gICAgICBsZXQgY2FsY1N0ciA9IGB2YXIgaW5kaWNlc0luZGljZXMke3h9ICA9ICR7aW5kaWNlcy50eXBlLmluZGljZXN9KDApO2A7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlc1Jhbms7IGkrKykge1xyXG4gICAgICAgIGNhbGNTdHIgKz0gYCR7aW5kaWNlc1JhbmsgPiAxID8gYGluZGljZXNJbmRpY2VzJHt4fVske2l9XWAgOiBgaW5kaWNlc0luZGljZXMke3h9YH0gPSAke1xyXG4gICAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoID4gMSA/IGBvdXRwdXRJbmRpY2VzJHt4fVt1bmlmb3Jtcy5heGlzICsgJHtpfV1gIDogYG91dHB1dEluZGljZXMke3h9YFxyXG4gICAgICAgIH07YDtcclxuICAgICAgfVxyXG4gICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgIHZhciBpZHgke3h9ID0gJHtpbmRpY2VzLmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke3h9YCl9O1xyXG4gICAgICAgICAgaWYgKGlkeCR7eH0gPCAwKSB7XHJcbiAgICAgICAgICAgIGlkeCR7eH0gPSBpZHgke3h9ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGRhdGFJbmRpY2VzJHt4fSA6ICR7ZGF0YS50eXBlLmluZGljZXN9O1xyXG4gICAgICAgIGA7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGlucHV0UmFuazsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgPT09IGF4aXMpIHtcclxuICAgICAgICAgIGNhbGNTdHIgKz0gYCR7aW5wdXRSYW5rID4gMSA/IGBkYXRhSW5kaWNlcyR7eH1bJHtpfV1gIDogYGRhdGFJbmRpY2VzJHt4fWB9ID0gdTMyKGlkeCR7eH0pO2A7XHJcbiAgICAgICAgICBqICs9IGluZGljZXNSYW5rO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjYWxjU3RyICs9IGAke2lucHV0UmFuayA+IDEgPyBgZGF0YUluZGljZXMke3h9WyR7aX1dYCA6IGBkYXRhSW5kaWNlcyR7eH1gfSA9ICR7XHJcbiAgICAgICAgICAgIG91dHB1dFNoYXBlLmxlbmd0aCA+IDEgPyBgb3V0cHV0SW5kaWNlcyR7eH1bJHtqfV1gIDogYG91dHB1dEluZGljZXMke3h9YFxyXG4gICAgICAgICAgfTtgO1xyXG4gICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2FsY1N0cjtcclxuICAgIH07XHJcbiAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xyXG4gICAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCkge1xyXG4gICAgICBjb25zdCBzaW5nbGVBc3NpZ25tZW50ID0gKHJlc1N0cjogc3RyaW5nLCB4OiBudW1iZXIsIHR5cGVDYXN0ID0gJycpID0+IGBcclxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt4fSA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHt4fXVgKX07XHJcbiAgICAgICAgICAke2NhbGNEYXRhSW5kaWNlcyh4KX07XHJcbiAgICAgICAgICBsZXQgb2Zmc2V0JHt4fSA9ICR7ZGF0YS5pbmRpY2VzVG9PZmZzZXQoYGRhdGFJbmRpY2VzJHt4fWApfTtcclxuICAgICAgICAgIGxldCBpbmRleCR7eH0gPSBvZmZzZXQke3h9IC8gNHU7XHJcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHt4fSA9IG9mZnNldCR7eH0gJSA0dTtcclxuICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7ZGF0YS5nZXRCeU9mZnNldChgaW5kZXgke3h9YCl9W2NvbXBvbmVudCR7eH1dKTtcclxuICAgICAgICBgO1xyXG4gICAgICBhc3NpZ25tZW50ID0gYFxyXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfTtcclxuICAgICAgICB2YXIgdmFsdWUgPSB2ZWM0PHUzMj4oMCk7XHJcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDAsICd1MzInKX1cclxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMSwgJ3UzMicpfVxyXG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAyLCAndTMyJyl9XHJcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDMsICd1MzInKX1cclxuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxyXG4gICAgICBgO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXNzaWdubWVudCA9IGBcclxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICAgICR7Y2FsY0RhdGFJbmRpY2VzKCcnKX07XHJcbiAgICAgIGxldCB2YWx1ZSA9ICR7ZGF0YS5nZXRCeUluZGljZXMoJ2RhdGFJbmRpY2VzJyl9O1xyXG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcclxuICAgICAgYDtcclxuICAgIH1cclxuICAgIHJldHVybiBgXHJcbiAgICAgICR7c2hhZGVySGVscGVyXHJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXNEaW1MaW1pdCcsICdpMzInKVxyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcclxuICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhkYXRhLCBpbmRpY2VzLCBvdXRwdXQpfVxyXG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XHJcbiAgICAgICAgJHthc3NpZ25tZW50fVxyXG4gICAgICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnR2F0aGVyJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuayddIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdhdGhlckF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdhdGhlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xyXG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgVW5pZm9ybXNBcnJheVR5cGUgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEdhdGhlck5EQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgYmF0Y2hEaW1zOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IGNvbXB1dGVTbGljZU9mZnNldHMgPSAoXHJcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXHJcbiAgaW5kaWNlc0RhdGE6IFRlbnNvclZpZXcsXHJcbiAgc2l6ZXNGcm9tU2xpY2VEaW1zRGF0YTogbnVtYmVyW10sXHJcbiAgYmF0Y2hEaW1zOiBudW1iZXIsXHJcbiAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcclxuICBudW1TbGljZXM6IG51bWJlcixcclxuICBudW1TbGljZXNQZXJCYXRjaDogbnVtYmVyLFxyXG4gIGlucHV0QmF0Y2hTdHJpZGU6IG51bWJlcixcclxuICBudW1TbGljZURpbXM6IG51bWJlcixcclxuKSA9PiB7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG51bVNsaWNlcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJhdGNoRGltcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0RGltcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNpemVzRnJvbVNsaWNlRGltc0RhdGEgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBudW1TbGljZXNQZXJCYXRjaCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0QmF0Y2hTdHJpZGUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBudW1TbGljZURpbXMgfSxcclxuICBdO1xyXG5cclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtudW1TbGljZXNdO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGluZGljZXNEYXRhLmRpbXMsIG91dHB1dFNoYXBlKSk7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2luZGljZXNfZGF0YScsIGluZGljZXNEYXRhLmRhdGFUeXBlLCBpbmRpY2VzRGF0YS5kaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhJywgRGF0YVR5cGUudWludDMyLCAxLCAxKTtcclxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtpbmRpY2VzLCBvdXRwdXRdO1xyXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2JhdGNoX2RpbXMnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdpbnB1dF9kaW1zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogaW5wdXREaW1zLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdzaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YScsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHNpemVzRnJvbVNsaWNlRGltc0RhdGEubGVuZ3RoIH0sXHJcbiAgICAgIHsgbmFtZTogJ251bV9zbGljZXNfcGVyX2JhdGNoJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnaW5wdXRfYmF0Y2hfc3RyaWRlJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnbnVtX3NsaWNlX2RpbXMnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgXTtcclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgIGxldCBiYXRjaF9pZHggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMubnVtX3NsaWNlc19wZXJfYmF0Y2g7XHJcbiAgICBsZXQgYmFzZV9vZmZzZXQgPSBiYXRjaF9pZHggKiB1bmlmb3Jtcy5pbnB1dF9iYXRjaF9zdHJpZGU7XHJcblxyXG4gICAgbGV0IHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7XHJcbiAgICB2YXIgcmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ID0gMDtcclxuICAgIGZvciAodmFyIGRpbV9pZHggPSAwdTsgZGltX2lkeCA8IHVuaWZvcm1zLm51bV9zbGljZV9kaW1zOyBkaW1faWR4ICsrKSB7XHJcbiAgICAgIHZhciBpbmRleCA9IGkzMihpbmRpY2VzX2RhdGFbZGltX2lkeCArIHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXRdLngpO1xyXG4gICAgICBsZXQgaW5wdXRfZGltX2lkeCA9IHVuaWZvcm1zLmJhdGNoX2RpbXMgKyBkaW1faWR4O1xyXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgJHtcclxuICAgICAgICAgIGlucHV0RGltcy5sZW5ndGggPT09IDFcclxuICAgICAgICAgICAgPyAnaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXMpOydcclxuICAgICAgICAgICAgOiAnaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXNbaW5wdXRfZGltX2lkeF0pOydcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgJHtcclxuICAgICAgICBzaXplc0Zyb21TbGljZURpbXNEYXRhLmxlbmd0aCA9PT0gMVxyXG4gICAgICAgICAgPyAncmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhKTsnXHJcbiAgICAgICAgICA6ICdyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGFbZGltX2lkeF0pOydcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlucHV0X3NsaWNlX29mZnNldHNfZGF0YVtnbG9iYWxfaWR4XSA9ICBiYXNlX29mZnNldCArIHUzMihyZWxhdGl2ZV9zbGljZV9vZmZzZXQpO1xyXG4gIH1gO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdjb21wdXRlU2xpY2VPZmZzZXRzJyxcclxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7aW5wdXREaW1zLmxlbmd0aH1fJHtzaXplc0Zyb21TbGljZURpbXNEYXRhLmxlbmd0aH1gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzFdLmRhdGFUeXBlIH1dLFxyXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG51bVNsaWNlcyAvIDY0KSB9LFxyXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgICAgfSksXHJcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIH0sXHJcbiAgICB7IGlucHV0czogW2luZGljZXNEYXRhXSwgb3V0cHV0czogWy0xXSB9LFxyXG4gIClbMF07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2F0aGVyTkQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlck5EQXR0cmlidXRlcykgPT4ge1xyXG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XHJcbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XHJcbiAgY29uc3QgbnVtU2xpY2VEaW1zID0gaW5kaWNlc1NoYXBlW2luZGljZXNTaGFwZS5sZW5ndGggLSAxXTtcclxuICBjb25zdCBudW1TbGljZXMgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGluZGljZXNTaGFwZSwgaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDEpO1xyXG4gIGNvbnN0IHNsaWNlU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dFNoYXBlLCBhdHRyaWJ1dGVzLmJhdGNoRGltcyArIG51bVNsaWNlRGltcyk7XHJcbiAgY29uc3QgbnVtQmF0Y2hlcyA9IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oaW5wdXRTaGFwZSwgYXR0cmlidXRlcy5iYXRjaERpbXMpO1xyXG4gIGNvbnN0IGlucHV0QmF0Y2hTdHJpZGUgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgYXR0cmlidXRlcy5iYXRjaERpbXMpO1xyXG4gIGNvbnN0IG51bVNsaWNlc1BlckJhdGNoID0gbnVtU2xpY2VzIC8gbnVtQmF0Y2hlcztcclxuICBjb25zdCBzaXplc0Zyb21TbGljZURpbXMgPSBuZXcgQXJyYXkobnVtU2xpY2VEaW1zKTtcclxuICBsZXQgcnVubmluZ1Byb2R1Y3QgPSBzbGljZVNpemU7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TbGljZURpbXM7ICsraSkge1xyXG4gICAgc2l6ZXNGcm9tU2xpY2VEaW1zW251bVNsaWNlRGltcyAtIDEgLSBpXSA9IHJ1bm5pbmdQcm9kdWN0O1xyXG4gICAgcnVubmluZ1Byb2R1Y3QgKj0gaW5wdXRTaGFwZVthdHRyaWJ1dGVzLmJhdGNoRGltcyArIG51bVNsaWNlRGltcyAtIDEgLSBpXTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGlucHV0U2xpY2VPZmZzZXRzID0gY29tcHV0ZVNsaWNlT2Zmc2V0cyhcclxuICAgIGNvbnRleHQsXHJcbiAgICBpbnB1dHNbMV0sXHJcbiAgICBzaXplc0Zyb21TbGljZURpbXMsXHJcbiAgICBhdHRyaWJ1dGVzLmJhdGNoRGltcyxcclxuICAgIGlucHV0U2hhcGUsXHJcbiAgICBudW1TbGljZXMsXHJcbiAgICBudW1TbGljZXNQZXJCYXRjaCxcclxuICAgIGlucHV0QmF0Y2hTdHJpZGUsXHJcbiAgICBudW1TbGljZURpbXMsXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgbGFzdEluZGljZXNEaW1lbnNpb24gPSBhdHRyaWJ1dGVzLmJhdGNoRGltcyArIG51bVNsaWNlRGltcztcclxuICBpZiAobGFzdEluZGljZXNEaW1lbnNpb24gPiBpbnB1dFNoYXBlLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXN0IGRpbWVuc2lvbiBvZiBpbmRpY2VzIG11c3Qgbm90IGJlIGxhcmdlciB0aGFuIHJhbmsgb2YgaW5wdXQgdGVuc29yJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGluZGljZXNTaGFwZS5zbGljZSgwLCAtMSkuY29uY2F0KGlucHV0U2hhcGUuc2xpY2UobGFzdEluZGljZXNEaW1lbnNpb24pKTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNsaWNlU2l6ZSB9LFxyXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0U2xpY2VPZmZzZXRzLmRpbXMsIG91dHB1dFNoYXBlKSxcclxuICBdO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnZGF0YScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGluZGljZXMgPSBpbnB1dFZhcmlhYmxlKCdzbGljZV9vZmZzZXRzJywgRGF0YVR5cGUudWludDMyLCBpbnB1dFNsaWNlT2Zmc2V0cy5kaW1zLmxlbmd0aCk7XHJcblxyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgICAke3NoYWRlckhlbHBlclxyXG4gICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKVxyXG4gICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdzbGljZV9zaXplJywgJ3UzMicpXHJcbiAgICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBpbmRpY2VzLCBvdXRwdXQpfVxyXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgICAgICAgIGxldCBzbGljZV9vZmZzZXQgPSBzbGljZV9vZmZzZXRzW2dsb2JhbF9pZHggLyB1bmlmb3Jtcy5zbGljZV9zaXplXTtcclxuICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGRhdGFbdTMyKHNsaWNlX29mZnNldCkgKyBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XHJcbiAgICAgICAgfWA7XHJcbiAgfTtcclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdHYXRoZXJORCcsXHJcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuayddIH0sXHJcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFR5cGUgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgICAgfSksXHJcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIH0sXHJcbiAgICB7IGlucHV0czogW2lucHV0c1swXSwgaW5wdXRTbGljZU9mZnNldHNdIH0sXHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlck5EQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdhdGhlck5EQXR0cmlidXRlcyA9PiB7XHJcbiAgY29uc3QgYmF0Y2hEaW1zID0gYXR0cmlidXRlcy5iYXRjaF9kaW1zIGFzIG51bWJlcjtcclxuICByZXR1cm4ge1xyXG4gICAgYmF0Y2hEaW1zLFxyXG4gICAgY2FjaGVLZXk6ICcnLFxyXG4gIH07XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIGdhdGhlckF4aXM6IG51bWJlcjtcclxuICBxdWFudGl6ZUF4aXM6IG51bWJlcjtcclxuICBibG9ja1NpemU6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDMgfHwgaW5wdXRzLmxlbmd0aCA+IDQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyQmxvY2tRdWFudGl6ZWQgcmVxdWlyZXMgMyBvciA0IGlucHV0cy4nKTtcclxuICB9XHJcbiAgY29uc3QgcXVhbnRpemVBeGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5xdWFudGl6ZUF4aXMsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XHJcbiAgY29uc3QgYmxvY2tTaXplID0gYXR0cmlidXRlcy5ibG9ja1NpemU7XHJcbiAgY29uc3QgZGF0YSA9IGlucHV0c1swXTtcclxuICBjb25zdCBzY2FsZXMgPSBpbnB1dHNbMl07XHJcbiAgY29uc3QgemVyb1BvaW50ID0gaW5wdXRzLmxlbmd0aCA9PT0gNCA/IGlucHV0c1szXSA6IHVuZGVmaW5lZDtcclxuICBpZiAoXHJcbiAgICBzY2FsZXMuZGltcy5sZW5ndGggIT09IGRhdGEuZGltcy5sZW5ndGggfHxcclxuICAgICFkYXRhLmRpbXNcclxuICAgICAgLm1hcCgoZCwgaSkgPT4gKGkgPT09IHF1YW50aXplQXhpcyA/IE1hdGguY2VpbChkIC8gYmxvY2tTaXplKSA9PT0gc2NhbGVzLmRpbXNbaV0gOiBkID09PSBzY2FsZXMuZGltc1tpXSkpXHJcbiAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSlcclxuICApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgJ1NjYWxlcyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIGdhdGhlckF4aXMuJyxcclxuICAgICk7XHJcbiAgfVxyXG4gIC8vIFRPRE8gVW5jb21tZW50IHRoZSBmb2xsb3dpbmcgY2hlY2sgb25jZSB0aGUgdGVzdCBjYXNlIGNyZWF0aW9uIGNvZGUgaXMgZml4ZWQgdG8gY3JlYXRlIGRhdGEgY29ycmVjdGx5IGFsaWduZWQuXHJcbiAgLy8gY29uc3QgaW5kaWNlcyA9IGlucHV0c1sxXTtcclxuICAvLyBjb25zdCB2YWxpZEluZGV4ID0gKGluZGV4OiBudW1iZXIpID0+IGluZGV4ID49IDAgJiYgaW5kZXggPCBkYXRhLmRpbXNbYXR0cmlidXRlcy5nYXRoZXJBeGlzXTtcclxuICAvLyBpZiAoaW5kaWNlcy5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIgJiYgaW5kaWNlcy5nZXRJbnQzMkFycmF5KCkuc29tZSgodikgPT4gIXZhbGlkSW5kZXgodikpIHx8XHJcbiAgLy8gICAgIGluZGljZXMuZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDY0ICYmIGluZGljZXMuZ2V0QmlnSW50NjRBcnJheSgpLnNvbWUoKHYpID0+ICF2YWxpZEluZGV4KE51bWJlcih2KSkpKSB7XHJcbiAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ0luZGljZXMgbXVzdCBiZSB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgZ2F0aGVyQXhpcy4nKTtcclxuICAvLyB9XHJcbiAgaWYgKHplcm9Qb2ludCkge1xyXG4gICAgaWYgKHplcm9Qb2ludC5kYXRhVHlwZSAhPT0gZGF0YS5kYXRhVHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1plcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZSBhcyB0aGUgaW5wdXQgdGVuc29yLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKFxyXG4gICAgICB6ZXJvUG9pbnQuZGltcy5sZW5ndGggIT09IHNjYWxlcy5kaW1zLmxlbmd0aCB8fFxyXG4gICAgICAhemVyb1BvaW50LmRpbXMubWFwKChkLCBpKSA9PiBkID09PSBzY2FsZXMuZGltc1tpXSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXHJcbiAgICApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICdaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gcXVhbnRpemVBeGlzLicsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlR2F0aGVyQmxvY2tRdWFudGl6ZWRQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XHJcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XHJcbiAgY29uc3QgZ2F0aGVyQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuZ2F0aGVyQXhpcywgaW5wdXRSYW5rKTtcclxuICBjb25zdCBxdWFudGl6ZUF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLnF1YW50aXplQXhpcywgaW5wdXRSYW5rKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XHJcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGdhdGhlckF4aXMsIDEsIC4uLmluZGljZXNTaGFwZSk7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICBjb25zdCBvdXRwdXRUeXBlID0gaW5wdXRzWzJdLmRhdGFUeXBlO1xyXG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcclxuICBjb25zdCBpc1NpZ25lZCA9IGlucHV0VHlwZSA9PT0gRGF0YVR5cGUuaW50NDsgLy8gaW5wdXQgZGF0YSB0eXBlIGlzIGVpdGhlciBpbnQ0IG9yIHVpbnQ0LlxyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcXVhbnRpemVBeGlzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZ2F0aGVyQXhpcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuYmxvY2tTaXplIH0sXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyguLi5pbnB1dHMubWFwKChpbnB1dCwgXykgPT4gaW5wdXQuZGltcyksIG91dHB1dFNoYXBlKSxcclxuICBdO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IGRhdGEgPSBpbnB1dFZhcmlhYmxlKCdkYXRhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xyXG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2lucHV0SW5kaWNlcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IHNjYWxlcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IHplcm9Qb2ludCA9XHJcbiAgICAgIGlucHV0cy5sZW5ndGggPiAzID8gaW5wdXRWYXJpYWJsZSgnemVyb1BvaW50JywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIG91dHB1dFR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtkYXRhLCBpbmRpY2VzLCBzY2FsZXNdO1xyXG4gICAgaWYgKHplcm9Qb2ludCkge1xyXG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKHplcm9Qb2ludCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAncXVhbnRpemVfYXhpcycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2dhdGhlcl9heGlzJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYmxvY2tfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgICB2YXIgaW5kaWNlc19pbmRpY2VzID0gJHtpbmRpY2VzLnR5cGUuaW5kaWNlc30oMCk7XHJcbiAgICAgICAgJHsoKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKGluZGljZXNTaGFwZS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtpbmRpY2VzU2hhcGUubGVuZ3RofTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmdhdGhlcl9heGlzICsgaScpfTtcclxuICAgICAgICAgICAgJHtpbmRpY2VzLmluZGljZXNTZXQoJ2luZGljZXNfaW5kaWNlcycsICdpJywgJ2luZGV4Jyl9O1xyXG4gICAgICAgICAgfWA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYGluZGljZXNfaW5kaWNlcyA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmdhdGhlcl9heGlzJyl9O2A7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKX07XHJcbiAgICAgICAgdmFyIGRhdGFfaW5kaWNlcyA9ICR7ZGF0YS50eXBlLmluZGljZXN9KDApO1xyXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5nYXRoZXJfYXhpczsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xyXG4gICAgICAgICAgJHtkYXRhLmluZGljZXNTZXQoJ2RhdGFfaW5kaWNlcycsICdpJywgJ2luZGV4Jyl9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5kZXhfZnJvbV9pbmRpY2VzID0gJHtpbmRpY2VzLmdldEJ5SW5kaWNlcygnaW5kaWNlc19pbmRpY2VzJyl9O1xyXG4gICAgICAgIGlmIChpbmRleF9mcm9tX2luZGljZXMgPCAwKSB7XHJcbiAgICAgICAgICBpbmRleF9mcm9tX2luZGljZXMgKz0gJHtpbnB1dFNoYXBlW2dhdGhlckF4aXNdfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJHtkYXRhLmluZGljZXNTZXQoJ2RhdGFfaW5kaWNlcycsICd1bmlmb3Jtcy5nYXRoZXJfYXhpcycsICd1MzIoaW5kZXhfZnJvbV9pbmRpY2VzKScpfTtcclxuICAgICAgICBmb3IgKHZhciBpID0gdW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyAxOyBpIDwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9OyBpKyspIHtcclxuICAgICAgICAgIGxldCBpbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgYGkgKyAke2luZGljZXNTaGFwZS5sZW5ndGh9IC0gMWApfTtcclxuICAgICAgICAgICR7ZGF0YS5pbmRpY2VzU2V0KCdkYXRhX2luZGljZXMnLCAnaScsICdpbmRleCcpfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRhdGFfb2Zmc2V0ID0gJHtkYXRhLmluZGljZXNUb09mZnNldCgnZGF0YV9pbmRpY2VzJyl9O1xyXG4gICAgICAgIGxldCBkYXRhX2luZGV4ID0gZGF0YV9vZmZzZXQgJSA4O1xyXG4gICAgICAgIC8vIENvbnZlcnQgNC1iaXQgcGFja2VkIGRhdGEgdG8gOC1iaXQgcGFja2VkIGRhdGEuXHJcbiAgICAgICAgbGV0IHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID0gJHtkYXRhLmdldEJ5T2Zmc2V0KCdkYXRhX29mZnNldCAvIDgnKX07XHJcbiAgICAgICAgbGV0IHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhID0gKHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID4+ICg0ICogKGRhdGFfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcclxuICAgICAgICBsZXQgcXVhbnRpemVkX2RhdGFfdmVjID0gJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4JyA6ICd1bnBhY2s0eFU4J30odTMyKHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhKSk7XHJcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhID0gcXVhbnRpemVkX2RhdGFfdmVjW2RhdGFfaW5kZXggLyAyXTtcclxuICAgICAgICB2YXIgc2NhbGVfaW5kaWNlcyA9IGRhdGFfaW5kaWNlcztcclxuICAgICAgICBsZXQgcXVhbnRpemVfYXhpc19pbmRleCA9ICR7c2NhbGVzLmluZGljZXNHZXQoJ2RhdGFfaW5kaWNlcycsICd1bmlmb3Jtcy5xdWFudGl6ZV9heGlzJyl9IC8gdW5pZm9ybXMuYmxvY2tfc2l6ZTtcclxuICAgICAgICAke3NjYWxlcy5pbmRpY2VzU2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLnF1YW50aXplX2F4aXMnLCAncXVhbnRpemVfYXhpc19pbmRleCcpfTtcclxuICAgICAgICB2YXIgc2NhbGUgPSAke3NjYWxlcy5nZXRCeUluZGljZXMoJ3NjYWxlX2luZGljZXMnKX07XHJcbiAgICAgICAgJHsoKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKCF6ZXJvUG9pbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd2YXIgemVyb19wb2ludCA9IDAnO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRpY2VzID0gc2NhbGVfaW5kaWNlcztcclxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke3plcm9Qb2ludC5pbmRpY2VzVG9PZmZzZXQoJ3plcm9fcG9pbnRfaW5kaWNlcycpfTtcclxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9IHplcm9fcG9pbnRfb2Zmc2V0ICUgODtcclxuICAgICAgICAgICAgICBsZXQgcGFja2VkXzRiaXRfemVyb19wb2ludHMgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9vZmZzZXQgLyA4Jyl9O1xyXG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfOGJpdF96ZXJvX3BvaW50cyA9IChwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA+PiAoNCAqICh6ZXJvX3BvaW50X2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XHJcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4JyA6ICd1bnBhY2s0eFU4J30odTMyKHBhY2tlZF84Yml0X3plcm9fcG9pbnRzKSk7XHJcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4IC8gMl07YDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSgpfTtcclxuICAgICAgICBsZXQgZGVxdWFudGl6ZWRfZGF0YSA9ICR7dGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShvdXRwdXRUeXBlKX0ocXVhbnRpemVkX2RhdGEgLSB6ZXJvX3BvaW50KSAqIHNjYWxlO1xyXG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2RlcXVhbnRpemVkX2RhdGEnKX07XHJcbiAgICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnR2F0aGVyQmxvY2tRdWFudGl6ZWQnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpbnB1dHNcclxuICAgICAgICAuZmlsdGVyKChfLCBpKSA9PiBpICE9PSAxKVxyXG4gICAgICAgIC5tYXAoKGlucHV0KSA9PiBpbnB1dC5kaW1zLmpvaW4oJ18nKSlcclxuICAgICAgICAuam9pbignOycpfWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBpbnB1dHMubGVuZ3RoIH0sIChfdiwgX2kpID0+ICdyYW5rJyksXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXRUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2F0aGVyQmxvY2tRdWFudGl6ZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xyXG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdhdGhlckJsb2NrUXVhbnRpemVkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyA9IChcclxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcclxuKTogR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcclxuICAgIGJsb2NrU2l6ZTogYXR0cmlidXRlcy5ibG9ja1NpemUgYXMgbnVtYmVyLFxyXG4gICAgZ2F0aGVyQXhpczogYXR0cmlidXRlcy5nYXRoZXJBeGlzIGFzIG51bWJlcixcclxuICAgIHF1YW50aXplQXhpczogYXR0cmlidXRlcy5xdWFudGl6ZUF4aXMgYXMgbnVtYmVyLFxyXG4gIH0pO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIGF4aXM6IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCA8IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBiZSByYW5rID49IDEuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVHYXRoZXJFbGVtZW50c1Byb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBpbnB1dE91dHB1dERhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xyXG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xyXG5cclxuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcclxuICBjb25zdCBpbmRpY2VzRGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7XHJcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRSYW5rKTtcclxuICBjb25zdCBheGlzRGltTGltaXQgPSBpbnB1dFNoYXBlW2F4aXNdO1xyXG5cclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGluZGljZXNTaGFwZS5zbGljZSgwKTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG5cclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRPdXRwdXREYXRhVHlwZSwgaW5wdXRSYW5rKTtcclxuICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5kaWNlc0lucHV0JywgaW5kaWNlc0RhdGFUeXBlLCBpbmRpY2VzU2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRPdXRwdXREYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF4aXNEaW1MaW1pdCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXMgfSxcclxuICBdO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIGluZGljZXNTaGFwZSwgb3V0cHV0U2hhcGUpKTtcclxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XHJcblxyXG4gIC8vIGludDY0IGluZGljZXMgd291bGQgYmUgdHJlYXRlZCBhcyBsaXR0bGUgZW5kaWFuIGkzMiB3aXRoIGFzc3VtcHRpb24gdGhleSBmYWxsIGluIGkzMiBsaW1pdHNcclxuICAvLyBUaGF0IGFzc3VtcHRpb24gaXMgc2FmZSBhcyBpdCdzIG5vdCBwb3NzaWJsZSB0byBhbGxvY2F0ZSA+MmdiIGJ1ZmZlciBmb3IgaW5wdXQgdGVuc29yXHJcbiAgLy8gSW5wdXQgZGF0YSB3aWxsIGJlIHRyZWF0ZWQgYXMgdTMyIG9yIHR3byB1MzIgZm9yIDgtYnl0ZSB0ZW5zb3JzXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgICAgICR7c2hhZGVySGVscGVyXHJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXNEaW1MaW1pdCcsICdpMzInKVxyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcclxuICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgaW5kaWNlcywgb3V0cHV0KX1cclxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cclxuXHJcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG5cclxuICAgICAgdmFyIGlkeCA9ICR7aW5kaWNlcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgaWYgKGlkeCA8IDApIHtcclxuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7aW5wdXQudHlwZS5pbmRpY2VzfShvdXRwdXRJbmRpY2VzKTtcclxuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICd1MzIoaWR4KScpfTtcclxuICAgICAgbGV0IHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0SW5kaWNlcycpfTtcclxuXHJcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xyXG4gIH1gO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0dhdGhlckVsZW1lbnRzJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGlucHV0RGVwZW5kZW5jaWVzIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlciB9KTtcclxuXHJcbmV4cG9ydCBjb25zdCBnYXRoZXJFbGVtZW50cyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XHJcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyRWxlbWVudHNQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBHZW1tVXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgaXMgbWlzc2luZycpO1xyXG4gIH1cclxuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWlkIGlucHV0IG51bWJlci4nKTtcclxuICB9XHJcblxyXG4gIC8vICdDJyBjYW4gYmUgb2YgZGltZW5zaW9uYWxpdHkgMCwgMSBvciAyIG9ubHlcclxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0uZGltcy5sZW5ndGggPiAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUgb2YgQycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzFdLmRhdGFUeXBlIHx8IChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzJdLmRhdGFUeXBlKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZCcpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR2VtbUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIHRyYW5zQTogYm9vbGVhbjtcclxuICB0cmFuc0I6IGJvb2xlYW47XHJcbiAgYWxwaGE6IG51bWJlcjtcclxuICBiZXRhOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IGNyZWF0ZUdlbW1Qcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcclxuICBjb25zdCBiU2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xyXG4gIGNvbnN0IFtNLCBOLCBLXSA9IEdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KFxyXG4gICAgYVNoYXBlLFxyXG4gICAgYXR0cmlidXRlcy50cmFuc0EsXHJcbiAgICBiU2hhcGUsXHJcbiAgICBhdHRyaWJ1dGVzLnRyYW5zQixcclxuICAgIGlucHV0cy5sZW5ndGggPT09IDMgPyBpbnB1dHNbMl0uZGltcyA6IHVuZGVmaW5lZCxcclxuICApO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW00sIE5dO1xyXG4gIGlmICghb3V0cHV0U2hhcGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xyXG4gIH1cclxuICBjb25zdCB0aWxlU2l6ZSA9IDE2O1xyXG4gIGNvbnN0IG51bVRpbGVOID0gTWF0aC5jZWlsKE4gLyB0aWxlU2l6ZSk7XHJcbiAgY29uc3QgbnVtVGlsZU0gPSBNYXRoLmNlaWwoTSAvIHRpbGVTaXplKTtcclxuICAvLyBUT0RPOiBGaW5kIHRoZSBjb25kaXRpb24gd2hlbiB0byB1c2UgdGhlIG5haXZlIG9uZS5cclxuICBjb25zdCB1c2VTaGFyZWQgPSB0cnVlO1xyXG5cclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB1c2VTaGFyZWQgPyBudW1UaWxlTiA6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTiB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEsgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYmV0YSB9LFxyXG4gIF07XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xyXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xyXG4gIH1cclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGxldCBsaW5lID0gJyc7XHJcbiAgICBpZiAoYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcclxuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW24gKiB1bmlmb3Jtcy5LICsga107JztcclxuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XHJcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltrICogdW5pZm9ybXMuTiArIG5dOyc7XHJcbiAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGVzLnRyYW5zQSAmJiBhdHRyaWJ1dGVzLnRyYW5zQikge1xyXG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTsnO1xyXG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XHJcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltrICogdW5pZm9ybXMuTiArIG5dOyc7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2FsY3VsYXRlQWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhID09PSAxID8gJycgOiAndmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7JztcclxuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcyk7XHJcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xyXG4gICAgY29uc3QgZGF0YVR5cGUgPSBhLnR5cGUudmFsdWU7XHJcbiAgICBsZXQgYzogSW5kaWNlc0hlbHBlciB8IG51bGwgPSBudWxsO1xyXG4gICAgY29uc3QgdmFyaWFibGVzID0gW2EsIGJdO1xyXG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcclxuICAgICAgYyA9IGlucHV0VmFyaWFibGUoJ2MnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XHJcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGMpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dCk7XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnTScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdLJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdiZXRhJywgdHlwZTogJ2YzMicgfSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gYFxyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxyXG5cclxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XHJcbiAgICBsZXQgbiA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5OO1xyXG5cclxuICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xyXG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrKyspIHtcclxuICAgICAgJHtsaW5lfVxyXG4gICAgfVxyXG5cclxuICAgICR7Y2FsY3VsYXRlQWxwaGF9XHJcbiAgICAkeygoKSA9PiB7XHJcbiAgICAgIGlmIChjICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gYGxldCBjT2Zmc2V0ID0gJHtjLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCd2ZWMyKG0sIG4pJywgb3V0cHV0KX07IHZhbHVlICs9ICR7XHJcbiAgICAgICAgICBkYXRhVHlwZVxyXG4gICAgICAgIH0odW5pZm9ybXMuYmV0YSkgKiAke2MuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07YDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9KSgpfVxyXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XHJcbiAgfWA7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlU2hhcmVkID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMpO1xyXG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zKTtcclxuICAgIGxldCBjOiBJbmRpY2VzSGVscGVyIHwgbnVsbCA9IG51bGw7XHJcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbYSwgYl07XHJcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICBjID0gaW5wdXRWYXJpYWJsZSgnYycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcclxuICAgICAgdmFyaWFibGVzLnB1c2goYyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG4gICAgdmFyaWFibGVzLnB1c2gob3V0cHV0KTtcclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnbnVtX3RpbGVfbicsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ00nLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdOJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYmV0YScsIHR5cGU6ICdmMzInIH0sXHJcbiAgICBdO1xyXG5cclxuICAgIGxldCBjYWxjUmVzdWx0ID0gJyc7XHJcbiAgICBsZXQgZmlsbFdvcmtncm91cE1lbW9yeSA9ICcnO1xyXG4gICAgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XHJcbiAgICAgIGZpbGxXb3JrZ3JvdXBNZW1vcnkgPSBgXHJcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XHJcbiAgICAgIHZhciByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcclxuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk0gJiYgcm93IDwgdW5pZm9ybXMuSykge1xyXG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHthLnR5cGUudmFsdWV9KDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcclxuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xyXG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XHJcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2IudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgIH1cclxuICAgICAgYDtcclxuICAgICAgY2FsY1Jlc3VsdCA9IGB2YWx1ZSArPSB0aWxlX2Fba11bbG9jYWxfaWQueV0gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107YDtcclxuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XHJcbiAgICAgIGZpbGxXb3JrZ3JvdXBNZW1vcnkgPSBgXHJcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XHJcbiAgICAgIHZhciByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcclxuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk0gJiYgcm93IDwgdW5pZm9ybXMuSykge1xyXG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHthLnR5cGUudmFsdWV9KDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb2wgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XHJcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xyXG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XHJcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5OICsgY29sXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2IudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgIH1cclxuICAgICAgYDtcclxuICAgICAgY2FsY1Jlc3VsdCA9IGB2YWx1ZSArPSB0aWxlX2Fba11bbG9jYWxfaWQueV0gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07YDtcclxuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XHJcbiAgICAgIGZpbGxXb3JrZ3JvdXBNZW1vcnkgPSBgXHJcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcclxuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcclxuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTSkge1xyXG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHthLnR5cGUudmFsdWV9KDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcclxuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xyXG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XHJcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2IudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgIH1cclxuICAgICAgYDtcclxuICAgICAgY2FsY1Jlc3VsdCA9IGB2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107YDtcclxuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xyXG4gICAgICBmaWxsV29ya2dyb3VwTWVtb3J5ID0gYFxyXG4gICAgICB2YXIgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XHJcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XHJcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcclxuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7YS50eXBlLnZhbHVlfSgwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xyXG4gICAgICByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcclxuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xyXG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtiLnR5cGUudmFsdWV9KDApO1xyXG4gICAgICB9XHJcbiAgICAgIGA7XHJcbiAgICAgIGNhbGNSZXN1bHQgPSBgdmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO2A7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2FsY3VsYXRlQWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhID09PSAxID8gJycgOiAndmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7JztcclxuXHJcbiAgICByZXR1cm4gYFxyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cclxuICB2YXI8d29ya2dyb3VwPiB0aWxlX2E6IGFycmF5PGFycmF5PCR7YS50eXBlLnN0b3JhZ2V9LCAke3RpbGVTaXplfT4sICR7dGlsZVNpemV9PjtcclxuICB2YXI8d29ya2dyb3VwPiB0aWxlX2I6IGFycmF5PGFycmF5PCR7Yi50eXBlLnN0b3JhZ2V9LCAke3RpbGVTaXplfT4sICR7dGlsZVNpemV9PjtcclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW3RpbGVTaXplLCB0aWxlU2l6ZSwgMV0pfVxyXG4gICAgbGV0IHRpbGVfY29sX3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAlIHVuaWZvcm1zLm51bV90aWxlX24pICogJHt0aWxlU2l6ZX07XHJcbiAgICBsZXQgdGlsZV9yb3dfc3RhcnQgPSAod29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMubnVtX3RpbGVfbikgKiAke3RpbGVTaXplfTtcclxuICAgIGxldCBudW1fdGlsZXMgPSAodW5pZm9ybXMuSyAtIDEpIC8gJHt0aWxlU2l6ZX0gKyAxO1xyXG4gICAgdmFyIGtfc3RhcnQgPSAwdTtcclxuICAgIHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xyXG4gICAgZm9yICh2YXIgdDogdTMyID0gMHU7IHQgPCBudW1fdGlsZXM7IHQrKykge1xyXG4gICAgICAke2ZpbGxXb3JrZ3JvdXBNZW1vcnl9XHJcbiAgICAgIGtfc3RhcnQgPSBrX3N0YXJ0ICsgJHt0aWxlU2l6ZX07XHJcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgJHt0aWxlU2l6ZX07IGsrKykge1xyXG4gICAgICAgICR7Y2FsY1Jlc3VsdH1cclxuICAgICAgfVxyXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgJHtjYWxjdWxhdGVBbHBoYX1cclxuICAgIGxldCBtID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xyXG4gICAgbGV0IG4gPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XHJcbiAgICAkeygoKSA9PiB7XHJcbiAgICAgIGlmIChjICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gYGxldCBjT2Zmc2V0ID0gJHtjLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCd2ZWMyKG0sIG4pJywgb3V0cHV0KX07IHZhbHVlICs9ICR7XHJcbiAgICAgICAgICBvdXRwdXQudHlwZS52YWx1ZVxyXG4gICAgICAgIH0odW5pZm9ybXMuYmV0YSkgKiAke2MuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07YDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9KSgpfVxyXG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XHJcbiAgICAgIG91dHB1dFttICogdW5pZm9ybXMuTiArIG5dID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgfWA7XHJcbiAgfTtcclxuXHJcbiAgaWYgKHVzZVNoYXJlZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZTogJ0dlbW1TaGFyZWQnLFxyXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXHJcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBudW1UaWxlTiAqIG51bVRpbGVNIH0sXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgICB9KSxcclxuICAgICAgZ2V0U2hhZGVyU291cmNlOiBnZXRTaGFkZXJTb3VyY2VTaGFyZWQsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdHZW1tJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VHZW1tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdlbW1BdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCB0cmFuc0EgPSBhdHRyaWJ1dGVzLnRyYW5zQSBhcyBib29sZWFuO1xyXG4gIGNvbnN0IHRyYW5zQiA9IGF0dHJpYnV0ZXMudHJhbnNCIGFzIGJvb2xlYW47XHJcbiAgY29uc3QgYWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhIGFzIG51bWJlcjtcclxuICBjb25zdCBiZXRhID0gYXR0cmlidXRlcy5iZXRhIGFzIG51bWJlcjtcclxuICByZXR1cm4ge1xyXG4gICAgdHJhbnNBLFxyXG4gICAgdHJhbnNCLFxyXG4gICAgYWxwaGEsXHJcbiAgICBiZXRhLFxyXG4gICAgY2FjaGVLZXk6IGAke2F0dHJpYnV0ZXMudHJhbnNBfTske2F0dHJpYnV0ZXMudHJhbnNCfTske2F0dHJpYnV0ZXMuYWxwaGEgPT09IDF9YCxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdlbW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHZW1tUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxubGV0IFtpZHhOLCBpZHhDLCBpZHhILCBpZHhXXSA9IFswLCAxLCAyLCAzXTsgLy8gTkNIV1xyXG50eXBlIE1vZGUgPSAnYmlsaW5lYXInIHwgJ25lYXJlc3QnIHwgJ2JpY3ViaWMnO1xyXG50eXBlIFBhZGRpbmdNb2RlID0gJ3plcm9zJyB8ICdib3JkZXInIHwgJ3JlZmxlY3Rpb24nO1xyXG50eXBlIEZvcm1hdCA9ICdOSFdDJyB8ICdOQ0hXJztcclxuZXhwb3J0IGludGVyZmFjZSBHcmlkU2FtcGVBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICBhbGlnbkNvcm5lcnM6IG51bWJlcjtcclxuICBtb2RlOiBNb2RlO1xyXG4gIHBhZGRpbmdNb2RlOiBQYWRkaW5nTW9kZTtcclxuICBmb3JtYXQ6IEZvcm1hdDtcclxufVxyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgNC1EIHRlbnNvciBpcyBzdXBwb3J0ZWQuJyk7XHJcbiAgfVxyXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwgdG8gZ3JpZCBkaW1lbnNpb25zJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMiAhPT0gaW5wdXRzWzFdLmRpbXNbaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMV0pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgbGFzdCBkaW1lbnNpb24gb2YgZ3JpZCBtdXN0IGJlIGVxdWFsIHRvICR7aW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMn1gKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dHNbMF0uZGltc1swXSAhPT0gaW5wdXRzWzFdLmRpbXNbMF0pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignZ3JpZCBiYXRjaCBzaXplIG11c3QgbWF0Y2ggaW5wdXQgYmF0Y2ggc2l6ZScpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGdzR2V0Q3ViaWNDb2VmZnMgPSBgXHJcbiAgZm4gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4OiBmMzIpIC0+IHZlYzQ8ZjMyPiB7XHJcbiAgICBsZXQgY3ViaWNfYWxwaGEgPSAtMC43NWY7XHJcbiAgICBsZXQgeF9hYnMgPSBhYnMoeCk7XHJcbiAgICB2YXIgY29lZmZzOiB2ZWM0PGYzMj47XHJcbiAgICBjb2VmZnNbMF0gPSAoKChjdWJpY19hbHBoYSAqICh4X2FicyArIDEpIC0gNSAqIGN1YmljX2FscGhhKSAqICh4X2FicyArIDEpICsgOCAqIGN1YmljX2FscGhhKSAqICh4X2FicyArIDEpIC0gNCAqIGN1YmljX2FscGhhKTtcclxuICAgIGNvZWZmc1sxXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiB4X2FicyAtIChjdWJpY19hbHBoYSArIDMpKSAqIHhfYWJzICogeF9hYnMgKyAxKTtcclxuICAgIGNvZWZmc1syXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiAoMSAtIHhfYWJzKSAtIChjdWJpY19hbHBoYSArIDMpKSAqICgxIC0geF9hYnMpICogKDEgLSB4X2FicykgKyAxKTtcclxuICAgIGNvZWZmc1szXSA9ICgoKGN1YmljX2FscGhhICogKDIgLSB4X2FicykgLSA1ICogY3ViaWNfYWxwaGEpICogKDIgLSB4X2FicykgKyA4ICogY3ViaWNfYWxwaGEpICogKDIgLSB4X2FicykgLSA0ICogY3ViaWNfYWxwaGEpO1xyXG4gICAgcmV0dXJuIGNvZWZmcztcclxuICB9XHJcbmA7XHJcblxyXG5jb25zdCBnc0JpY3ViaWNJbnRlcnBvbGF0ZSA9IChkYXRhVHlwZTogc3RyaW5nKTogc3RyaW5nID0+IGBcclxuICBmbiBnc19iaWN1YmljX2ludGVycG9sYXRlKHA6IG1hdDR4NDwke2RhdGFUeXBlfT4sIHg6IGYzMiwgeTogZjMyKSAtPiAke2RhdGFUeXBlfSB7XHJcbiAgICB2YXIgdjogdmVjNDxmMzI+O1xyXG4gICAgdmFyIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICB2W2ldID0gY29lZmZzWzBdICogcFtpXVswXSArIGNvZWZmc1sxXSAqIHBbaV1bMV0gKyBjb2VmZnNbMl0gKiBwW2ldWzJdICsgY29lZmZzWzNdICogcFtpXVszXTtcclxuICAgIH1cclxuICAgIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeSk7XHJcbiAgICBsZXQgcGl4ZWwgPSAke2RhdGFUeXBlfShjb2VmZnNbMF0gKiB2WzBdICsgY29lZmZzWzFdICogdlsxXSArIGNvZWZmc1syXSAqIHZbMl0gKyBjb2VmZnNbM10gKiB2WzNdKTtcclxuICAgIHJldHVybiBwaXhlbDtcclxuICB9XHJcbmA7XHJcblxyXG5jb25zdCBnc0Rlbm9ybWFsaXplID0gKGF0dHJpYnV0ZXM6IEdyaWRTYW1wZUF0dHJpYnV0ZXMpOiBzdHJpbmcgPT4gYFxyXG4gIGZuIGdzX2Rlbm9ybWFsaXplKG46IGYzMiwgbGVuZ3RoOiBpMzIpIC0+IGYzMiB7XHJcbiAgICAke1xyXG4gICAgICBhdHRyaWJ1dGVzLmFsaWduQ29ybmVycyA9PT0gMFxyXG4gICAgICAgID8gYFxyXG4gICAgLy8gYWxpZ25Db3JuZXJzOiBmYWxzZSA9PiBbLTEsIDFdIHRvIFstMC41LCBsZW5ndGggLSAwLjVdXHJcbiAgICByZXR1cm4gKChuICsgMS4wKSAqIGYzMihsZW5ndGgpIC0gMS4wKSAvIDIuMDtcclxuICAgIGBcclxuICAgICAgICA6IGBcclxuICAgIC8vIGFsaWduQ29ybmVyczogdHJ1ZSA9PiBbLTEsIDFdIHRvIFswLCBsZW5ndGggLSAxXVxyXG4gICAgcmV0dXJuIChuICsgMS4wKSAvIDIuMCAqIChmMzIobGVuZ3RoIC0gMSkpO1xyXG4gICAgYFxyXG4gICAgfVxyXG4gIH1cclxuYDtcclxuXHJcbmNvbnN0IGdzUmVmbGVjdCA9IChhdHRyaWJ1dGVzOiBHcmlkU2FtcGVBdHRyaWJ1dGVzKTogc3RyaW5nID0+IGBcclxuICAke1xyXG4gICAgYXR0cmlidXRlcy5wYWRkaW5nTW9kZSA9PT0gJ3JlZmxlY3Rpb24nXHJcbiAgICAgID8gYFxyXG4gICAgICBmbiBnc19yZWZsZWN0KHg6IGkzMiwgeF9taW46IGYzMiwgeF9tYXg6IGYzMikgLT4gdTMyIHtcclxuICAgICAgICB2YXIgZHggPSAwLjA7XHJcbiAgICAgICAgdmFyIGZ4ID0gZjMyKHgpO1xyXG4gICAgICAgIGxldCByYW5nZSA9IHhfbWF4IC0geF9taW47XHJcbiAgICAgICAgaWYgKGZ4IDwgeF9taW4pIHtcclxuICAgICAgICAgIGR4ID0geF9taW4gLSBmeDtcclxuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xyXG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xyXG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcclxuICAgICAgICAgICAgZnggPSB4X21pbiArIHI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGZ4ID4geF9tYXgpIHtcclxuICAgICAgICAgIGR4ID0gZnggLSB4X21heDtcclxuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xyXG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xyXG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcclxuICAgICAgICAgICAgZnggPSB4X21heCAtIHI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHUzMihmeCk7XHJcbiAgICAgIH1gXHJcbiAgICAgIDogJydcclxuICB9XHJcbmA7XHJcblxyXG5jb25zdCBwaXhlbEF0R3JpZCA9IChpbnB1dDogSW5kaWNlc0hlbHBlciwgZGF0YVR5cGU6IHN0cmluZywgYXR0cmlidXRlczogR3JpZFNhbXBlQXR0cmlidXRlcyk6IHN0cmluZyA9PlxyXG4gIGBcclxuICBmbiBwaXhlbF9hdF9ncmlkKHI6IGkzMiwgYzogaTMyLCBIOiBpMzIsIFc6IGkzMiwgYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBib3JkZXI6IHZlYzQ8ZjMyPikgLT4gJHtkYXRhVHlwZX0ge1xyXG4gICAgIHZhciBwaXhlbCA9ICR7ZGF0YVR5cGV9KDApO1xyXG4gICAgIHZhciBpbmRpY2VzID0gdmVjNDx1MzI+KDApO1xyXG4gICAgIGluZGljZXNbJHtpZHhOfV0gPSBiYXRjaDtcclxuICAgICBpbmRpY2VzWyR7aWR4Q31dID0gY2hhbm5lbDtgICtcclxuICAoKCkgPT4ge1xyXG4gICAgc3dpdGNoIChhdHRyaWJ1dGVzLnBhZGRpbmdNb2RlKSB7XHJcbiAgICAgIGNhc2UgJ3plcm9zJzpcclxuICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgaWYgKHIgPj0gMCAmJiByIDwgSCAmJiBjID49MCAmJiBjIDwgVykge1xyXG4gICAgICAgICAgICBpbmRpY2VzWyR7aWR4SH1dID0gdTMyKHIpO1xyXG4gICAgICAgICAgICBpbmRpY2VzWyR7aWR4V31dID0gdTMyKGMpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICR7ZGF0YVR5cGV9KDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGA7XHJcbiAgICAgIGNhc2UgJ2JvcmRlcic6XHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgIGluZGljZXNbJHtpZHhIfV0gPSB1MzIoY2xhbXAociwgMCwgSCAtIDEpKTtcclxuICAgICAgICAgIGluZGljZXNbJHtpZHhXfV0gPSB1MzIoY2xhbXAoYywgMCwgVyAtIDEpKTtcclxuICAgICAgICBgO1xyXG4gICAgICBjYXNlICdyZWZsZWN0aW9uJzpcclxuICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgaW5kaWNlc1ske2lkeEh9XSA9IGdzX3JlZmxlY3QociwgYm9yZGVyWzFdLCBib3JkZXJbM10pO1xyXG4gICAgICAgICAgaW5kaWNlc1ske2lkeFd9XSA9IGdzX3JlZmxlY3QoYywgYm9yZGVyWzBdLCBib3JkZXJbMl0pO1xyXG4gICAgICAgIGA7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nIG1vZGUgJHthdHRyaWJ1dGVzLnBhZGRpbmdNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICB9XHJcbiAgfSkoKSArXHJcbiAgYFxyXG4gICAgcmV0dXJuICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbmRpY2VzJyl9O1xyXG4gIH1cclxuYDtcclxuXHJcbmNvbnN0IGNvbXB1dGVQaXhlbCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGRhdGFUeXBlOiBzdHJpbmcsIGF0dHJpYnV0ZXM6IEdyaWRTYW1wZUF0dHJpYnV0ZXMpOiBzdHJpbmcgPT5cclxuICAoKCkgPT4ge1xyXG4gICAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcclxuICAgICAgY2FzZSAnbmVhcmVzdCc6XHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgIGxldCByZXN1bHQgPSBwaXhlbF9hdF9ncmlkKGkzMihyb3VuZCh5KSksIGkzMihyb3VuZCh4KSksIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XHJcbiAgICAgICAgYDtcclxuICAgICAgY2FzZSAnYmlsaW5lYXInOlxyXG4gICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICBsZXQgeDEgPSBpMzIoZmxvb3IoeCkpO1xyXG4gICAgICAgICAgbGV0IHkxID0gaTMyKGZsb29yKHkpKTtcclxuICAgICAgICAgIGxldCB4MiA9IHgxICsgMTtcclxuICAgICAgICAgIGxldCB5MiA9IHkxICsgMTtcclxuXHJcbiAgICAgICAgICBsZXQgcDExID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XHJcbiAgICAgICAgICBsZXQgcDEyID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XHJcbiAgICAgICAgICBsZXQgcDIxID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XHJcbiAgICAgICAgICBsZXQgcDIyID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtpZHhOfV0sIGluZGljZXNbJHtpZHhDfV0sIGJvcmRlcik7XHJcblxyXG4gICAgICAgICAgbGV0IGR4MiA9ICR7ZGF0YVR5cGV9KGYzMih4MikgLSB4KTtcclxuICAgICAgICAgIGxldCBkeDEgPSAke2RhdGFUeXBlfSh4IC0gZjMyKHgxKSk7XHJcbiAgICAgICAgICBsZXQgZHkyID0gJHtkYXRhVHlwZX0oZjMyKHkyKSAtIHkpO1xyXG4gICAgICAgICAgbGV0IGR5MSA9ICR7ZGF0YVR5cGV9KHkgLSBmMzIoeTEpKTtcclxuICAgICAgICAgIGxldCByZXN1bHQgPSBkeTIgKiAoZHgyICogcDExICsgZHgxICogcDEyKSArIGR5MSAqIChkeDIgKiBwMjEgKyBkeDEgKiBwMjIpO1xyXG4gICAgICAgIGA7XHJcbiAgICAgIGNhc2UgJ2JpY3ViaWMnOlxyXG4gICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICBsZXQgeDAgPSBpMzIoZmxvb3IoeCkpIC0gMTtcclxuICAgICAgICAgIGxldCB5MCA9IGkzMihmbG9vcih5KSkgLSAxO1xyXG4gICAgICAgICAgdmFyIHA6IG1hdDR4NDwke2RhdGFUeXBlfT47XHJcbiAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IDQ7IGgrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IDQ7IHcrKykge1xyXG4gICAgICAgICAgICAgIHBbaF1bd10gPSBwaXhlbF9hdF9ncmlkKGggKyB5MCwgdyArIHgwLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7aWR4Tn1dLCBpbmRpY2VzWyR7aWR4Q31dLCBib3JkZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbGV0IGR4ID0geCAtIGYzMih4MCArIDEpO1xyXG4gICAgICAgICAgbGV0IGR5ID0geSAtIGYzMih5MCArIDEpO1xyXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocCwgZHgsIGR5KTtcclxuICAgICAgICBgO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbW9kZSAke2F0dHJpYnV0ZXMubW9kZX0gaXMgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgfVxyXG4gIH0pKCkgKyBgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAncmVzdWx0Jyl9YDtcclxuXHJcbmNvbnN0IGNyZWF0ZUdyaWRTYW1wbGVQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR3JpZFNhbXBlQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcclxuICAvLyBkaXNjYXJkIGxhc3QgZGltZW5zaW9uIGZvciB1c2luZyB2ZWMyIHRvIGFjY2VzcyBncmlkIGRhdGFcclxuICBjb25zdCBncmlkU2hhcGUgPSBbaW5wdXRzWzFdLmRpbXNbMF0sIGlucHV0c1sxXS5kaW1zWzFdLCBpbnB1dHNbMV0uZGltc1syXV07XHJcbiAgY29uc3QgZ3JpZCA9IGlucHV0VmFyaWFibGUoJ2dyaWQnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGdyaWRTaGFwZS5sZW5ndGgsIDIpO1xyXG4gIGxldCBvdXRwdXRTaGFwZSA9IFtpbnB1dHNbMF0uZGltc1swXSwgaW5wdXRzWzBdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzFdLCBpbnB1dHNbMV0uZGltc1syXV07XHJcbiAgaWYgKGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycpIHtcclxuICAgIG91dHB1dFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMV0uZGltc1sxXSwgaW5wdXRzWzFdLmRpbXNbMl0sIGlucHV0c1swXS5kaW1zWzNdXTtcclxuICAgIFtpZHhOLCBpZHhDLCBpZHhILCBpZHhXXSA9IFswLCAzLCAxLCAyXTtcclxuICB9XHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGdyaWRTaGFwZSwgb3V0cHV0U2hhcGUpLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBncmlkLCBvdXRwdXQpfVxyXG4gICR7Z3NHZXRDdWJpY0NvZWZmc31cclxuICAke2dzQmljdWJpY0ludGVycG9sYXRlKGRhdGFUeXBlKX1cclxuICAke2dzRGVub3JtYWxpemUoYXR0cmlidXRlcyl9XHJcbiAgJHtnc1JlZmxlY3QoYXR0cmlidXRlcyl9XHJcbiAgJHtwaXhlbEF0R3JpZCh4LCBkYXRhVHlwZSwgYXR0cmlidXRlcyl9XHJcblxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgICAgbGV0IEhfaW4gPSBpMzIodW5pZm9ybXMueF9zaGFwZVske2lkeEh9XSk7XHJcbiAgICAgIGxldCBXX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtpZHhXfV0pO1xyXG5cclxuICAgICAgJHtcclxuICAgICAgICBhdHRyaWJ1dGVzLmFsaWduQ29ybmVycyA9PT0gMFxyXG4gICAgICAgICAgPyBgXHJcbiAgICAgIGxldCB4X21pbiA9IC0wLjU7XHJcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDAuNTtcclxuICAgICAgbGV0IHlfbWluID0gLTAuNTtcclxuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMC41O1xyXG4gICAgICBgXHJcbiAgICAgICAgICA6IGBcclxuICAgICAgbGV0IHhfbWluID0gMC4wO1xyXG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAxLjA7XHJcbiAgICAgIGxldCB5X21pbiA9IDAuMDtcclxuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMS4wO1xyXG4gICAgICBgXHJcbiAgICAgIH07XHJcbiAgICAgIGxldCBib3JkZXIgPSB2ZWM0PGYzMj4oeF9taW4sIHlfbWluLCB4X21heCwgeV9tYXgpO1xyXG5cclxuICAgICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICAgIHZhciBncmlkX2luZGljZXMgPSB2ZWMzPHUzMj4oaW5kaWNlc1ske2lkeE59XSwgaW5kaWNlc1ske2lkeEh9XSwgaW5kaWNlc1ske2lkeFd9XSk7XHJcbiAgICAgIGxldCBueHkgPSAke2dyaWQuZ2V0QnlJbmRpY2VzKCdncmlkX2luZGljZXMnKX07XHJcbiAgICAgIHZhciB4ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVswXSksIFdfaW4pO1xyXG4gICAgICB2YXIgeSA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMV0pLCBIX2luKTtcclxuXHJcbiAgICAgICR7Y29tcHV0ZVBpeGVsKG91dHB1dCwgZGF0YVR5cGUsIGF0dHJpYnV0ZXMpfVxyXG4gIH1gO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0dyaWRTYW1wbGUnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXSB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKGlucHV0cykgPT4ge1xyXG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ3JpZFNhbXBsZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR3JpZFNhbXBlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR3JpZFNhbXBsZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VHcmlkU2FtcGxlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdyaWRTYW1wZUF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xyXG4gICAgYWxpZ25Db3JuZXJzOiBhdHRyaWJ1dGVzLmFsaWduX2Nvcm5lcnMgYXMgbnVtYmVyLFxyXG4gICAgbW9kZTogYXR0cmlidXRlcy5tb2RlIGFzIE1vZGUsXHJcbiAgICBwYWRkaW5nTW9kZTogYXR0cmlidXRlcy5wYWRkaW5nX21vZGUgYXMgUGFkZGluZ01vZGUsXHJcbiAgICBmb3JtYXQ6IGF0dHJpYnV0ZXMuZm9ybWF0IGFzIEZvcm1hdCxcclxuICB9KTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBHcHVEYXRhVHlwZSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGFwcGx5QXR0ZW50aW9uLFxyXG4gIEF0dGVudGlvbkF0dHJzLFxyXG4gIEF0dGVudGlvbk1hc2tUeXBlLFxyXG4gIEF0dGVudGlvblBhcmFtZXRlcnMsXHJcbiAgQXR0ZW50aW9uUWt2Rm9ybWF0LFxyXG59IGZyb20gJy4vYXR0ZW50aW9uJztcclxuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgVW5pZm9ybXNBcnJheVR5cGUgfSBmcm9tICcuL2NvbW1vbic7XHJcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xyXG5cclxuY29uc3QgZ2V0SW5wdXQgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGk6IG51bWJlcikgPT5cclxuICBpbnB1dHMubGVuZ3RoID4gaSAmJiBpbnB1dHNbaV0uZGltcy5sZW5ndGggPiAwID8gaW5wdXRzW2ldIDogdW5kZWZpbmVkO1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uUGFyYW1ldGVycyA9PiB7XHJcbiAgY29uc3QgcXVlcnkgPSBpbnB1dHNbMF07XHJcbiAgY29uc3Qga2V5ID0gZ2V0SW5wdXQoaW5wdXRzLCAxKTtcclxuICBjb25zdCB2YWx1ZSA9IGdldElucHV0KGlucHV0cywgMik7XHJcbiAgY29uc3QgYmlhcyA9IGdldElucHV0KGlucHV0cywgMyk7XHJcbiAgY29uc3Qga2V5UGFkZGluZ01hc2sgPSBnZXRJbnB1dChpbnB1dHMsIDQpO1xyXG4gIGNvbnN0IGF0dGVudGlvbkJpYXMgPSBnZXRJbnB1dChpbnB1dHMsIDUpO1xyXG4gIGNvbnN0IHBhc3RLZXkgPSBnZXRJbnB1dChpbnB1dHMsIDYpO1xyXG4gIGNvbnN0IHBhc3RWYWx1ZSA9IGdldElucHV0KGlucHV0cywgNyk7XHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIE5vdGF0aW9uczpcclxuICAvLyAgICBCOiBiYXRjaF9zaXplXHJcbiAgLy8gICAgTjogbnVtX2hlYWRzXHJcbiAgLy8gICAgSDogaGVhZF9zaXplIG9mIFEgYW5kIEtcclxuICAvLyAgICBIX3Y6IGhlYWRfc2l6ZSBvZiBWXHJcbiAgLy8gICAgRDogaGlkZGVuX3NpemUgZm9yIFEgYW5kIEssIHdoZXJlIEQgPSBOICogSFxyXG4gIC8vICAgIERfdjogaGlkZGVuX3NpemUgb2YgViwgd2hlcmUgRF92ID0gTiAqIEhfdlxyXG4gIC8vICAgIFM6IHFfc2VxdWVuY2VfbGVuZ3RoXHJcbiAgLy8gICAgUDogcGFzdF9zZXF1ZW5jZV9sZW5ndGggb2Yga3YgY2FjaGVcclxuICAvLyAgICBMOiBrdl9zZXF1ZW5jZV9sZW5ndGhcclxuICAvLyAgICBUOiB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBQICsgTFxyXG4gIC8vICAgIE06IG1heF9zZXF1ZW5jZV9sZW5ndGggb2Yga3YgY2FjaGUgd2hlbiBwYXN0IGFuZCBwcmVzZW50IHNoYXJlIGJ1ZmZlclxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIE11bHRpSGVhZEF0dGVudGlvbiBpbnB1dHM6XHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgLy8gIFFfS19WX0JTTkggLSBubyBwYWNraW5nOlxyXG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxyXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBEKVxyXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IChCLCBMLCBEX3YpXHJcbiAgLy8gIFFfS19WX0JTTkhfQk5TSF9CTlNIIC0gY3Jvc3MgYXR0ZW50aW9uIChrdiBjYWNoZSBpcyBub3QgdXNlZCwgTCA9PSBULCBEID09IERfdik6XHJcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXHJcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIE4sIEwsIEgpXHJcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogKEIsIE4sIEwsIEhfdilcclxuICAvLyAgUV9LVl9CU05IX0JTTjJIIC0gcGFja2VkIGt2IChrdiBjYWNoZSBpcyBub3QgdXNlZCwgYmlhcyBpcyBub3QgYWxsb3dlZCBmb3IgcGFja2VkIGt2KTpcclxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcclxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSy9WKSAgICAgOiAoQiwgTCwgTiwgMiwgSClcclxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAgICAgICAgICAgOiBOb25lXHJcbiAgLy8gIFFLVl9CU04zSCAtIHBhY2tlZCBxa3YgKGt2IGNhY2hlIGlzIG5vdCB1c2VkLCBTID09IEwsIEQgPT0gRF92KTpcclxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUS9LL1YpICAgOiAoQiwgUywgTiwgMywgSClcclxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAgICAgICAgICAgOiBOb25lXHJcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgICAgICAgICAgIDogTm9uZVxyXG4gIC8vXHJcbiAgLy8gIE90aGVyIGlucHV0czpcclxuICAvLyAgICAgYmlhcyAgICAgICAgICAgICAoUS9LL1YpICAgOiBOb25lIG9yIChEICsgRCArIERfdilcclxuICAvLyAgICAga2V5X3BhZGRpbmdfbWFzayAoSy9WKSAgICAgOiAoQikgb3IgKDMgKiBCICsgMikgb3IgKEIsIFQpIG9yIChCLCBTLCBUKVxyXG4gIC8vICAgICBhdHRlbnRpb25fYmlhcyAgICAgICAgICAgICA6IE5vbmUgb3IgKEIsIE4sIFMsIFQpLCAoMSwgTiwgUywgVCksIChCLCAxLCBTLCBUKSBvciAoMSwgMSwgUywgVClcclxuICAvLyAgICAgcGFzdF9rZXkgICAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUCwgSCkgb3IgTm9uZS4gUGFzdCBzdGF0ZSBpcyBvbmx5IGFsbG93ZWQgZm9yIFFfS19WX0JTTkguXHJcbiAgLy8gICAgIHBhc3RfdmFsdWUgICAgICAgICAgICAgICAgIDogKEIsIE4sIFAsIEgpIG9yIE5vbmUuIFBhc3Qgc3RhdGUgaXMgb25seSBhbGxvd2VkIGZvciBRX0tfVl9CU05ILlxyXG4gIC8vXHJcbiAgLy8gIE5vdCBTdXBwb3J0ZWQ6XHJcbiAgLy8gICAgIGtleV9wYWRkaW5nX21hc2ssIHBhY2tlZCBrdiwgcGFja2VkIHFrdiwgYW5kIGJyb2FkY2FzdCBmb3IgYXR0ZW50aW9uX2JpYXMuXHJcblxyXG4gIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBiYXRjaFNpemUgPSBxdWVyeS5kaW1zWzBdO1xyXG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gcXVlcnkuZGltc1sxXTtcclxuICBjb25zdCBoaWRkZW5TaXplID0gcXVlcnkuZGltcy5sZW5ndGggPT09IDMgPyBxdWVyeS5kaW1zWzJdIDogYXR0cmlidXRlcy5udW1IZWFkcyAqIHF1ZXJ5LmRpbXNbNF07XHJcbiAgbGV0IGt2U2VxdWVuY2VMZW5ndGggPSBzZXF1ZW5jZUxlbmd0aDtcclxuXHJcbiAgbGV0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IDA7XHJcbiAgbGV0IG1heFNlcXVlbmNlTGVuZ3RoID0gMDtcclxuICBjb25zdCBoZWFkU2l6ZSA9IE1hdGguZmxvb3IoaGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpO1xyXG4gIGlmIChwYXN0S2V5ICYmIHBhc3RWYWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpICYmIFNoYXBlVXRpbC5zaXplKHBhc3RWYWx1ZS5kaW1zKSkge1xyXG4gICAgaWYgKHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuICAgIGlmIChwYXN0S2V5LmRpbXNbMF0gIT09IGJhdGNoU2l6ZSB8fCBwYXN0S2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwgcGFzdEtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO1xyXG4gICAgfVxyXG4gICAgaWYgKFxyXG4gICAgICBwYXN0VmFsdWUuZGltc1swXSAhPT0gYmF0Y2hTaXplIHx8XHJcbiAgICAgIHBhc3RWYWx1ZS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8XHJcbiAgICAgIHBhc3RWYWx1ZS5kaW1zWzNdICE9PSBoZWFkU2l6ZVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtcclxuICAgIH1cclxuICAgIGlmIChwYXN0S2V5LmRpbXNbMl0gIT09IHBhc3RWYWx1ZS5kaW1zWzJdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKScpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XHJcbiAgICB9XHJcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XHJcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1syXTtcclxuICB9IGVsc2UgaWYgKChwYXN0S2V5ICYmIFNoYXBlVXRpbC5zaXplKHBhc3RLZXkuZGltcykpIHx8IChwYXN0VmFsdWUgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO1xyXG4gIH1cclxuXHJcbiAgbGV0IHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0O1xyXG4gIGlmIChrZXkgJiYgU2hhcGVVdGlsLnNpemUoa2V5LmRpbXMpID4gMCkge1xyXG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoIDwgMyB8fCBrZXkuZGltcy5sZW5ndGggPiA1KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IGtleS5kaW1zWzBdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gcXVlcnkuZGltc1syXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAoaGlkZGVuX3NpemUpJyk7XHJcbiAgICAgIH1cclxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJTTkg7XHJcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcclxuICAgIH0gZWxzZSBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSA1KSB7XHJcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gMiB8fCBrZXkuZGltc1s0XSAhPT0gaGVhZFNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO1xyXG4gICAgICB9XHJcbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xS3ZCU05IeEJTTjJIO1xyXG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBrZXlfZGltcy5zaXplKCkgPT0gNCAoY3Jvc3MtYXR0ZW50aW9uIHdpdGggcGFzdF9rZXkpXHJcbiAgICAgIGlmIChrZXkuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gaGVhZFNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnVua25vd247IC8vIFFfS19WX0JTTkhfQk5TSF9CTlNIXHJcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1syXTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gcGFja2VkIFFLVlxyXG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBxdWVyeS5kaW1zWzNdICE9PSAzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xyXG4gICAgfVxyXG5cclxuICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU04zSDtcclxuICB9XHJcblxyXG4gIGlmIChiaWFzICYmIFNoYXBlVXRpbC5zaXplKGJpYXMuZGltcykgPiAwKSB7XHJcbiAgICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDUgJiYga2V5LmRpbXNbM10gPT09IDIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgbm90IGFsbG93ZWQgZm9yIHBhY2tlZCBrdi4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIGt2U2VxdWVuY2VMZW5ndGg7XHJcblxyXG4gIGxldCBtYXNrVHlwZTogQXR0ZW50aW9uTWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5ub25lO1xyXG4gIGlmIChrZXlQYWRkaW5nTWFzayAmJiBTaGFwZVV0aWwuc2l6ZShrZXlQYWRkaW5nTWFzay5kaW1zKSA+IDApIHtcclxuICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd247XHJcbiAgICBjb25zdCBtYXNrRGltcyA9IGtleVBhZGRpbmdNYXNrLmRpbXM7XHJcbiAgICBpZiAobWFza0RpbXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIGlmIChtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplKSB7XHJcbiAgICAgICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrMWRLZXlTZXFMZW47XHJcbiAgICAgIH0gZWxzZSBpZiAobWFza0RpbXNbMF0gPT09IDMgKiBiYXRjaFNpemUgKyAyKSB7XHJcbiAgICAgICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrMURLZXlTZXFMZW5TdGFydDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtYXNrRGltcy5sZW5ndGggPT09IDIgJiYgbWFza0RpbXNbMF0gPT09IGJhdGNoU2l6ZSAmJiBtYXNrRGltc1sxXSA9PT0gdG90YWxTZXF1ZW5jZUxlbmd0aCkge1xyXG4gICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2syZEtleVBhZGRpbmc7XHJcbiAgICB9XHJcbiAgICBpZiAobWFza1R5cGUgPT09IEF0dGVudGlvbk1hc2tUeXBlLm1hc2tVbmtub3duKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hc2sgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgbGV0IHBhc3NQYXN0SW5LdiA9IGZhbHNlO1xyXG4gIGxldCB2SGlkZGVuU2l6ZSA9IGhpZGRlblNpemU7XHJcbiAgaWYgKHZhbHVlICYmIFNoYXBlVXRpbC5zaXplKHZhbHVlLmRpbXMpID4gMCkge1xyXG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoICE9PSAzICYmIHZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0gdmFsdWUuZGltc1swXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggPT09IDMpIHtcclxuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMV0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XHJcbiAgICAgIH1cclxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzJdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gUV9LX1ZfQlNOSF9CTlNIX0JOU0hcclxuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMl0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XHJcbiAgICAgIH1cclxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzFdICogdmFsdWUuZGltc1szXTtcclxuICAgICAgcGFzc1Bhc3RJbkt2ID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGJyb2FkY2FzdFJlc1Bvc0JpYXMgPSBmYWxzZTtcclxuXHJcbiAgaWYgKGtleVBhZGRpbmdNYXNrICYmIFNoYXBlVXRpbC5zaXplKGtleVBhZGRpbmdNYXNrLmRpbXMpID4gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICB9XHJcblxyXG4gIGlmIChhdHRlbnRpb25CaWFzICYmIFNoYXBlVXRpbC5zaXplKGF0dGVudGlvbkJpYXMuZGltcykgPiAwKSB7XHJcbiAgICBpZiAoYXR0ZW50aW9uQmlhcy5kaW1zLmxlbmd0aCAhPT0gNCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IHN1cHBvcnQgYnJvYWRjYXN0aW5nIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGRpbWVuc2lvbnMgb2YgYXR0ZW50aW9uX2JpYXMuXHJcbiAgICBpZiAoXHJcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1swXSAhPT0gYmF0Y2hTaXplIHx8XHJcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fFxyXG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMl0gIT09IHNlcXVlbmNlTGVuZ3RoIHx8XHJcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1szXSAhPT0gdG90YWxTZXF1ZW5jZUxlbmd0aFxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBiYXRjaFNpemUsXHJcbiAgICBzZXF1ZW5jZUxlbmd0aCxcclxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcclxuICAgIGt2U2VxdWVuY2VMZW5ndGgsXHJcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgbWF4U2VxdWVuY2VMZW5ndGgsXHJcbiAgICBpbnB1dEhpZGRlblNpemU6IDAsXHJcbiAgICBoaWRkZW5TaXplLFxyXG4gICAgdkhpZGRlblNpemUsXHJcbiAgICBoZWFkU2l6ZSxcclxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxyXG4gICAgbnVtSGVhZHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMsXHJcbiAgICBpc1VuaWRpcmVjdGlvbmFsOiBmYWxzZSxcclxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxyXG4gICAgbWFza0ZpbHRlclZhbHVlOiBhdHRyaWJ1dGVzLm1hc2tGaWx0ZXJWYWx1ZSxcclxuICAgIG1hc2tUeXBlLFxyXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXHJcbiAgICBicm9hZGNhc3RSZXNQb3NCaWFzLFxyXG4gICAgcGFzc1Bhc3RJbkt2LFxyXG4gICAgcWt2Rm9ybWF0LFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uQXR0cnMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyAuLi5hdHRyaWJ1dGVzIH0pO1xyXG5cclxuY29uc3Qgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgcGVybTogWzAsIDIsIDEsIDNdIH0pO1xyXG5cclxuY29uc3QgYWRkQmlhc1RyYW5zcG9zZSA9IChcclxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcclxuICBxa3Y6IFRlbnNvclZpZXcsXHJcbiAgYmlhczogVGVuc29yVmlldyxcclxuICBiYXRjaFNpemU6IG51bWJlcixcclxuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxyXG4gIGhpZGRlblNpemU6IG51bWJlcixcclxuICBiaWFzT2Zmc2V0OiBudW1iZXIsXHJcbikgPT4ge1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgc2VxdWVuY2VMZW5ndGgsIGhpZGRlblNpemVdO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBiaWFzT2Zmc2V0IH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaGlkZGVuU2l6ZSB9LFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Frdl93aXRoX2JpYXMnLCBxa3YuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcclxuICAgIGNvbnN0IHFrdklucHV0ID0gaW5wdXRWYXJpYWJsZSgncWt2JywgcWt2LmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XHJcbiAgICBjb25zdCBiaWFzSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgYmlhcy5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xyXG5cclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdiaWFzX29mZnNldCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gYFxyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMocWt2SW5wdXQsIGJpYXNJbnB1dCwgb3V0cHV0KX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcbiAgICBsZXQgYmlhc19vZmZzZXRfaWR4ID0gKGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgKyB1bmlmb3Jtcy5iaWFzX29mZnNldDtcclxuXHJcbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xyXG4gIH1gO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdNdWx0aUhlYWRBdHRlbnRpb25BZGRCaWFzJyxcclxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZScsICd0eXBlJ10gfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHFrdi5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgICAgfSksXHJcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIH0sXHJcbiAgICB7IGlucHV0czogW3FrdiwgYmlhc10sIG91dHB1dHM6IFstMV0gfSxcclxuICApWzBdO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyA9IChcclxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcclxuICBiYXRjaFNpemU6IG51bWJlcixcclxuICBudW1IZWFkczogbnVtYmVyLFxyXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXHJcbiAgaGVhZFNpemU6IG51bWJlcixcclxuICBpbnB1dDogVGVuc29yVmlldyxcclxuICBiaWFzPzogVGVuc29yVmlldyxcclxuICBiaWFzT2Zmc2V0PzogbnVtYmVyLFxyXG4pID0+IHtcclxuICAvLyBjb25zdCBuZXdEaW1zID0gW107XHJcblxyXG4gIGxldCByZXNoYXBlZElucHV0ID0gaW5wdXQ7XHJcbiAgaWYgKCEoYmlhcyAmJiBTaGFwZVV0aWwuc2l6ZShiaWFzLmRpbXMpID4gMCkpIHtcclxuICAgIGlmIChpbnB1dC5kaW1zLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICByZXNoYXBlZElucHV0ID0gaW5wdXQucmVzaGFwZShbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIGhlYWRTaXplXSk7XHJcbiAgICB9XHJcbiAgICBpZiAobnVtSGVhZHMgPT09IDEgfHwgc2VxdWVuY2VMZW5ndGggPT09IDEpIHtcclxuICAgICAgcmV0dXJuIHJlc2hhcGVkSW5wdXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSwge1xyXG4gICAgICBpbnB1dHM6IFtyZXNoYXBlZElucHV0XSxcclxuICAgICAgb3V0cHV0czogWy0xXSxcclxuICAgIH0pWzBdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoc2VxdWVuY2VMZW5ndGggPT09IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRCaWFzUmVzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQuIFBsZWFzZSBleHBvcnQgeW91ciBtb2RlbCB3aXRoIHBhY2tlZCBRS1Ygb3IgS1YnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc2hhcGVkSW5wdXQgPSBhZGRCaWFzVHJhbnNwb3NlKFxyXG4gICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgaW5wdXQsXHJcbiAgICAgICAgYmlhcyxcclxuICAgICAgICBiYXRjaFNpemUsXHJcbiAgICAgICAgc2VxdWVuY2VMZW5ndGgsXHJcbiAgICAgICAgbnVtSGVhZHMgKiBoZWFkU2l6ZSxcclxuICAgICAgICBiaWFzT2Zmc2V0ISxcclxuICAgICAgKTtcclxuICAgICAgcmVzaGFwZWRJbnB1dCA9IHJlc2hhcGVkSW5wdXQucmVzaGFwZShbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIGhlYWRTaXplXSk7XHJcbiAgICAgIGlmIChudW1IZWFkcyA9PT0gMSB8fCBzZXF1ZW5jZUxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiByZXNoYXBlZElucHV0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlLnBlcm0pLCB7XHJcbiAgICAgICAgaW5wdXRzOiBbcmVzaGFwZWRJbnB1dF0sXHJcbiAgICAgICAgb3V0cHV0czogWy0xXSxcclxuICAgICAgfSlbMF07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG11bHRpSGVhZEF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiB2b2lkID0+IHtcclxuICBjb25zdCBwYXJhbXMgPSB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgY29uc3QgcXVlcnkgPSBjb250ZXh0LmlucHV0c1swXTtcclxuICBjb25zdCBrZXkgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgMSk7XHJcbiAgY29uc3QgdmFsdWUgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgMik7XHJcbiAgY29uc3QgYmlhcyA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCAzKTtcclxuICBjb25zdCBrZXlQYWRkaW5nTWFzayA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA0KTtcclxuICBjb25zdCBhdHRlbnRpb25CaWFzID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDUpO1xyXG4gIGNvbnN0IHBhc3RLZXkgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgNik7XHJcbiAgY29uc3QgcGFzdFZhbHVlID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDcpO1xyXG4gIGlmIChxdWVyeS5kaW1zLmxlbmd0aCA9PT0gNSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGtleT8uZGltcy5sZW5ndGggPT09IDUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gYXBwbHlBdHRlbnRpb24gZXhwZWN0cyBCTlNIIGlucHV0c1xyXG4gIGNvbnN0IGt2Qk5TSCA9IGtleSAmJiB2YWx1ZSAmJiBrZXkuZGltcy5sZW5ndGggPT09IDQgJiYgdmFsdWUuZGltcy5sZW5ndGggPT09IDQ7XHJcblxyXG4gIGNvbnN0IFEgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXHJcbiAgICBjb250ZXh0LFxyXG4gICAgcGFyYW1zLmJhdGNoU2l6ZSxcclxuICAgIHBhcmFtcy5udW1IZWFkcyxcclxuICAgIHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCxcclxuICAgIHBhcmFtcy5oZWFkU2l6ZSxcclxuICAgIHF1ZXJ5LFxyXG4gICAgYmlhcyxcclxuICAgIDAsXHJcbiAgKTtcclxuXHJcbiAgaWYgKGt2Qk5TSCkge1xyXG4gICAgcmV0dXJuIGFwcGx5QXR0ZW50aW9uKGNvbnRleHQsIFEsIGtleSwgdmFsdWUsIGtleVBhZGRpbmdNYXNrLCB1bmRlZmluZWQsIHBhc3RLZXksIHBhc3RWYWx1ZSwgYXR0ZW50aW9uQmlhcywgcGFyYW1zKTtcclxuICB9XHJcbiAgaWYgKCFrZXkgfHwgIXZhbHVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleSBhbmQgdmFsdWUgbXVzdCBiZSBwcm92aWRlZCcpO1xyXG4gIH1cclxuICBjb25zdCBLID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxyXG4gICAgY29udGV4dCxcclxuICAgIHBhcmFtcy5iYXRjaFNpemUsXHJcbiAgICBwYXJhbXMubnVtSGVhZHMsXHJcbiAgICBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCxcclxuICAgIHBhcmFtcy5oZWFkU2l6ZSxcclxuICAgIGtleSxcclxuICAgIGJpYXMsXHJcbiAgICBwYXJhbXMuaGlkZGVuU2l6ZSxcclxuICApO1xyXG5cclxuICBjb25zdCBWID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxyXG4gICAgY29udGV4dCxcclxuICAgIHBhcmFtcy5iYXRjaFNpemUsXHJcbiAgICBwYXJhbXMubnVtSGVhZHMsXHJcbiAgICBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCxcclxuICAgIHBhcmFtcy52SGVhZFNpemUsXHJcbiAgICB2YWx1ZSxcclxuICAgIGJpYXMsXHJcbiAgICAyICogcGFyYW1zLmhpZGRlblNpemUsXHJcbiAgKTtcclxuXHJcbiAgYXBwbHlBdHRlbnRpb24oY29udGV4dCwgUSwgSywgViwga2V5UGFkZGluZ01hc2ssIHVuZGVmaW5lZCwgcGFzdEtleSwgcGFzdFZhbHVlLCBhdHRlbnRpb25CaWFzLCBwYXJhbXMpO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtLCBUZW5zb3JJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBnZXRFbGVtZW50QXQsXHJcbiAgSW5kaWNlc0hlbHBlcixcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IG51bU91dHB1dHM6IG51bWJlcjtcclxuICByZWFkb25seSBzcGxpdFNpemVzOiBudW1iZXJbXTtcclxufVxyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b28gZmV3IGlucHV0cycpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZVNwbGl0QXR0cmlidXRlc0Zyb21JbnB1dHMgPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzLFxyXG4pOiBTcGxpdEF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IHNwbGl0U2l6ZXM6IG51bWJlcltdID0gW107XHJcbiAgbGV0IG51bU91dHB1dHM6IG51bWJlciA9IGF0dHJpYnV0ZXMubnVtT3V0cHV0cztcclxuICBpZiAoaW5wdXRzWzFdLmRpbXNbMF0gPiAwKSB7XHJcbiAgICBpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goKHYpID0+IHNwbGl0U2l6ZXMucHVzaChOdW1iZXIodikpKTtcclxuICAgIG51bU91dHB1dHMgPSBzcGxpdFNpemVzLmxlbmd0aDtcclxuICB9XHJcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IG51bU91dHB1dHMsIGF4aXM6IGF0dHJpYnV0ZXMuYXhpcywgc3BsaXRTaXplcyB9KTtcclxufTtcclxuXHJcbmNvbnN0IGNhbGN1bGF0ZU91dHB1dEluZGV4SW1wbCA9IChudW1iZXJPZlRlbnNvcnM6IG51bWJlcik6IHN0cmluZyA9PiBgXHJcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XHJcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7bnVtYmVyT2ZUZW5zb3JzfXU7IGkgKz0gMXUgKSB7XHJcbiAgICBpZiAoaW5kZXggPCAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzJywgJ2knLCBudW1iZXJPZlRlbnNvcnMpfSkge1xyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICR7bnVtYmVyT2ZUZW5zb3JzfXU7XHJcbn1gO1xyXG5jb25zdCB3cml0ZUJ1ZmZlckRhdGFJbXBsID0gKG91dHB1dHM6IHJlYWRvbmx5IEluZGljZXNIZWxwZXJbXSkgPT4ge1xyXG4gIGNvbnN0IG51bWJlck9mVGVuc29ycyA9IG91dHB1dHMubGVuZ3RoO1xyXG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVGVuc29yczsgKytpKSB7XHJcbiAgICBjb25zdCByZXR1cm5TbmlwcGV0ID0gb3V0cHV0c1tpXS5zZXRCeUluZGljZXMoJ2luZGljZXMnLCAnaW5wdXRbZ2xvYmFsX2lkeF0nKTtcclxuICAgIGlmIChudW1iZXJPZlRlbnNvcnMgPT09IDEpIHtcclxuICAgICAgY29kZUxpbmVzLnB1c2gocmV0dXJuU25pcHBldCk7XHJcbiAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcclxuICAgICAgY29kZUxpbmVzLnB1c2goYGlmIChvdXRwdXRfbnVtYmVyID09ICR7aX11KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xyXG4gICAgfSBlbHNlIGlmIChpID09PSBudW1iZXJPZlRlbnNvcnMgLSAxKSB7XHJcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2RlTGluZXMucHVzaChgZWxzZSBpZiAob3V0cHV0X251bWJlciA9PSAke2l9KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gYFxyXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlcjogdTMyLCBpbmRpY2VzOiAke291dHB1dHNbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XHJcbiAgICAgICAgJHtjb2RlTGluZXMuam9pbignXFxuJyl9XHJcbiAgICAgIH1gO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XHJcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xyXG4gIGNvbnN0IG91dHB1dHMgPSBuZXcgQXJyYXk8SW5kaWNlc0hlbHBlcj4oYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCBzaXplSW5TcGxpdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihhdHRyaWJ1dGVzLm51bU91dHB1dHMpO1xyXG4gIGNvbnN0IG91dHB1dHNUZW5zb3JJbmZvOiBUZW5zb3JJbmZvW10gPSBbXTtcclxuICBjb25zdCBvdXRwdXRTaGFwZXM6IG51bWJlcltdW10gPSBbXTtcclxuICBsZXQgcHJldmlvdXNTdW0gPSAwO1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRTaXplIH1dO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5udW1PdXRwdXRzOyBpKyspIHtcclxuICAgIHByZXZpb3VzU3VtICs9IGF0dHJpYnV0ZXMuc3BsaXRTaXplc1tpXTtcclxuICAgIHNpemVJblNwbGl0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xyXG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XHJcbiAgICBvdXRwdXRTaGFwZVtheGlzXSA9IGF0dHJpYnV0ZXMuc3BsaXRTaXplc1tpXTtcclxuICAgIG91dHB1dFNoYXBlcy5wdXNoKG91dHB1dFNoYXBlKTtcclxuICAgIG91dHB1dHNbaV0gPSBvdXRwdXRWYXJpYWJsZShgb3V0cHV0JHtpfWAsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG4gICAgb3V0cHV0c1RlbnNvckluZm8ucHVzaCh7IGRpbXM6IG91dHB1dFNoYXBlc1tpXSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9KTtcclxuICB9XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2l6ZUluU3BsaXRBeGlzIH0sXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCAuLi5vdXRwdXRTaGFwZXMpLFxyXG4gICk7XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgJHtzaGFkZXJIZWxwZXJcclxuICAgIC5yZWdpc3RlclVuaWZvcm0oJ2lucHV0X3NpemUnLCAndTMyJylcclxuICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NpemVfaW5fc3BsaXRfYXhpcycsICd1MzInLCBzaXplSW5TcGxpdEF4aXMubGVuZ3RoKVxyXG4gICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIC4uLm91dHB1dHMpfVxyXG4gICR7Y2FsY3VsYXRlT3V0cHV0SW5kZXhJbXBsKHNpemVJblNwbGl0QXhpcy5sZW5ndGgpfVxyXG4gICR7d3JpdGVCdWZmZXJEYXRhSW1wbChvdXRwdXRzKX1cclxuXHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5pbnB1dF9zaXplJyl9XHJcblxyXG4gICAgdmFyIGluZGljZXMgPSAke2lucHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgIHZhciBpbmRleCA9ICR7aW5wdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGF4aXMpfTtcclxuICAgIGxldCBvdXRwdXRfbnVtYmVyID0gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXgpO1xyXG4gICAgaWYgKG91dHB1dF9udW1iZXIgIT0gMCkge1xyXG4gICAgICBpbmRleCAtPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzJywgJ291dHB1dF9udW1iZXIgLSAxdScsIHNpemVJblNwbGl0QXhpcy5sZW5ndGgpfTtcclxuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbmRpY2VzJywgYXhpcywgJ2luZGV4Jyl9O1xyXG4gICAgfVxyXG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xyXG4gIH1gO1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnU3BsaXQnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBvdXRwdXRzVGVuc29ySW5mbyxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoaW5wdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc3BsaXQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlcyA9XHJcbiAgICBjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDEgPyBhdHRyaWJ1dGVzIDogY3JlYXRlU3BsaXRBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZVNwbGl0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNwbGl0QXR0cmlidXRlcyA9PiB7XHJcbiAgY29uc3QgYXhpcyA9IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXI7XHJcbiAgY29uc3Qgc3BsaXRTaXplczogbnVtYmVyW10gPSBhdHRyaWJ1dGVzLnNwbGl0U2l6ZXMgYXMgbnVtYmVyW107XHJcbiAgY29uc3QgbnVtT3V0cHV0cyA9IChhdHRyaWJ1dGVzLm51bU91dHB1dHMgYXMgbnVtYmVyKSA8IDAgPyBzcGxpdFNpemVzLmxlbmd0aCA6IChhdHRyaWJ1dGVzLm51bU91dHB1dHMgYXMgbnVtYmVyKTtcclxuICBpZiAobnVtT3V0cHV0cyAhPT0gc3BsaXRTaXplcy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignbnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5ndGggbXVzdCBiZSBlcXVhbCcpO1xyXG4gIH1cclxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhpcywgbnVtT3V0cHV0cywgc3BsaXRTaXplcyB9KTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgV09SS0dST1VQX1NJWkUgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMge1xyXG4gIHJlYWRvbmx5IGludGVybGVhdmVkOiBib29sZWFuO1xyXG4gIHJlYWRvbmx5IG51bUhlYWRzOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgcm90YXJ5RW1iZWRkaW5nRGltOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgc2NhbGU6IG51bWJlcjtcclxufVxyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICBjb25zdCBbaW5wdXQsIHBvc2l0aW9uSWRzLCBjb3NDYWNoZSwgc2luQ2FjaGVdID0gaW5wdXRzO1xyXG4gIGNvbnN0IHsgbnVtSGVhZHMsIHJvdGFyeUVtYmVkZGluZ0RpbSB9ID0gYXR0cmlidXRlcztcclxuXHJcbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzICYmIGlucHV0LmRpbXMubGVuZ3RoICE9PSA0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICd4JyBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zLCBnb3QgJHtpbnB1dC5kaW1zLmxlbmd0aH1gKTtcclxuICB9XHJcbiAgaWYgKFxyXG4gICAgIVNoYXBlVXRpbC5hcmVFcXVhbChwb3NpdGlvbklkcy5kaW1zLCBbXSkgJiZcclxuICAgICFTaGFwZVV0aWwuYXJlRXF1YWwocG9zaXRpb25JZHMuZGltcywgWzFdKSAmJlxyXG4gICAgcG9zaXRpb25JZHMuZGltcy5sZW5ndGggIT09IDJcclxuICApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAwLCAxLCBvciAyIGRpbWVuc2lvbnMsIGdvdCAke3Bvc2l0aW9uSWRzLmRpbXMubGVuZ3RofWApO1xyXG4gIH1cclxuICBpZiAoY29zQ2FjaGUuZGltcy5sZW5ndGggIT09IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke2Nvc0NhY2hlLmRpbXMubGVuZ3RofWApO1xyXG4gIH1cclxuICBpZiAoc2luQ2FjaGUuZGltcy5sZW5ndGggIT09IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Npbl9jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke3NpbkNhY2hlLmRpbXMubGVuZ3RofWApO1xyXG4gIH1cclxuICBpZiAoIVNoYXBlVXRpbC5hcmVFcXVhbChjb3NDYWNoZS5kaW1zLCBzaW5DYWNoZS5kaW1zKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXRzICdjb3NfY2FjaGUnIGFuZCAnc2luX2NhY2hlJyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTtcclxuICB9XHJcblxyXG4gIGlmIChyb3RhcnlFbWJlZGRpbmdEaW0gPiAwICYmIG51bUhlYWRzID09PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bV9oZWFkcyBtdXN0IGJlIHByb3ZpZGVkIGlmIHJvdGFyeV9lbWJlZGRpbmdfZGltIGlzIHNwZWNpZmllZCcpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXQuZGltc1swXTtcclxuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0LmRpbXNbaW5wdXQuZGltcy5sZW5ndGggLSAyXTtcclxuICBjb25zdCBtYXhTZXF1ZW5jZUxlbmd0aCA9IGNvc0NhY2hlLmRpbXNbMF07XHJcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dC5kaW1zLCAxKSAvIHNlcXVlbmNlTGVuZ3RoO1xyXG4gIGNvbnN0IGhlYWRTaXplID0gcm90YXJ5RW1iZWRkaW5nRGltID09PSAwID8gY29zQ2FjaGUuZGltc1sxXSAqIDIgOiBoaWRkZW5TaXplIC8gbnVtSGVhZHM7XHJcbiAgaWYgKHJvdGFyeUVtYmVkZGluZ0RpbSA+IGhlYWRTaXplKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdGFyeV9lbWJlZGRpbmdfZGltIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGhlYWRfc2l6ZScpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHBvc2l0aW9uSWRzLmRpbXMubGVuZ3RoID09PSAyKSB7XHJcbiAgICBpZiAoYmF0Y2hTaXplICE9PSBwb3NpdGlvbklkcy5kaW1zWzBdKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDAgc2hvdWxkIGJlIG9mIHNpemUgYmF0Y2hfc2l6ZSwgZ290ICR7cG9zaXRpb25JZHMuZGltc1swXX1gKTtcclxuICAgIH1cclxuICAgIGlmIChzZXF1ZW5jZUxlbmd0aCAhPT0gcG9zaXRpb25JZHMuZGltc1sxXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBvZiBzaXplIHNlcXVlbmNlX2xlbmd0aCwgZ290ICR7cG9zaXRpb25JZHMuZGltc1sxXX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChoZWFkU2l6ZSAvIDIgIT09IGNvc0NhY2hlLmRpbXNbMV0gJiYgcm90YXJ5RW1iZWRkaW5nRGltIC8gMiAhPT0gY29zQ2FjaGUuZGltc1sxXSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgSW5wdXQgJ2Nvc19jYWNoZScgZGltZW5zaW9uIDEgc2hvdWxkIGJlIHNhbWUgYXMgaGVhZF9zaXplIC8gMiBvciByb3RhcnlfZW1iZWRkaW5nX2RpbSAvIDIsIGdvdCAke1xyXG4gICAgICAgIGNvc0NhY2hlLmRpbXNbMV1cclxuICAgICAgfWAsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaWYgKHNlcXVlbmNlTGVuZ3RoID4gbWF4U2VxdWVuY2VMZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRpbmcgY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW4gUm90YXJ5RW1iZWRkaW5nIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJvdGFyeUVtYmVkZGluZ1Byb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCB7IGludGVybGVhdmVkLCBudW1IZWFkcywgcm90YXJ5RW1iZWRkaW5nRGltLCBzY2FsZSB9ID0gYXR0cmlidXRlcztcclxuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dHNbMF0uZGltc1swXTtcclxuICBjb25zdCBiYXRjaFN0cmlkZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dHNbMF0uZGltcywgMSk7XHJcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dHNbMF0uZGltc1tpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyXTtcclxuICBjb25zdCBoaWRkZW5TaXplID0gYmF0Y2hTdHJpZGUgLyBzZXF1ZW5jZUxlbmd0aDtcclxuICBjb25zdCBoYWxmUm90YXJ5RW1iZWRkaW5nRGltID0gaW5wdXRzWzJdLmRpbXNbMV07XHJcbiAgY29uc3QgaGVhZFNpemUgPSByb3RhcnlFbWJlZGRpbmdEaW0gPT09IDAgPyBoYWxmUm90YXJ5RW1iZWRkaW5nRGltICogMiA6IGhpZGRlblNpemUgLyBudW1IZWFkcztcclxuXHJcbiAgLy8gUm90YXJ5IGVtYmVkZGluZ3Mgd2lsbCBiZSBjYWxjdWxhdGVkIGluIGEgcGFpci13aXNlIGZhc2hpb24uIEluIGFjY29yZGFuY2UsIHVzZSB0aGUgc2hhcGVcclxuICAvLyBbYmF0Y2ggc2l6ZSwgc2VxdWVuY2UgbGVuZ3RoLCBudW0gb2YgaGVhZHMsIG51bSBvZiBwYWlycyB0byByb3RhdGUgKyBudW0gb2YgZGltcyB0byBjb3B5XVxyXG4gIC8vIHRvIHVuZm9sZCB0aGUgZ2xvYmFsIGluZGV4IGluIHNoYWRlci5cclxuICBjb25zdCBnbG9iYWxTaGFwZSA9IG5ldyBBcnJheTxudW1iZXI+KFxyXG4gICAgYmF0Y2hTaXplLFxyXG4gICAgc2VxdWVuY2VMZW5ndGgsXHJcbiAgICBoaWRkZW5TaXplIC8gaGVhZFNpemUsXHJcbiAgICBoZWFkU2l6ZSAtIGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0sXHJcbiAgKTtcclxuICBjb25zdCBnbG9iYWxTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGdsb2JhbFNoYXBlKTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogc2NhbGUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnbG9iYWxTaGFwZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGdsb2JhbFN0cmlkZXMgfSxcclxuXHJcbiAgICAvLyBzdHJpZGVzIGZvciBhZGRyZXNzaW5nIHRoZSBpbnB1dC9vdXRwdXQgdGVuc29yLCBpbiBwZXJtdXRhdGVkIG9yZGVyIHRvIGFsaWduIHdpdGggdGhlIHVuZm9sZGVkIGdsb2JhbCBpbmRleCxcclxuICAgIC8vIGkuZS4gQlNOSFxyXG4gICAgLi4uKGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gM1xyXG4gICAgICA/IG5ldyBBcnJheTxQcm9ncmFtVW5pZm9ybT4oeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFtiYXRjaFN0cmlkZSwgaGlkZGVuU2l6ZSwgaGVhZFNpemUsIDFdIH0pXHJcbiAgICAgIDogW10pLFxyXG4gICAgLi4uKGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNFxyXG4gICAgICA/IG5ldyBBcnJheTxQcm9ncmFtVW5pZm9ybT4oe1xyXG4gICAgICAgICAgdHlwZTogRGF0YVR5cGUudWludDMyLFxyXG4gICAgICAgICAgZGF0YTogW2JhdGNoU3RyaWRlLCBoZWFkU2l6ZSwgc2VxdWVuY2VMZW5ndGggKiBoZWFkU2l6ZSwgMV0sXHJcbiAgICAgICAgfSlcclxuICAgICAgOiBbXSksXHJcblxyXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBpbnB1dHNbMl0uZGltcywgaW5wdXRzWzNdLmRpbXMsIGlucHV0c1swXS5kaW1zKSxcclxuICBdO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBwb3NpdGlvbklkcyA9IGlucHV0VmFyaWFibGUoJ3Bvc2l0aW9uX2lkcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGNvc0NhY2hlID0gaW5wdXRWYXJpYWJsZSgnY29zX2NhY2hlJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xyXG4gICAgY29uc3Qgc2luQ2FjaGUgPSBpbnB1dFZhcmlhYmxlKCdzaW5fY2FjaGUnLCBpbnB1dHNbM10uZGF0YVR5cGUsIGlucHV0c1szXS5kaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xyXG5cclxuICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKFtcclxuICAgICAgeyBuYW1lOiAnc2NhbGUnLCB0eXBlOiAnZjMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdnbG9iYWxfc2hhcGUnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBnbG9iYWxTaGFwZS5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAnZ2xvYmFsX3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBnbG9iYWxTdHJpZGVzLmxlbmd0aCB9LFxyXG4gICAgICB7IG5hbWU6ICdpbnB1dF9vdXRwdXRfc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGdsb2JhbFN0cmlkZXMubGVuZ3RoIH0sXHJcbiAgICBdKTtcclxuXHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIHBvc2l0aW9uSWRzLCBjb3NDYWNoZSwgc2luQ2FjaGUsIG91dHB1dCl9XHJcblxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChXT1JLR1JPVVBfU0laRSl9XHJcbiAgICAgICAgICBsZXQgaGFsZl9yb3RhcnlfZW1iX2RpbSA9IHVuaWZvcm1zLiR7Y29zQ2FjaGUubmFtZX1fc2hhcGVbMV07XHJcbiAgICAgICAgICBsZXQgYnNuaCA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlcyAlIHVuaWZvcm1zLmdsb2JhbF9zaGFwZTtcclxuICAgICAgICAgIGxldCBzaXplID0gdW5pZm9ybXMuZ2xvYmFsX3NoYXBlWzBdICogdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXNbMF07XHJcbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCdzaXplJyl9XHJcblxyXG4gICAgICAgICAgaWYgKGJzbmhbM10gPCBoYWxmX3JvdGFyeV9lbWJfZGltKSB7XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZHNfaWR4ID1cclxuICAgICAgICAgICAgICAgICR7cG9zaXRpb25JZHMuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ2JzbmgueHknLCBvdXRwdXRWYXJpYWJsZSgnJywgcG9zaXRpb25JZHMudHlwZS50ZW5zb3IsIDIpKX07XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZCA9XHJcbiAgICAgICAgICAgICAgICB1MzIoJHtwb3NpdGlvbklkcy5nZXRCeU9mZnNldCgncG9zaXRpb25faWRzX2lkeCcpfSkgKyBzZWxlY3QoMCwgYnNuaFsxXSwgcG9zaXRpb25faWRzX2lkeCA9PSAwKTtcclxuICAgICAgICAgICAgbGV0IGkgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgc2VsZWN0KDAsIGJzbmhbM10sICR7aW50ZXJsZWF2ZWR9KTtcclxuICAgICAgICAgICAgbGV0IGogPSBpICsgc2VsZWN0KGhhbGZfcm90YXJ5X2VtYl9kaW0sIDEsICR7aW50ZXJsZWF2ZWR9KTtcclxuICAgICAgICAgICAgbGV0IHJlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnaScpfSAqICR7Y29zQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9IC1cclxuICAgICAgICAgICAgICAgICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2onKX0gKiAke3NpbkNhY2hlLmdldCgncG9zaXRpb25faWQnLCAnYnNuaFszXScpfTtcclxuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2knLCAncmUnKX1cclxuICAgICAgICAgICAgbGV0IGltID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnaScpfSAqICR7c2luQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9ICtcclxuICAgICAgICAgICAgICAgICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2onKX0gKiAke2Nvc0NhY2hlLmdldCgncG9zaXRpb25faWQnLCAnYnNuaFszXScpfTtcclxuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2onLCAnaW0nKX1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBrID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIGhhbGZfcm90YXJ5X2VtYl9kaW07XHJcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdrJywgaW5wdXQuZ2V0QnlPZmZzZXQoJ2snKSl9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdSb3RhcnlFbWJlZGRpbmcnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcclxuICAgICAgICBpbnRlcmxlYXZlZCxcclxuICAgICAgfSkuY2FjaGVLZXksXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuaycsICdyYW5rJywgJ3JhbmsnXSxcclxuICAgIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBpbnB1dHNbMF0uZGltcywgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoZ2xvYmFsU2hhcGUpIC8gV09SS0dST1VQX1NJWkUpIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgcm90YXJ5RW1iZWRkaW5nID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVSb3RhcnlFbWJlZGRpbmdQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgYXBwbHlBdHRlbnRpb24sIEF0dGVudGlvbk1hc2tUeXBlLCBBdHRlbnRpb25QYXJhbWV0ZXJzLCBBdHRlbnRpb25Ra3ZGb3JtYXQgfSBmcm9tICcuL2F0dGVudGlvbic7XHJcbmltcG9ydCB7IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyB9IGZyb20gJy4vbXVsdGloZWFkLWF0dGVudGlvbic7XHJcbmltcG9ydCB7IGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8sIFNwbGl0QXR0cmlidXRlcyB9IGZyb20gJy4vc3BsaXQnO1xyXG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbywgVHJhbnNwb3NlQXR0cmlidXRlcyB9IGZyb20gJy4vdHJhbnNwb3NlJztcclxuaW1wb3J0IHsgUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcywgY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8gfSBmcm9tICcuL3JvdGFyeS1lbWJlZGRpbmcnO1xyXG5pbXBvcnQgeyBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZSB9IGZyb20gJy4vY29tbW9uJztcclxuZXhwb3J0IGludGVyZmFjZSBHcm91cFF1ZXJ5QXR0ZW50aW9uQXR0cmlidXRlcyB7XHJcbiAgbnVtSGVhZHM6IG51bWJlcjtcclxuICBrdk51bUhlYWRzOiBudW1iZXI7XHJcbiAgc2NhbGU6IG51bWJlcjtcclxuICBzb2Z0Y2FwOiBudW1iZXI7XHJcbiAgZG9Sb3Rhcnk6IG51bWJlcjtcclxuICByb3RhcnlJbnRlcmxlYXZlZDogbnVtYmVyO1xyXG4gIHNtb290aFNvZnRtYXg6IGJvb2xlYW47XHJcbiAgbG9jYWxXaW5kb3dTaXplOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUlucHV0cyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBHcm91cFF1ZXJ5QXR0ZW50aW9uQXR0cmlidXRlcyxcclxuKTogQXR0ZW50aW9uUGFyYW1ldGVycyA9PiB7XHJcbiAgaWYgKGF0dHJpYnV0ZXMuZG9Sb3RhcnkgJiYgaW5wdXRzLmxlbmd0aCA8PSA3KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nvc19jYWNoZSBhbmQgc2luX2NhY2hlIGlucHV0cyBhcmUgcmVxdWlyZWQgaWYgZG9fcm90YXJ5IGlzIHNwZWNpZmllZCcpO1xyXG4gIH1cclxuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcclxuICBjb25zdCBrZXkgPSBpbnB1dHNbMV07XHJcbiAgY29uc3QgdmFsdWUgPSBpbnB1dHNbMl07XHJcbiAgY29uc3QgcGFzdEtleSA9IGlucHV0c1szXTtcclxuICBjb25zdCBwYXN0VmFsdWUgPSBpbnB1dHNbNF07XHJcbiAgaWYgKGF0dHJpYnV0ZXMuZG9Sb3RhcnkgIT09IDAgJiYgaW5wdXRzLmxlbmd0aCA8PSA3KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nvc19jYXN0IGFuZCBzaW5fY2FjaGUgYXJlIGV4cGVjdGVkIGlmIGRvX3JvdGFyeSBhdHRyaWJ1dGUgaXMgbm9uLXplcm8nKTtcclxuICB9XHJcbiAgaWYgKGF0dHJpYnV0ZXMubG9jYWxXaW5kb3dTaXplICE9PSAtMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhbCBhdHRlbnRpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuICBpZiAoYXR0cmlidXRlcy5zb2Z0Y2FwICE9PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvZnRjYXAgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuICBpZiAoYXR0cmlidXRlcy5yb3RhcnlJbnRlcmxlYXZlZCAhPT0gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3RhcnkgaW50ZXJsZWF2ZWQgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuICBpZiAoYXR0cmlidXRlcy5zbW9vdGhTb2Z0bWF4KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Ntb290aCBzb2Z0bWF4IGlzIG5vdCBzdXBwb3J0ZWQnKTtcclxuICB9XHJcbiAgLy8gQWJicmV2aWF0aW9uIGFuZCBNZWFuaW5nczpcclxuICAvLyAgIEI6ICAgIGJhdGNoX3NpemVcclxuICAvLyAgIFM6ICAgIHNlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIHF1ZXJ5KVxyXG4gIC8vICAgUDogICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggKHBhc3Qgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcclxuICAvLyAgIEw6ICAgIGt2X3NlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcclxuICAvLyAgIE06ICAgIG1heF9zZXF1ZW5jZV9sZW5ndGhcclxuICAvLyAgIFQ6ICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsga3Zfc2VxdWVuY2VfbGVuZ3RoXHJcbiAgLy8gICBOOiAgICBudW1faGVhZHNcclxuICAvLyAgIEg6ICAgIGhlYWQgc2l6ZSBmb3IgUSBhbmQgSywgYWthIHFfaGVhZF9zaXplIG9yIGtfaGVhZF9zaXplIG9yIHFrX2hlYWRfc2l6ZVxyXG4gIC8vICAgSF92OiAgdl9oZWFkX3NpemVcclxuICAvLyAgIERfaTogIGlucHV0IGhpZGRlbiBzaXplXHJcbiAgLy8gICBEOiAgICBoaWRkZW4gc2l6ZSBmb3IgUSBhbmQgSyAoRCA9IE4gKiBIKSwgYWthIHFfaGlkZGVuX3NpemUgb3Iga19oaWRkZW5fc2l6ZSBvciBxa19oaWRkZW5fc2l6ZVxyXG4gIC8vICAgRF92OiAgdl9oaWRkZW5fc2l6ZSA9IG51bV9oZWFkcyAqIHZfaGVhZF9zaXplXHJcblxyXG4gIC8vICAgICBwYXN0X2tleSAgICAgICAgICAgICAgICAgICA6IChCLCBOLCBTKiwgSClcclxuICAvLyAgICAgcGFzdF92YWx1ZSAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUyosIEgpXHJcbiAgLy8gV2hlbiBubyBwYWNraW5nIGZvciBxL2svdjpcclxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcclxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiAoQiwgTCwgRCkgb3IgKEIsIE4sIFMqLCBIKVxyXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IChCLCBMLCBEX3YpIG9yIChCLCBOLCBTKiwgSClcclxuICAvLyBXaGVuIHBhY2tlZCBrdiBpcyB1c2VkOlxyXG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxyXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBOLCAyLCBIKVxyXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IE5vbmVcclxuICAvLyBXaGVuIHBhY2tlZCBxa3YgaXMgdXNlZDpcclxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgTCwgTiwgMywgSCkgb3IgKEIsIFMsIDMqRClcclxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiBOb25lXHJcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogTm9uZVxyXG5cclxuICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucycpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZG1taGFQYWNraW5nID0gZmFsc2U7XHJcbiAgY29uc3QgYmF0Y2hTaXplID0gcXVlcnkuZGltc1swXTtcclxuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IHF1ZXJ5LmRpbXNbMV07XHJcbiAgbGV0IGhpZGRlblNpemUgPVxyXG4gICAgcXVlcnkuZGltcy5sZW5ndGggPT09IDMgPyAoZG1taGFQYWNraW5nID8gcXVlcnkuZGltc1syXSAvIDMgOiBxdWVyeS5kaW1zWzJdKSA6IGF0dHJpYnV0ZXMubnVtSGVhZHMgKiBxdWVyeS5kaW1zWzRdO1xyXG4gIGxldCBrdlNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XHJcblxyXG4gIGxldCBwYXN0U2VxdWVuY2VMZW5ndGggPSAwO1xyXG4gIGNvbnN0IHBhY2tlZFFLViA9ICFrZXkgfHwga2V5LmRpbXMubGVuZ3RoID09PSAwO1xyXG4gIGNvbnN0IGhlYWRTaXplID0gIXBhY2tlZFFLVlxyXG4gICAgPyBNYXRoLmZsb29yKGhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKVxyXG4gICAgOiBNYXRoLmZsb29yKGhpZGRlblNpemUgLyAoYXR0cmlidXRlcy5udW1IZWFkcyArIDIgKiBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMpKTtcclxuICBpZiAocGFja2VkUUtWKSB7XHJcbiAgICBoaWRkZW5TaXplID0gaGVhZFNpemUgKiBhdHRyaWJ1dGVzLm51bUhlYWRzO1xyXG4gIH1cclxuICBjb25zdCBoYXNQYXN0S2V5ID0gcGFzdEtleSAmJiBwYXN0S2V5LmRpbXMubGVuZ3RoICE9PSAwO1xyXG4gIGNvbnN0IGhhc1Bhc3RWYWx1ZSA9IHBhc3RWYWx1ZSAmJiBwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDA7XHJcbiAgLy8gQ3VycmVudGx5IHRoZSBvbm54cnVudGltZSBHUUEgc3BlY2lmaWNhdGlvbiBvbmx5IHN1cHBvcnQga2V5L3ZhbHVlIEJOU0ggZm9ybWF0LlxyXG4gIGNvbnN0IGlzUGFzdGt2QlNOSCA9XHJcbiAgICBoYXNQYXN0S2V5ICYmXHJcbiAgICBwYXN0S2V5LmRpbXMubGVuZ3RoID09PSA0ICYmXHJcbiAgICBwYXN0S2V5LmRpbXNbMF0gPT09IGJhdGNoU2l6ZSAmJlxyXG4gICAgcGFzdEtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMgJiZcclxuICAgIHBhc3RLZXkuZGltc1syXSA9PT0gYXR0cmlidXRlcy5rdk51bUhlYWRzICYmXHJcbiAgICBwYXN0S2V5LmRpbXNbM10gPT09IGhlYWRTaXplO1xyXG5cclxuICBpZiAoaXNQYXN0a3ZCU05IKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JTTkggcGFzdEtleS9wYXN0VmFsdWUgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuICBpZiAoaGFzUGFzdEtleSAmJiBoYXNQYXN0VmFsdWUpIHtcclxuICAgIGlmIChwYXN0S2V5LmRpbXMubGVuZ3RoICE9PSA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFzdFZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1syXTtcclxuICB9IGVsc2UgaWYgKGhhc1Bhc3RLZXkgfHwgaGFzUGFzdFZhbHVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7XHJcbiAgfVxyXG5cclxuICBsZXQgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2Qk5TSDtcclxuICBpZiAoa2V5ICYmIGtleS5kaW1zLmxlbmd0aCA+IDApIHtcclxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA8IDMgfHwga2V5LmRpbXMubGVuZ3RoID4gNSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSBrZXkuZGltc1swXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICBpZiAocXVlcnkuZGltc1syXSAlIGtleS5kaW1zWzJdICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gMiBvZiBcInF1ZXJ5XCIgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgXCJrZXlcIicpO1xyXG4gICAgICB9XHJcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcclxuICAgIH0gZWxzZSBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSA1KSB7XHJcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gMiB8fCBrZXkuZGltc1s0XSAhPT0gaGVhZFNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO1xyXG4gICAgICB9XHJcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGtleV9kaW1zLnNpemUoKSA9PSA0IChjcm9zcy1hdHRlbnRpb24gd2l0aCBwYXN0X2tleSlcclxuICAgICAgaWYgKGtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO1xyXG4gICAgICB9XHJcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1syXTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gcGFja2VkIFFLVlxyXG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzICYmIHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtcclxuICAgIH1cclxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCA9PT0gNSAmJiAocXVlcnkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBxdWVyeS5kaW1zWzNdICE9PSAzKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcclxuICAgIH1cclxuXHJcbiAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOM0g7XHJcbiAgfVxyXG5cclxuICBjb25zdCBtYXNrVHlwZTogQXR0ZW50aW9uTWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5ub25lO1xyXG4gIGxldCBwYXNzUGFzdEluS3YgPSBmYWxzZTtcclxuICBsZXQgdkhpZGRlblNpemUgPSBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMgPyBoZWFkU2l6ZSAqIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyA6IGhpZGRlblNpemU7XHJcbiAgaWYgKHZhbHVlICYmIHZhbHVlLmRpbXMubGVuZ3RoID4gMCkge1xyXG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoICE9PSAzICYmIHZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0gdmFsdWUuZGltc1swXSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggPT09IDMpIHtcclxuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMV0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XHJcbiAgICAgIH1cclxuICAgICAgdkhpZGRlblNpemUgPSB2YWx1ZS5kaW1zWzJdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMl0pIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO1xyXG4gICAgICB9XHJcbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1sxXSAqIHZhbHVlLmRpbXNbM107XHJcbiAgICAgIHBhc3NQYXN0SW5LdiA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHNlcWxMZW5zID0gaW5wdXRzLmxlbmd0aCA+IDQgPyBpbnB1dHNbNV0gOiB1bmRlZmluZWQ7XHJcbiAgaWYgKHNlcWxMZW5zICYmIHNlcWxMZW5zLmRpbXMubGVuZ3RoICE9PSAxICYmIHNlcWxMZW5zLmRpbXNbMF0gIT09IGJhdGNoU2l6ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInNlcWxlbnNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uIGFuZCB0aGUgc2FtZSBkaW0gMCBhcyBiYXRjaF9zaXplJyk7XHJcbiAgfVxyXG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSAtMTtcclxuICBjb25zdCBtYXhTZXF1ZW5jZUxlbmd0aCA9IC0xO1xyXG4gIGNvbnN0IGJyb2FkY2FzdFJlc1Bvc0JpYXMgPSBmYWxzZTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGJhdGNoU2l6ZSxcclxuICAgIHNlcXVlbmNlTGVuZ3RoLFxyXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxyXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcclxuICAgIHRvdGFsU2VxdWVuY2VMZW5ndGgsXHJcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCxcclxuICAgIGlucHV0SGlkZGVuU2l6ZTogMCxcclxuICAgIGhpZGRlblNpemUsXHJcbiAgICB2SGlkZGVuU2l6ZSxcclxuICAgIGhlYWRTaXplLFxyXG4gICAgdkhlYWRTaXplOiBNYXRoLmZsb29yKHZIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5rdk51bUhlYWRzKSxcclxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxyXG4gICAga3ZOdW1IZWFkczogYXR0cmlidXRlcy5rdk51bUhlYWRzLFxyXG4gICAgblJlcHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMgLyBhdHRyaWJ1dGVzLmt2TnVtSGVhZHMsXHJcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcclxuICAgIG1hc2tUeXBlLFxyXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXHJcbiAgICBicm9hZGNhc3RSZXNQb3NCaWFzLFxyXG4gICAgcGFzc1Bhc3RJbkt2LFxyXG4gICAgcWt2Rm9ybWF0LFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGU6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBwZXJtOiBbMCwgMiwgMSwgM10gfSk7XHJcblxyXG5jb25zdCBtYXliZVRyYW5zcG9zZVRvQk5TSCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXQ6IFRlbnNvclZpZXcsIHBhcmFtczogQXR0ZW50aW9uUGFyYW1ldGVycykgPT4ge1xyXG4gIGxldCByZXNoYXBlZElucHV0ID0gaW5wdXQ7XHJcbiAgY29uc3QgbnVtSGVhZHMgPSBwYXJhbXMua3ZOdW1IZWFkcyE7XHJcbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoID09PSAzICYmIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoICE9PSAwKSB7XHJcbiAgICByZXNoYXBlZElucHV0ID0gaW5wdXQucmVzaGFwZShbcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGgsIG51bUhlYWRzLCBwYXJhbXMuaGVhZFNpemVdKTtcclxuICAgIHJlc2hhcGVkSW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlLnBlcm0pLCB7XHJcbiAgICAgIGlucHV0czogW3Jlc2hhcGVkSW5wdXRdLFxyXG4gICAgICBvdXRwdXRzOiBbLTFdLFxyXG4gICAgfSlbMF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzaGFwZWRJbnB1dDtcclxufTtcclxuXHJcbmNvbnN0IGdlbmVyYXRlUG9zaXRpb25JZHNQcm9ncmFtSW5mbyA9IChcclxuICBiYXRjaFNpemU6IG51bWJlcixcclxuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxyXG4gIHNlcUxlbnM6IFRlbnNvclZpZXcsXHJcbiAgdG90YWxTZXFMZW46IFRlbnNvclZpZXcsXHJcbikgPT4ge1xyXG4gIGNvbnN0IG91dHB1dERhdGFUeXBlID0gRGF0YVR5cGUuaW50NjQ7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSAqIHNlcXVlbmNlTGVuZ3RoXTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gYmF0Y2hTaXplICogc2VxdWVuY2VMZW5ndGg7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzZXF1ZW5jZUxlbmd0aCB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJhdGNoU2l6ZSB9LFxyXG4gIF07XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBzZXFMZW5zSW5wdXRIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdzZXFfbGVucycsIHNlcUxlbnMuZGF0YVR5cGUsIHNlcUxlbnMuZGltcyk7XHJcbiAgICBjb25zdCB0b3RhbFNlcUxlbklucHV0SGVscGVyID0gaW5wdXRWYXJpYWJsZSgndG90YWxfc2VxX2xlbnMnLCB0b3RhbFNlcUxlbi5kYXRhVHlwZSwgdG90YWxTZXFMZW4uZGltcyk7XHJcbiAgICBjb25zdCBwb3NpdGlvbklkc0hlbHBlciA9IG91dHB1dFZhcmlhYmxlKCdwb3NfaWRzJywgb3V0cHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcclxuXHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYmF0Y2hfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhzZXFMZW5zSW5wdXRIZWxwZXIsIHRvdGFsU2VxTGVuSW5wdXRIZWxwZXIsIHBvc2l0aW9uSWRzSGVscGVyKX1cclxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcbiAgICBsZXQgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdTMyKCR7dG90YWxTZXFMZW5JbnB1dEhlbHBlci5nZXRCeU9mZnNldCgnMCcpfSk7XHJcbiAgICBsZXQgaXNfc3Vic2VxdWVudF9wcm9tcHQgPSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGggPiAxICYmIHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCAhPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XHJcbiAgICBsZXQgaXNfZmlyc3RfcHJvbXB0ID0gIWlzX3N1YnNlcXVlbnRfcHJvbXB0ICYmIHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XHJcbiAgICBsZXQgYmF0Y2hfaWR4ID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aDtcclxuICAgIGxldCBzZXF1ZW5jZV9pZHggPSBpMzIoZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aCk7XHJcbiAgICB2YXIgcG9zX2lkOiBpMzIgPSAwO1xyXG4gICAgbGV0IHNlcWxlbiA9ICR7c2VxTGVuc0lucHV0SGVscGVyLmdldEJ5T2Zmc2V0KCdiYXRjaF9pZHgnKX07XHJcbiAgICBsZXQgdG90YWxfc2VxbGVuID0gc2VxbGVuICsgMTtcclxuICAgIGlmIChpc19maXJzdF9wcm9tcHQpIHtcclxuICAgICAgaWYgKHNlcXVlbmNlX2lkeCA8IHRvdGFsX3NlcWxlbikge1xyXG4gICAgICAgIHBvc19pZCA9IHNlcXVlbmNlX2lkeDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwb3NfaWQgPSAxO1xyXG4gICAgICB9XHJcbiAgICAgICR7cG9zaXRpb25JZHNIZWxwZXIuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAncG9zX2lkJyl9XHJcbiAgICB9IGVsc2UgaWYgKGlzX3N1YnNlcXVlbnRfcHJvbXB0KSB7XHJcbiAgICAgIGxldCBwYXN0X3NlcWxlbiA9IHRvdGFsX3NlcWxlbiAtIGkzMih1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGgpO1xyXG4gICAgICBpZiAocGFzdF9zZXFsZW4gKyBzZXF1ZW5jZV9pZHggPCB0b3RhbF9zZXFsZW4pIHtcclxuICAgICAgICBwb3NfaWQgPSBwYXN0X3NlcWxlbiArIHNlcXVlbmNlX2lkeDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwb3NfaWQgPSAxO1xyXG4gICAgICB9XHJcbiAgICAgICR7cG9zaXRpb25JZHNIZWxwZXIuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAncG9zX2lkJyl9XHJcbiAgICB9IGVsc2UgaWYgKGdsb2JhbF9pZHggPCB1bmlmb3Jtcy5iYXRjaF9zaXplKSB7XHJcbiAgICAgICR7cG9zaXRpb25JZHNIZWxwZXIuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnc2VxbGVuJyl9XHJcbiAgICB9O1xyXG4gIH1cclxuICBgO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdHZW5lcmF0ZVBvc2l0aW9uSWRzJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2JhdGNoU2l6ZX07JHtzZXF1ZW5jZUxlbmd0aH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdyb3VwUXVlcnlBdHRlbnRpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdyb3VwUXVlcnlBdHRlbnRpb25BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgY29uc3QgcGFyYW1zID0gdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xyXG4gIGlmIChjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aCA9PT0gNSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBxID0gY29udGV4dC5pbnB1dHNbMF07XHJcbiAgY29uc3QgayA9IGNvbnRleHQuaW5wdXRzWzFdICYmIGNvbnRleHQuaW5wdXRzWzFdLmRpbXMubGVuZ3RoID4gMCA/IGNvbnRleHQuaW5wdXRzWzFdIDogdW5kZWZpbmVkO1xyXG4gIGNvbnN0IHYgPSBjb250ZXh0LmlucHV0c1syXSAmJiBjb250ZXh0LmlucHV0c1syXS5kaW1zLmxlbmd0aCA+IDAgPyBjb250ZXh0LmlucHV0c1syXSA6IHVuZGVmaW5lZDtcclxuICBjb25zdCBwYXN0S2V5ID0gY29udGV4dC5pbnB1dHNbM10gJiYgY29udGV4dC5pbnB1dHNbM10uZGltcy5sZW5ndGggIT09IDAgPyBjb250ZXh0LmlucHV0c1szXSA6IHVuZGVmaW5lZDtcclxuICBjb25zdCBwYXN0VmFsdWUgPSBjb250ZXh0LmlucHV0c1s0XSAmJiBjb250ZXh0LmlucHV0c1s0XS5kaW1zLmxlbmd0aCAhPT0gMCA/IGNvbnRleHQuaW5wdXRzWzRdIDogdW5kZWZpbmVkO1xyXG4gIGNvbnN0IHNlcUxlbnMgPSBjb250ZXh0LmlucHV0cy5sZW5ndGggPiA0ID8gY29udGV4dC5pbnB1dHNbNV0gOiB1bmRlZmluZWQ7XHJcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aElucHV0ID0gY29udGV4dC5pbnB1dHMubGVuZ3RoID4gNSA/IGNvbnRleHQuaW5wdXRzWzZdIDogdW5kZWZpbmVkO1xyXG4gIGNvbnN0IGt2TnVtSGVhZHMgPSBwYXJhbXMua3ZOdW1IZWFkcyA/IHBhcmFtcy5rdk51bUhlYWRzIDogcGFyYW1zLm51bUhlYWRzO1xyXG5cclxuICAvLyBUT0RPIFJlbW92ZSBleHBsaWNpdCBzcGxpdCBvcGVyYXRpb24gYW5kIHVzZSBpbmRleGluZyBpbiBBdHRlbnRpb24gaW1wbGVtZW50YXRpb24gdG8gYXZvaWQgb3ZlcmhlYWQuXHJcblxyXG4gIGNvbnN0IHNwbGl0QXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcclxuICAgIGF4aXM6IDIsXHJcbiAgICBudW1PdXRwdXRzOiAzLFxyXG4gICAgc3BsaXRTaXplczogW3BhcmFtcy5udW1IZWFkcyAqIHBhcmFtcy5oZWFkU2l6ZSwga3ZOdW1IZWFkcyAqIHBhcmFtcy5oZWFkU2l6ZSwga3ZOdW1IZWFkcyAqIHBhcmFtcy5oZWFkU2l6ZV0sXHJcbiAgfSk7XHJcbiAgY29uc3QgW3F1ZXJ5LCBrZXksIHZhbHVlXSA9XHJcbiAgICAhayAmJiAhdlxyXG4gICAgICA/IGNvbnRleHQuY29tcHV0ZShjcmVhdGVTcGxpdFByb2dyYW1JbmZvKFtxXSwgc3BsaXRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFtxXSwgb3V0cHV0czogWy0xLCAtMSwgLTFdIH0pXHJcbiAgICAgIDogW3EsIGshLCB2IV07XHJcbiAgbGV0IHFSb3Rhcnk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQ7XHJcbiAgbGV0IGtSb3Rhcnk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQ7XHJcbiAgaWYgKGF0dHJpYnV0ZXMuZG9Sb3RhcnkpIHtcclxuICAgIGNvbnN0IHBvc0lkcyA9IGNvbnRleHQuY29tcHV0ZShcclxuICAgICAgZ2VuZXJhdGVQb3NpdGlvbklkc1Byb2dyYW1JbmZvKHBhcmFtcy5iYXRjaFNpemUsIHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCwgc2VxTGVucyEsIHRvdGFsU2VxdWVuY2VMZW5ndGhJbnB1dCEpLFxyXG4gICAgICB7IGlucHV0czogW3NlcUxlbnMhLCB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQhXSwgb3V0cHV0czogWy0xXSB9LFxyXG4gICAgKVswXTtcclxuICAgIGNvbnN0IGNvc0NhY2hlID0gY29udGV4dC5pbnB1dHNbN107XHJcbiAgICBjb25zdCBzaW5DYWNoZSA9IGNvbnRleHQuaW5wdXRzWzhdO1xyXG4gICAgY29uc3QgcVJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xyXG4gICAgICBpbnRlcmxlYXZlZDogYXR0cmlidXRlcy5yb3RhcnlJbnRlcmxlYXZlZCAhPT0gMCxcclxuICAgICAgbnVtSGVhZHM6IHBhcmFtcy5udW1IZWFkcyxcclxuICAgICAgcm90YXJ5RW1iZWRkaW5nRGltOiAwLFxyXG4gICAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgaW5wdXRzID0gW3F1ZXJ5LCBwb3NJZHMsIGNvc0NhY2hlLCBzaW5DYWNoZV07XHJcbiAgICBjb25zdCBvdXRwdXRzID0gWy0xXTtcclxuICAgIHFSb3RhcnkgPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8oaW5wdXRzLCBxUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyksIHtcclxuICAgICAgaW5wdXRzLFxyXG4gICAgICBvdXRwdXRzLFxyXG4gICAgfSlbMF07XHJcbiAgICBpbnB1dHMuc3BsaWNlKDAsIDEsIGtleSk7XHJcbiAgICBjb25zdCBrUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XHJcbiAgICAgIGludGVybGVhdmVkOiBhdHRyaWJ1dGVzLnJvdGFyeUludGVybGVhdmVkICE9PSAwLFxyXG4gICAgICBudW1IZWFkczogcGFyYW1zLmt2TnVtSGVhZHMhLFxyXG4gICAgICByb3RhcnlFbWJlZGRpbmdEaW06IDAsXHJcbiAgICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxyXG4gICAgfSk7XHJcbiAgICBrUm90YXJ5ID0gY29udGV4dC5jb21wdXRlKGNyZWF0ZVJvdGFyeUVtYmVkZGluZ1Byb2dyYW1JbmZvKGlucHV0cywga1JvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMpLCB7XHJcbiAgICAgIGlucHV0cyxcclxuICAgICAgb3V0cHV0cyxcclxuICAgIH0pWzBdO1xyXG4gIH1cclxuICBjb25zdCBRID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxyXG4gICAgY29udGV4dCxcclxuICAgIHBhcmFtcy5iYXRjaFNpemUsXHJcbiAgICBwYXJhbXMubnVtSGVhZHMsXHJcbiAgICBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsXHJcbiAgICBwYXJhbXMuaGVhZFNpemUsXHJcbiAgICBhdHRyaWJ1dGVzLmRvUm90YXJ5ID8gcVJvdGFyeSEgOiBxdWVyeSxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIDAsXHJcbiAgKTtcclxuICBjb25zdCBLID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0goY29udGV4dCwgYXR0cmlidXRlcy5kb1JvdGFyeSA/IGtSb3RhcnkhIDoga2V5LCBwYXJhbXMpO1xyXG4gIGNvbnN0IFYgPSBtYXliZVRyYW5zcG9zZVRvQk5TSChjb250ZXh0LCB2YWx1ZSwgcGFyYW1zKTtcclxuXHJcbiAgYXBwbHlBdHRlbnRpb24oXHJcbiAgICBjb250ZXh0LFxyXG4gICAgUSxcclxuICAgIEssXHJcbiAgICBWLFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgdW5kZWZpbmVkLFxyXG4gICAgcGFzdEtleSxcclxuICAgIHBhc3RWYWx1ZSxcclxuICAgIHVuZGVmaW5lZCxcclxuICAgIHBhcmFtcyxcclxuICAgIHNlcUxlbnMsXHJcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoSW5wdXQsXHJcbiAgKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBnZXRNYXhDb21wb25lbnRzLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIHN1bVZlY3RvcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzIHtcclxuICBlcHNpbG9uOiBudW1iZXI7XHJcbiAgZm9ybWF0OiAnTkhXQycgfCAnTkNIVyc7XHJcbn1cclxuXHJcbmNvbnN0IGNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdCA9IChcclxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcclxuICBpbnB1dDogVGVuc29yVmlldyxcclxuICBzY2FsZTogVGVuc29yVmlldyxcclxuICBiaWFzOiBUZW5zb3JWaWV3LFxyXG4gIG46IG51bWJlcixcclxuICBoOiBudW1iZXIsXHJcbiAgYzogbnVtYmVyLFxyXG4gIGVwc2lsb246IG51bWJlcixcclxuKSA9PiB7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoaCk7XHJcbiAgY29uc3QgZjMyVHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAnZjMyJyA6IGB2ZWMke2NvbXBvbmVudHN9ZmA7XHJcbiAgY29uc3Qgd2dUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICd2ZWMyZicgOiBgbWF0Mngke2NvbXBvbmVudHN9ZmA7XHJcbiAgY29uc3QgdW5pdHNPZldvcmsgPSBuICogYztcclxuICBsZXQgd29ya2dyb3VwU2l6ZSA9IDY0O1xyXG4gIGlmICh1bml0c09mV29yayA9PT0gMSkge1xyXG4gICAgd29ya2dyb3VwU2l6ZSA9IDI1NjtcclxuICB9XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IFtuLCBjLCBoIC8gY29tcG9uZW50c107XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbbiwgYywgMl07XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAndHlwZScsICd0eXBlJ107XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpKTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCAzLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IHMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIHNjYWxlLmRhdGFUeXBlLCBzY2FsZS5kaW1zKTtcclxuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgYmlhcy5kYXRhVHlwZSwgYmlhcy5kaW1zKTtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgMywgMik7XHJcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbeCwgcywgYiwgb3V0cHV0XTtcclxuICAgIHJldHVybiBgXHJcbiAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZCA6IGFycmF5PCR7d2dUeXBlfSwgJHt3b3JrZ3JvdXBTaXplfT47XHJcbiAgY29uc3Qgd29ya2dyb3VwX3NpemUgPSAke3dvcmtncm91cFNpemV9dTtcclxuICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XHJcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KHdvcmtncm91cFNpemUpfVxyXG4gICAgbGV0IGJhdGNoID0gd29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMueF9zaGFwZVsxXTtcclxuICAgIGxldCBjaGFubmVsID0gd29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMueF9zaGFwZVsxXTtcclxuICAgIGxldCBoaWdodCA9IHVuaWZvcm1zLnhfc2hhcGVbMl07XHJcbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcclxuICAgIHZhciBzdW0gPSAke2YzMlR5cGV9KDApO1xyXG4gICAgdmFyIHNxdWFyZWRfc3VtID0gJHtmMzJUeXBlfSgwKTtcclxuICAgIGZvciAodmFyIGggPSBsb2NhbF9pZHg7IGggPCBoaWdodDsgaCArPSB3b3JrZ3JvdXBfc2l6ZSkge1xyXG4gICAgICBsZXQgdmFsdWUgPSAke2YzMlR5cGV9KCR7eC5nZXQoJ2JhdGNoJywgJ2NoYW5uZWwnLCAnaCcpfSk7XHJcbiAgICAgIHN1bSArPSB2YWx1ZTtcclxuICAgICAgc3F1YXJlZF9zdW0gKz0gdmFsdWUgKiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9ICR7d2dUeXBlfShzdW0sIHNxdWFyZWRfc3VtKTtcclxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdvcmtncm91cF9zaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xyXG4gICAgICBpZiAobG9jYWxfaWR4IDwgY3VyclNpemUpIHtcclxuICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gKyB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeCArIGN1cnJTaXplXTtcclxuICAgICAgfVxyXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcbiAgICB9XHJcbiAgICBpZiAobG9jYWxfaWR4ID09IDApIHtcclxuICAgICAgbGV0IHN1bV9maW5hbCA9ICR7c3VtVmVjdG9yKCd3b3JrZ3JvdXBfc2hhcmVkWzBdWzBdJywgY29tcG9uZW50cyl9IC8gZjMyKGhpZ2h0ICogJHtjb21wb25lbnRzfSk7XHJcbiAgICAgIGxldCBzcXVhcmVkX3N1bV9maW5hbCA9ICR7c3VtVmVjdG9yKCd3b3JrZ3JvdXBfc2hhcmVkWzBdWzFdJywgY29tcG9uZW50cyl9IC8gZjMyKGhpZ2h0ICogJHtjb21wb25lbnRzfSk7XHJcblxyXG4gICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkX3N1bV9maW5hbCAtIHN1bV9maW5hbCAqIHN1bV9maW5hbCArIGYzMigke2Vwc2lsb259KSk7XHJcbiAgICAgIGxldCBjaGFubmVsX3NjYWxlID0gaW52X3N0ZF9kZXYgKiBmMzIoc2NhbGVbY2hhbm5lbF0pO1xyXG4gICAgICBsZXQgY2hhbm5lbF9zaGlmdCA9IGYzMihiaWFzW2NoYW5uZWxdKSAtIHN1bV9maW5hbCAqIGNoYW5uZWxfc2NhbGU7XHJcbiAgICAgIG91dHB1dFt3b3JrZ3JvdXBfaW5kZXhdID0gdmVjMmYoY2hhbm5lbF9zY2FsZSwgY2hhbm5lbF9zaGlmdCk7XHJcbiAgICB9XHJcbiAgfWA7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcclxuICAgIHtcclxuICAgICAgbmFtZTogJ0luc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdCcsXHJcbiAgICAgIC8vIFRPRE86IHVzZSBlcHNpbG9uIGFzIHVuaWZvcm0uIEN1cnJlbnRseSBlcHNpbG9uIGFzIHVuaWZvcm0gZmFpbHMgdGVzdF9pbnN0YW5jZW5vcm1fZXBzaWxvbi5cclxuICAgICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7Y29tcG9uZW50c307JHtlcHNpbG9ufTske3dvcmtncm91cFNpemV9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0IH1dLFxyXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogdW5pdHNPZldvcmsgfSxcclxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICAgIH0pLFxyXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICB9LFxyXG4gICAgeyBpbnB1dHM6IFtpbnB1dCwgc2NhbGUsIGJpYXNdLCBvdXRwdXRzOiBbLTFdIH0sXHJcbiAgKVswXTtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZUluc3RhbmNlTm9ybVByb2dyYW1JbmZvID0gKFxyXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMsXHJcbikgPT4ge1xyXG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xyXG4gIGNvbnN0IGF4aXMgPSAyO1xyXG4gIGNvbnN0IE4gPSB4U2hhcGVbMF07XHJcbiAgY29uc3QgQyA9IHhTaGFwZVsxXTtcclxuICBjb25zdCBIID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoSCk7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHM7XHJcbiAgLy8gY29tcHV0ZSBjaGFubmVsIHNjYWxlIGFuZCBjaGFubmVsIHNoaWZ0LlxyXG4gIGNvbnN0IGNoYW5uZWxTY2FsZVNoaWZ0ID0gY29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0KFxyXG4gICAgY29udGV4dCxcclxuICAgIGlucHV0c1swXSxcclxuICAgIGlucHV0c1sxXSxcclxuICAgIGlucHV0c1syXSxcclxuICAgIE4sXHJcbiAgICBILFxyXG4gICAgQyxcclxuICAgIGF0dHJpYnV0ZXMuZXBzaWxvbixcclxuICApO1xyXG5cclxuICBjb25zdCBpbnB1dFNoYXBlID0gW04sIEMsIEggLyBjb21wb25lbnRzXTtcclxuICBjb25zdCBzY2FsZVNoYXBlID0gW04sIENdO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ25vbmUnXTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZV9zaGlmdCcsIERhdGFUeXBlLmZsb2F0LCBzY2FsZVNoYXBlLmxlbmd0aCwgMik7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XHJcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbeCwgc2NhbGUsIG91dHB1dF07XHJcbiAgICByZXR1cm4gYFxyXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRJbmRpY2VzWzBdO1xyXG4gICAgICBsZXQgY2hhbm5lbCA9IG91dHB1dEluZGljZXNbMV07XHJcbiAgICAgIGxldCBzY2FsZV9zaGlmdCA9ICR7c2NhbGUuZ2V0QnlJbmRpY2VzKCd2ZWMyPHUzMj4oYmF0Y2gsIGNoYW5uZWwpJyl9O1xyXG4gICAgICBsZXQgdmFsdWUgPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX0gKiAke291dHB1dC50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC54KSArICR7b3V0cHV0LnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LnkpO1xyXG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcclxuICB9YDtcclxuICB9O1xyXG5cclxuICBjb250ZXh0LmNvbXB1dGUoXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1hbGl6YXRpb24nLFxyXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtjb21wb25lbnRzfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXHJcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXHJcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIHNjYWxlU2hhcGUsIGlucHV0U2hhcGUpLFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0pLFxyXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICB9LFxyXG4gICAgeyBpbnB1dHM6IFtpbnB1dHNbMF0sIGNoYW5uZWxTY2FsZVNoaWZ0XSB9LFxyXG4gICk7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVJbnN0YW5jZU5vcm1OSFdDUHJvZ3JhbUluZm8gPSAoXHJcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogSW5zdGFuY2VOb3JtQXR0cmlidXRlcyxcclxuKSA9PiB7XHJcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XHJcbiAgY29uc3QgTiA9IHhTaGFwZVswXTtcclxuICBjb25zdCBDID0geFNoYXBlW3hTaGFwZS5sZW5ndGggLSAxXTtcclxuICBjb25zdCBIID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgMSkgLyBDO1xyXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEMpO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBIIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5mbG9vcihDIC8gY29tcG9uZW50cykgfSxcclxuICBdO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcclxuXHJcbiAgLy8gMS4gdHJhbnNwb3NlIHggZnJvbSBOSFdDIHRvIE5DSFdcclxuICBsZXQgbmVlZFRyYW5zcG9zZSA9IGZhbHNlO1xyXG4gIGNvbnN0IHRyYW5zcG9zZWRYUGVybSA9IFswLCB4U2hhcGUubGVuZ3RoIC0gMV07XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4U2hhcGUubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICBuZWVkVHJhbnNwb3NlID0gbmVlZFRyYW5zcG9zZSB8fCB4U2hhcGVbaSArIDFdICE9PSAxO1xyXG4gICAgdHJhbnNwb3NlZFhQZXJtLnB1c2goaSArIDEpO1xyXG4gIH1cclxuXHJcbiAgbmVlZFRyYW5zcG9zZSA9IG5lZWRUcmFuc3Bvc2UgJiYgeFNoYXBlW3hTaGFwZS5sZW5ndGggLSAxXSAhPT0gMTtcclxuXHJcbiAgY29uc3QgdHJhbnNwb3NlZFggPSBuZWVkVHJhbnNwb3NlXHJcbiAgICA/IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgdHJhbnNwb3NlZFhQZXJtKSwge1xyXG4gICAgICAgIGlucHV0czogW2NvbnRleHQuaW5wdXRzWzBdXSxcclxuICAgICAgICBvdXRwdXRzOiBbLTFdLFxyXG4gICAgICB9KVswXVxyXG4gICAgOiBjb250ZXh0LmlucHV0c1swXS5yZXNoYXBlKEFycmF5LmZyb20oeyBsZW5ndGg6IHhTaGFwZS5sZW5ndGggfSwgKF8sIGkpID0+IHhTaGFwZVt0cmFuc3Bvc2VkWFBlcm1baV1dKSk7XHJcbiAgLy8gMi4gY29tcHV0ZSBjaGFubmVsIHNjYWxlIGFuZCBjaGFubmVsIHNoaWZ0LlxyXG4gIGNvbnN0IGNoYW5uZWxTY2FsZVNoaWZ0ID0gY29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0KFxyXG4gICAgY29udGV4dCxcclxuICAgIHRyYW5zcG9zZWRYLFxyXG4gICAgaW5wdXRzWzFdLFxyXG4gICAgaW5wdXRzWzJdLFxyXG4gICAgTixcclxuICAgIEgsXHJcbiAgICBDLFxyXG4gICAgYXR0cmlidXRlcy5lcHNpbG9uLFxyXG4gICk7XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xyXG4gICAgY29uc3Qgc2NhbGVUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICd2ZWMyZicgOiBgbWF0JHtjb21wb25lbnRzfXgyZmA7XHJcbiAgICBjb25zdCBzY2FsZURhdGEgPSAobnVtOiBudW1iZXIpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSBudW0gPT09IDAgPyAneCcgOiAneSc7XHJcbiAgICAgIGNvbnN0IGYzMlR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ2YzMicgOiBgdmVjJHtjb21wb25lbnRzfWZgO1xyXG4gICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICByZXR1cm4gYCR7ZGF0YVR5cGV9KCR7ZjMyVHlwZX0oc2NhbGUuJHtpbmRleH0pKWA7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgcmV0dXJuIGB2ZWMyPCR7ZGF0YVR5cGV9Pigke2YzMlR5cGV9KHNjYWxlWzBdLiR7aW5kZXh9LCBzY2FsZVsxXS4ke2luZGV4fSkpYDtcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICByZXR1cm4gYHZlYzQ8JHtkYXRhVHlwZX0+KCR7ZjMyVHlwZX0oc2NhbGVbMF0uJHtpbmRleH0sIHNjYWxlWzFdLiR7aW5kZXh9LCBzY2FsZVsyXS4ke2luZGV4fSwgc2NhbGVbM10uJHtpbmRleH0pKWA7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBjb21wb2VudHMgJHtjb21wb25lbnRzfWApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW5wdXRIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3Qgb3V0cHV0SGVscGVyID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpO1xyXG5cclxuICAgIHJldHVybiBgXHJcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7aW5wdXRIZWxwZXIudHlwZS5zdG9yYWdlfT47XHJcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZV9pbnB1dCA6IGFycmF5PCR7c2NhbGVUeXBlfT47XHJcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke291dHB1dEhlbHBlci50eXBlLnN0b3JhZ2V9PjtcclxuICBzdHJ1Y3QgVW5pZm9ybXMge0g6IHUzMiwgQyA6IHUzMn07XHJcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XHJcblxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgbGV0IGN1cnJlbnRfaW1hZ2VfbnVtYmVyID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5DICogdW5pZm9ybXMuSCk7XHJcbiAgICBsZXQgY3VycmVudF9jaGFubmVsX251bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xyXG5cclxuICAgIGxldCBzY2FsZV9vZmZzZXQgPSBjdXJyZW50X2ltYWdlX251bWJlciAqIHVuaWZvcm1zLkMgKyBjdXJyZW50X2NoYW5uZWxfbnVtYmVyO1xyXG4gICAgbGV0IHNjYWxlID0gc2NhbGVfaW5wdXRbc2NhbGVfb2Zmc2V0XTtcclxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHtzY2FsZURhdGEoMCl9LCAke3NjYWxlRGF0YSgxKX0pO1xyXG4gIH1gO1xyXG4gIH07XHJcbiAgY29udGV4dC5jb21wdXRlKFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnSW5zdGFuY2VOb3JtYWxpemF0aW9uTkhXQycsXHJcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcclxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgICB9KSxcclxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgfSxcclxuICAgIHsgaW5wdXRzOiBbaW5wdXRzWzBdLCBjaGFubmVsU2NhbGVTaGlmdF0gfSxcclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGluc3RhbmNlTm9ybSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogSW5zdGFuY2VOb3JtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmIChhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnKSB7XHJcbiAgICBjcmVhdGVJbnN0YW5jZU5vcm1OSFdDUHJvZ3JhbUluZm8oY29udGV4dCwgY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjcmVhdGVJbnN0YW5jZU5vcm1Qcm9ncmFtSW5mbyhjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgfVxyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNhc3RUb0YzMixcclxuICBmaWxsVmVjdG9yLFxyXG4gIGdldE1heENvbXBvbmVudHMsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgc3VtVmVjdG9yLFxyXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcclxuICBVbmlmb3Jtc0FycmF5VHlwZSxcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5pbnRlcmZhY2UgTGF5ZXJOb3JtQXR0cmlidXRlcyB7XHJcbiAgc2ltcGxpZmllZDogYm9vbGVhbjtcclxuICBheGlzOiBudW1iZXI7XHJcbiAgZXBzaWxvbjogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAyIGlucHV0cy4nKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVMYXllck5vcm1Qcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBMYXllck5vcm1BdHRyaWJ1dGVzLFxyXG4gIG91dHB1dENvdW50OiBudW1iZXIsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBzaW1wbGlmaWVkID0gYXR0cmlidXRlcy5zaW1wbGlmaWVkO1xyXG5cclxuICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBzY2FsZSA9IGlucHV0c1sxXTtcclxuICBjb25zdCBiaWFzID0gIXNpbXBsaWZpZWQgJiYgaW5wdXRzWzJdO1xyXG5cclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IHhTaGFwZTtcclxuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCB4U2hhcGUubGVuZ3RoKTtcclxuICBjb25zdCBub3JtQ291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XHJcbiAgY29uc3Qgbm9ybVNpemUgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oeFNoYXBlLCBheGlzKTtcclxuXHJcbiAgY29uc3Qgc2NhbGVTaXplID0gU2hhcGVVdGlsLnNpemUoc2NhbGUuZGltcyk7XHJcbiAgY29uc3QgYmlhc1NpemUgPSBiaWFzID8gU2hhcGVVdGlsLnNpemUoYmlhcy5kaW1zKSA6IDA7XHJcbiAgaWYgKHNjYWxlU2l6ZSAhPT0gbm9ybVNpemUgfHwgKGJpYXMgJiYgYmlhc1NpemUgIT09IG5vcm1TaXplKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBTaXplIG9mIFguc2hhcGUoKVtheGlzOl0gPT0gJHtub3JtU2l6ZX0uXHJcbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxyXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHtzY2FsZVNpemV9IGFuZCBiaWFzIHNpemUgb2YgJHtiaWFzU2l6ZX1gKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG1lYW5JbnZTdGREZXZEaW06IG51bWJlcltdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4U2hhcGUubGVuZ3RoOyArK2kpIHtcclxuICAgIGlmIChpIDwgYXhpcykge1xyXG4gICAgICBtZWFuSW52U3RkRGV2RGltLnB1c2goeFNoYXBlW2ldKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1lYW5JbnZTdGREZXZEaW0ucHVzaCgxKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMobm9ybVNpemUpO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbm9ybUNvdW50IH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBub3JtU2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguZmxvb3Iobm9ybVNpemUgLyBjb21wb25lbnRzKSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5lcHNpbG9uIH0sXHJcbiAgXTtcclxuICBpZiAoYmlhcykge1xyXG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xyXG4gIH1cclxuICBjb25zdCBoYXNNZWFuRGF0YU91dHB1dCA9IG91dHB1dENvdW50ID4gMTtcclxuICBjb25zdCBoYXNJbnZTdGRPdXRwdXQgPSBvdXRwdXRDb3VudCA+IDI7XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtcclxuICAgICAgaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpLFxyXG4gICAgICBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIHNjYWxlLmRhdGFUeXBlLCBzY2FsZS5kaW1zLCBjb21wb25lbnRzKSxcclxuICAgIF07XHJcbiAgICBpZiAoYmlhcykge1xyXG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgYmlhcy5kYXRhVHlwZSwgYmlhcy5kaW1zLCBjb21wb25lbnRzKSk7XHJcbiAgICB9XHJcbiAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xyXG4gICAgaWYgKGhhc01lYW5EYXRhT3V0cHV0KSB7XHJcbiAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdtZWFuX2RhdGFfb3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIG1lYW5JbnZTdGREZXZEaW0pKTtcclxuICAgIH1cclxuICAgIGlmIChoYXNJbnZTdGRPdXRwdXQpIHtcclxuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ2ludl9zdGRfb3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIG1lYW5JbnZTdGREZXZEaW0pKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ25vcm1fY291bnQnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdub3JtX3NpemUnLCB0eXBlOiAnZjMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdub3JtX3NpemVfdmVjdG9yaXplZCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2Vwc2lsb24nLCB0eXBlOiAnZjMyJyB9LFxyXG4gICAgXTtcclxuICAgIHJldHVybiBgXHJcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxyXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMubm9ybV9jb3VudCcpfVxyXG4gICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDtcclxuICAgIHZhciBtZWFuX3ZlY3RvciA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xyXG4gICAgdmFyIG1lYW5fc3F1YXJlX3ZlY3RvciA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xyXG5cclxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGgrKykge1xyXG4gICAgICBsZXQgdmFsdWUgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3hbaCArIG9mZnNldF0nKX07XHJcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xyXG4gICAgICBtZWFuX3NxdWFyZV92ZWN0b3IgKz0gdmFsdWUgKiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGxldCBtZWFuID0gJHtzdW1WZWN0b3IoJ21lYW5fdmVjdG9yJywgY29tcG9uZW50cyl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xyXG4gICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtzdW1WZWN0b3IoJ21lYW5fc3F1YXJlX3ZlY3RvcicsIGNvbXBvbmVudHMpfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZSAke1xyXG4gICAgICBzaW1wbGlmaWVkID8gJycgOiAnLSBtZWFuICogbWVhbidcclxuICAgIH0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcclxuXHJcbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xyXG4gICAgICBsZXQgZjMyaW5wdXQgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3hbaiArIG9mZnNldF0nKX07XHJcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAnc2NhbGVbal0nKX07XHJcbiAgICAgIG91dHB1dFtqICsgb2Zmc2V0XSA9ICR7dmFyaWFibGVzWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAke3NpbXBsaWZpZWQgPyAnJyA6ICctIG1lYW4nfSkgKiBpbnZfc3RkX2RldiAqIGYzMnNjYWxlXHJcbiAgICAgICAgJHtiaWFzID8gYCsgJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICdiaWFzW2pdJyl9YCA6ICcnfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgICR7aGFzTWVhbkRhdGFPdXRwdXQgPyAnbWVhbl9kYXRhX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW4nIDogJyd9O1xyXG4gICAgJHtoYXNJbnZTdGRPdXRwdXQgPyAnaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldicgOiAnJ307XHJcbiAgfWA7XHJcbiAgfTtcclxuICBjb25zdCBvdXRwdXRzID0gW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV07XHJcbiAgaWYgKGhhc01lYW5EYXRhT3V0cHV0KSB7XHJcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfSk7XHJcbiAgfVxyXG4gIGlmIChoYXNJbnZTdGRPdXRwdXQpIHtcclxuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnTGF5ZXJOb3JtYWxpemF0aW9uJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7b3V0cHV0Q291bnR9OyR7c2ltcGxpZmllZH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0cyxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwobm9ybUNvdW50IC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbGF5ZXJOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBMYXllck5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVMYXllck5vcm1Qcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcywgY29udGV4dC5vdXRwdXRDb3VudCkpO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8gfSBmcm9tICcuL21hdG11bC1zaGFkZXJzJztcclxuaW1wb3J0IHsgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1swXS5kaW1zW2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdICE9PSBpbnB1dHNbMV0uZGltc1tpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyXSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLicpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBtYXRNdWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShjb250ZXh0LmlucHV0c1swXS5kaW1zLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zLCB0cnVlKTtcclxuICBpZiAoIW91dHB1dFNoYXBlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xyXG4gIH1cclxuICBjb25zdCBOID0gb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV07XHJcbiAgY29uc3QgSyA9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXTtcclxuICBpZiAoTiA8IDggJiYgSyA8IDgpIHtcclxuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB7IGFjdGl2YXRpb246ICcnIH0sIG91dHB1dFNoYXBlKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IE0gPSBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAyXTtcclxuICAgIGNvbnN0IGJhdGNoQSA9IFNoYXBlVXRpbC5zaXplKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMuc2xpY2UoMCwgLTIpKTtcclxuICAgIGNvbnN0IGJhdGNoQiA9IFNoYXBlVXRpbC5zaXplKGNvbnRleHQuaW5wdXRzWzFdLmRpbXMuc2xpY2UoMCwgLTIpKTtcclxuICAgIGlmIChiYXRjaEEgIT09IDEgJiYgTSA9PT0gMSAmJiBiYXRjaEIgPT09IDEpIHtcclxuICAgICAgLy8gT3B0aW1pemF0aW9uIGZvciBiYXRjaGVkIHZlYy1tYXQtbXVsXHJcbiAgICAgIGNvbnN0IHJlc2hhcGVkQSA9IGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoWzEsIGJhdGNoQSwgS10pO1xyXG4gICAgICBjb25zdCByZXNoYXBlZEIgPSBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFsxLCBLLCBOXSk7XHJcbiAgICAgIGNvbnN0IG1hdG11bE91dHB1dFNoYXBlID0gWzEsIGJhdGNoQSwgTl07XHJcbiAgICAgIGNvbnN0IG1hdG11bElucHV0cyA9IFtyZXNoYXBlZEEsIHJlc2hhcGVkQl07XHJcbiAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyhtYXRtdWxJbnB1dHMsIHsgYWN0aXZhdGlvbjogJycgfSwgb3V0cHV0U2hhcGUsIG1hdG11bE91dHB1dFNoYXBlKSwge1xyXG4gICAgICAgIGlucHV0czogbWF0bXVsSW5wdXRzLFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgeyBhY3RpdmF0aW9uOiAnJyB9LCBvdXRwdXRTaGFwZSkpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgZ2V0TWF4Q29tcG9uZW50cyxcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuLy8gIFRPRE8gc3VwcG9ydCBxdWFudGl6YXRpb24gYml0cyBub3QgZXF1YWwgdG8gNFxyXG5leHBvcnQgaW50ZXJmYWNlIE1hdE11bE5CaXRzQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgazogbnVtYmVyO1xyXG4gIG46IG51bWJlcjtcclxuICBhY2N1cmFjeUxldmVsOiBudW1iZXI7XHJcbiAgYml0czogbnVtYmVyO1xyXG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogTWF0TXVsTkJpdHNBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPCAzIHx8IGlucHV0cy5sZW5ndGggPiA0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdE11bE5CaXRzIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHMnKTtcclxuICB9XHJcbiAgY29uc3QgYSA9IGlucHV0c1swXTtcclxuICBjb25zdCBhUmFuayA9IGEuZGltcy5sZW5ndGg7XHJcbiAgaWYgKGEuZGltc1thUmFuayAtIDFdICE9PSBhdHRyaWJ1dGVzLmspIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlJyk7XHJcbiAgfVxyXG4gIGNvbnN0IG5CbG9ja3NQZXJDb2wgPSBNYXRoLmZsb29yKChhdHRyaWJ1dGVzLmsgKyBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSAtIDEpIC8gYXR0cmlidXRlcy5ibG9ja1NpemUpO1xyXG4gIGNvbnN0IGJsb2JTaXplID0gKGF0dHJpYnV0ZXMuYmxvY2tTaXplIC8gOCkgKiBhdHRyaWJ1dGVzLmJpdHM7XHJcbiAgY29uc3QgYiA9IGlucHV0c1sxXTtcclxuICBpZiAoIVNoYXBlVXRpbC5hcmVFcXVhbChiLmRpbXMsIFthdHRyaWJ1dGVzLm4sIG5CbG9ja3NQZXJDb2wsIGJsb2JTaXplXSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlY29uZCBpbnB1dHMgbXVzdCBiZSAzRCB0ZW5zb3Igd2l0aCBzaGFwZSBOIFggbkJsb2Nrc1BlckNvbCBYIGJsb2JTaXplJyk7XHJcbiAgfVxyXG4gIGNvbnN0IHNjYWxlcyA9IGlucHV0c1syXTtcclxuICBjb25zdCBzY2FsZXNTaGFwZSA9IHNjYWxlcy5kaW1zO1xyXG4gIGlmIChTaGFwZVV0aWwuc2l6ZShzY2FsZXNTaGFwZSkgIT09IGF0dHJpYnV0ZXMubiAqIG5CbG9ja3NQZXJDb2wpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGVzIGlucHV0IHNpemUgZXJyb3IuJyk7XHJcbiAgfVxyXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XHJcbiAgICBjb25zdCB6ZXJvUG9pbnRzID0gaW5wdXRzWzNdO1xyXG4gICAgY29uc3QgemVyb1BvaW50c1NoYXBlID0gemVyb1BvaW50cy5kaW1zO1xyXG5cclxuICAgIC8vIFRoaXMgYXNzdW1lcyB6ZXJvIHBvaW50cyBhcmUgcGFja2VkLlxyXG4gICAgLy8gVW5wYWNrIGZvcm1hdCAoemVybyBwb2ludCBoYXMgc2FtZSBkYXRhIHR5cGUgYW5kIHNoYXBlIGFzIHNjYWxlKSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHdlYmdwdS5cclxuICAgIGNvbnN0IGV4cGVjdGVkWmVyb1BvaW50c1NpemUgPVxyXG4gICAgICBhdHRyaWJ1dGVzLm4gKiAoYXR0cmlidXRlcy5iaXRzID09PSA4ID8gbkJsb2Nrc1BlckNvbCA6IE1hdGguZmxvb3IoKG5CbG9ja3NQZXJDb2wgKiBhdHRyaWJ1dGVzLmJpdHMgKyA3KSAvIDgpKTtcclxuICAgIGlmIChTaGFwZVV0aWwuc2l6ZSh6ZXJvUG9pbnRzU2hhcGUpICE9PSBleHBlY3RlZFplcm9Qb2ludHNTaXplKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignemVyb1BvaW50cyBpbnB1dCBzaXplIGVycm9yLicpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRNdWxOQml0c1Byb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IE1hdE11bE5CaXRzQXR0cmlidXRlcyxcclxuKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBhUmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xyXG4gIGNvbnN0IGRpbUFPdXRlciA9IGlucHV0U2hhcGVbYVJhbmsgLSAyXTtcclxuICBjb25zdCBkaW1Jbm5lciA9IGF0dHJpYnV0ZXMuaztcclxuICBjb25zdCBkaW1CT3V0ZXIgPSBhdHRyaWJ1dGVzLm47XHJcbiAgY29uc3QgYmF0Y2hEaW1zID0gaW5wdXRTaGFwZS5zbGljZSgwLCBhUmFuayAtIDIpO1xyXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGJhdGNoRGltcyk7XHJcbiAgY29uc3QgYmxvYlNpemUgPSBpbnB1dHNbMV0uZGltc1syXTtcclxuICBjb25zdCBibG9iU2l6ZUluV29yZHMgPSBibG9iU2l6ZSAvIDQ7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XHJcbiAgY29uc3QgYUNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGF0dHJpYnV0ZXMuayk7XHJcbiAgY29uc3QgYkNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGJsb2JTaXplSW5Xb3Jkcyk7XHJcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoZGltQk91dGVyKTtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGJhdGNoRGltcy5jb25jYXQoW2RpbUFPdXRlciwgZGltQk91dGVyXSk7XHJcbiAgY29uc3Qgb3V0cHV0TnVtYmVyID0gZGltQU91dGVyID4gMSAmJiAoZGltQk91dGVyIC8gY29tcG9uZW50cykgJSAyID09PSAwID8gMiA6IDE7XHJcbiAgY29uc3QgZGlzcGF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcclxuXHJcbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDY0O1xyXG5cclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXTtcclxuICBjb25zdCBpbnB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltSW5uZXIgLyBhQ29tcG9uZW50c107XHJcbiAgY29uc3QgYlNoYXBlID0gU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbMV0uZGltcykuc2xpY2UoKTtcclxuICBiU2hhcGUuc3BsaWNlKC0xLCAxLCBibG9iU2l6ZUluV29yZHMgLyBiQ29tcG9uZW50cyk7XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZVRlbXApKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiU2hhcGUpKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xyXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1szXS5kaW1zKSkpO1xyXG4gIH1cclxuICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlVGVtcCkpO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGVUZW1wLmxlbmd0aDtcclxuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmssIGFDb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgRGF0YVR5cGUudWludDMyLCBiU2hhcGUubGVuZ3RoLCBiQ29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBzY2FsZXMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFthLCBiLCBzY2FsZXNdO1xyXG4gICAgY29uc3QgemVyb1BvaW50cyA9XHJcbiAgICAgIGlucHV0cy5sZW5ndGggPT09IDQgPyBpbnB1dFZhcmlhYmxlKCd6ZXJvX3BvaW50cycsIERhdGFUeXBlLnVpbnQzMiwgaW5wdXRzWzNdLmRpbXMubGVuZ3RoKSA6IHVuZGVmaW5lZDtcclxuICAgIGlmICh6ZXJvUG9pbnRzKSB7XHJcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goemVyb1BvaW50cyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGVUZW1wLmxlbmd0aDtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFJhbmssIGNvbXBvbmVudHMpO1xyXG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuXHJcbiAgICBjb25zdCBxRHFEYXRhVHlwZSA9ICgoKSA9PiB7XHJcbiAgICAgIHN3aXRjaCAoYUNvbXBvbmVudHMpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICByZXR1cm4gYGFycmF5PCR7ZGF0YVR5cGV9LCA4PmA7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgcmV0dXJuIGBtYXQ0eDI8JHtkYXRhVHlwZX0+YDtcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICByZXR1cm4gYG1hdDJ4NDwke2RhdGFUeXBlfT5gO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YUNvbXBvbmVudHN9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIGNvbnN0IHByb2Nlc3NPbmVXb3JkID0gKCk6IHN0cmluZyA9PiB7XHJcbiAgICAgIGxldCBjYWxjU3RyID0gYFxyXG4gICAgICAgICAgLy8gcmV1c2UgYSBkYXRhXHJcbiAgICAgICAgICAgIHZhciBpbnB1dF9vZmZzZXQgPSAke2EuaW5kaWNlc1RvT2Zmc2V0KGAke2EudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCB3b3JkX29mZnNldClgKX07XHJcbiAgICAgICAgICAgIHZhciBhX2RhdGE6ICR7cURxRGF0YVR5cGV9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgJHs4IC8gYUNvbXBvbmVudHN9OyBqKyspIHtcclxuICAgICAgICAgICAgICBhX2RhdGFbal0gPSAke2EuZ2V0QnlPZmZzZXQoJ2lucHV0X29mZnNldCcpfTtcclxuICAgICAgICAgICAgICBpbnB1dF9vZmZzZXQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgYDtcclxuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb21wb25lbnRzICogb3V0cHV0TnVtYmVyOyBjKyspIHtcclxuICAgICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgICAgYl92YWx1ZSA9ICR7YkNvbXBvbmVudHMgPT09IDEgPyBgYiR7Y31fZGF0YWAgOiBgYiR7Y31fZGF0YVtpXWB9O1xyXG4gICAgICAgICAgICBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgYl9tYXNrKTtcclxuICAgICAgICAgICAgYl92YWx1ZV91cHBlciA9IHVucGFjazR4VTgoKGJfdmFsdWUgPj4gNCkgJiBiX21hc2spO1xyXG4gICAgICAgICAgICBiX3F1YW50aXplZF92YWx1ZXMgPSAke3FEcURhdGFUeXBlfSgke0FycmF5LmZyb20oXHJcbiAgICAgICAgICAgICAgeyBsZW5ndGg6IDQgfSxcclxuICAgICAgICAgICAgICAoXywgaSkgPT4gYCR7ZGF0YVR5cGV9KGJfdmFsdWVfbG93ZXJbJHtpfV0pLCAke2RhdGFUeXBlfShiX3ZhbHVlX3VwcGVyWyR7aX1dKWAsXHJcbiAgICAgICAgICAgICkuam9pbignLCAnKX0pO1xyXG4gICAgICAgICAgICBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9ICR7KCgpID0+IHtcclxuICAgICAgICAgICAgICBpZiAoYUNvbXBvbmVudHMgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtxRHFEYXRhVHlwZX0oJHtBcnJheS5mcm9tKFxyXG4gICAgICAgICAgICAgICAgICB7IGxlbmd0aDogOCB9LFxyXG4gICAgICAgICAgICAgICAgICAoXywgaSkgPT4gYChiX3F1YW50aXplZF92YWx1ZXNbJHtpfV0gLSAke3plcm9Qb2ludHMgPyBgemVyb19wb2ludCR7Y31gIDogJ3plcm9fcG9pbnQnfSkgKiBzY2FsZSR7Y31gLFxyXG4gICAgICAgICAgICAgICAgKS5qb2luKCcsICcpfSk7YDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtxRHFEYXRhVHlwZX0oJHtBcnJheSg4KVxyXG4gICAgICAgICAgICAgICAgICAuZmlsbChgJHt6ZXJvUG9pbnRzID8gYHplcm9fcG9pbnQke2N9YCA6ICd6ZXJvX3BvaW50J31gKVxyXG4gICAgICAgICAgICAgICAgICAuam9pbignLCcpfSkpICogc2NhbGUke2N9O2A7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSgpfTtcclxuICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZC54ICogJHtvdXRwdXROdW1iZXJ9ICsgJHtNYXRoLmZsb29yKGMgLyBjb21wb25lbnRzKX1dJHtjb21wb25lbnRzID4gMSA/IGBbJHtjICUgY29tcG9uZW50c31dYCA6ICcnfSArPSAke0FycmF5LmZyb20oXHJcbiAgICAgICAgICAgICAgeyBsZW5ndGg6IDggLyBhQ29tcG9uZW50cyB9LFxyXG4gICAgICAgICAgICAgIChfLCBpKSA9PlxyXG4gICAgICAgICAgICAgICAgYCR7XHJcbiAgICAgICAgICAgICAgICAgIGFDb21wb25lbnRzID09PSAxXHJcbiAgICAgICAgICAgICAgICAgICAgPyBgYV9kYXRhWyR7aX1dICogYl9kZXF1YW50aXplZF92YWx1ZXNbJHtpfV1gXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgZG90KGFfZGF0YVske2l9XSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtpfV0pYFxyXG4gICAgICAgICAgICAgICAgfWAsXHJcbiAgICAgICAgICAgICkuam9pbignICsgJyl9O1xyXG4gICAgICAgICAgYDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2FsY1N0cjtcclxuICAgIH07XHJcbiAgICBjb25zdCBwcmVwYXJlU2NhbGVBbmRaZXJvUG9pbnQgPSAoKTogc3RyaW5nID0+IHtcclxuICAgICAgbGV0IGNhbGNTdHIgPSBgXHJcbiAgICAgICAgICAgIHZhciBjb2xfaW5kZXggPSBjb2wgKiAke2NvbXBvbmVudHN9O1xyXG4gICAgICAgICAgICAke1xyXG4gICAgICAgICAgICAgIHplcm9Qb2ludHNcclxuICAgICAgICAgICAgICAgID8gYFxyXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDI7XHJcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVfY291bnQ6IHUzMjtcclxuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZF9pbmRleDogdTMyO1xyXG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyO1xyXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9uaWJibGVfb2Zmc2V0OiB1MzIgPSBibG9jayAmIDB4MXU7XHJcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0OiB1MzI7XHJcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgXHJcbiAgICAgICAgICAgICAgICA6IGBcclxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oJHs4LjB9KTtgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYDtcclxuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb21wb25lbnRzICogb3V0cHV0TnVtYmVyOyBjKyspIHtcclxuICAgICAgICBjYWxjU3RyICs9IGBcclxuICAgICAgICAgICAgbGV0IHNjYWxlJHtjfSA9ICR7c2NhbGVzLmdldEJ5T2Zmc2V0KGBjb2xfaW5kZXggKiBuQmxvY2tzUGVyQ29sICsgYmxvY2tgKX07XHJcbiAgICAgICAgICAgICR7XHJcbiAgICAgICAgICAgICAgemVyb1BvaW50c1xyXG4gICAgICAgICAgICAgICAgPyBgXHJcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGNvbF9pbmRleCAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcclxuICAgICAgICAgICAgemVyb19wb2ludF93b3JkX2luZGV4ID0gemVyb19wb2ludF9ieXRlX2NvdW50ID4+IDB4MnU7XHJcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xyXG4gICAgICAgICAgICB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xyXG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmQgPSAke3plcm9Qb2ludHMuZ2V0QnlPZmZzZXQoJ3plcm9fcG9pbnRfd29yZF9pbmRleCcpfSA+PiB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0O1xyXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCR7Y30gPSAke2RhdGFUeXBlfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2BcclxuICAgICAgICAgICAgICAgIDogJydcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb2xfaW5kZXggKz0gMTtgO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjYWxjU3RyO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByZXBhcmVCRGF0YSA9ICgpOiBzdHJpbmcgPT4ge1xyXG4gICAgICBsZXQgY2FsY1N0ciA9IGBjb2xfaW5kZXggPSBjb2wgKiAke2NvbXBvbmVudHN9O2A7XHJcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29tcG9uZW50cyAqIG91dHB1dE51bWJlcjsgYysrKSB7XHJcbiAgICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgICAgIGxldCBiJHtjfV9kYXRhID0gJHtiLmdldEJ5SW5kaWNlcyhgJHtiLnR5cGUuaW5kaWNlc30oY29sX2luZGV4LCBibG9jaywgd29yZClgKX07XHJcbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7XHJcbiAgICAgIH1cclxuICAgICAgY2FsY1N0ciArPSBgXHJcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlOiB1MzI7XHJcbiAgICAgICAgICAgIGxldCBiX21hc2s6IHUzMiA9IDB4MEYwRjBGMEZ1O1xyXG4gICAgICAgICAgICB2YXIgYl92YWx1ZV9sb3dlcjogdmVjNDx1MzI+O1xyXG4gICAgICAgICAgICB2YXIgYl92YWx1ZV91cHBlcjogdmVjNDx1MzI+O1xyXG4gICAgICAgICAgICB2YXIgYl9xdWFudGl6ZWRfdmFsdWVzOiAke3FEcURhdGFUeXBlfTtcclxuICAgICAgICAgICAgdmFyIGJfZGVxdWFudGl6ZWRfdmFsdWVzOiAke3FEcURhdGFUeXBlfTtgO1xyXG4gICAgICByZXR1cm4gY2FsY1N0cjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQ6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dE51bWJlciAqIHdvcmtncm91cFNpemV9PjtcclxuICAgICAgICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbd29ya2dyb3VwU2l6ZSwgMSwgMV0pfVxyXG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGAoZ2xvYmFsX2lkeCAvICR7d29ya2dyb3VwU2l6ZX0pICogJHtvdXRwdXROdW1iZXJ9YCl9O1xyXG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xyXG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xyXG4gICAgICAgICAgbGV0IGJhdGNoID0gb3V0cHV0X2luZGljZXNbMF07XHJcbiAgICAgICAgICBsZXQgbkJsb2Nrc1BlckNvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XHJcblxyXG4gICAgICAgICAgZm9yICh2YXIgYmxvY2sgPSBsb2NhbF9pZC54OyBibG9jayA8IG5CbG9ja3NQZXJDb2w7IGJsb2NrICs9ICR7d29ya2dyb3VwU2l6ZX0pIHtcclxuICAgICAgICAgICAgLy9wcm9jZXNzIG9uZSBibG9ja1xyXG4gICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQ6IHUzMiA9IGJsb2NrICogJHthdHRyaWJ1dGVzLmJsb2NrU2l6ZSAvIGFDb21wb25lbnRzfTtcclxuICAgICAgICAgICAgJHtwcmVwYXJlU2NhbGVBbmRaZXJvUG9pbnQoKX1cclxuICAgICAgICAgICAgZm9yICh2YXIgd29yZDogdTMyID0gMDsgd29yZCA8ICR7YmxvYlNpemVJbldvcmRzfTsgd29yZCArPSAke2JDb21wb25lbnRzfSkge1xyXG4gICAgICAgICAgICAgICR7cHJlcGFyZUJEYXRhKCl9XHJcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7YkNvbXBvbmVudHN9OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICR7cHJvY2Vzc09uZVdvcmQoKX1cclxuICAgICAgICAgICAgICAgIHdvcmRfb2Zmc2V0ICs9ICR7OCAvIGFDb21wb25lbnRzfTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICAgICAgICBpZiAobG9jYWxfaWQueCA8ICR7b3V0cHV0TnVtYmVyfSkge1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke291dHB1dC50eXBlLnZhbHVlfSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xyXG4gICAgICAgICAgICB2YXIgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQ6IHUzMiA9IGxvY2FsX2lkLng7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGI6IHUzMiA9IDB1OyBiIDwgJHt3b3JrZ3JvdXBTaXplfXU7IGIrKykge1xyXG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSB3b3JrZ3JvdXBfc2hhcmVkW3dvcmtncm91cF9zaGFyZWRfb2Zmc2V0XTtcclxuICAgICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldCArPSAke291dHB1dE51bWJlcn07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlJbmRpY2VzKGAke291dHB1dC50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkLngpYCwgJ291dHB1dF92YWx1ZScpfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9YDtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnTWF0TXVsTkJpdHMnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5ibG9ja1NpemV9OyR7YXR0cmlidXRlcy5iaXRzfTske2FDb21wb25lbnRzfTske2JDb21wb25lbnRzfTske2NvbXBvbmVudHN9OyR7b3V0cHV0TnVtYmVyfTske3dvcmtncm91cFNpemV9YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IEFycmF5KGlucHV0cy5sZW5ndGgpLmZpbGwoJ3JhbmsnKSxcclxuICAgIH0sXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hTaXplIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBDdXJyZW50bHksIG9ubHkgc3VwcG9ydCBibG9ja1NpemUgPSAzMi5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdE11bE5CaXRzQmxvY2tTaXplMzJQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgYVJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcclxuICBjb25zdCBkaW1BT3V0ZXIgPSBpbnB1dFNoYXBlW2FSYW5rIC0gMl07XHJcbiAgY29uc3QgZGltSW5uZXIgPSBhdHRyaWJ1dGVzLms7XHJcbiAgY29uc3QgZGltQk91dGVyID0gYXR0cmlidXRlcy5uO1xyXG4gIGNvbnN0IGJhdGNoRGltcyA9IGlucHV0U2hhcGUuc2xpY2UoMCwgYVJhbmsgLSAyKTtcclxuICBjb25zdCBiYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShiYXRjaERpbXMpO1xyXG4gIGNvbnN0IGJsb2JTaXplID0gaW5wdXRzWzFdLmRpbXNbMl07XHJcbiAgY29uc3QgYmxvYlNpemVJbldvcmRzID0gYmxvYlNpemUgLyA0O1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xyXG4gIGNvbnN0IGFDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhhdHRyaWJ1dGVzLmspO1xyXG4gIGNvbnN0IGJDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhibG9iU2l6ZUluV29yZHMpO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYmF0Y2hEaW1zLmNvbmNhdChbZGltQU91dGVyLCBkaW1CT3V0ZXJdKTtcclxuXHJcbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDEyODtcclxuICBjb25zdCB3b3JrZ3JvdXBZID0gZGltQk91dGVyICUgOCA9PT0gMCA/IDggOiBkaW1CT3V0ZXIgJSA0ID09PSAwID8gNCA6IDE7XHJcbiAgY29uc3Qgd29ya2dyb3VwWCA9IHdvcmtncm91cFNpemUgLyB3b3JrZ3JvdXBZO1xyXG4gIGNvbnN0IHRpbGVTaXplID0gd29ya2dyb3VwWCAqIGJDb21wb25lbnRzICogODsgLy8gZWFjaCB1aW50MzIgaGFzIDggZGF0YS5cclxuICBjb25zdCBhTGVuZ3RoUGVyVGlsZSA9IHRpbGVTaXplIC8gYUNvbXBvbmVudHM7XHJcbiAgY29uc3QgYmxvY2tzUGVyVGlsZSA9IHRpbGVTaXplIC8gYXR0cmlidXRlcy5ibG9ja1NpemU7XHJcbiAgY29uc3QgZGlzcGF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gd29ya2dyb3VwWTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XHJcbiAgY29uc3QgaW5wdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUlubmVyIC8gYUNvbXBvbmVudHNdO1xyXG4gIGNvbnN0IGJTaGFwZSA9IFNoYXBlVXRpbC5jb252ZXJ0U2hhcGUoaW5wdXRzWzFdLmRpbXMpLnNsaWNlKCk7XHJcbiAgYlNoYXBlLnNwbGljZSgtMSwgMSwgYmxvYlNpemVJbldvcmRzIC8gYkNvbXBvbmVudHMpO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGVUZW1wKSk7XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYlNoYXBlKSk7XHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcclxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbM10uZGltcykpKTtcclxuICB9XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGVUZW1wID0gW2JhdGNoU2l6ZSwgZGltQU91dGVyLCBkaW1CT3V0ZXJdO1xyXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlVGVtcCkpO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGVUZW1wLmxlbmd0aDtcclxuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmssIGFDb21wb25lbnRzKTtcclxuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgRGF0YVR5cGUudWludDMyLCBiU2hhcGUubGVuZ3RoLCBiQ29tcG9uZW50cyk7XHJcbiAgICBjb25zdCBzY2FsZXMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFthLCBiLCBzY2FsZXNdO1xyXG4gICAgY29uc3QgemVyb1BvaW50cyA9XHJcbiAgICAgIGlucHV0cy5sZW5ndGggPT09IDQgPyBpbnB1dFZhcmlhYmxlKCd6ZXJvX3BvaW50cycsIERhdGFUeXBlLnVpbnQzMiwgaW5wdXRzWzNdLmRpbXMubGVuZ3RoKSA6IHVuZGVmaW5lZDtcclxuICAgIGlmICh6ZXJvUG9pbnRzKSB7XHJcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goemVyb1BvaW50cyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGVUZW1wLmxlbmd0aDtcclxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFJhbmspO1xyXG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcclxuICAgIGNvbnN0IHJlYWRBID0gKCkgPT4ge1xyXG4gICAgICBzd2l0Y2ggKGFDb21wb25lbnRzKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgIGxldCBhX2RhdGEwID0gdmVjNDwke2RhdGFUeXBlfT4oc3ViX2Fbd29yZF9vZmZzZXRdLCBzdWJfYVt3b3JkX29mZnNldCArIDFdLCBzdWJfYVt3b3JkX29mZnNldCArIDJdLCBzdWJfYVt3b3JkX29mZnNldCArIDNdKTtcclxuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke2RhdGFUeXBlfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyA0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA1XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA2XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA3XSk7YDtcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0pO1xyXG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7ZGF0YVR5cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDJdLCBzdWJfYVt3b3JkX29mZnNldCArIDNdKTtgO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcclxuICAgICAgICAgIGxldCBhX2RhdGExID0gc3ViX2Fbd29yZF9vZmZzZXQgKyAxXTtgO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YUNvbXBvbmVudHN9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBgXHJcbiAgICAgICAgdmFyPHdvcmtncm91cD4gc3ViX2E6IGFycmF5PCR7YS50eXBlLnZhbHVlfSwgJHthTGVuZ3RoUGVyVGlsZX0+O1xyXG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke3dvcmtncm91cFh9PiwgJHt3b3JrZ3JvdXBZfT47XHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cclxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW3dvcmtncm91cFgsIHdvcmtncm91cFksIDFdKX1cclxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgd29ya2dyb3VwX2luZGV4ICogJHt3b3JrZ3JvdXBZfWApfTtcclxuICAgICAgICAgIGxldCBjb2wgPSBvdXRwdXRfaW5kaWNlc1syXTtcclxuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcclxuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xyXG4gICAgICAgICAgbGV0IG5fYmxvY2tzX3Blcl9jb2wgPSB1bmlmb3Jtcy5iX3NoYXBlWzFdO1xyXG4gICAgICAgICAgbGV0IG51bV90aWxlcyA9ICAobl9ibG9ja3NfcGVyX2NvbCAtIDEpIC8gJHtibG9ja3NQZXJUaWxlfSArIDE7XHJcblxyXG4gICAgICAgICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXHJcbiAgICAgICAgICBmb3IgKHZhciB0aWxlOiB1MzIgPSAwOyB0aWxlIDwgbnVtX3RpbGVzOyB0aWxlICs9IDEpIHtcclxuICAgICAgICAgICAgbGV0IGFfY29sX3N0YXJ0ID0gdGlsZSAqICR7YUxlbmd0aFBlclRpbGV9O1xyXG4gICAgICAgICAgICAvLyBsb2FkIG9uZSB0aWxlIEEgZGF0YSBpbnRvIHNoYXJlZCBtZW1vcnkuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGFfb2Zmc2V0ID0gbG9jYWxfaWR4OyBhX29mZnNldCA8ICR7YUxlbmd0aFBlclRpbGV9OyBhX29mZnNldCArPSAke3dvcmtncm91cFNpemV9KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbGV0IGFfY29sID0gYV9jb2xfc3RhcnQgKyBhX29mZnNldDtcclxuICAgICAgICAgICAgICBpZiAoYV9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzJdKVxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7YS5nZXRCeUluZGljZXMoYCR7YS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGFfY29sKWApfTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHthLnR5cGUudmFsdWV9KDApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBlYWNoIHRocmVhZCBwcm9jZXNzIG9uZSBibG9ja1xyXG4gICAgICAgICAgICBsZXQgYl9yb3cgPSBjb2wgKyBsb2NhbF9pZC55O1xyXG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aWxlICogJHtibG9ja3NQZXJUaWxlfSArIGxvY2FsX2lkLng7XHJcbiAgICAgICAgICAgICR7XHJcbiAgICAgICAgICAgICAgemVyb1BvaW50c1xyXG4gICAgICAgICAgICAgICAgPyBgXHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobl9ibG9ja3NfcGVyX2NvbCArIDEpIC8gMjtcclxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGJfcm93ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xyXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkX2luZGV4ID0gemVyb19wb2ludF9ieXRlX2NvdW50ID4+IDB4MnU7XHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0ID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcclxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xyXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfbmliYmxlX29mZnNldCA8PCAyKTtcclxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZCA9ICR7emVyb1BvaW50cy5nZXRCeU9mZnNldCgnemVyb19wb2ludF93b3JkX2luZGV4Jyl9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oKHplcm9fcG9pbnRfd29yZCkgJiAweEZ1KTtgXHJcbiAgICAgICAgICAgICAgICA6IGBcclxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXHJcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oJHs4LjB9KTtgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNjYWxlID0gJHtzY2FsZXMuZ2V0QnlPZmZzZXQoYGJfcm93ICogbl9ibG9ja3NfcGVyX2NvbCArIGJsb2NrYCl9O1xyXG4gICAgICAgICAgICBsZXQgYl9kYXRhID0gJHtiLmdldEJ5SW5kaWNlcyhgJHtiLnR5cGUuaW5kaWNlc30oYl9yb3csIGJsb2NrLCAwKWApfTtcclxuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0ID0gbG9jYWxfaWQueCAqICR7YXR0cmlidXRlcy5ibG9ja1NpemUgLyBhQ29tcG9uZW50c307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2JDb21wb25lbnRzfTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgJHtyZWFkQSgpfVxyXG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlID0gJHtiQ29tcG9uZW50cyA9PT0gMSA/IGBiX2RhdGFgIDogYGJfZGF0YVtpXWB9O1xyXG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgMHgwRjBGMEYwRnUpO1xyXG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIDB4MEYwRjBGMEZ1KTtcclxuICAgICAgICAgICAgICBsZXQgYl9xdWFudGl6ZWRfdmFsdWVzID0gbWF0Mng0PCR7ZGF0YVR5cGV9Pigke0FycmF5LmZyb20oXHJcbiAgICAgICAgICAgICAgICB7IGxlbmd0aDogNCB9LFxyXG4gICAgICAgICAgICAgICAgKF8sIGkpID0+IGAke2RhdGFUeXBlfShiX3ZhbHVlX2xvd2VyWyR7aX1dKSwgJHtkYXRhVHlwZX0oYl92YWx1ZV91cHBlclske2l9XSlgLFxyXG4gICAgICAgICAgICAgICkuam9pbignLCAnKX0pO1xyXG4gICAgICAgICAgICAgIGxldCBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9IChiX3F1YW50aXplZF92YWx1ZXMgLSBtYXQyeDQ8JHtkYXRhVHlwZX0+KCR7QXJyYXkoOCkuZmlsbCgnemVyb19wb2ludCcpLmpvaW4oJywnKX0pKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgIGludGVyX3Jlc3VsdHNbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gKz0gJHtBcnJheS5mcm9tKFxyXG4gICAgICAgICAgICAgICAgeyBsZW5ndGg6IDIgfSxcclxuICAgICAgICAgICAgICAgIChfLCBpKSA9PiBgJHtgZG90KGFfZGF0YSR7aX0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7aX1dKWB9YCxcclxuICAgICAgICAgICAgICApLmpvaW4oJyArICcpfTtcclxuICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezggLyBhQ29tcG9uZW50c307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChsb2NhbF9pZHggPCAke3dvcmtncm91cFl9KSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7b3V0cHV0LnR5cGUudmFsdWV9ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwdTsgYiA8ICR7d29ya2dyb3VwWH07IGIrKykge1xyXG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbCArIGxvY2FsX2lkeCA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsyXSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5SW5kaWNlcyhgJHtvdXRwdXQudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBjb2wgKyBsb2NhbF9pZHgpYCwgJ291dHB1dF92YWx1ZScpfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfWA7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ0Jsb2Nrd2lzZU1hdE11bE5CaXRzMzInLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5ibG9ja1NpemV9OyR7YUNvbXBvbmVudHN9OyR7YkNvbXBvbmVudHN9OyR7d29ya2dyb3VwWH07JHt3b3JrZ3JvdXBZfWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBBcnJheShpbnB1dHMubGVuZ3RoKS5maWxsKCdyYW5rJyksXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoU2l6ZSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG1hdE11bE5CaXRzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgaWYgKFxyXG4gICAgYXR0cmlidXRlcy5ibG9ja1NpemUgPT09IDMyICYmXHJcbiAgICBjb250ZXh0LmFkYXB0ZXJJbmZvLmlzVmVuZG9yKCdpbnRlbCcpICYmXHJcbiAgICBjb250ZXh0LmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKCdnZW4tMTJscCcpXHJcbiAgKSB7XHJcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF0TXVsTkJpdHNCbG9ja1NpemUzMlByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRNdWxOQml0c1Byb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlTWF0TXVsTkJpdHNBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogTWF0TXVsTkJpdHNBdHRyaWJ1dGVzID0+XHJcbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMgT21pdDxNYXRNdWxOQml0c0F0dHJpYnV0ZXMsIGtleW9mIEF0dHJpYnV0ZVdpdGhDYWNoZUtleT4pO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIGdldEVsZW1lbnRBdCxcclxuICBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuaW50ZXJmYWNlIFBhZEF0dHJpYnV0ZXMge1xyXG4gIC8vIDAtY29uc3RhbnQsIDEtcmVmbGVjdCwgMi1lZGdlLCAzLXdyYXBcclxuICByZWFkb25seSBtb2RlOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkgdmFsdWU6IG51bWJlcjtcclxuICByZWFkb25seSBwYWRzOiBudW1iZXJbXTtcclxufVxyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcclxuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb28gZmV3IGlucHV0cycpO1xyXG4gIH1cclxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCAmJiBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0MTYpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZSBtdXN0IGJlIGZsb2F0IG9yIGZsb2F0MTYuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICBsZXQgdmFsaWRQYWRzID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoICogMiA9PT0gaW5wdXRzWzFdLmRpbXNbMF07XHJcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICB2YWxpZFBhZHMgPSBpbnB1dHNbM10uZGltc1swXSAqIDIgPT09IGlucHV0c1sxXS5kaW1zWzBdO1xyXG4gICAgfVxyXG4gICAgaWYgKCF2YWxpZFBhZHMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS4nKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBnZXRQYWRDb25zdGFudCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xyXG4gIGxldCBibG9jayA9ICcnO1xyXG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgYmxvY2sgKz0gYFxyXG4gICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XHJcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XHJcbiAgICAgICAgYDtcclxuICB9XHJcblxyXG4gIHJldHVybiBgXHJcbiAgICAgICAgICB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KHVuaWZvcm1zLmNvbnN0YW50X3ZhbHVlKTtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgICAgICR7YmxvY2t9XHJcbiAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICBgO1xyXG59O1xyXG5cclxuY29uc3QgZ2V0UGFkUmVmbGVjdCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xyXG4gIGxldCBibG9jayA9ICcnO1xyXG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgYmxvY2sgKz0gYFxyXG4gICAgICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIGsgPSAtaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgbGV0IF8ybl8xID0gMiAqIChpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgayA9IGsgJSBfMm5fMTtcclxuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xyXG4gICAgICAgICAgICBgO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgICAgICAgJHtibG9ja31cclxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcclxuICAgICAgICAgIGA7XHJcbn07XHJcblxyXG5jb25zdCBnZXRQYWRFZGdlID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XHJcbiAgbGV0IGJsb2NrID0gJyc7XHJcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICBibG9jayArPSBgXHJcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XHJcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgayA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcclxuICAgICAgICAgICAgICAgICAgayA9IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSAtIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xyXG4gICAgICAgICAgICBgO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgICAgICAgJHtibG9ja31cclxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcclxuICAgICAgICAgIGA7XHJcbn07XHJcblxyXG5jb25zdCBnZXRQYWRXcmFwID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XHJcbiAgbGV0IGJsb2NrID0gJyc7XHJcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICBibG9jayArPSBgXHJcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XHJcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XHJcbiAgICAgICAgICAgICAgICAgIGsgKz0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX1dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xyXG4gICAgICAgICAgICAgICAgICBrIC09IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XHJcbiAgICAgICAgICAgIGA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICAgICAgICAke2Jsb2NrfVxyXG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xyXG4gICAgICAgICAgYDtcclxufTtcclxuXHJcbmNvbnN0IGdldFBhZFNuaXBwZXQgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHN0cmluZyA9PiB7XHJcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcclxuICAgIGNhc2UgMDpcclxuICAgICAgcmV0dXJuIGdldFBhZENvbnN0YW50KG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcclxuICAgIGNhc2UgMTpcclxuICAgICAgcmV0dXJuIGdldFBhZFJlZmxlY3Qob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICByZXR1cm4gZ2V0UGFkRWRnZShvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XHJcbiAgICBjYXNlIDM6XHJcbiAgICAgIHJldHVybiBnZXRQYWRXcmFwKG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb2RlJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlUGFkUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBTaGFwZVV0aWwucGFkU2hhcGUoaW5wdXRzWzBdLmRpbXMuc2xpY2UoKSwgYXR0cmlidXRlcy5wYWRzKTtcclxuICBjb25zdCBpbnB1dERpbXMgPSBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnBhZHMgfSxcclxuICBdO1xyXG5cclxuICBjb25zdCBpc1ZhbHVlRnJvbUlucHV0ID0gaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhO1xyXG4gIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09IDApIHtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKHsgdHlwZTogaXNWYWx1ZUZyb21JbnB1dCA/IGlucHV0c1syXS5kYXRhVHlwZSA6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLnZhbHVlIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIG91dHB1dFNoYXBlKSk7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dERpbXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IGRhdGFUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcclxuICAgIGNvbnN0IHBhZFNuaXBwZXQgPSBnZXRQYWRTbmlwcGV0KG91dHB1dCwgaW5wdXREaW1zLmxlbmd0aCwgYXR0cmlidXRlcyk7XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggfSxcclxuICAgIF07XHJcbiAgICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAwKSB7XHJcbiAgICAgIHVuaWZvcm1zLnB1c2goeyBuYW1lOiAnY29uc3RhbnRfdmFsdWUnLCB0eXBlOiAoaXNWYWx1ZUZyb21JbnB1dCA/IGRhdGFUeXBlIDogJ2YzMicpIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cclxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcblxyXG4gICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xyXG4gICAgICAgICAgICAke3BhZFNuaXBwZXR9XHJcbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xyXG4gICAgICAgIH1gO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnUGFkJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMubW9kZX0ke2lzVmFsdWVGcm9tSW5wdXR9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZVBhZEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogUGFkQXR0cmlidXRlcyA9PiB7XHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPiAxKSB7XHJcbiAgICBjb25zdCBiaWdJbnQ2NFBhZHMgPSBpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpO1xyXG4gICAgY29uc3QgdmFsdWUgPVxyXG4gICAgICBpbnB1dHMubGVuZ3RoID49IDMgJiYgaW5wdXRzWzJdLmRhdGFcclxuICAgICAgICA/IGlucHV0c1syXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNlxyXG4gICAgICAgICAgPyBpbnB1dHNbMl0uZ2V0VWludDE2QXJyYXkoKVswXVxyXG4gICAgICAgICAgOiBpbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF1cclxuICAgICAgICA6IDAuMDtcclxuXHJcbiAgICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XHJcbiAgICBjb25zdCB1cGRhdGVQYWRzID0gbmV3IEludDMyQXJyYXkoMiAqIGlucHV0UmFuaykuZmlsbCgwKTtcclxuICAgIGlmIChpbnB1dHMubGVuZ3RoID49IDQpIHtcclxuICAgICAgY29uc3QgYXhlcyA9IGlucHV0c1szXS5nZXRCaWdJbnQ2NEFycmF5KCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHVwZGF0ZVBhZHNbTnVtYmVyKGF4ZXNbaV0pXSA9IE51bWJlcihiaWdJbnQ2NFBhZHNbaV0pO1xyXG4gICAgICAgIHVwZGF0ZVBhZHNbTnVtYmVyKGF4ZXNbaV0pICsgaW5wdXRSYW5rXSA9IE51bWJlcihiaWdJbnQ2NFBhZHNbaSArIGF4ZXMubGVuZ3RoXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJpZ0ludDY0UGFkcy5mb3JFYWNoKCh2LCBpKSA9PiAodXBkYXRlUGFkc1tOdW1iZXIoaSldID0gTnVtYmVyKHYpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcGFkczogbnVtYmVyW10gPSBbXTtcclxuICAgIHVwZGF0ZVBhZHMuZm9yRWFjaCgodikgPT4gcGFkcy5wdXNoKHYpKTtcclxuXHJcbiAgICByZXR1cm4geyBtb2RlOiBhdHRyaWJ1dGVzLm1vZGUsIHZhbHVlLCBwYWRzIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBjcmVhdGVQYWRBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVBhZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcyksIHsgaW5wdXRzOiBbMF0gfSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgZW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBQb29sQ29udlV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgZ2V0RWxlbWVudEF0LFxyXG4gIEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuLy8gVE9ETzogc3VwcG9ydDpcclxuLy8gLSBjZWlsX21vZGUgICAgICAgICAgICAgICAgIFwidGVzdF9tYXhwb29sXzJkX2NlaWxcIlxyXG4vLyAtIHN0b3JhZ2Vfb3JkZXIgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfd2l0aF9hcmdtYXhfMmRfcHJlY29tcHV0ZWRfc3RyaWRlc1wiXHJcbi8vIC0gW01heFBvb2xdIGRpbGF0aW9ucyAgICAgICBcInRlc3RfbWF4cG9vbF8yZF9kaWxhdGlvbnNcIlxyXG4vLyAtIFtNYXhQb29sXSBvdXRwdXRbMV0gICAgICAgXCJ0ZXN0X21heHBvb2xfd2l0aF9hcmdtYXhfMmRfcHJlY29tcHV0ZWRfcGFkc1wiXHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xyXG4gIGlmIChlbnYud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50ICYmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZ2V0QWRqdXN0ZWRQb29sQXR0cmlidXRlc0FuZE91dHB1dFNoYXBlID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXHJcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXHJcbiAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcclxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxyXG4pOiBbQXR0cmlidXRlVHlwZSwgbnVtYmVyW11dID0+IHtcclxuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XHJcbiAgY29uc3QgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0ID0gaW5wdXQuZGltcy5zbGljZSgpO1xyXG4gIGlmIChpc0NoYW5uZWxzTGFzdCkge1xyXG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LnNwbGljZSgxLCAwLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QucG9wKCkhKTsgLy8gTW92ZSBjaGFubmVsIHRvIHRoZSBzZWNvbmQgcG9zaXRpb24uXHJcbiAgfVxyXG4gIGNvbnN0IGhhc0RpbGF0aW9ucyA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsICdkaWxhdGlvbnMnKTtcclxuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcclxuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzLnNsaWNlKCk7XHJcbiAgY29uc3QgZGlsYXRpb25zOiBudW1iZXJbXSA9IGhhc0RpbGF0aW9ucyA/IChhdHRyaWJ1dGVzIGFzIE1heFBvb2xBdHRyaWJ1dGVzKS5kaWxhdGlvbnMuc2xpY2UoKSA6IFtdO1xyXG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcclxuICBQb29sQ29udlV0aWwuYWRqdXN0UG9vbEF0dHJpYnV0ZXMoaXNHbG9iYWxPcGVyYXRvciwgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LCBrZXJuZWxTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWRzKTtcclxuXHJcbiAgY29uc3Qgb3V0cHV0U2hhcGVBc0NoYW5uZWxGaXJzdCA9IFBvb2xDb252VXRpbC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKFxyXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcclxuICAgIGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCxcclxuICAgIHN0cmlkZXMsXHJcbiAgICBkaWxhdGlvbnMsXHJcbiAgICBrZXJuZWxTaGFwZSxcclxuICAgIHBhZHMsXHJcbiAgICBhdHRyaWJ1dGVzLmF1dG9QYWQsXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgbmV3QXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpO1xyXG4gIGlmIChoYXNEaWxhdGlvbnMpIHtcclxuICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgZGlsYXRpb25zLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleSB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleSB9KTtcclxuICB9XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0ID0gb3V0cHV0U2hhcGVBc0NoYW5uZWxGaXJzdC5zbGljZSgpO1xyXG4gIG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdC5wdXNoKG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdC5zcGxpY2UoMSwgMSlbMF0pO1xyXG4gIHJldHVybiBbbmV3QXR0cmlidXRlcywgaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3QgOiBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0XTtcclxufTtcclxuXHJcbmNvbnN0IGdldFVuaWZvcm1BbmRQYWRJbmZvID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXHJcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZVR5cGUsXHJcbik6IFtQcm9ncmFtVW5pZm9ybVtdLCBVbmlmb3Jtc0FycmF5VHlwZSwgYm9vbGVhbiwgYm9vbGVhbiwgYm9vbGVhbl0gPT4ge1xyXG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcclxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtlcm5lbFNpemUgfSxcclxuICBdO1xyXG4gIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgIHsgbmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgeyBuYW1lOiAna2VybmVsU2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgXTtcclxuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xyXG4gICAgY29uc3Qga3cgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCBzdyA9IGF0dHJpYnV0ZXMuc3RyaWRlc1thdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCBwd1N0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMV07XHJcbiAgICBjb25zdCBwd0VuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMV07XHJcbiAgICBjb25zdCBwd1N0YXJ0RW5kTm90WmVybyA9ICEhKHB3U3RhcnQgKyBwd0VuZCk7XHJcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcclxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGt3IH0sXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzdyB9LFxyXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcHdTdGFydCB9LFxyXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcHdFbmQgfSxcclxuICAgICk7XHJcbiAgICB1bmlmb3Jtcy5wdXNoKFxyXG4gICAgICB7IG5hbWU6ICdrdycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ3N3JywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAncHdTdGFydCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ3B3RW5kJywgdHlwZTogJ3UzMicgfSxcclxuICAgICk7XHJcblxyXG4gICAgbGV0IHBoU3RhcnRFbmROb3RaZXJvID0gZmFsc2U7XHJcbiAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDIpIHtcclxuICAgICAgY29uc3Qga2ggPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMl07XHJcbiAgICAgIGNvbnN0IHNoID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAyXTtcclxuICAgICAgY29uc3QgcGhTdGFydCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC8gMiAtIDJdO1xyXG4gICAgICBjb25zdCBwaEVuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMl07XHJcbiAgICAgIHBoU3RhcnRFbmROb3RaZXJvID0gISEocGhTdGFydCArIHBoRW5kKTtcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtoIH0sXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNoIH0sXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBoU3RhcnQgfSxcclxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGhFbmQgfSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHVuaWZvcm1zLnB1c2goXHJcbiAgICAgICAgeyBuYW1lOiAna2gnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICAgIHsgbmFtZTogJ3NoJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgICB7IG5hbWU6ICdwaFN0YXJ0JywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgICB7IG5hbWU6ICdwaEVuZCcsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsIHRydWUsIHB3U3RhcnRFbmROb3RaZXJvLCBwaFN0YXJ0RW5kTm90WmVyb107XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LicpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qga2VybmVsU3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcclxuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxyXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga2VybmVsU3RyaWRlcyB9LFxyXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5wYWRzIH0sXHJcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnN0cmlkZXMgfSxcclxuICAgICk7XHJcbiAgICB1bmlmb3Jtcy5wdXNoKFxyXG4gICAgICB7IG5hbWU6ICdrZXJuZWxTdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDoga2VybmVsU3RyaWRlcy5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggfSxcclxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggfSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgaGFzUGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5yZWR1Y2UoKHN1bSwgY3VyKSA9PiBzdW0gKyBjdXIpO1xyXG4gICAgcmV0dXJuIFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCAhIWhhc1BhZHMsIGZhbHNlLCBmYWxzZV07XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZ2VuZXJhdGVQb29saW5nQ29kZSA9IDxBdHRyaWJ1dGVUeXBlIGV4dGVuZHMgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzIHwgTWF4UG9vbEF0dHJpYnV0ZXM+KFxyXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxyXG4gIHg6IEluZGljZXNIZWxwZXIsXHJcbiAgcmFuazogbnVtYmVyLFxyXG4gIG91dHB1dFNoYXBlUmFuazogbnVtYmVyLFxyXG4gIGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZVR5cGUsXHJcbiAgb3AxOiBzdHJpbmcsXHJcbiAgb3AyOiBzdHJpbmcsXHJcbiAgc3RhcnQ6IG51bWJlcixcclxuICB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUsXHJcbiAgaGFzUGFkczogYm9vbGVhbixcclxuICBwd1N0YXJ0RW5kTm90WmVybzogYm9vbGVhbixcclxuICBwaFN0YXJ0RW5kTm90WmVybzogYm9vbGVhbixcclxuKTogc3RyaW5nID0+IHtcclxuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XHJcbiAgY29uc3QgZGF0YVR5cGUgPSB4LnR5cGUudmFsdWU7XHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHgudHlwZS50ZW5zb3IsIG91dHB1dFNoYXBlUmFuayk7XHJcblxyXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA8PSAyKSB7XHJcbiAgICBsZXQgY29kZVcgPSAnJztcclxuICAgIGxldCBjb2RlSCA9ICcnO1xyXG4gICAgbGV0IGNvZGVIRW5kID0gJyc7XHJcbiAgICBjb25zdCBkaW1JZHhXID0gcmFuayAtIChpc0NoYW5uZWxzTGFzdCA/IDIgOiAxKTtcclxuICAgIGlmIChwd1N0YXJ0RW5kTm90WmVybykge1xyXG4gICAgICBjb2RlVyA9IGBcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeFd9XSA9IGluZGljZXNbJHtkaW1JZHhXfV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtkaW1JZHhXfV0gPCAwIHx8IHhJbmRpY2VzWyR7ZGltSWR4V31dXHJcbiAgICAgICAgICAgICAgICAgICAgICA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7ZGltSWR4V31dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkKys7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XHJcbiAgICAgICAgICAgICAgICAgICR7b3AxfVxyXG4gICAgICAgICAgICAgICAgfWA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2RlVyA9IGBcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeFd9XSA9IGluZGljZXNbJHtkaW1JZHhXfV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xyXG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7eC5pbmRpY2VzVG9PZmZzZXQoJ3hJbmRpY2VzJyl9XTtcclxuICAgICAgICAgICAgICAgICAgJHtvcDF9XHJcbiAgICAgICAgICAgICAgICB9YDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDIpIHtcclxuICAgICAgY29uc3QgZGltSWR4SCA9IHJhbmsgLSAoaXNDaGFubmVsc0xhc3QgPyAzIDogMik7XHJcbiAgICAgIGlmIChwaFN0YXJ0RW5kTm90WmVybykge1xyXG4gICAgICAgIGNvZGVIID0gYFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4SH1dID0gaW5kaWNlc1ske2RpbUlkeEh9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske2RpbUlkeEh9XSA8IDAgfHwgeEluZGljZXNbJHtkaW1JZHhIfV0gPj0gdW5pZm9ybXMueF9zaGFwZVske2RpbUlkeEh9XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZCArPSBpMzIodW5pZm9ybXMua3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb2RlSCA9IGBcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeEh9XSA9IGluZGljZXNbJHtkaW1JZHhIfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xyXG4gICAgICAgICAgICAgICAgYDtcclxuICAgICAgfVxyXG4gICAgICBjb2RlSEVuZCA9IGBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcG9vbGluZ0NvZGUgPSBgXHJcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgb3V0cHV0KX1cclxuXHJcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cclxuXHJcbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG5cclxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgke3N0YXJ0fSk7XHJcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XHJcbiAgICAgICAgICAgICAgJHtjb2RlSH1cclxuICAgICAgICAgICAgICAke2NvZGVXfVxyXG4gICAgICAgICAgICAgICR7Y29kZUhFbmR9XHJcbiAgICAgICAgICAgICAgJHtvcDJ9XHJcblxyXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9YDtcclxuICAgIHJldHVybiBwb29saW5nQ29kZTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdHJpZGVzUmFuayA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoO1xyXG4gICAgY29uc3QgcGFkc1JhbmsgPSBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoO1xyXG4gICAgbGV0IHBhZENvZGUgPSAnJztcclxuICAgIGlmIChoYXNQYWRzKSB7XHJcbiAgICAgIHBhZENvZGUgPSBgXHJcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbal0gPj0gdW5pZm9ybXMueF9zaGFwZVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICBwYWQrKztcclxuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XHJcbiAgICAgICAgICAgICAgICAke29wMX1cclxuICAgICAgICAgICAgICB9YDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhZENvZGUgPSBgXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xyXG4gICAgICAgICAgICAgICR7b3AxfVxyXG4gICAgICAgICAgICBgO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcG9vbGluZ0NvZGUgPSBgXHJcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgb3V0cHV0KX1cclxuXHJcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cclxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XHJcblxyXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7c3RyaWRlc1Jhbmt9PjtcclxuXHJcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oJHtzdGFydH0pO1xyXG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xyXG4gICAgICAgICAgICAgIHZhciBpc1BhZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmtlcm5lbFNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke3N0cmlkZXNSYW5rIC0gMX11OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzJywgJ2onLCBzdHJpZGVzUmFuayl9O1xyXG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzJywgJ2onLCBzdHJpZGVzUmFuayl9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0c1ske3N0cmlkZXNSYW5rIC0gMX1dID0gb2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dTsgaiA8ICR7cmFua311OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogJHtnZXRFbGVtZW50QXQoXHJcbiAgICAgICAgICAgICAgICAgICAgJ3VuaWZvcm1zLnN0cmlkZXMnLFxyXG4gICAgICAgICAgICAgICAgICAgIGBqIC0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dWAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaWRlc1JhbmssXHJcbiAgICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3JhbmsgLSBzdHJpZGVzUmFua311XSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgJ2ogLSAydScsIHBhZHNSYW5rKX07XHJcbiAgICAgICAgICAgICAgICAgICR7cGFkQ29kZX1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgJHtvcDJ9XHJcblxyXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9YDtcclxuICAgIHJldHVybiBwb29saW5nQ29kZTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdEF0dHJpYnV0ZXMge1xyXG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnIHwgJ05DSFcnO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBvb2xDb21tb25BdHRyaWJ1dGVzIGV4dGVuZHMgRm9ybWF0QXR0cmlidXRlcyB7XHJcbiAgcmVhZG9ubHkgYXV0b1BhZDogc3RyaW5nO1xyXG4gIHJlYWRvbmx5IGNlaWxNb2RlOiBudW1iZXI7XHJcbiAgcmVhZG9ubHkga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xyXG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xyXG59XHJcblxyXG5jb25zdCBjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBQb29sQ29tbW9uQXR0cmlidXRlcyk6IHN0cmluZyA9PlxyXG4gIGAke2F0dHJpYnV0ZXMuZm9ybWF0fTske2F0dHJpYnV0ZXMuY2VpbE1vZGV9OyR7YXR0cmlidXRlcy5hdXRvUGFkfTske2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RofWA7XHJcblxyXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHN0cmluZyA9PlxyXG4gIGAke2NyZWF0ZVNoYWRlcktleUZyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpfTske2F0dHJpYnV0ZXMuY291bnRJbmNsdWRlUGFkfWA7XHJcblxyXG5jb25zdCBjcmVhdGVNYXhQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiBzdHJpbmcgPT5cclxuICBgJHtjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKX07JHthdHRyaWJ1dGVzLnN0b3JhZ2VPcmRlcn07JHthdHRyaWJ1dGVzLmRpbGF0aW9uc31gO1xyXG5cclxuY29uc3QgcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFBvb2xDb21tb25BdHRyaWJ1dGVzID0+ICh7XHJcbiAgZm9ybWF0OiBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXSxcclxuICBhdXRvUGFkOiBbJ05PVFNFVCcsICdWQUxJRCcsICdTQU1FX1VQUEVSJywgJ1NBTUVfTE9XRVInXVthdHRyaWJ1dGVzLmF1dG9fcGFkIGFzIG51bWJlcl0sXHJcbiAgY2VpbE1vZGU6IGF0dHJpYnV0ZXMuY2VpbF9tb2RlIGFzIG51bWJlcixcclxuICBrZXJuZWxTaGFwZTogYXR0cmlidXRlcy5rZXJuZWxfc2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSxcclxuICBzdHJpZGVzOiBhdHRyaWJ1dGVzLnN0cmlkZXMgYXMgW251bWJlciwgbnVtYmVyXSxcclxuICBwYWRzOiBhdHRyaWJ1dGVzLnBhZHMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBQb29sQ29tbW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBjb3VudEluY2x1ZGVQYWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmNvbnN0IGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8gPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxyXG4gIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXHJcbiAgYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgW2FkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGVdID0gZ2V0QWRqdXN0ZWRQb29sQXR0cmlidXRlc0FuZE91dHB1dFNoYXBlKFxyXG4gICAgaW5wdXQsXHJcbiAgICBhdHRyaWJ1dGVzLFxyXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcclxuICApO1xyXG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMubGVuZ3RoKTtcclxuICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcclxuXHJcbiAgY29uc3Qgb3AxID0gJ3ZhbHVlICs9IHhfdmFsOyc7XHJcbiAgbGV0IG9wMiA9ICcnO1xyXG4gIGlmIChhZGp1c3RlZEF0dHJpYnV0ZXMuY291bnRJbmNsdWRlUGFkKSB7XHJcbiAgICBvcDIgKz0gYHZhbHVlIC89ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A7XHJcbiAgfSBlbHNlIHtcclxuICAgIG9wMiArPSBgdmFsdWUgLz0gJHtkYXRhVHlwZX0oaTMyKHVuaWZvcm1zLmtlcm5lbFNpemUpIC0gcGFkKTtgO1xyXG4gIH1cclxuICBjb25zdCBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgaGFzUGFkcywgcHdTdGFydEVuZE5vdFplcm8sIHBoU3RhcnRFbmROb3RaZXJvXSA9IGdldFVuaWZvcm1BbmRQYWRJbmZvKFxyXG4gICAgb3V0cHV0U2hhcGUsXHJcbiAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXHJcbiAgKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dC5kaW1zLCBvdXRwdXRTaGFwZSkpO1xyXG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJ107XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWUsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2hhc1BhZHN9OyR7cHdTdGFydEVuZE5vdFplcm99OyR7cGhTdGFydEVuZE5vdFplcm99YCxcclxuICAgICAgaW5wdXREZXBlbmRlbmNpZXMsXHJcbiAgICB9LFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dC5kYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyKSA9PlxyXG4gICAgICBnZW5lcmF0ZVBvb2xpbmdDb2RlKFxyXG4gICAgICAgIHNoYWRlckhlbHBlcixcclxuICAgICAgICB4LFxyXG4gICAgICAgIGlucHV0LmRpbXMubGVuZ3RoLFxyXG4gICAgICAgIG91dHB1dFNoYXBlLmxlbmd0aCxcclxuICAgICAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgb3AxLFxyXG4gICAgICAgIG9wMixcclxuICAgICAgICAwLjAsXHJcbiAgICAgICAgdW5pZm9ybXMsXHJcbiAgICAgICAgaGFzUGFkcyxcclxuICAgICAgICBwd1N0YXJ0RW5kTm90WmVybyxcclxuICAgICAgICBwaFN0YXJ0RW5kTm90WmVybyxcclxuICAgICAgKSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBjb3VudEluY2x1ZGVQYWQgPSAoYXR0cmlidXRlcy5jb3VudF9pbmNsdWRlX3BhZCBhcyBudW1iZXIpID09PSAwID8gZmFsc2UgOiB0cnVlO1xyXG5cclxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcclxuICAvLyBUT0RPOiBzdXBwb3J0IGF0dHJpYnV0ZSAnY2VpbF9tb2RlJ1xyXG4gIGlmIChhdHRyLmNlaWxNb2RlICE9PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2wnKTtcclxuICB9XHJcbiAgY29uc3QgYXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0geyBjb3VudEluY2x1ZGVQYWQsIC4uLmF0dHIsIGNhY2hlS2V5OiAnJyB9O1xyXG4gIHJldHVybiB7IC4uLmF2ZXJhZ2VQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZUF2ZXJhZ2VQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXZlcmFnZVBvb2xBdHRyaWJ1dGVzKSB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8oJ0F2ZXJhZ2VQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIGZhbHNlLCBhdHRyaWJ1dGVzKSk7XHJcbn07XHJcblxyXG5jb25zdCBnbG9iYWxQb29sQXR0cmlidXRlcyA9IHtcclxuICBhdXRvUGFkOiAnJyxcclxuICBjZWlsTW9kZTogMCxcclxuICBjb3VudEluY2x1ZGVQYWQ6IGZhbHNlLFxyXG4gIGtlcm5lbFNoYXBlOiBbXSxcclxuICBzdHJpZGVzOiBbXSxcclxuICBwYWRzOiBbXSxcclxuICBzdG9yYWdlT3JkZXI6IDAsXHJcbiAgZGlsYXRpb25zOiBbXSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9PiB7XHJcbiAgY29uc3QgZm9ybWF0ID0gYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0QXR0cmlidXRlc1snZm9ybWF0J107XHJcbiAgcmV0dXJuIHsgZm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdCB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdsb2JhbEF2ZXJhZ2VQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8oJ0dsb2JhbEF2ZXJhZ2VQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIHRydWUsIGF0dHJpYnV0ZXMpKTtcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWF4UG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBQb29sQ29tbW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBzdG9yYWdlT3JkZXI6IG51bWJlcjtcclxuICByZWFkb25seSBkaWxhdGlvbnM6IG51bWJlcltdO1xyXG59XHJcblxyXG5jb25zdCBjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8gPSAoXHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxyXG4gIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXHJcbiAgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBbYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZV0gPSBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUoXHJcbiAgICBpbnB1dCxcclxuICAgIGF0dHJpYnV0ZXMsXHJcbiAgICBpc0dsb2JhbE9wZXJhdG9yLFxyXG4gICk7XHJcbiAgY29uc3Qgb3AxID0gYFxyXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xyXG4gICAgYDtcclxuICBjb25zdCBvcDIgPSAnJztcclxuICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLmxlbmd0aCk7XHJcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcclxuICBjb25zdCBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgaGFzUGFkcywgcHdTdGFydEVuZE5vdFplcm8sIHBoU3RhcnRFbmROb3RaZXJvXSA9IGdldFVuaWZvcm1BbmRQYWRJbmZvKFxyXG4gICAgb3V0cHV0U2hhcGUsXHJcbiAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXHJcbiAgKTtcclxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dC5kaW1zLCBvdXRwdXRTaGFwZSkpO1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHtcclxuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtoYXNQYWRzfTske3B3U3RhcnRFbmROb3RaZXJvfTske3BoU3RhcnRFbmROb3RaZXJvfWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxyXG4gICAgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXQuZGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cclxuICAgICAgZ2VuZXJhdGVQb29saW5nQ29kZShcclxuICAgICAgICBzaGFkZXJIZWxwZXIsXHJcbiAgICAgICAgeCxcclxuICAgICAgICBpbnB1dC5kaW1zLmxlbmd0aCxcclxuICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGgsXHJcbiAgICAgICAgYWRqdXN0ZWRBdHRyaWJ1dGVzLFxyXG4gICAgICAgIG9wMSxcclxuICAgICAgICBvcDIsXHJcbiAgICAgICAgaW5wdXQuZGF0YVR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYgPyAtNjU1MDQgOiAtMWU1LFxyXG4gICAgICAgIHVuaWZvcm1zLFxyXG4gICAgICAgIGhhc1BhZHMsXHJcbiAgICAgICAgcHdTdGFydEVuZE5vdFplcm8sXHJcbiAgICAgICAgcGhTdGFydEVuZE5vdFplcm8sXHJcbiAgICAgICksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBtYXhQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKCdNYXhQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIGZhbHNlLCBhdHRyaWJ1dGVzKSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VNYXhQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1heFBvb2xBdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBzdG9yYWdlT3JkZXIgPSBhdHRyaWJ1dGVzLnN0b3JhZ2Vfb3JkZXIgYXMgbnVtYmVyO1xyXG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIFtudW1iZXIsIG51bWJlcl07XHJcblxyXG4gIGNvbnN0IGF0dHIgPSBwYXJzZVBvb2xDb21tb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xyXG4gIC8vIFRPRE86IHN1cHBvcnQgYXR0cmlidXRlICdjZWlsX21vZGUnIGFuZCAnc3RvcmFnZV9vcmRlcidcclxuICBpZiAoc3RvcmFnZU9yZGVyICE9PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sJyk7XHJcbiAgfVxyXG4gIGlmIChhdHRyLmNlaWxNb2RlICE9PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xyXG4gIH1cclxuICBjb25zdCBtYXhQb29sQXR0cmlidXRlcyA9IHsgc3RvcmFnZU9yZGVyLCBkaWxhdGlvbnMsIC4uLmF0dHIsIGNhY2hlS2V5OiAnJyB9O1xyXG4gIHJldHVybiB7IC4uLm1heFBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogY3JlYXRlTWF4UG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzKG1heFBvb2xBdHRyaWJ1dGVzKSB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlR2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBNYXhQb29sQXR0cmlidXRlcyA9PiB7XHJcbiAgY29uc3QgZm9ybWF0ID0gYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0QXR0cmlidXRlc1snZm9ybWF0J107XHJcbiAgcmV0dXJuIHsgZm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdCB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8oJ0dsb2JhbE1heFBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgdHJ1ZSwgYXR0cmlidXRlcykpO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xyXG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBnZXRNYXhDb21wb25lbnRzLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGVxdWFudGl6ZUxpbmVyQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgYXhpczogbnVtYmVyO1xyXG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogRGVxdWFudGl6ZUxpbmVyQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgMiB8fCBpbnB1dHMubGVuZ3RoID4gMykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXF1YW50aXplTGluZWFyIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMuJyk7XHJcbiAgfVxyXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1sxXS5kaW1zID09PSBpbnB1dHNbMl0uZGltcykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd4LXNjYWxlIGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLicpO1xyXG4gIH1cclxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IGlucHV0c1syXS5kYXRhVHlwZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd4IGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZS4nKTtcclxuICB9XHJcbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIgJiYgaW5wdXRzLmxlbmd0aCA+IDIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW4gdGhlIGNhc2Ugb2YgZGVxdWFudGl6aW5nIGludDMyIHRoZXJlIGlzIG5vIHplcm8gcG9pbnQuJyk7XHJcbiAgfVxyXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDAgJiYgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxICYmIGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYWxlIGlucHV0IG11c3QgYmUgYSBzY2FsYXIsIGEgMUQgdGVuc29yLCBvciBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvci4nKTtcclxuICB9XHJcbiAgLy8gdmFsaWRhdGUgc2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXQgc2hhcGVzXHJcbiAgaWYgKGlucHV0cy5sZW5ndGggPiAyKSB7XHJcbiAgICAvLyB6ZXJvLXBvaW50IGlucHV0IHR5cGUgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIGlucHV0IGRhdGEgdHlwZS5cclxuICAgIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgIT09IGlucHV0c1syXS5kYXRhVHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLicpO1xyXG4gICAgfVxyXG4gICAgLy8gU2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZVxyXG4gICAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzJdLmRpbXMubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpbnB1dHNbMV0uZGltcy5tYXAoKGQsIGkpID0+IGQgPT09IGlucHV0c1syXS5kaW1zW2ldKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLicpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBWYWxpZGF0ZSBibG9ja1NpemVcclxuICBpZiAoYXR0cmlidXRlcy5ibG9ja1NpemUgPiAwKSB7XHJcbiAgICAvLyBCbG9jayBxdW5hdGl6YXRpb25cclxuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggPT09IDAgfHwgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHNbMV0uZGltc1swXSA9PT0gMSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9ja1NpemUgbXVzdCBiZSBzZXQgb25seSBmb3IgYmxvY2sgcXVhbnRpemF0aW9uLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKFxyXG4gICAgICAhaW5wdXRzWzFdLmRpbXMubWFwKChkLCBpKSA9PiBpID09PSBhdHRyaWJ1dGVzLmF4aXMgfHwgZCA9PT0gaW5wdXRzWzBdLmRpbXNbaV0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKVxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm9yIGJsb2NrIHF1bmF0aXphdGlvbiwgc2NhbGUgaW5wdXQgc2hhcGUgdG8gbWF0Y2ggdGhlIGlucHV0IHNoYXBlIGV4Y2VwdCBmb3IgdGhlIGF4aXMnKTtcclxuICAgIH1cclxuICAgIC8vIFNjYWxlIGlucHV0IHJhbmsgc2hvdWxkIGJlIHNhbWUgYXMgdGhlIGlucHV0IHJhbmtcclxuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvciBibG9jayBxdW5hdGl6YXRpb24gdGhlIHNjYWxlIGlucHV0IHJhbmsgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgeCByYW5rLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZEkgPSBpbnB1dHNbMF0uZGltc1thdHRyaWJ1dGVzLmF4aXNdO1xyXG4gICAgY29uc3Qgc2kgPSBpbnB1dHNbMV0uZGltc1thdHRyaWJ1dGVzLmF4aXNdO1xyXG4gICAgaWYgKGF0dHJpYnV0ZXMuYmxvY2tTaXplIDwgTWF0aC5jZWlsKGRJIC8gc2kpIHx8IGF0dHJpYnV0ZXMuYmxvY2tTaXplID4gTWF0aC5jZWlsKGRJIC8gKHNpIC0gMSkgLSAxKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NrU2l6ZSBtdXN0IGJlIHdpdGggaW4gdGhlIHJhbmdlIFtjZWlsKGRJIC8gU2kpLCBjZWlsKGRJIC8gKFNpIC0gMSkgLSAxKV0uJyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlRGVxdWFudGl6ZUxpbmVhclByb2dyYW1JbmZvID0gKFxyXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGF0dHJpYnV0ZXM6IERlcXVhbnRpemVMaW5lckF0dHJpYnV0ZXMsXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xyXG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcclxuICBjb25zdCBpc1NpZ25lZCA9IGlucHV0VHlwZSA9PT0gRGF0YVR5cGUuaW50ODtcclxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zOyAvLyBvdXRwdXQgc2hhcGUgaXMgc2FtZSBhcyB0aGUgaW5wdXQgc2hhcGVcclxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1sxXS5kYXRhVHlwZTsgLy8gb3V0cHV0IHR5cGUgaXMgc2FtZSBhcyB0aGUgdGhlIHNjYWxlIGlucHV0IHR5cGVcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gIGNvbnN0IGlzUGFja2VkID0gaW5wdXRUeXBlID09PSBEYXRhVHlwZS5pbnQ4IHx8IGlucHV0VHlwZSA9PT0gRGF0YVR5cGUudWludDg7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlzUGFja2VkID8gW01hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShpbnB1dHNbMF0uZGltcykgLyA0KV0gOiBpbnB1dHNbMF0uZGltcztcclxuICBjb25zdCBzY2FsZVNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XHJcbiAgY29uc3QgemVyb1BvaW50SW5wdXQgPSBpbnB1dHMubGVuZ3RoID4gMiA/IGlucHV0c1syXSA6IHVuZGVmaW5lZDtcclxuICBjb25zdCB6ZXJvUG9pbnRTaGFwZSA9IHplcm9Qb2ludElucHV0XHJcbiAgICA/IGlzUGFja2VkXHJcbiAgICAgID8gW01hdGguY2VpbChTaGFwZVV0aWwuc2l6ZSh6ZXJvUG9pbnRJbnB1dC5kaW1zKSAvIDQpXVxyXG4gICAgICA6IHplcm9Qb2ludElucHV0LmRpbXNcclxuICAgIDogdW5kZWZpbmVkO1xyXG4gIC8vIFNjYWxlcyBpbnB1dCBpcyBhIHNjYWxlciBmb3IgcGVyLXRlbnNvci9wZXItbGF5ZXIgcXVhbnRpemF0aW9uLCAxLUQgdGVuc29yIGZvciBwZXItYXhpcyBxdWFudGl6YXRpb25cclxuICAvLyBvciB0ZW5zb3Igd2l0aCBzYW1lIHJhbmsgYXMgaW5wdXQgZm9yIGJsb2NrZWQgcXVhbnRpemF0aW9uLlxyXG4gIGNvbnN0IHBlckxheWVyUXVhbnRpemF0aW9uID0gc2NhbGVTaGFwZS5sZW5ndGggPT09IDAgfHwgKHNjYWxlU2hhcGUubGVuZ3RoID09PSAxICYmIHNjYWxlU2hhcGVbMF0gPT09IDEpO1xyXG4gIGNvbnN0IHBlckF4aXNRdWFudGl6YXRpb24gPSBwZXJMYXllclF1YW50aXphdGlvbiA9PT0gZmFsc2UgJiYgc2NhbGVTaGFwZS5sZW5ndGggPT09IDE7XHJcbiAgLy8gTGVmdCB1bm5lY2Vzc2FyeSBjb21tZW50ZWQtb3V0IGFzc2lnbm1lbnQgZm9yIGRvY3VtZW50YXRpb25cclxuICAvLyBjb25zdCBibG9ja1F1YW50aXphdGlvbiA9IHBlckxheWVyUXVhbnRpemF0aW9uID09PSBmYWxzZSAmJiBwZXJBeGlzUXVhbnRpemF0aW9uID09PSBmYWxzZTtcclxuICBjb25zdCBtYXhDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaXplKTtcclxuICBjb25zdCB1c2VDb21wb25lbnRzID0gcGVyTGF5ZXJRdWFudGl6YXRpb24gJiYgKCFpc1BhY2tlZCB8fCBtYXhDb21wb25lbnRzID09PSA0KTtcclxuICBjb25zdCBjb21wb25lbnRzID0gdXNlQ29tcG9uZW50cyA/IG1heENvbXBvbmVudHMgOiAxO1xyXG4gIGNvbnN0IGlucHV0Q29tcG9uZW50ID0gdXNlQ29tcG9uZW50cyAmJiAhaXNQYWNrZWQgPyBtYXhDb21wb25lbnRzIDogMTtcclxuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaXNQYWNrZWQgPyBEYXRhVHlwZS51aW50MzIgOiBpbnB1dFR5cGUsIGlucHV0U2hhcGUubGVuZ3RoLCBpbnB1dENvbXBvbmVudCk7XHJcbiAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIGRhdGFUeXBlLCBzY2FsZVNoYXBlLmxlbmd0aCk7XHJcbiAgY29uc3QgemVyb1BvaW50ID0gemVyb1BvaW50SW5wdXRcclxuICAgID8gaW5wdXRWYXJpYWJsZSgnemVyb19wb2ludCcsIGlzUGFja2VkID8gRGF0YVR5cGUudWludDMyIDogaW5wdXRUeXBlLCB6ZXJvUG9pbnRTaGFwZSEubGVuZ3RoKVxyXG4gICAgOiB1bmRlZmluZWQ7XHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG4gIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2lucHV0LCBzY2FsZV07XHJcbiAgaWYgKHplcm9Qb2ludCkge1xyXG4gICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnQpO1xyXG4gIH1cclxuICBjb25zdCBpbnB1dFNoYXBlcyA9IFtpbnB1dFNoYXBlLCBzY2FsZVNoYXBlXTtcclxuICBpZiAoemVyb1BvaW50SW5wdXQpIHtcclxuICAgIGlucHV0U2hhcGVzLnB1c2goemVyb1BvaW50U2hhcGUhKTtcclxuICB9XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgLyBjb21wb25lbnRzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXhpcyB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuYmxvY2tTaXplIH0sXHJcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyguLi5pbnB1dFNoYXBlcywgb3V0cHV0U2hhcGUpLFxyXG4gIF07XHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XHJcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXHJcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcclxuICAgICAgeyBuYW1lOiAnYXhpcycsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2Jsb2NrX3NpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgXTtcclxuICAgIHJldHVybiBgXHJcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XHJcbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgaW5wdXQgeFxyXG4gICAgICAgICAgJHsoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNQYWNrZWQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4IC8gNCcpfTtcclxuICAgICAgICAgICAgbGV0IHhfdmVjID0gJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4KGlucHV0KScgOiAndW5wYWNrNHhVOChpbnB1dCknfTtcclxuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAke2NvbXBvbmVudHMgPT09IDEgPyAneF92ZWNbZ2xvYmFsX2lkeCAlIDRdJyA6ICd4X3ZlYyd9O2A7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBsZXQgeF92YWx1ZSA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSkoKX07XHJcblxyXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XHJcbiAgICAgICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwZXJMYXllclF1YW50aXphdGlvbikge1xyXG4gICAgICAgICAgICAgIC8vIHNjYWxlIGlucHV0IGlzIGEgc2NhbGFyICgpXHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBsZXQgc2NhbGVfdmFsdWU9ICR7c2NhbGUuZ2V0QnlPZmZzZXQoJzAnKX1gO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBlckF4aXNRdWFudGl6YXRpb24pIHtcclxuICAgICAgICAgICAgICAvLyBzY2FsZSBpbnB1dCBpcyBhIDFEIHRlbnNvclxyXG4gICAgICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgIGxldCBzY2FsZV9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX07XHJcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtzY2FsZS5nZXRCeU9mZnNldCgnc2NhbGVfaW5kZXgnKX07YDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBCbG9jayBxdWFudGl6YXRpb24uIFNjYWxlIGlucHV0IHJhbmsgaXMgc2FtZSBhcyBpbnB1dC9vdXRwdXQgcmFuay5cclxuICAgICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICB2YXIgc2NhbGVfaW5kaWNlczogJHtzY2FsZS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7c2NhbGUuaW5kaWNlc0dldCgnc2NhbGVfaW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJyl9IC8gdW5pZm9ybXMuYmxvY2tfc2l6ZTtcclxuICAgICAgICAgICAgJHtzY2FsZS5pbmRpY2VzU2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnLCAnaW5kZXgnKX07XHJcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtzY2FsZS5nZXRCeUluZGljZXMoJ3NjYWxlX2luZGljZXMnKX07YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSkoKX07XHJcblxyXG4gICAgICAgICAgLy8gU2V0IHplcm8tcG9pbnQgaW5wdXRcclxuICAgICAgICAgICR7KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHplcm9Qb2ludCkge1xyXG4gICAgICAgICAgICAgIGlmIChwZXJMYXllclF1YW50aXphdGlvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gemVyby1wb2ludCBpbnB1dCBpcyBhIHNjYWxhclxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGFja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCcwJyl9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KScgOiAndW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KSd9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWU9IHplcm9fcG9pbnRfdmVjWzBdYDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnMCcpfWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZXJBeGlzUXVhbnRpemF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB6ZXJvLXBvaW50IGlucHV0IGlzIGEgMUQgdGVuc29yXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQYWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfTtcclxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJ3plcm9fcG9pbnRfaW5kZXggLyA0Jyl9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KScgOiAndW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KSd9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4ICUgNF1gO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfTtcclxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJ3plcm9fcG9pbnRfaW5kZXgnKX07YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQmxvY2tlZFF1YW50aXphdGlvbi4gVGhlIHplcm8tcG9pbnQgaW5wdXQgc2hhcGUgaXMgc2FtZSBhcyB0aGUgaW5wdXQgc2hhcGUgZXhjZXB0IGFsb25nIGF4aXMuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQYWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7c2NhbGUuaW5kaWNlc1RvT2Zmc2V0KCdzY2FsZV9pbmRpY2VzJyl9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnemVyb19wb2ludF9vZmZzZXQgLyA0Jyl9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpJyA6ICd1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpJ307XHJcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfb2Zmc2V0ICUgNF07YDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3plcm9Qb2ludC5nZXRCeUluZGljZXMoJ3NjYWxlX2luZGljZXMnKX07YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7aXNQYWNrZWQgPyAoaXNTaWduZWQgPyAnaTMyJyA6ICd1MzInKSA6IGlucHV0LnR5cGUudmFsdWV9KDApO2A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pKCl9O1xyXG4gICAgICAvLyBDb21wdXRlIGFuZCB3cml0ZSBvdXRwdXRcclxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBgJHtvdXRwdXQudHlwZS52YWx1ZX0oeF92YWx1ZSAtIHplcm9fcG9pbnRfdmFsdWUpICogc2NhbGVfdmFsdWVgKX07XHJcbiAgICAgIH1gO1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdEZXF1YW50aXplTGluZWFyJyxcclxuICAgIHNoYWRlckNhY2hlOiB7XHJcbiAgICAgIGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiB6ZXJvUG9pbnQgPyBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ10gOiBbJ3JhbmsnLCAncmFuayddLFxyXG4gICAgfSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIGNvbXBvbmVudHMgLyA2NCksIHk6IDEsIHo6IDEgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkZXF1YW50aXplTGluZWFyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVEZXF1YW50aXplTGluZWFyUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZURlcXVhbnRpemVMaW5lYXJBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogRGVxdWFudGl6ZUxpbmVyQXR0cmlidXRlcyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIsIGJsb2NrU2l6ZTogYXR0cmlidXRlcy5ibG9ja1NpemUgYXMgbnVtYmVyIH0pO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHNDb250ZW50ID0gKHN0YXJ0OiBudW1iZXIsIGxpbWl0OiBudW1iZXIsIGRlbHRhOiBudW1iZXIpOiB2b2lkID0+IHtcclxuICBjb25zdCBzYW1lU3RhcnRMaW1pdCA9IHN0YXJ0ID09PSBsaW1pdDtcclxuICBjb25zdCBpbmNyZWFzaW5nUmFuZ2VOZWdhdGl2ZVN0ZXAgPSBzdGFydCA8IGxpbWl0ICYmIGRlbHRhIDwgMDtcclxuICBjb25zdCBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXAgPSBzdGFydCA+IGxpbWl0ICYmIGRlbHRhID4gMDtcclxuXHJcbiAgaWYgKHNhbWVTdGFydExpbWl0IHx8IGluY3JlYXNpbmdSYW5nZU5lZ2F0aXZlU3RlcCB8fCBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlIHRoZXNlIGlucHV0cycgY29udGVudHMgYXJlIGludmFsaWQuXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZVJhbmdlUHJvZ3JhbUluZm8gPSAoc3RhcnQ6IG51bWJlciwgbGltaXQ6IG51bWJlciwgZGVsdGE6IG51bWJlciwgZGF0YVR5cGU6IERhdGFUeXBlKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IG51bUVsZW1lbnRzID0gTWF0aC5hYnMoTWF0aC5jZWlsKChsaW1pdCAtIHN0YXJ0KSAvIGRlbHRhKSk7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW251bUVsZW1lbnRzXTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gbnVtRWxlbWVudHM7XHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogZGF0YVR5cGUsIGRhdGE6IHN0YXJ0IH0sXHJcbiAgICB7IHR5cGU6IGRhdGFUeXBlLCBkYXRhOiBkZWx0YSB9LFxyXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG4gICAgY29uc3Qgd2dzbFR5cGUgPSBvdXRwdXQudHlwZS52YWx1ZTtcclxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgICAgeyBuYW1lOiAnb3V0cHV0U2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ3N0YXJ0JywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxyXG4gICAgICB7IG5hbWU6ICdkZWx0YScsIHR5cGU6IHdnc2xUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gYFxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMob3V0cHV0KX1cclxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cclxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XHJcbiAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdW5pZm9ybXMuc3RhcnQgKyAke3dnc2xUeXBlfShnbG9iYWxfaWR4KSAqIHVuaWZvcm1zLmRlbHRhO1xyXG4gICAgICB9YDtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ1JhbmdlJyxcclxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2RhdGFUeXBlfWAgfSxcclxuICAgIGdldFNoYWRlclNvdXJjZSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcclxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxyXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXHJcbiAgICB9KSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJhbmdlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XHJcbiAgbGV0IHN0YXJ0ID0gMDtcclxuICBsZXQgbGltaXQgPSAwO1xyXG4gIGxldCBkZWx0YSA9IDA7XHJcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMikge1xyXG4gICAgc3RhcnQgPSBjb250ZXh0LmlucHV0c1swXS5nZXRJbnQzMkFycmF5KClbMF07XHJcbiAgICBsaW1pdCA9IGNvbnRleHQuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXTtcclxuICAgIGRlbHRhID0gY29udGV4dC5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdO1xyXG4gIH0gZWxzZSBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmZsb2F0KSB7XHJcbiAgICBzdGFydCA9IGNvbnRleHQuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdO1xyXG4gICAgbGltaXQgPSBjb250ZXh0LmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTtcclxuICAgIGRlbHRhID0gY29udGV4dC5pbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF07XHJcbiAgfVxyXG4gIGlmIChlbnYud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50KSB7XHJcbiAgICB2YWxpZGF0ZUlucHV0c0NvbnRlbnQoc3RhcnQsIGxpbWl0LCBkZWx0YSk7XHJcbiAgfVxyXG5cclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUmFuZ2VQcm9ncmFtSW5mbyhzdGFydCwgbGltaXQsIGRlbHRhLCBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSksIHsgaW5wdXRzOiBbXSB9KTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7XHJcbiAgYXRvbWljT3V0cHV0VmFyaWFibGUsXHJcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXHJcbiAgaW5wdXRWYXJpYWJsZSxcclxuICBvdXRwdXRWYXJpYWJsZSxcclxuICBTaGFkZXJIZWxwZXIsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTY2F0dGVyTkRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWR1Y3Rpb246IHN0cmluZztcclxufVxyXG5cclxudHlwZSBSZWR1Y3Rpb25UeXBlID0gJ2kzMicgfCAndTMyJyB8ICdmMzInO1xyXG5cclxuY29uc3QgYXRvbWljUmVkdWN0aW9uU25pcHBldCA9IChyZWR1Y3Rpb246IHN0cmluZywgcHRyOiBzdHJpbmcsIHY6IHN0cmluZywgdHlwZTogUmVkdWN0aW9uVHlwZSkgPT4ge1xyXG4gIGlmIChyZWR1Y3Rpb24gIT09ICdub25lJyAmJiB0eXBlICE9PSAnaTMyJyAmJiB0eXBlICE9PSAndTMyJyAmJiB0eXBlICE9PSAnZjMyJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3R5cGV9IGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCByZWR1Y3Rpb24gJHtyZWR1Y3Rpb259LmApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZmxvYXRTdGFydCA9IGB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgbG9vcCB7XHJcbiAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZUYzMiA9YDtcclxuICBjb25zdCBmbG9hdEVuZCA9IGA7XHJcbiAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IGJpdGNhc3Q8aTMyPihuZXdWYWx1ZUYzMik7XHJcbiAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrKCYke3B0cn0sIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIHJlcy5leGNoYW5nZWQge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzLm9sZF92YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9YDtcclxuXHJcbiAgc3dpdGNoIChyZWR1Y3Rpb24pIHtcclxuICAgIGNhc2UgJ25vbmUnOlxyXG4gICAgICByZXR1cm4gYCR7cHRyfT0ke3Z9O2A7XHJcbiAgICBjYXNlICdhZGQnOlxyXG4gICAgICBpZiAodHlwZSA9PT0gJ2kzMicgfHwgdHlwZSA9PT0gJ3UzMicpIHtcclxuICAgICAgICByZXR1cm4gYGF0b21pY0FkZCgmJHtwdHJ9LCBiaXRjYXN0PCR7dHlwZX0+KCR7dn0pKTtgO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGF0b21pY0FkZCBvbmx5IHN1cHBvcnRzIHVpbnQvaW50IHR5cGUuIEZvciBmbG9hdCwgd2UgdXNlXHJcbiAgICAgICAgLy8gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhayB0byBzaW11bGF0ZS5cclxuICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAgICR7ZmxvYXRTdGFydH1iaXRjYXN0PCR7dHlwZX0+KG9sZFZhbHVlKSArICgke3Z9KSR7ZmxvYXRFbmR9YDtcclxuICAgICAgfVxyXG4gICAgY2FzZSAnbWF4JzpcclxuICAgICAgaWYgKHR5cGUgPT09ICdpMzInIHx8IHR5cGUgPT09ICd1MzInKSB7XHJcbiAgICAgICAgcmV0dXJuIGBhdG9taWNNYXgoJiR7cHRyfSwgYml0Y2FzdDwke3R5cGV9Pigke3Z9KSk7YDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBhdG9taWNNYXggb25seSBzdXBwb3J0cyB1aW50L2ludCB0eXBlLiBGb3IgZmxvYXQsIHdlIHVzZVxyXG4gICAgICAgIC8vIGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsgdG8gc2ltdWxhdGUuXHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICAgICR7ZmxvYXRTdGFydH1tYXgoYml0Y2FzdDxmMzI+KG9sZFZhbHVlKSwgKCR7dn0pKSR7ZmxvYXRFbmR9YDtcclxuICAgICAgfVxyXG4gICAgY2FzZSAnbWluJzpcclxuICAgICAgaWYgKHR5cGUgPT09ICdpMzInIHx8IHR5cGUgPT09ICd1MzInKSB7XHJcbiAgICAgICAgcmV0dXJuIGBhdG9taWNNaW4oJiR7cHRyfSwgYml0Y2FzdDwke3R5cGV9Pigke3Z9KSk7YDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBhdG9taWNNaW4gb25seSBzdXBwb3J0cyB1aW50L2ludCB0eXBlLiBGb3IgZmxvYXQsIHdlIHVzZVxyXG4gICAgICAgIC8vIGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsgdG8gc2ltdWxhdGUuXHJcbiAgICAgICAgcmV0dXJuIGAke2Zsb2F0U3RhcnR9bWluKGJpdGNhc3Q8JHt0eXBlfT4ob2xkVmFsdWUpLCAoJHt2fSkpJHtmbG9hdEVuZH1gO1xyXG4gICAgICB9XHJcbiAgICBjYXNlICdtdWwnOlxyXG4gICAgICAvLyBhdG9taWNNdWwgaXMgbm90IHN1cHBvcnRlZCwgd2UgdXNlIGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsgdG8gc2ltdWxhdGUuXHJcbiAgICAgIHJldHVybiBgJHtmbG9hdFN0YXJ0fShiaXRjYXN0PCR7dHlwZX0+KG9sZFZhbHVlKSAqICgke3Z9KSkke2Zsb2F0RW5kfWA7XHJcblxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWR1Y3Rpb24gJHtyZWR1Y3Rpb259IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlU2NhdHRlck5EUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNjYXR0ZXJOREF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcclxuICAvLyBUT0RPOiBzdXBwb3J0IGJvb2wgd2l0aCBjb21wb25lbnRzIDQuXHJcbiAgY29uc3QgY29tcG9uZW50cyA9IDE7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGluZGljZXNTaGFwZSwgaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDEpIC8gY29tcG9uZW50cyk7XHJcbiAgY29uc3QgbGFzdEluZGV4RGltZW5zaW9uID0gaW5kaWNlc1NoYXBlW2luZGljZXNTaGFwZS5sZW5ndGggLSAxXTtcclxuICBjb25zdCBudW1VcGRhdGVzRWxlbWVudHMgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgbGFzdEluZGV4RGltZW5zaW9uKTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBsYXN0SW5kZXhEaW1lbnNpb24gfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBudW1VcGRhdGVzRWxlbWVudHMgfSxcclxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1sxXS5kaW1zLCBpbnB1dHNbMl0uZGltcywgb3V0cHV0U2hhcGUpLFxyXG4gIF07XHJcblxyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xyXG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2luZGljZXMnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCk7XHJcbiAgICBjb25zdCB1cGRhdGVzID0gaW5wdXRWYXJpYWJsZSgndXBkYXRlcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcclxuICAgIGNvbnN0IG91dHB1dCA9XHJcbiAgICAgIGF0dHJpYnV0ZXMucmVkdWN0aW9uICE9PSAnbm9uZScgJiYgYXR0cmlidXRlcy5yZWR1Y3Rpb24gIT09ICcnXHJcbiAgICAgICAgPyBhdG9taWNPdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpXHJcbiAgICAgICAgOiBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xyXG5cclxuICAgIHJldHVybiBgXHJcbiAgICAgICR7c2hhZGVySGVscGVyXHJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJylcclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdsYXN0X2luZGV4X2RpbWVuc2lvbicsICd1MzInKVxyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ251bV91cGRhdGVzX2VsZW1lbnRzJywgJ3UzMicpXHJcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5kaWNlcywgdXBkYXRlcywgb3V0cHV0KX1cclxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICB2YXIgZGF0YV9vZmZzZXQgPSAwdTtcclxuICBsZXQgaW5kaWNlc19zdGFydCA9IHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uICogZ2xvYmFsX2lkeDtcclxuICBsZXQgaW5kaWNlc19lbmQgPSBpbmRpY2VzX3N0YXJ0ICsgdW5pZm9ybXMubGFzdF9pbmRleF9kaW1lbnNpb247XHJcbiAgZm9yICh2YXIgaSA9IGluZGljZXNfc3RhcnQ7IGkgPCBpbmRpY2VzX2VuZDsgaSsrKSB7XHJcbiAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc1tpXS54KTtcclxuICAgICR7XHJcbiAgICAgIGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gMVxyXG4gICAgICAgID8gYFxyXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXM7XHJcbiAgICBsZXQgZGltX3ZhbHVlID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlO2BcclxuICAgICAgICA6IGBcclxuICAgIGxldCBlbGVtZW50X2NvdW50X2RpbSA9IHVuaWZvcm1zLm91dHB1dF9zdHJpZGVzW2kgLSBpbmRpY2VzX3N0YXJ0XTtcclxuICAgIGxldCBkaW1fdmFsdWUgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbaSAtIGluZGljZXNfc3RhcnRdO2BcclxuICAgIH1cclxuICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgIGlmIChpbmRleCA+PSBpMzIoZGltX3ZhbHVlKSkge1xyXG4gICAgICAgIGluZGV4ID0gaTMyKGRpbV92YWx1ZSAtIDEpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoaW5kZXggPCAtaTMyKGRpbV92YWx1ZSkpIHtcclxuICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5kZXggKz0gaTMyKGRpbV92YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGRhdGFfb2Zmc2V0ICs9IHUzMigodTMyKGluZGV4KSAqIGVsZW1lbnRfY291bnRfZGltKSk7XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBpID0gMHU7IGkgPCB1bmlmb3Jtcy5udW1fdXBkYXRlc19lbGVtZW50czsgaSsrKSB7XHJcbiAgICBsZXQgdmFsdWUgPSB1cGRhdGVzW3VuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzICogZ2xvYmFsX2lkeCArIGldO1xyXG4gICAgJHthdG9taWNSZWR1Y3Rpb25TbmlwcGV0KFxyXG4gICAgICBhdHRyaWJ1dGVzLnJlZHVjdGlvbixcclxuICAgICAgJ291dHB1dFtkYXRhX29mZnNldCArIGldJyxcclxuICAgICAgJ3ZhbHVlJyxcclxuICAgICAgb3V0cHV0LnR5cGUudmFsdWUgYXMgUmVkdWN0aW9uVHlwZSxcclxuICAgICl9XHJcbiAgfVxyXG5cclxuICAgICAgfWA7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ1NjYXR0ZXJORCcsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fV8ke2F0dHJpYnV0ZXMucmVkdWN0aW9ufWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuayddLFxyXG4gICAgfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VTY2F0dGVyTkRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogU2NhdHRlck5EQXR0cmlidXRlcyA9PlxyXG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHJlZHVjdGlvbjogYXR0cmlidXRlcy5yZWR1Y3Rpb24gYXMgc3RyaW5nIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNjYXR0ZXJORCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU2NhdHRlck5EQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVTY2F0dGVyTkRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyksIHtcclxuICAgIGlucHV0czogW2NvbnRleHQuaW5wdXRzWzFdLCBjb250ZXh0LmlucHV0c1syXV0sXHJcbiAgICBvdXRwdXRzOiBbXSxcclxuICB9KTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcclxuICBnZXRFbGVtZW50QXQsXHJcbiAgSW5kaWNlc0hlbHBlcixcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxufSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG50eXBlIENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cclxuICB8ICdoYWxmX3BpeGVsJ1xyXG4gIHwgJ2FzeW1tZXRyaWMnXHJcbiAgfCAncHl0b3JjaF9oYWxmX3BpeGVsJ1xyXG4gIHwgJ3RmX2hhbGZfcGl4ZWxfZm9yX25uJ1xyXG4gIHwgJ2FsaWduX2Nvcm5lcnMnXHJcbiAgfCAndGZfY3JvcF9hbmRfcmVzaXplJ1xyXG4gIHwgJ2hhbGZfcGl4ZWxfc3ltbWV0cmljJztcclxuXHJcbnR5cGUgS2VlcEFzcGVjdFJhdGlvUG9saWN5ID0gJ3N0cmV0Y2gnIHwgJ25vdF9zbWFsbGVyJyB8ICdub3RfbGFyZ2VyJztcclxuXHJcbnR5cGUgTW9kZSA9ICduZWFyZXN0JyB8ICdsaW5lYXInIHwgJ2N1YmljJztcclxuXHJcbnR5cGUgTmVhcmVzdE1vZGUgPSAncm91bmRfcHJlZmVyX2Zsb29yJyB8ICdyb3VuZF9wcmVmZXJfY2VpbCcgfCAnZmxvb3InIHwgJ2NlaWwnIHwgJ3NpbXBsZSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlc2l6ZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xyXG4gIGFudGlhbGlhczogbnVtYmVyO1xyXG4gIGF4ZXM6IG51bWJlcltdO1xyXG4gIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiBDb29yZGluYXRlVHJhbnNmb3JtTW9kZTtcclxuICBjdWJpY0NvZWZmQTogbnVtYmVyO1xyXG4gIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xyXG4gIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyO1xyXG4gIGtlZXBBc3BlY3RSYXRpb1BvbGljeTogS2VlcEFzcGVjdFJhdGlvUG9saWN5O1xyXG4gIG1vZGU6IE1vZGU7XHJcbiAgbmVhcmVzdE1vZGU6IE5lYXJlc3RNb2RlO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZVNjYWxlcyA9IChzY2FsZXM6IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgc2NhbGVzLmV2ZXJ5KFxyXG4gICAgKHZhbHVlKSA9PlxyXG4gICAgICB2YWx1ZSA+IDAgfHxcclxuICAgICAgKCgpID0+IHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlJyk7XHJcbiAgICAgIH0pLFxyXG4gICk7XHJcbiAgLy8gQ2hlY2sgc2NhbGVzIGRpbXMgYmFzZWQgb24gbW9kZTogTElORUFSLCBDVUJJQ1xyXG4gIGlmIChzY2FsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgaWYgKGF0dHJpYnV0ZXMubW9kZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICEoXHJcbiAgICAgICAgICBzY2FsZXMubGVuZ3RoID09PSAyIHx8XHJcbiAgICAgICAgICBzY2FsZXMubGVuZ3RoID09PSAzIHx8XHJcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzFdID09PSAxKSB8fFxyXG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1szXSA9PT0gMSkgfHxcclxuICAgICAgICAgIChzY2FsZXMubGVuZ3RoID09PSA1ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbMV0gPT09IDEpXHJcbiAgICAgICAgKVxyXG4gICAgICApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgRm9yIGxpbmVhciBtb2RlLCBSZXNpemUgcmVxdWlyZXMgc2NhbGVzIHRvIGJlIDJELCAzRCwgNEQgd2l0aCBlaXRoZXIgdHdvIG91dGVybW9zdCBvciBvbmUgaW5uZXJtb3N0IGFuZFxyXG4gICAgICAgICAgICBvbmUgb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxLCBvciA1RCB3aXRoIHR3byBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDFgLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAnY3ViaWMnKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICAhKFxyXG4gICAgICAgICAgc2NhbGVzLmxlbmd0aCA9PT0gMiB8fFxyXG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkgfHxcclxuICAgICAgICAgIChzY2FsZXMubGVuZ3RoID09PSA0ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbM10gPT09IDEpXHJcbiAgICAgICAgKVxyXG4gICAgICApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGUnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IHVwZGF0ZVNjYWxlcyA9IChzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xyXG4gIGF4ZXMuZXZlcnkoXHJcbiAgICAodmFsdWUpID0+XHJcbiAgICAgICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgcmFuaykgfHxcclxuICAgICAgKCgpID0+IHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmsnKTtcclxuICAgICAgfSksXHJcbiAgKTtcclxuICBjb25zdCBuZXdTY2FsZXMgPSBuZXcgQXJyYXkocmFuaykuZmlsbCgxLjApO1xyXG4gIGF4ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiAobmV3U2NhbGVzW3ZhbHVlXSA9IHNjYWxlc1tpbmRleF0pKTtcclxuICByZXR1cm4gbmV3U2NhbGVzO1xyXG59O1xyXG5cclxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyxcclxuICBvcHNldFZlcnNpb246IG51bWJlcixcclxuICBzY2FsZXM6IG51bWJlcltdLFxyXG4gIHNpemVzOiBudW1iZXJbXSxcclxuICByb2k6IG51bWJlcltdLFxyXG4pOiB2b2lkID0+IHtcclxuICBjb25zdCBbcm9pSW5wdXRJbmRleCwgc2NhbGVzSW5wdXRJbmRleCwgc2l6ZXNJbnB1dEluZGV4XSA9XHJcbiAgICBvcHNldFZlcnNpb24gPiAxMCA/IFsxLCAyLCAzXSA6IFstMSwgaW5wdXRzLmxlbmd0aCA+IDEgPyAxIDogLTEsIC0xXTtcclxuICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xyXG4gIGlmIChyb2lJbnB1dEluZGV4ID4gMCAmJiBpbnB1dHMubGVuZ3RoID4gcm9pSW5wdXRJbmRleCAmJiBpbnB1dHNbcm9pSW5wdXRJbmRleF0uZGltcy5sZW5ndGggPiAwKSB7XHJcbiAgICBpbnB1dHNbcm9pSW5wdXRJbmRleF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHJvaS5wdXNoKHZhbHVlKSk7XHJcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgUm9JIGlucHV0IHRvIGJlIHNwZWNpZmllZCB3aGVuIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGlzIHRmQ3JvcEFuZFJlc2l6ZScpO1xyXG4gIH1cclxuXHJcbiAgaWYgKFxyXG4gICAgc2NhbGVzSW5wdXRJbmRleCA+IDAgJiZcclxuICAgIGlucHV0cy5sZW5ndGggPiBzY2FsZXNJbnB1dEluZGV4ICYmXHJcbiAgICBpbnB1dHNbc2NhbGVzSW5wdXRJbmRleF0uZGltcy5sZW5ndGggPT09IDEgJiZcclxuICAgIGlucHV0c1tzY2FsZXNJbnB1dEluZGV4XS5kaW1zWzBdID4gMFxyXG4gICkge1xyXG4gICAgaW5wdXRzW3NjYWxlc0lucHV0SW5kZXhdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2goKHZhbHVlKSA9PiBzY2FsZXMucHVzaCh2YWx1ZSkpO1xyXG4gICAgaWYgKFxyXG4gICAgICBzY2FsZXMubGVuZ3RoICE9PSAwICYmXHJcbiAgICAgIHNjYWxlcy5sZW5ndGggIT09IHJhbmsgJiZcclxuICAgICAgb3BzZXRWZXJzaW9uID49IDE4ICYmXHJcbiAgICAgIHNjYWxlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGhcclxuICAgICkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXAnKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlU2NhbGVzKHNjYWxlcywgYXR0cmlidXRlcyk7XHJcbiAgICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdXBkYXRlU2NhbGVzKHNjYWxlcywgYXR0cmlidXRlcy5heGVzLCByYW5rKS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IChzY2FsZXNbaW5kZXhdID0gdmFsdWUpKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKFxyXG4gICAgc2l6ZXNJbnB1dEluZGV4ID4gMCAmJlxyXG4gICAgaW5wdXRzLmxlbmd0aCA+IHNpemVzSW5wdXRJbmRleCAmJlxyXG4gICAgaW5wdXRzW3NpemVzSW5wdXRJbmRleF0uZGltcy5sZW5ndGggPT09IDEgJiZcclxuICAgIGlucHV0c1tzaXplc0lucHV0SW5kZXhdLmRpbXNbMF0gPiAwXHJcbiAgKSB7XHJcbiAgICBpbnB1dHNbc2l6ZXNJbnB1dEluZGV4XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHNpemVzLnB1c2goTnVtYmVyKHZhbHVlKSkpO1xyXG4gICAgaWYgKHNpemVzLmxlbmd0aCAhPT0gMCAmJiBzaXplcy5sZW5ndGggIT09IHJhbmsgJiYgb3BzZXRWZXJzaW9uID49IDE4ICYmIHNpemVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzaXplcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBpZiAoc2NhbGVzLmxlbmd0aCAhPT0gMCAmJiBzY2FsZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2NhbGVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2l6ZXMubGVuZ3RoICE9PSAwICYmIHNpemVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHR5cGVvZiBzY2FsZXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzaXplcyAhPT0gJ3VuZGVmaW5lZCcgJiYgc2NhbGVzLmxlbmd0aCA+IDAgJiYgc2l6ZXMubGVuZ3RoID4gcmFuaykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZ2V0U2FmZUludGVnZXJEaXZpc2lvbiA9IChhOiBzdHJpbmcsIGI6IHN0cmluZywgYzogc3RyaW5nLCBkVHlwZTogc3RyaW5nKTogc3RyaW5nID0+IGBcclxuICAvLyBUaGUgd2hvbGUgcGFydCBhbmQgdGhlIGZyYWN0aW9uYWwgcGFydCBhcmUgY2FsY3VsYXRlZCBzZXBhcmF0ZWx5IGR1ZSB0byBpbmFjY3VyYWN5IG9mIGZsb2F0aW5nXHJcbiAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXHJcbiAgLy8gb2Zmc2V0LWJ5LW9uZSBlcnJvciBsYXRlciBpbiBmbG9vcigpLlxyXG4gIGxldCBiaWcgPSAoJHthfSkgKiAoJHtifSk7XHJcbiAgbGV0IHdob2xlID0gJHtkVHlwZX0oYmlnIC8gKCR7Y30pKTtcclxuICBsZXQgZnJhY3QgPSAke2RUeXBlfShiaWcgJSAoJHtjfSkpIC8gJHtkVHlwZX0oJHtjfSk7XHJcbiAgcmV0dXJuIHdob2xlICsgZnJhY3Q7XHJcbmA7XHJcblxyXG5jb25zdCBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUgPSAoXHJcbiAgY29vcmRpbmF0ZVRyYW5zZmVyTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsXHJcbiAgZFR5cGU6IHN0cmluZyxcclxuKTogc3RyaW5nID0+XHJcbiAgYGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxyXG4gICAgIGxlbmd0aE9yaWdpbmFsOiB1MzIsIHJvaVN0YXJ0OiBmMzIsIHJvaUVuZDogZjMyKSAtPiAke2RUeXBlfSB7IGAgK1xyXG4gICgoKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGNvb3JkaW5hdGVUcmFuc2Zlck1vZGUpIHtcclxuICAgICAgY2FzZSAnYXN5bW1ldHJpYyc6XHJcbiAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgIGlmICh4U2NhbGUgPCAxLjAgfHwgZmxvb3IoeFNjYWxlKSAhPSB4U2NhbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICR7ZFR5cGV9KHhSZXNpemVkKSAvICR7ZFR5cGV9KHhTY2FsZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAke2dldFNhZmVJbnRlZ2VyRGl2aXNpb24oJ3hSZXNpemVkJywgJ2xlbmd0aE9yaWdpbmFsJywgJ2xlbmd0aFJlc2l6ZWQnLCBkVHlwZSl9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgYDtcclxuICAgICAgY2FzZSAncHl0b3JjaF9oYWxmX3BpeGVsJzpcclxuICAgICAgICByZXR1cm4gYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkgLSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcclxuICAgICAgICAgICAgICAgICAgfWA7XHJcbiAgICAgIGNhc2UgJ3RmX2hhbGZfcGl4ZWxfZm9yX25uJzpcclxuICAgICAgICByZXR1cm4gYHJldHVybiAoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSk7YDtcclxuICAgICAgY2FzZSAnYWxpZ25fY29ybmVycyc6XHJcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAke2dldFNhZmVJbnRlZ2VyRGl2aXNpb24oJ3hSZXNpemVkJywgJ2xlbmd0aE9yaWdpbmFsIC0gMScsICdsZW5ndGhSZXNpemVkIC0gMScsIGRUeXBlKX1cclxuICAgICAgICAgICAgICAgICAgfWA7XHJcbiAgICAgIGNhc2UgJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSc6XHJcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHtkVHlwZX0ocm9pU3RhcnQpICogJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwgLSAxKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgke2RUeXBlfSh4UmVzaXplZCkgKiAke2RUeXBlfShyb2lFbmQgLSByb2lTdGFydCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpKSAvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogJHtkVHlwZX0ocm9pU3RhcnQgKyByb2lFbmQpICogJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgfWA7XHJcbiAgICAgIGNhc2UgJ2hhbGZfcGl4ZWxfc3ltbWV0cmljJzpcclxuICAgICAgICByZXR1cm4gYGNvbnN0IG91dHB1dFdpZHRoID0gJHtkVHlwZX14U2NhbGUgKiAke2RUeXBlfShsZW5ndGhSZXNpemVkKTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9ICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQpIC8gb3V0cHV0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9ICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGNlbnRlciAqICgxIC0gYWRqdXN0bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpKSAtIDAuNTtgO1xyXG4gICAgICBjYXNlICdoYWxmX3BpeGVsJzpcclxuICAgICAgICByZXR1cm4gYHJldHVybiAoKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpKSAtIDAuNTtgO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2Nvb3JkaW5hdGVUcmFuc2Zlck1vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcclxuICAgIH1cclxuICB9KSgpICtcclxuICAnfSc7XHJcblxyXG5jb25zdCBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwgPSAobmVhcmVzdE1vZGU6IE5lYXJlc3RNb2RlLCBvcHNldFZlcnNpb246IG51bWJlciwgZFR5cGU6IHN0cmluZyk6IHN0cmluZyA9PlxyXG4gIGBmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiAke2RUeXBlfSwgaXNEb3duU2FtcGxlOiBib29sKSAtPiAke2RUeXBlfSB7YCArXHJcbiAgKCgpID0+IHtcclxuICAgIHN3aXRjaCAobmVhcmVzdE1vZGUpIHtcclxuICAgICAgY2FzZSAncm91bmRfcHJlZmVyX2NlaWwnOlxyXG4gICAgICAgIHJldHVybiAnaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7IFxcXHJcbiAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7IFxcXHJcbiAgICAgICAgICB9IGVsc2UgeyBcXFxyXG4gICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgXFxcclxuICAgICAgICAgIH0nO1xyXG4gICAgICBjYXNlICdmbG9vcic6XHJcbiAgICAgICAgcmV0dXJuICdyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsnO1xyXG4gICAgICBjYXNlICdjZWlsJzpcclxuICAgICAgICByZXR1cm4gJ3JldHVybiBjZWlsKHhPcmlnaW5hbCk7JztcclxuICAgICAgY2FzZSAncm91bmRfcHJlZmVyX2Zsb29yJzpcclxuICAgICAgICByZXR1cm4gJ2lmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyBcXFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9vcih4T3JpZ2luYWwpOyBcXFxyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgeyBcXFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxyXG4gICAgICAgICAgICAgICAgICB9JztcclxuICAgICAgY2FzZSAnc2ltcGxlJzpcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBpZiAob3BzZXRWZXJzaW9uIDwgMTEpIHtcclxuICAgICAgICAgIHJldHVybiAnaWYgKGlzRG93blNhbXBsZSkgXFxcclxuICAgICAgICAgICAgICAgICAgICB7IFxcXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyBcXFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxcXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geE9yaWdpbmFsOyBcXFxyXG4gICAgICAgICAgICAgICAgICAgIH0nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke25lYXJlc3RNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XHJcbiAgICB9XHJcbiAgfSkoKSArXHJcbiAgJ30nO1xyXG5cclxuY29uc3QgdXBkYXRlUm9JID0gKHJvaTogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XHJcbiAgY29uc3Qgcm9pVG1wID0gbmV3IEFycmF5KHJhbmspLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyYW5rKS5maWxsKDEpKTtcclxuICBjb25zdCByb2lMb2NhbCA9IHJvaS5sZW5ndGggPT09IDAgPyByb2lUbXAgOiByb2kuc2xpY2UoKTtcclxuICBpZiAoYXhlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBheGVzLmZvckVhY2goKHYsIGkpID0+IHtcclxuICAgICAgcm9pVG1wW3ZdID0gcm9pTG9jYWxbaV07XHJcbiAgICAgIHJvaVRtcFtpICsgcmFua10gPSByb2lMb2NhbFtheGVzLmxlbmd0aCArIGldO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcm9pVG1wO1xyXG4gIH1cclxuICByZXR1cm4gcm9pTG9jYWw7XHJcbn07XHJcblxyXG5jb25zdCBpbml0T3V0cHV0U2hhcGUgPSAoXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSxcclxuICBzaXplczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbik6IG51bWJlcltdID0+IHtcclxuICBsZXQgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XHJcbiAgaWYgKHNpemVzLmxlbmd0aCA+IDApIHtcclxuICAgIGlmIChheGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgaW5wdXRTaGFwZS5mb3JFYWNoKCh2KSA9PiBvdXRwdXRTaGFwZS5wdXNoKHYpKTtcclxuICAgICAgaWYgKE1hdGgubWF4KC4uLmF4ZXMpID4gaW5wdXRTaGFwZS5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4ZXMgaXMgb3V0IG9mIGJvdW5kJyk7XHJcbiAgICAgIH1cclxuICAgICAgYXhlcy5mb3JFYWNoKCh2LCBpKSA9PiAob3V0cHV0U2hhcGVbdl0gPSBzaXplc1tpXSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2l6ZXMuZm9yRWFjaCgodikgPT4gb3V0cHV0U2hhcGUucHVzaCh2KSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChzY2FsZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUubWFwKCh2YWx1ZSwgaW5kZXgpID0+IE1hdGgucm91bmQodmFsdWUgKiBzY2FsZXNbaW5kZXhdKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBvdXRwdXRTaGFwZTtcclxufTtcclxuXHJcbmNvbnN0IGFkanVzdE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzY2FsZXM6IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKSA9PiB7XHJcbiAgY29uc3Qgc2NhbGVJblBvbGljeSA9ICgoKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5KSB7XHJcbiAgICAgIGNhc2UgJ25vdF9sYXJnZXInOlxyXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMFxyXG4gICAgICAgICAgPyBNYXRoLm1pbiguLi5hdHRyaWJ1dGVzLmF4ZXMubWFwKChpKSA9PiBzY2FsZXNbaV0pLCBOdW1iZXIuTUFYX1ZBTFVFKVxyXG4gICAgICAgICAgOiBNYXRoLm1pbiguLi5zY2FsZXMsIE51bWJlci5NQVhfVkFMVUUpO1xyXG4gICAgICBjYXNlICdub3Rfc21hbGxlcic6XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwXHJcbiAgICAgICAgICA/IE1hdGgubWF4KC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoKGkpID0+IHNjYWxlc1tpXSksIE51bWJlci5NSU5fVkFMVUUpXHJcbiAgICAgICAgICA6IE1hdGgubWF4KC4uLnNjYWxlcywgTnVtYmVyLk1JTl9WQUxVRSk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHthdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApO1xyXG4gICAgfVxyXG4gIH0pKCk7XHJcbiAgc2NhbGVzLmZpbGwoMS4wLCAwLCBzY2FsZXMubGVuZ3RoKTtcclxuICBjb25zdCBhZGp1c3RlZE91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xyXG4gIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IChzY2FsZXNbdl0gPSBzY2FsZUluUG9saWN5KSk7XHJcbiAgICBhdHRyaWJ1dGVzLmF4ZXMuZm9yRWFjaCgodikgPT4gKGFkanVzdGVkT3V0cHV0U2hhcGVbdl0gPSBNYXRoLnJvdW5kKGlucHV0U2hhcGVbdl0gKiBzY2FsZXNbdl0pKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNjYWxlcy5maWxsKHNjYWxlSW5Qb2xpY3ksIDAsIHNjYWxlcy5sZW5ndGgpO1xyXG4gICAgYWRqdXN0ZWRPdXRwdXRTaGFwZS5mb3JFYWNoKCh2LCBpKSA9PiAoYWRqdXN0ZWRPdXRwdXRTaGFwZVtpXSA9IE1hdGgucm91bmQodiAqIHNjYWxlc1tpXSkpKTtcclxuICB9XHJcbiAgcmV0dXJuIGFkanVzdGVkT3V0cHV0U2hhcGU7XHJcbn07XHJcblxyXG5jb25zdCBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyA9IChcclxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHNjYWxlc0xlbmd0aDogbnVtYmVyLFxyXG4gIHJvaUxlbmd0aDogbnVtYmVyLFxyXG4pOiBzdHJpbmcgPT4gYFxyXG4gICAgZm4gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+IGFycmF5PCR7XHJcbiAgICAgIG91dHB1dC50eXBlLnZhbHVlXHJcbiAgICB9LCAke291dHB1dFNoYXBlLmxlbmd0aH0+IHtcclxuICAgICAgdmFyIG9yaWdpbmFsX2luZGljZXM6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dFNoYXBlLmxlbmd0aH0+O1xyXG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke291dHB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xyXG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xyXG4gICAgICAgIHZhciBzY2FsZSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zY2FsZXMnLCAnaScsIHNjYWxlc0xlbmd0aCl9O1xyXG4gICAgICAgIHZhciByb2lfbG93ID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnJvaScsICdpJywgcm9pTGVuZ3RoKX07XHJcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCBgaSArICR7aW5wdXRTaGFwZS5sZW5ndGh9YCwgcm9pTGVuZ3RoKX07XHJcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xyXG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KG91dHB1dF9pbmRleCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xyXG4gICAgICAgICAgdmFyIG91dHB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLm91dHB1dF9zaGFwZScsICdpJywgb3V0cHV0U2hhcGUubGVuZ3RoKX07XHJcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3JpZ2luYWxfaW5kaWNlcztcclxuICAgIH1gO1xyXG5cclxuY29uc3QgY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMgPSAoXHJcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBzY2FsZXNMZW5ndGg6IG51bWJlcixcclxuICByb2lMZW5ndGg6IG51bWJlcixcclxuICB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxyXG4pOiBzdHJpbmcgPT4gYFxyXG4gICAgZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7aW5wdXQudHlwZS5pbmRpY2VzfSB7XHJcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XHJcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX07XHJcbiAgICAgICAgdmFyIGlucHV0X2luZGV4OiB1MzI7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNjYWxlcycsICdpJywgc2NhbGVzTGVuZ3RoKX07XHJcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xyXG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciByb2lfbG93ID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnJvaScsICdpJywgcm9pTGVuZ3RoKX07XHJcbiAgICAgICAgICB2YXIgcm9pX2hpID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnJvaScsIGBpICsgJHtpbnB1dFNoYXBlLmxlbmd0aH1gLCByb2lMZW5ndGgpfTtcclxuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xyXG4gICAgICAgICAgdmFyIG91dHB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLm91dHB1dF9zaGFwZScsICdpJywgb3V0cHV0U2hhcGUubGVuZ3RoKX07XHJcbiAgICAgICAgICB2YXIgb3JpZ2luYWxfaWR4ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xyXG4gICAgICAgICAgaWYgKCEke3VzZUV4dHJhcG9sYXRpb259IHx8IChvcmlnaW5hbF9pZHggPj0gMCAmJiBvcmlnaW5hbF9pZHggPCAke291dHB1dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pKSkpIHtcclxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcclxuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxfaWR4ID4gJHtvdXRwdXQudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZSA8IDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgJ2knLCAnaW5wdXRfaW5kZXgnKX1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcclxuICAgIH1gO1xyXG5jb25zdCBjaGVja0lucHV0SW5kaWNlcyA9IChpbnB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBzdHJpbmcgPT4gYFxyXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9KSAtPiBib29sIHtcclxuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtpbnB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xyXG4gICAgICAgIHZhciBpbnB1dF9pbmRleCA9ICR7aW5wdXQuaW5kaWNlc0dldCgnaW5wdXRfaW5kaWNlcycsICdpJyl9O1xyXG4gICAgICAgIGlmIChpbnB1dF9pbmRleCA8IDAgfHwgaW5wdXRfaW5kZXggPj0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9KSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfWA7XHJcblxyXG5jb25zdCBzZXRDaGFubmVsQW5kQmF0Y2hJbmRpY2VzID0gKFxyXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxyXG4gIGNoYW5uZWxJZHg6IG51bWJlcixcclxuICBiYXRjaElkeDogbnVtYmVyLFxyXG4gIHNwYWNpYWxEaW1zOiBudW1iZXIsXHJcbik6IHN0cmluZyA9PlxyXG4gIGlucHV0LnJhbmsgPiBzcGFjaWFsRGltc1xyXG4gICAgPyBgXHJcbiAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBjaGFubmVsSWR4LCAnY2hhbm5lbCcpfTtcclxuICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGJhdGNoSWR4LCAnYmF0Y2gnKX07XHJcbmBcclxuICAgIDogJyc7XHJcblxyXG5jb25zdCBiaWxpbmVhckludGVycG9sYXRpb24gPSAoXHJcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXHJcbiAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3QgaXNOY2h3ID0gdHJ1ZTtcclxuICBjb25zdCBbYmF0Y2hJZHgsIGhlaWdodElkeCwgd2lkdGhJZHgsIGNoYW5uZWxJZHhdID1cclxuICAgIGlucHV0U2hhcGUubGVuZ3RoID09PSAyID8gWy0xLCAwLCAxLCAtMV0gOiBpc05jaHcgPyBbMCwgMiwgMywgMV0gOiBbMCwgMSwgMiwgM107XHJcbiAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xyXG4gIHJldHVybiBgXHJcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgcm93OiB1MzIsIGNvbDogdTMyKSAtPiAke2RUeXBlfSB7XHJcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XHJcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGhlaWdodElkeCwgYG1heCgwLCBtaW4ocm93LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSlgKX07XHJcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIHdpZHRoSWR4LCBgbWF4KDAsIG1pbihjb2wsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpYCl9O1xyXG4gICAgICAke3NldENoYW5uZWxBbmRCYXRjaEluZGljZXMoaW5wdXQsIGNoYW5uZWxJZHgsIGJhdGNoSWR4LCAyKX1cclxuICAgICAgcmV0dXJuICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xyXG4gICAgfVxyXG5cclxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xyXG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xyXG4gICAgICB2YXIgcm93OiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7aGVpZ2h0SWR4fV07XHJcbiAgICAgIHZhciBjb2w6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHt3aWR0aElkeH1dO1xyXG4gICAgICAke1xyXG4gICAgICAgIHVzZUV4dHJhcG9sYXRpb25cclxuICAgICAgICAgID8gYGlmIChyb3cgPCAwIHx8IHJvdyA+ICgke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICgke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKSB7XHJcbiAgICAgICAgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtcclxuICAgICAgfWBcclxuICAgICAgICAgIDogJydcclxuICAgICAgfTtcclxuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKTtcclxuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpO1xyXG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XHJcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcclxuICAgICAgdmFyIHJvdzI6IHUzMiA9IHUzMihyb3cgKyAxKTtcclxuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcclxuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7aW5wdXRTaGFwZS5sZW5ndGggPiAyID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtjaGFubmVsSWR4fV0pYCA6ICcwJ307XHJcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7aW5wdXRTaGFwZS5sZW5ndGggPiAyID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtiYXRjaElkeH1dKWAgOiAnMCd9O1xyXG4gICAgICB2YXIgeDExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDEpO1xyXG4gICAgICB2YXIgeDEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDIpO1xyXG4gICAgICB2YXIgeDIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDEpO1xyXG4gICAgICB2YXIgeDIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDIpO1xyXG4gICAgICB2YXIgZHgxOiAke2RUeXBlfSA9IGFicyhyb3cgLSAke2RUeXBlfShyb3cxKSk7XHJcbiAgICAgIHZhciBkeDI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KHJvdzIpIC0gcm93KTtcclxuICAgICAgdmFyIGR5MTogJHtkVHlwZX0gPSBhYnMoY29sIC0gJHtkVHlwZX0oY29sMSkpO1xyXG4gICAgICB2YXIgZHkyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShjb2wyKSAtIGNvbCk7XHJcbiAgICAgIGlmIChyb3cxID09IHJvdzIpIHtcclxuICAgICAgICBkeDEgPSAwLjU7XHJcbiAgICAgICAgZHgyID0gMC41O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb2wxID09IGNvbDIpIHtcclxuICAgICAgICBkeTEgPSAwLjU7XHJcbiAgICAgICAgZHkyID0gMC41O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcclxuICAgIH1gO1xyXG59O1xyXG5cclxuY29uc3QgYmljdWJpY0ludGVycG9sYXRpb24gPSAoXHJcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuICBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHJvaTogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgY3ViaWNDb2VmZkE6IG51bWJlcixcclxuICB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxyXG4gIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyLFxyXG4gIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuLFxyXG4pOiBzdHJpbmcgPT4ge1xyXG4gIGNvbnN0IGlzMkQgPSBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMjtcclxuICBjb25zdCBpc05jaHcgPSB0cnVlO1xyXG4gIGNvbnN0IFtoZWlnaHRJZHgsIHdpZHRoSWR4XSA9IGlzMkQgPyBbMCwgMV0gOiBpc05jaHcgPyBbMiwgM10gOiBbMSwgMl07XHJcbiAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xyXG4gIGNvbnN0IGNyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gKGlkeDogbnVtYmVyKTogc3RyaW5nID0+IHtcclxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGlkeCA9PT0gaGVpZ2h0SWR4ID8gJ3JvdycgOiAnY29sJztcclxuICAgIHJldHVybiBgXHJcbiAgICAgIGZuICR7ZGlyZWN0aW9ufUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30sIG91dHB1dF9pbmRpY2VzOiAke1xyXG4gICAgICAgIG91dHB1dC50eXBlLmluZGljZXNcclxuICAgICAgfSkgLT4gJHtkVHlwZX0ge1xyXG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIGlkeCl9O1xyXG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHtkVHlwZX0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCAke3NjYWxlc1tpZHhdfSxcclxuICAgICAgICAke291dHB1dFNoYXBlW2lkeF19LCAke2lucHV0U2hhcGVbaWR4XX0sICR7cm9pW2lkeF19LCAke3JvaVtpZHhdfSArICR7aW5wdXRTaGFwZS5sZW5ndGh9KTtcclxuICAgICAgICB2YXIgZnJhY3RPcmlnaW5hbElkeDogJHtkVHlwZX0gPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcclxuICAgICAgICB2YXIgY29lZnMgPSBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhmcmFjdE9yaWdpbmFsSWR4KTtcclxuXHJcbiAgICAgICAgaWYgKCR7dXNlRXh0cmFwb2xhdGlvbn0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke2lucHV0U2hhcGVbaWR4XX0gLSAxKSkpIHtcclxuICAgICAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXRhOiBhcnJheTwke2RUeXBlfSwgND4gPSBhcnJheTwke2RUeXBlfSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcclxuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAtMTsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgdmFyICR7ZGlyZWN0aW9ufTogJHtkVHlwZX0gPSBvcmlnaW5hbElkeCArICR7ZFR5cGV9KGkpO1xyXG4gICAgICAgICAgaWYgKCR7ZGlyZWN0aW9ufSA8IDAgfHwgJHtkaXJlY3Rpb259ID49ICR7aW5wdXRTaGFwZVtpZHhdfSkge1xyXG4gICAgICAgICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVPdXRzaWRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYGNvZWZzW2kgKyAxXSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7YDtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVzZUV4dHJhcG9sYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtgO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZGlyZWN0aW9ufSA9IG1heCgwLCBtaW4oJHtkaXJlY3Rpb259LCAke2lucHV0U2hhcGVbaWR4XX0gLSAxKSk7YDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKCl9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSA9IGlucHV0X2luZGljZXM7XHJcbiAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXNfY29weScsIGlkeCwgYHUzMigke2RpcmVjdGlvbn0pYCl9O1xyXG4gICAgICAgICAgZGF0YVtpICsgMV0gPSAke1xyXG4gICAgICAgICAgICBpZHggPT09IGhlaWdodElkeFxyXG4gICAgICAgICAgICAgID8gaW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzX2NvcHknKVxyXG4gICAgICAgICAgICAgIDogJ3Jvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzX2NvcHksIG91dHB1dF9pbmRpY2VzKSdcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdWJpY0ludGVycG9sYXRpb24xRChkYXRhLCBjb2Vmcyk7XHJcbiAgICAgIH1gO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBgXHJcbiAgICAke2NyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGhlaWdodElkeCl9O1xyXG4gICAgJHtjcmVhdGVDdWJpY0ludGVycG9sYXRpb25GdW5jdGlvbih3aWR0aElkeCl9O1xyXG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6ICR7ZFR5cGV9KSAtPiBhcnJheTwke2RUeXBlfSwgND4ge1xyXG4gICAgdmFyIGFic1MgPSBhYnMocyk7XHJcbiAgICB2YXIgY29lZmZzOiBhcnJheTwke2RUeXBlfSwgND4gPSBhcnJheTwke2RUeXBlfSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcclxuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7ZFR5cGV9ID0gMS4wIC0gYWJzUztcclxuICAgIHZhciB0d29NaW51c0Fic1M6ICR7ZFR5cGV9ID0gMi4wIC0gYWJzUztcclxuICAgIHZhciBvbmVQbHVzQWJzUzogJHtkVHlwZX0gPSAxLjAgKyBhYnNTO1xyXG4gICAgY29lZmZzWzBdID0gKCgke2N1YmljQ29lZmZBfSAqIG9uZVBsdXNBYnNTIC0gNSAqICR7Y3ViaWNDb2VmZkF9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7XHJcbiAgICAgIGN1YmljQ29lZmZBXHJcbiAgICB9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7Y3ViaWNDb2VmZkF9O1xyXG4gICAgY29lZmZzWzFdID0gKCgke2N1YmljQ29lZmZBfSArIDIpICogYWJzUyAtICgke2N1YmljQ29lZmZBfSArIDMpKSAqIGFic1MgKiBhYnNTICsgMTtcclxuICAgIGNvZWZmc1syXSA9ICgoJHtjdWJpY0NvZWZmQX0gKyAyKSAqIG9uZU1pbnVzQWJzUyAtICgke2N1YmljQ29lZmZBfSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XHJcbiAgICBjb2VmZnNbM10gPSAoKCR7Y3ViaWNDb2VmZkF9ICogdHdvTWludXNBYnNTIC0gNSAqICR7Y3ViaWNDb2VmZkF9KSAqIHR3b01pbnVzQWJzUyArIDggKiAke1xyXG4gICAgICBjdWJpY0NvZWZmQVxyXG4gICAgfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHtjdWJpY0NvZWZmQX07XHJcbiAgICByZXR1cm4gY29lZmZzO1xyXG4gIH1cclxuXHJcbiAgZm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoeDogYXJyYXk8JHtkVHlwZX0sIDQ+LCBjb2VmczogYXJyYXk8JHtkVHlwZX0sIDQ+KSAtPiAke2RUeXBlfSB7XHJcbiAgICB2YXIgY29lZnNTdW06ICR7ZFR5cGV9ID0gY29lZnNbMF0gKyBjb2Vmc1sxXSArIGNvZWZzWzJdICsgY29lZnNbM107XHJcbiAgICByZXR1cm4gKHhbMF0gKiBjb2Vmc1swXSArIHhbMV0gKiBjb2Vmc1sxXSsgeFsyXSAqIGNvZWZzWzJdKyB4WzNdICogY29lZnNbM10pIC8gY29lZnNTdW07XHJcbiAgfVxyXG5cclxuICBmbiBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xyXG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xyXG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzLCBvdXRwdXRfaW5kaWNlcyk7XHJcbiAgfVxyXG4gICAgYDtcclxufTtcclxuXHJcbmNvbnN0IHRyaWxpbmVhckludGVycG9sYXRpb24gPSAoXHJcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXHJcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXHJcbiAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsXHJcbik6IHN0cmluZyA9PiB7XHJcbiAgY29uc3QgaXNOY2h3ID0gdHJ1ZTtcclxuICBjb25zdCBbYmF0Y2hJZHgsIGRlcHRoSWR4LCBoZWlnaHRJZHgsIHdpZHRoSWR4LCBjaGFubmVsSWR4XSA9XHJcbiAgICBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMyA/IFstMSwgMCwgMSwgMiwgLTFdIDogaXNOY2h3ID8gWzAsIDIsIDMsIDQsIDFdIDogWzAsIDEsIDIsIDMsIDRdO1xyXG4gIGNvbnN0IGRUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcclxuICByZXR1cm4gYFxyXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGRlcHRoOnUzMiwgaGVpZ2h0OiB1MzIsIHdpZHRoOiB1MzIpIC0+ICR7ZFR5cGV9IHtcclxuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcclxuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgZGVwdGhJZHgsIGBtYXgoMCwgbWluKGRlcHRoLCAke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpKWApfTtcclxuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaGVpZ2h0SWR4LCBgbWF4KDAsIG1pbihoZWlnaHQsICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKWApfTtcclxuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgd2lkdGhJZHgsIGBtYXgoMCwgbWluKHdpZHRoLCAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKWApfTtcclxuICAgICAgJHtzZXRDaGFubmVsQW5kQmF0Y2hJbmRpY2VzKGlucHV0LCBjaGFubmVsSWR4LCBiYXRjaElkeCwgMyl9XHJcbiAgICAgIHJldHVybiAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcclxuICAgIH1cclxuXHJcbiAgICBmbiB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XHJcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XHJcbiAgICAgIHZhciBkZXB0aDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske2RlcHRoSWR4fV07XHJcbiAgICAgIHZhciBoZWlnaHQ6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHtoZWlnaHRJZHh9XTtcclxuICAgICAgdmFyIHdpZHRoOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7d2lkdGhJZHh9XTtcclxuICAgICAgJHtcclxuICAgICAgICB1c2VFeHRyYXBvbGF0aW9uXHJcbiAgICAgICAgICA/IGBpZiAoZGVwdGggPCAwIHx8IGRlcHRoID4gKCR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkgfHwgaGVpZ2h0IDwgMCB8fCBoZWlnaHQgPiAoJHtcclxuICAgICAgICAgICAgICBpbnB1dFNoYXBlW2hlaWdodElkeF1cclxuICAgICAgICAgICAgfSAtIDEpIHx8IHdpZHRoIDwgMCB8fCAod2lkdGggPiAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKSB7XHJcbiAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XHJcbiAgICAgICAgfWBcclxuICAgICAgICAgIDogJydcclxuICAgICAgfTtcclxuXHJcbiAgICBkZXB0aCA9IG1heCgwLCBtaW4oZGVwdGgsICR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkpO1xyXG4gICAgICBoZWlnaHQgPSBtYXgoMCwgbWluKGhlaWdodCwgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpO1xyXG4gICAgICB3aWR0aCA9IG1heCgwLCBtaW4od2lkdGgsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpO1xyXG4gICAgICB2YXIgZGVwdGgxOiB1MzIgPSB1MzIoZGVwdGgpO1xyXG4gICAgICB2YXIgaGVpZ2h0MTogdTMyID0gdTMyKGhlaWdodCk7XHJcbiAgICAgIHZhciB3aWR0aDE6IHUzMiA9IHUzMih3aWR0aCk7XHJcbiAgICAgIHZhciBkZXB0aDI6IHUzMiA9IHUzMihkZXB0aCArIDEpO1xyXG4gICAgICB2YXIgaGVpZ2h0MjogdTMyID0gdTMyKGhlaWdodCArIDEpO1xyXG4gICAgICB2YXIgd2lkdGgyOiB1MzIgPSB1MzIod2lkdGggKyAxKTtcclxuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7aW5wdXRTaGFwZS5sZW5ndGggPiAzID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtjaGFubmVsSWR4fV0pYCA6ICcwJ307XHJcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7aW5wdXRTaGFwZS5sZW5ndGggPiAzID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtiYXRjaElkeH1dKWAgOiAnMCd9O1xyXG5cclxuICAgICAgdmFyIHgxMTE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDEpO1xyXG4gICAgICB2YXIgeDExMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMik7XHJcbiAgICAgIHZhciB4MTIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgxKTtcclxuICAgICAgdmFyIHgxMjI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDIpO1xyXG4gICAgICB2YXIgeDIxMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMSk7XHJcbiAgICAgIHZhciB4MjEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgyKTtcclxuICAgICAgdmFyIHgyMjE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDEpO1xyXG4gICAgICB2YXIgeDIyMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMik7XHJcbiAgICAgIHZhciBkeDE6ICR7ZFR5cGV9ID0gYWJzKGRlcHRoIC0gJHtkVHlwZX0oZGVwdGgxKSk7XHJcbiAgICAgIHZhciBkeDI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KGRlcHRoMikgLSBkZXB0aCk7XHJcbiAgICAgIHZhciBkeTE6ICR7ZFR5cGV9ID0gYWJzKGhlaWdodCAtICR7ZFR5cGV9KGhlaWdodDEpKTtcclxuICAgICAgdmFyIGR5MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0oaGVpZ2h0MikgLSBoZWlnaHQpO1xyXG4gICAgICB2YXIgZHoxOiAke2RUeXBlfSA9IGFicyh3aWR0aCAtICR7ZFR5cGV9KHdpZHRoMSkpO1xyXG4gICAgICB2YXIgZHoyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfSh3aWR0aDIpIC0gd2lkdGgpO1xyXG4gICAgICBpZiAoZGVwdGgxID09IGRlcHRoMikge1xyXG4gICAgICAgIGR4MSA9IDAuNTtcclxuICAgICAgICBkeDIgPSAwLjU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGhlaWdodDEgPT0gaGVpZ2h0Mikge1xyXG4gICAgICAgIGR5MSA9IDAuNTtcclxuICAgICAgICBkeTIgPSAwLjU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHdpZHRoMSA9PSB3aWR0aDIpIHtcclxuICAgICAgICBkejEgPSAwLjU7XHJcbiAgICAgICAgZHoyID0gMC41O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoeDExMSAqIGR4MiAqIGR5MiAqIGR6MiArIHgxMTIgKiBkeDIgKiBkeTIgKiBkejEgKyB4MTIxICogZHgyICogZHkxICpkejIgKyB4MTIyICogZHgyICogZHkxICogZHoxICtcclxuICAgICAgICAgICAgICB4MjExICogZHgxICogZHkyICogZHoyICsgeDIxMiAqIGR4MSAqIGR5MiAqIGR6MSArIHgyMjEgKiBkeDEgKiBkeTEgKmR6MiArIHgyMjIgKiBkeDEgKiBkeTEgKiBkejEpO1xyXG4gICAgfWA7XHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVSZXNpemVQcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dFRlbnNvcjogVGVuc29yVmlldyxcclxuICBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzLFxyXG4gIG9wc2V0VmVyc2lvbjogbnVtYmVyLFxyXG4gIHNjYWxlc0lucHV0OiByZWFkb25seSBudW1iZXJbXSxcclxuICBzaXplczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgcm9pSW5wdXQ6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0VGVuc29yLmRpbXM7XHJcbiAgY29uc3Qgcm9pID0gdXBkYXRlUm9JKHJvaUlucHV0LCBhdHRyaWJ1dGVzLmF4ZXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcclxuXHJcbiAgbGV0IG91dHB1dFNoYXBlID0gaW5pdE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNjYWxlc0lucHV0LCBzaXplcywgYXR0cmlidXRlcy5heGVzKTtcclxuICBsZXQgc2NhbGVzID0gc2NhbGVzSW5wdXQuc2xpY2UoKTtcclxuICBpZiAoc2NhbGVzSW5wdXQubGVuZ3RoID09PSAwKSB7XHJcbiAgICBzY2FsZXMgPSBpbnB1dFNoYXBlLm1hcCgodmFsdWUsIGluZGV4KSA9PiAodmFsdWUgPT09IDAgPyAxLjAgOiBvdXRwdXRTaGFwZVtpbmRleF0gLyB2YWx1ZSkpO1xyXG4gICAgaWYgKGF0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5ICE9PSAnc3RyZXRjaCcpIHtcclxuICAgICAgb3V0cHV0U2hhcGUgPSBhZGp1c3RPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCBzY2FsZXMsIGF0dHJpYnV0ZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRUZW5zb3IuZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0VGVuc29yLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuICBjb25zdCBub1NjYWxlID0gaW5wdXRTaGFwZS5sZW5ndGggPT09IG91dHB1dFNoYXBlLmxlbmd0aCAmJiBpbnB1dFNoYXBlLmV2ZXJ5KChkLCBpKSA9PiBkID09PSBvdXRwdXRTaGFwZVtpXSk7XHJcbiAgY29uc3QgdXNlRXh0cmFwb2xhdGlvbiA9IGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPT09ICd0Zl9jcm9wX2FuZF9yZXNpemUnO1xyXG4gIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlO1xyXG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICAgICAgJHtcclxuICAgICAgICBub1NjYWxlXHJcbiAgICAgICAgICA/ICcnXHJcbiAgICAgICAgICA6IGBcclxuICAgICAgJHtnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoYXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSwgZGF0YVR5cGUpfTtcclxuICAgICAgJHsoKCkgPT4ge1xyXG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XHJcbiAgICAgICAgICBjYXNlICduZWFyZXN0JzpcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICAke2NoZWNrSW5wdXRJbmRpY2VzKGlucHV0LCBpbnB1dFNoYXBlKX07XHJcbiAgICAgICAgICAgICAgJHtnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSwgb3BzZXRWZXJzaW9uLCBkYXRhVHlwZSl9O1xyXG4gICAgICAgICAgICAgICR7Y2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMoXHJcbiAgICAgICAgICAgICAgICBpbnB1dCxcclxuICAgICAgICAgICAgICAgIG91dHB1dCxcclxuICAgICAgICAgICAgICAgIGlucHV0U2hhcGUsXHJcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZSxcclxuICAgICAgICAgICAgICAgIHNjYWxlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICByb2kubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgdXNlRXh0cmFwb2xhdGlvbixcclxuICAgICAgICAgICAgICApfTtcclxuICAgICAgICAgICAgICBgO1xyXG4gICAgICAgICAgY2FzZSAnbGluZWFyJzpcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgICAke2NhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dCwgaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUsIHNjYWxlcy5sZW5ndGgsIHJvaS5sZW5ndGgpfTtcclxuICAgICAgICAgICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2JpbGluZWFySW50ZXJwb2xhdGlvbihpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlLCB1c2VFeHRyYXBvbGF0aW9uLCBleHRyYXBvbGF0aW9uVmFsdWUpfWA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0U2hhcGUubGVuZ3RoID09PSAzIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA1KSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUsIHVzZUV4dHJhcG9sYXRpb24sIGV4dHJhcG9sYXRpb25WYWx1ZSl9YDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdMaW5lYXIgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiwgMywgNCBhbmQgNSBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pKCl9O1xyXG4gICAgICAgICAgICBgO1xyXG4gICAgICAgICAgY2FzZSAnY3ViaWMnOlxyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICAkeygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoID09PSAyIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7YmljdWJpY0ludGVycG9sYXRpb24oXHJcbiAgICAgICAgICAgICAgICAgIGlucHV0LFxyXG4gICAgICAgICAgICAgICAgICBvdXRwdXQsXHJcbiAgICAgICAgICAgICAgICAgIGlucHV0U2hhcGUsXHJcbiAgICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlLFxyXG4gICAgICAgICAgICAgICAgICBzY2FsZXMsXHJcbiAgICAgICAgICAgICAgICAgIHJvaSxcclxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5jdWJpY0NvZWZmQSxcclxuICAgICAgICAgICAgICAgICAgdXNlRXh0cmFwb2xhdGlvbixcclxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZXhjbHVkZU91dHNpZGUsXHJcbiAgICAgICAgICAgICAgICApfWA7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdDdWJpYyBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyIGFuZCA0IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSgpfTtcclxuICAgICAgICAgICAgYDtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHJlc2l6ZSBtb2RlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KSgpfTtcclxuICAgICAgYFxyXG4gICAgICB9XHJcbiAgICAgICR7c2hhZGVySGVscGVyXHJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJylcclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdzY2FsZXMnLCAnZjMyJywgc2NhbGVzLmxlbmd0aClcclxuICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdyb2knLCAnZjMyJywgcm9pLmxlbmd0aClcclxuICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cclxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cclxuICAgICAgICAke1xyXG4gICAgICAgICAgbm9TY2FsZVxyXG4gICAgICAgICAgICA/ICdvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTsnXHJcbiAgICAgICAgICAgIDogYFxyXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xyXG4gICAgICAgICR7KCgpID0+IHtcclxuICAgICAgICAgIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ25lYXJlc3QnOlxyXG4gICAgICAgICAgICAgIHJldHVybiBgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7YXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWV9O1xyXG4gICAgICAgICAgICAgICAgfWA7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xpbmVhcic6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke1xyXG4gICAgICAgICAgICAgICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQgPyAnYmlsaW5lYXJJbnRlcnBvbGF0aW9uJyA6ICd0cmlsaW5lYXJJbnRlcnBvbGF0aW9uJ1xyXG4gICAgICAgICAgICAgIH0ob3V0cHV0X2luZGljZXMpO2A7XHJcbiAgICAgICAgICAgIGNhc2UgJ2N1YmljJzpcclxuICAgICAgICAgICAgICByZXR1cm4gJ291dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzKTsnO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCByZXNpemUgbW9kZTogJHthdHRyaWJ1dGVzLm1vZGV9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKX07XHJcbmBcclxuICAgICAgICB9XHJcbiAgICAgIH1gO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ1Jlc2l6ZScsXHJcbiAgICBzaGFkZXJDYWNoZToge1xyXG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fXwke29wc2V0VmVyc2lvbn18JHtcclxuICAgICAgICBzY2FsZXMubGVuZ3RoID4gMCA/IChhdHRyaWJ1dGVzLm1vZGUgPT09ICdjdWJpYycgPyBzY2FsZXMgOiBzY2FsZXMubGVuZ3RoKSA6ICcnXHJcbiAgICAgIH18JHtzaXplcy5sZW5ndGggPiAwID8gc2l6ZXMgOiAnJ318JHtyb2kubGVuZ3RoID4gMCA/IHJvaSA6ICcnfXwke25vU2NhbGV9fCR7XHJcbiAgICAgICAgYXR0cmlidXRlcy5tb2RlID09PSAnbmVhcmVzdCcgPyBpbnB1dFNoYXBlLmxlbmd0aCA6IGlucHV0U2hhcGVcclxuICAgICAgfWAsXHJcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSxcclxuICAgIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VGVuc29yLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogc2NhbGVzIH0sXHJcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogcm9pIH0sXHJcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpLFxyXG4gICAgICBdLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IGdldE9wc2V0VmVyc2lvbkZyb21DdXN0b21EYXRhQnVmZmVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogbnVtYmVyID0+IHtcclxuICBjb25zdCBjdXN0b21EYXRhQnVmZmVyID0gY29udGV4dC5jdXN0b21EYXRhQnVmZmVyO1xyXG4gIGNvbnN0IGN1c3RvbURhdGFCdWZmZXIzMiA9IG5ldyBVaW50MzJBcnJheShjdXN0b21EYXRhQnVmZmVyLCBjdXN0b21EYXRhQnVmZmVyLmJ5dGVPZmZzZXQsIDEpO1xyXG4gIGNvbnN0IG9wc2V0VmVyc2lvbiA9IGN1c3RvbURhdGFCdWZmZXIzMlswXTtcclxuICByZXR1cm4gb3BzZXRWZXJzaW9uO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlc2l6ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IHNjYWxlczogbnVtYmVyW10gPSBbXTtcclxuICBjb25zdCBzaXplczogbnVtYmVyW10gPSBbXTtcclxuICBjb25zdCByb2k6IG51bWJlcltdID0gW107XHJcblxyXG4gIC8vIE5vdGUgdGhhdCBzY2FsZXMgaW4gcmVzaXplIGFyZSBhbHdheXMgZjMyLiByb2kgY2FuIGJlIGYzMiBvciBmMTYuXHJcbiAgLy8gVE9ETzogQ3VycmVudGx5IHRoaXMgY29kZSBkb2VzIG5vdCBzdXBwb3J0IGYxNiBmb3Igcm9pIHdoZW4gcGFzc2VkIGFzIG9wdGlvbmFsIGlucHV0LlxyXG5cclxuICBjb25zdCBvcHNldFZlcnNpb24gPSBnZXRPcHNldFZlcnNpb25Gcm9tQ3VzdG9tRGF0YUJ1ZmZlcihjb250ZXh0KTtcclxuICBpZiAoYXR0cmlidXRlcy5hbnRpYWxpYXMgIT09IDApIHtcclxuICAgIHRocm93IEVycm9yKCdPbmx5IGRlZmF1bHQgdmFsdWUgKDApIGZvciBBbnRpYWxpYXMgYXR0cmlidXRlIGlzIHN1cHBvcnRlZCcpO1xyXG4gIH1cclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcywgb3BzZXRWZXJzaW9uLCBzY2FsZXMsIHNpemVzLCByb2kpO1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVSZXNpemVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcywgb3BzZXRWZXJzaW9uLCBzY2FsZXMsIHNpemVzLCByb2kpLCB7XHJcbiAgICBpbnB1dHM6IFswXSxcclxuICB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBSZXNpemVBdHRyaWJ1dGVzID0+IHtcclxuICBjb25zdCBhbnRpYWxpYXMgPSBhdHRyaWJ1dGVzLmFudGlhbGlhcyBhcyBudW1iZXI7XHJcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcyBhcyBudW1iZXJbXTtcclxuICBjb25zdCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPVxyXG4gICAgYXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSBhcyBDb29yZGluYXRlVHJhbnNmb3JtTW9kZTtcclxuICBjb25zdCBjdWJpY0NvZWZmQSA9IGF0dHJpYnV0ZXMuY3ViaWNDb2VmZkEgYXMgbnVtYmVyO1xyXG4gIGNvbnN0IGV4Y2x1ZGVPdXRzaWRlID0gKGF0dHJpYnV0ZXMuZXhjbHVkZU91dHNpZGUgYXMgbnVtYmVyKSAhPT0gMDtcclxuICBjb25zdCBleHRyYXBvbGF0aW9uVmFsdWUgPSBhdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZSBhcyBudW1iZXI7XHJcbiAgY29uc3Qga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3kgPSBhdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeSBhcyBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XHJcbiAgY29uc3QgbW9kZTogTW9kZSA9IGF0dHJpYnV0ZXMubW9kZSBhcyBNb2RlO1xyXG4gIC8vIElmIG5lYXJlc3RNb2RlIGlzIG5vdCBzcGVjaWZpZWQsIHVzZSBzaW1wbGUgbW9kZS5cclxuICBjb25zdCBuZWFyZXN0TW9kZTogTmVhcmVzdE1vZGUgPSAoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSA9PT0gJycgPyAnc2ltcGxlJyA6IGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUpIGFzIE5lYXJlc3RNb2RlO1xyXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xyXG4gICAgYW50aWFsaWFzLFxyXG4gICAgYXhlcyxcclxuICAgIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLFxyXG4gICAgY3ViaWNDb2VmZkEsXHJcbiAgICBleGNsdWRlT3V0c2lkZSxcclxuICAgIGV4dHJhcG9sYXRpb25WYWx1ZSxcclxuICAgIGtlZXBBc3BlY3RSYXRpb1BvbGljeSxcclxuICAgIG1vZGUsXHJcbiAgICBuZWFyZXN0TW9kZSxcclxuICB9KTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNhc3RUb0YzMixcclxuICBnZXRNYXhDb21wb25lbnRzLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIHN1bVZlY3RvcixcclxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXHJcbiAgVW5pZm9ybXNBcnJheVR5cGUsXHJcbn0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTa2lwTGF5ZXJOb3JtQXR0cmlidXRlcyB7XHJcbiAgc2ltcGxpZmllZDogYm9vbGVhbjtcclxuICBlcHNpbG9uOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLicpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaW5wdXQ6IFRlbnNvclZpZXcgPSBpbnB1dHNbMF07XHJcbiAgY29uc3Qgc2tpcDogVGVuc29yVmlldyA9IGlucHV0c1sxXTtcclxuICBjb25zdCBnYW1tYTogVGVuc29yVmlldyA9IGlucHV0c1syXTtcclxuXHJcbiAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBza2lwLmRhdGFUeXBlIHx8IGlucHV0LmRhdGFUeXBlICE9PSBnYW1tYS5kYXRhVHlwZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbGwgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUnKTtcclxuICB9XHJcblxyXG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gMyAmJiBpbnB1dC5kaW1zLmxlbmd0aCAhPT0gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIDJEIG9yIDNEJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoc2tpcC5kaW1zLmxlbmd0aCAhPT0gMyAmJiBza2lwLmRpbXMubGVuZ3RoICE9PSAyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgbXVzdCBiZSAyRCBvciAzRCcpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IGlucHV0LmRpbXNbaW5wdXQuZGltcy5sZW5ndGggLSAxXTtcclxuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0LmRpbXNbaW5wdXQuZGltcy5sZW5ndGggLSAyXTtcclxuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xyXG4gIH1cclxuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAyXSAhPT0gc2VxdWVuY2VMZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgc2VxdWVuY2UgbGVuZ3RoIGFzIGlucHV0Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAoZ2FtbWEuZGltcy5sZW5ndGggIT09IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignR2FtbWEgbXVzdCBiZSAxRCcpO1xyXG4gIH1cclxuICBpZiAoZ2FtbWEuZGltc1tnYW1tYS5kaW1zLmxlbmd0aCAtIDFdICE9PSBoaWRkZW5TaXplKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhbW1hIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xyXG4gIH1cclxuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDMpIHtcclxuICAgIGNvbnN0IGJldGE6IFRlbnNvclZpZXcgPSBpbnB1dHNbM107XHJcbiAgICBpZiAoYmV0YS5kaW1zLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JldGEgbXVzdCBiZSAxRCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKGJldGEuZGltc1tiZXRhLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCZXRhIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDQpIHtcclxuICAgIGNvbnN0IGJpYXM6IFRlbnNvclZpZXcgPSBpbnB1dHNbNF07XHJcbiAgICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpYXMgbXVzdCBiZSAxRCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKGJpYXMuZGltc1tiaWFzLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZVNraXBMYXllck5vcm1Qcm9ncmFtSW5mbyA9IChcclxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICBhdHRyaWJ1dGVzOiBTa2lwTGF5ZXJOb3JtQXR0cmlidXRlcyxcclxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxyXG4gIGlzVHJhaW5pbmc6IGJvb2xlYW4sXHJcbik6IFByb2dyYW1JbmZvID0+IHtcclxuICBjb25zdCBzaW1wbGlmaWVkID0gYXR0cmlidXRlcy5zaW1wbGlmaWVkO1xyXG5cclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XHJcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xyXG4gIGNvbnN0IG91dHB1dFNpemUgPSBpbnB1dFNpemU7XHJcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IGlucHV0U2hhcGUuc2xpY2UoLTEpWzBdO1xyXG4gIGNvbnN0IG1lYW5JbnZTdGREZXZEaW0gPSBpc1RyYWluaW5nID8gaW5wdXRTaGFwZS5zbGljZSgwLCAtMSkuY29uY2F0KDEpIDogW107XHJcbiAgY29uc3QgaGFzQmV0YUlucHV0ID0gIXNpbXBsaWZpZWQgJiYgaW5wdXRzLmxlbmd0aCA+IDM7XHJcbiAgY29uc3QgaGFzQmlhc0lucHV0ID0gaW5wdXRzLmxlbmd0aCA+IDQ7XHJcbiAgY29uc3QgaGFzTWVhbk91dHB1dCA9IGlzVHJhaW5pbmcgJiYgb3V0cHV0Q291bnQgPiAxO1xyXG4gIGNvbnN0IGhhc0ludlN0ZERldk91dHB1dCA9IGlzVHJhaW5pbmcgJiYgb3V0cHV0Q291bnQgPiAyO1xyXG4gIGNvbnN0IGhhc0lucHV0U2tpcEJpYXNTdW1PdXRwdXQgPSBvdXRwdXRDb3VudCA+IDM7XHJcbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDY0O1xyXG5cclxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhoaWRkZW5TaXplKTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBjb21wb25lbnRzIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaGlkZGVuU2l6ZSB9LFxyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5lcHNpbG9uIH0sXHJcbiAgXTtcclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcclxuICAgIGNvbnN0IHVuaWZvcm1zQXJyYXk6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xyXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2NvbXBvbmVudHMnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgICB7IG5hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInIH0sXHJcbiAgICAgIHsgbmFtZTogJ2Vwc2lsb24nLCB0eXBlOiAnZjMyJyB9LFxyXG4gICAgXTtcclxuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtcclxuICAgICAgaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpLFxyXG4gICAgICBpbnB1dFZhcmlhYmxlKCdza2lwJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcywgY29tcG9uZW50cyksXHJcbiAgICAgIGlucHV0VmFyaWFibGUoJ2dhbW1hJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cyksXHJcbiAgICBdO1xyXG4gICAgaWYgKGhhc0JldGFJbnB1dCkge1xyXG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiZXRhJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY29tcG9uZW50cykpO1xyXG4gICAgfVxyXG4gICAgaWYgKGhhc0JpYXNJbnB1dCkge1xyXG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzRdLmRhdGFUeXBlLCBpbnB1dHNbNF0uZGltcywgY29tcG9uZW50cykpO1xyXG4gICAgfVxyXG4gICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpKTtcclxuICAgIGlmIChoYXNNZWFuT3V0cHV0KSB7XHJcbiAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdtZWFuX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzSW52U3RkRGV2T3V0cHV0KSB7XHJcbiAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdpbnZfc3RkX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dCkge1xyXG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW5wdXRfc2tpcF9iaWFzX3N1bScsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XHJcbiAgICBjb25zdCB2ZWNEYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XHJcbiAgICByZXR1cm4gYFxyXG5cclxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3Jtc0FycmF5KS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XHJcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zaGFyZWQgOiBhcnJheTwke3ZlY0RhdGFUeXBlfSwgJHt3b3JrZ3JvdXBTaXplfT47XHJcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcclxuXHJcbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbd29ya2dyb3VwU2l6ZSwgMSwgMV0pfVxyXG4gICAgICAgIGxldCBpeCA9IGxvY2FsX2lkLng7XHJcbiAgICAgICAgbGV0IGl5ID0gZ2xvYmFsX2lkLnggLyAke3dvcmtncm91cFNpemV9O1xyXG5cclxuICAgICAgICBsZXQgaGlkZGVuX3NpemVfdmVjdG9yaXplZDogdTMyID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgLyB1bmlmb3Jtcy5jb21wb25lbnRzO1xyXG4gICAgICAgIHZhciBzdHJpZGUgPSBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkIC8gJHt3b3JrZ3JvdXBTaXplfTtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gaXggKiBzdHJpZGUgKyBpeSAqIGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ7XHJcbiAgICAgICAgbGV0IG9mZnNldDFkID0gc3RyaWRlICogaXg7XHJcbiAgICAgICAgaWYgKGl4ID09ICR7d29ya2dyb3VwU2l6ZSAtIDF9KSB7XHJcbiAgICAgICAgICBzdHJpZGUgPSBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkIC0gc3RyaWRlICogaXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xyXG4gICAgICAgICAgbGV0IHNraXBfdmFsdWUgPSBza2lwW29mZnNldCArIGldO1xyXG4gICAgICAgICAgbGV0IGJpYXNfdmFsdWUgPSAke2hhc0JpYXNJbnB1dCA/ICdiaWFzW29mZnNldDFkICsgaV0nIDogZGF0YVR5cGUgKyAnKDAuMCknfTtcclxuICAgICAgICAgIGxldCBpbnB1dF92YWx1ZSA9IHhbb2Zmc2V0ICsgaV07XHJcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dF92YWx1ZSArIHNraXBfdmFsdWUgKyBiaWFzX3ZhbHVlO1xyXG4gICAgICAgICAgJHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0ID8gJ2lucHV0X3NraXBfYmlhc19zdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTsnIDogJyd9XHJcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcclxuICAgICAgICAgIGxldCBmMzJfdmFsdWUgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3ZhbHVlJyl9O1xyXG4gICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlO1xyXG4gICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBmMzJfdmFsdWUgKiBmMzJfdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuXHJcbiAgICAgICAgdmFyIHJlZHVjZV9zaXplIDogdTMyID0gJHt3b3JrZ3JvdXBTaXplfTtcclxuICAgICAgICBmb3IgKHZhciBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxOyAgY3Vycl9zaXplID4gMDsgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMSkge1xyXG4gICAgICAgICAgcmVkdWNlX3NpemUgPSBjdXJyX3NpemUgKyAocmVkdWNlX3NpemUgJiAxKTtcclxuICAgICAgICAgIGlmIChpeCA8IGN1cnJfc2l6ZSkge1xyXG4gICAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBzdW1fc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xyXG4gICAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IHN1bV9zcXVhcmVkX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzdW0gPSBzdW1fc2hhcmVkWzBdO1xyXG4gICAgICAgIGxldCBzcXVhcmVfc3VtID0gc3VtX3NxdWFyZWRfc2hhcmVkWzBdO1xyXG4gICAgICAgIGxldCBtZWFuID0gJHtzdW1WZWN0b3IoJ3N1bScsIGNvbXBvbmVudHMpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSk7XHJcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtzdW1WZWN0b3IoJ3NxdWFyZV9zdW0nLCBjb21wb25lbnRzKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpICR7XHJcbiAgICAgICAgICBzaW1wbGlmaWVkID8gJycgOiAnLSBtZWFuICogbWVhbidcclxuICAgICAgICB9ICsgdW5pZm9ybXMuZXBzaWxvbik7XHJcbiAgICAgICAgJHtoYXNNZWFuT3V0cHV0ID8gJ21lYW5fb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbjsnIDogJyd9XHJcbiAgICAgICAgJHtoYXNJbnZTdGREZXZPdXRwdXQgPyAnaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldjsnIDogJyd9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xyXG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gKG91dHB1dFtvZmZzZXQgKyBpXSAke3NpbXBsaWZpZWQgPyAnJyA6IGAtICR7ZGF0YVR5cGV9KG1lYW4pYH0pICpcclxuICAgICAgICAgICAgJHtkYXRhVHlwZX0oaW52X3N0ZF9kZXYpICogZ2FtbWFbb2Zmc2V0MWQgKyBpXVxyXG4gICAgICAgICAgICAke2hhc0JldGFJbnB1dCA/ICcrIGJldGFbb2Zmc2V0MWQgKyBpXScgOiAnJ307XHJcbiAgICAgICAgfVxyXG4gICAgICB9YDtcclxuICB9O1xyXG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XTtcclxuICBpZiAob3V0cHV0Q291bnQgPiAxKSB7XHJcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfSk7XHJcbiAgfVxyXG4gIGlmIChvdXRwdXRDb3VudCA+IDIpIHtcclxuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcclxuICB9XHJcbiAgaWYgKG91dHB1dENvdW50ID4gMykge1xyXG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogaW5wdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9KTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJyxcclxuICAgIHNoYWRlckNhY2hlOiB7XHJcbiAgICAgIGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7aGFzTWVhbk91dHB1dH07JHtoYXNJbnZTdGREZXZPdXRwdXR9OyR7aGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dH1gLFxyXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogaW5wdXRzLm1hcCgoX2lucHV0LCBfaW5kZXgpID0+ICd0eXBlJyksXHJcbiAgICB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0cyxcclxuICAgICAgZGlzcGF0Y2hHcm91cDoge1xyXG4gICAgICAgIHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gaGlkZGVuU2l6ZSksXHJcbiAgICAgIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcclxuICAgIH0pLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgc2tpcExheWVyTm9ybSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcclxuICAvLyBUT0RPOiBpbml0aWFsaXplIGlzVHJhaW5pbmcgZnJvbSBDb21wdXRlQ29udGV4dFxyXG4gIGNvbnN0IGlzVHJhaW5pbmcgPSBmYWxzZTtcclxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XHJcbiAgLy8gTWVhbiBhbmQgSW52U3RkRGV2IGFyZSBvbmx5IHVzZWQgaW4gdHJhaW5pbmcgbW9kZSBhbmQgYXJlIG5vdCByZXF1aXJlZCBmb3IgaW5mZXJlbmNlLlxyXG4gIC8vIFRoZXkgYXJlIGFkZGVkIGhlcmUgZm9yIGNvbXBsZXRlbmVzcyBvbmx5LlxyXG4gIGNvbnN0IG91dHB1dHMgPSBbMF07XHJcbiAgaWYgKGNvbnRleHQub3V0cHV0Q291bnQgPiAxKSB7XHJcbiAgICBvdXRwdXRzLnB1c2goaXNUcmFpbmluZyA/IDEgOiAtMyk7XHJcbiAgfVxyXG4gIGlmIChjb250ZXh0Lm91dHB1dENvdW50ID4gMikge1xyXG4gICAgb3V0cHV0cy5wdXNoKGlzVHJhaW5pbmcgPyAyIDogLTMpO1xyXG4gIH1cclxuICBpZiAoY29udGV4dC5vdXRwdXRDb3VudCA+IDMpIHtcclxuICAgIG91dHB1dHMucHVzaCgzKTtcclxuICB9XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNraXBMYXllck5vcm1Qcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcywgY29udGV4dC5vdXRwdXRDb3VudCwgaXNUcmFpbmluZyksIHtcclxuICAgIG91dHB1dHMsXHJcbiAgfSk7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0sIFRlbnNvckluZm8gfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxyXG4gIGdldEVsZW1lbnRBdCxcclxuICBJbmRpY2VzSGVscGVyLFxyXG4gIGlucHV0VmFyaWFibGUsXHJcbiAgb3V0cHV0VmFyaWFibGUsXHJcbiAgU2hhZGVySGVscGVyLFxyXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcclxuICByZWFkb25seSBzdGFydHM6IG51bWJlcltdO1xyXG4gIHJlYWRvbmx5IGVuZHM6IG51bWJlcltdO1xyXG4gIHJlYWRvbmx5IGF4ZXM6IG51bWJlcltdO1xyXG59XHJcblxyXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcclxuICB9XHJcbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggIT09IDApIHtcclxuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggfHwgYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5lbmRzLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4ZXMsIHN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuZW5kcy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGgnKTtcclxuICB9XHJcbiAgaW5wdXRzLnNsaWNlKDEpLmZvckVhY2goKF8sIGlkeCkgPT4ge1xyXG4gICAgaWYgKGlucHV0c1tpZHggKyAxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50MzIgJiYgaW5wdXRzW2lkeCArIDFdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQ2NCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7aWR4fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG5jb25zdCByZWFkSW5wdXQgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGlkeDogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xyXG4gIGNvbnN0IGlucHV0OiBudW1iZXJbXSA9IFtdO1xyXG4gIGlmIChpbnB1dHMubGVuZ3RoID4gaWR4KSB7XHJcbiAgICBpZiAoaW5wdXRzW2lkeF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDY0KSB7XHJcbiAgICAgIGlucHV0c1tpZHhdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKCh2KSA9PiBpbnB1dC5wdXNoKE51bWJlcih2KSkpO1xyXG4gICAgfSBlbHNlIGlmIChpbnB1dHNbaWR4XS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcclxuICAgICAgaW5wdXRzW2lkeF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2goKHYpID0+IGlucHV0LnB1c2goTnVtYmVyKHYpKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7aWR4fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBpbnB1dDtcclxufTtcclxuXHJcbmNvbnN0IGNyZWF0ZVNsaWNlQXR0cmlidXRlc0Zyb21JbnB1dHMgPSAoXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzLFxyXG4pOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xyXG4gIGlmIChpbnB1dHMubGVuZ3RoID4gMSkge1xyXG4gICAgY29uc3Qgc3RhcnRzOiBudW1iZXJbXSA9IHJlYWRJbnB1dChpbnB1dHMsIDEpO1xyXG4gICAgY29uc3QgZW5kczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAyKTtcclxuICAgIGxldCBheGVzOiBudW1iZXJbXSA9IHJlYWRJbnB1dChpbnB1dHMsIDMpO1xyXG4gICAgaWYgKGF4ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGF4ZXMgPSBbLi4uQXJyYXkoaW5wdXRzWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHN0YXJ0cywgZW5kcywgYXhlcyB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZml4U3RhcnRFbmRWYWx1ZXMgPSAoXHJcbiAgdmFsdWU6IG51bWJlcixcclxuICBpbmRleDogbnVtYmVyLFxyXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gIHN0ZXBzOiByZWFkb25seSBudW1iZXJbXSxcclxuKTogbnVtYmVyID0+IHtcclxuICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcclxuICBpZiAodmFsdWUgPCAwKSB7XHJcbiAgICBuZXdWYWx1ZSArPSBpbnB1dFNoYXBlW2F4ZXNbaW5kZXhdXTtcclxuICB9XHJcbiAgaWYgKHN0ZXBzW2luZGV4XSA8IDApIHtcclxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihuZXdWYWx1ZSwgaW5wdXRTaGFwZVtheGVzW2luZGV4XV0gLSAxKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihuZXdWYWx1ZSwgaW5wdXRTaGFwZVtheGVzW2luZGV4XV0pKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBjYWxjdWxhdGVJbnB1dEluZGljZXNJbXBsID0gKFxyXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxyXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcclxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcclxuKTogc3RyaW5nID0+XHJcbiAgYGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcclxuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XHJcbiAgICAgICAgICB2YXIgY2FycnkgPSAwdTtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAke2lucHV0U2hhcGUubGVuZ3RoIC0gMX07IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xyXG4gICAgICAgICAgICBsZXQgc3RlcHNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zdGVwcycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcclxuICAgICAgICAgICAgbGV0IHNpZ25zX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2lnbnMnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XHJcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zdGFydHMnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xyXG4gICAgICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXggKiBzdGVwc19pICsgc3RhcnRzX2kgKyBjYXJyeTtcclxuICAgICAgICAgICAgY2FycnkgPSBpbnB1dF9pbmRleCAvIGlucHV0X3NoYXBlX2k7XHJcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfaW5kZXggJSBpbnB1dF9zaGFwZV9pO1xyXG4gICAgICAgICAgICBpZiAoc2lnbnNfaSA8IDApIHtcclxuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSBpbnB1dF9pbmRleCAtIDF1ICsgc3RhcnRzX2k7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgJ2knLCAnaW5wdXRfaW5kZXgnKX07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcclxuICAgICAgfWA7XHJcblxyXG5jb25zdCBjcmVhdGVTbGljZVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IGlucHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpO1xyXG4gIGNvbnN0IGF4ZXMgPVxyXG4gICAgYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDBcclxuICAgICAgPyBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyhhdHRyaWJ1dGVzLmF4ZXMsIGlucHV0U2hhcGUubGVuZ3RoKVxyXG4gICAgICA6IFsuLi5BcnJheShpbnB1dFNoYXBlLmxlbmd0aCkua2V5cygpXTtcclxuICBsZXQgc3RlcHMgPSByZWFkSW5wdXQoaW5wdXRzLCA0KTtcclxuICBzdGVwcy5mb3JFYWNoKFxyXG4gICAgKHN0ZXApID0+XHJcbiAgICAgIHN0ZXAgIT09IDAgfHxcclxuICAgICAgKCgpID0+IHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0ZXAgY2Fubm90IGJlIDAnKTtcclxuICAgICAgfSksXHJcbiAgKTtcclxuICBpZiAoc3RlcHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICBzdGVwcyA9IEFycmF5KGF4ZXMubGVuZ3RoKS5maWxsKDEpO1xyXG4gIH1cclxuICBjb25zdCBzdGFydHMgPSBhdHRyaWJ1dGVzLnN0YXJ0cy5tYXAoKHN0YXJ0LCBpKSA9PiBmaXhTdGFydEVuZFZhbHVlcyhzdGFydCwgaSwgaW5wdXRTaGFwZSwgYXhlcywgc3RlcHMpKTtcclxuXHJcbiAgY29uc3QgZW5kcyA9IGF0dHJpYnV0ZXMuZW5kcy5tYXAoKGVuZCwgaSkgPT4gZml4U3RhcnRFbmRWYWx1ZXMoZW5kLCBpLCBpbnB1dFNoYXBlLCBheGVzLCBzdGVwcykpO1xyXG5cclxuICBpZiAoYXhlcy5sZW5ndGggIT09IHN0YXJ0cy5sZW5ndGggfHwgYXhlcy5sZW5ndGggIT09IGVuZHMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0LCBlbmRzIGFuZCBheGVzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGF4ZXMubGVuZ3RoICE9PSBpbnB1dFNoYXBlLmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGlmICghYXhlcy5pbmNsdWRlcyhpKSkge1xyXG4gICAgICAgIHN0YXJ0cy5zcGxpY2UoaSwgMCwgMCk7XHJcbiAgICAgICAgZW5kcy5zcGxpY2UoaSwgMCwgaW5wdXRTaGFwZVtpXSk7XHJcbiAgICAgICAgc3RlcHMuc3BsaWNlKGksIDAsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHNpZ25zID0gc3RlcHMubWFwKChzdGVwKSA9PiBNYXRoLnNpZ24oc3RlcCkpO1xyXG4gIC8vIENvbnZlcnQgbmVnYXRpdmUgc3RlcHMgdG8gcG9zaXRpdmUgc3RlcHMgYW5kIHJldmVyc2Ugc3RhcnRzIGFuZCBlbmRzXHJcbiAgc3RlcHMuZm9yRWFjaCgoc3RlcCwgaSwgYXJyYXkpID0+IHtcclxuICAgIGlmIChzdGVwIDwgMCkge1xyXG4gICAgICBjb25zdCBudW1TdGVwcyA9IChlbmRzW2ldIC0gc3RhcnRzW2ldKSAvIHN0ZXA7XHJcbiAgICAgIGNvbnN0IG5ld0VuZCA9IHN0YXJ0c1tpXTtcclxuICAgICAgY29uc3QgbmV3U3RhcnQgPSBuZXdFbmQgKyBudW1TdGVwcyAqIHN0ZXBzW2ldO1xyXG4gICAgICBzdGFydHNbaV0gPSBuZXdTdGFydDtcclxuICAgICAgZW5kc1tpXSA9IG5ld0VuZDtcclxuICAgICAgYXJyYXlbaV0gPSAtc3RlcDtcclxuICAgIH1cclxuICB9KTtcclxuICAvLyBPdXRwdXQgcmFuayBpcyBleHBlY3RlZCB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGlucHV0IHJhbmsuXHJcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDApO1xyXG4gIGF4ZXMuZm9yRWFjaCgoYXhpcywgXykgPT4ge1xyXG4gICAgb3V0cHV0U2hhcGVbYXhpc10gPSBNYXRoLmNlaWwoKGVuZHNbYXhpc10gLSBzdGFydHNbYXhpc10pIC8gc3RlcHNbYXhpc10pO1xyXG4gIH0pO1xyXG4gIGNvbnN0IG91dHB1dFRlbnNvckluZm86IFRlbnNvckluZm8gPSB7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH07XHJcblxyXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xyXG4gIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcclxuICAgIHsgbmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJyB9LFxyXG4gICAgeyBuYW1lOiAnc3RhcnRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogc3RhcnRzLmxlbmd0aCB9LFxyXG4gICAgeyBuYW1lOiAnc2lnbnMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBzaWducy5sZW5ndGggfSxcclxuICAgIHsgbmFtZTogJ3N0ZXBzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogc3RlcHMubGVuZ3RoIH0sXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xyXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzdGFydHMgfSxcclxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHNpZ25zIH0sXHJcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc3RlcHMgfSxcclxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBvdXRwdXRTaGFwZSksXHJcbiAgXTtcclxuXHJcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXHJcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XHJcbiAgICAgICAgJHtjYWxjdWxhdGVJbnB1dEluZGljZXNJbXBsKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUpfVxyXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxyXG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxyXG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xyXG4gICAgICAgICAgbGV0IGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xyXG4gICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKSl9XHJcbiAgICAgIH1gO1xyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lOiAnU2xpY2UnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7c2lnbnMubGVuZ3RofV8ke3N0YXJ0cy5sZW5ndGh9XyR7c3RlcHMubGVuZ3RofWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcclxuICAgICAgb3V0cHV0czogW291dHB1dFRlbnNvckluZm9dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChpbnB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcclxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzbGljZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xyXG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gY3JlYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XHJcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwgeyBpbnB1dHM6IFswXSB9KTtcclxuICAvLyBpZiAoU2hhcGVVdGlsLnNpemUocHJvZ3JhbS5vdXRwdXRzWzBdLmRpbXMpID4gMCkge1xyXG4gIC8vICAgY29udGV4dC5jb21wdXRlKHByb2dyYW1JbmZvTG9hZGVyLCB7aW5wdXRzOiBbMF19KTtcclxuICAvLyB9IGVsc2Uge1xyXG4gIC8vICAgLy8gVE9ETzogc3VwcG9ydCBlbXB0eSBvdXRwdXRcclxuICAvLyAgIHRocm93IG5ldyBFcnJvcignc2xpY2U6IG91dHB1dCBzaXplIGlzIDAnKTtcclxuICAvLyB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcGFyc2VTbGljZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xyXG4gIGNvbnN0IHN0YXJ0cyA9IGF0dHJpYnV0ZXMuc3RhcnRzIGFzIG51bWJlcltdO1xyXG4gIGNvbnN0IGVuZHMgPSBhdHRyaWJ1dGVzLmVuZHMgYXMgbnVtYmVyW107XHJcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcyBhcyBudW1iZXJbXTtcclxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgc3RhcnRzLCBlbmRzLCBheGVzIH0pO1xyXG59O1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbi8vIFRPRE86IHRoaXMgaXMgdGhlIHNhbWUgbmFpdmUgaW1wbGVtZW50YXRpb24gd2UgdXNlIGZvciByZWR1Y2UgdGhhdCBoYXNcclxuLy8gcGVyZm9ybWFuY2UgbGltaXRhdGlvbnMgd2hlbiB0aGUgcmVkdWNlZCBheGlzIGlzIGxvbmcuIE5lZWQgdG8gYWRkXHJcbi8vIGEgb3B0aW1pemVkIGNvZGVwYXRoIGZvciB0aGlzLlxyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHJhbnNwb3NlJztcclxuXHJcbmltcG9ydCB7XHJcbiAgZ2V0TWF4Q29tcG9uZW50cyxcclxuICBpbnB1dFZhcmlhYmxlLFxyXG4gIG91dHB1dFZhcmlhYmxlLFxyXG4gIFNoYWRlckhlbHBlcixcclxuICBzdW1WZWN0b3IsXHJcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxyXG59IGZyb20gJy4vY29tbW9uJztcclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTb2Z0bWF4IG9wIHJlcXVpcmVzIDEgaW5wdXQuJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTb2Z0bWF4QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XHJcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xyXG59XHJcblxyXG5jb25zdCBjcmVhdGVTb2Z0bWF4UHJvZ3JhbUluZm8gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKSA9PiB7XHJcbiAgY29uc3QgaW5wdXQgPSBjb250ZXh0LmlucHV0c1swXTtcclxuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXQuZGltcztcclxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XHJcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XHJcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRSYW5rKTtcclxuICBjb25zdCBpc1RyYW5zcG9zZVJlcXVpcmVkID0gYXhpcyA8IGlucHV0U2hhcGUubGVuZ3RoIC0gMTtcclxuICBsZXQgdHJhbnNwb3NlZElucHV0OiBUZW5zb3JWaWV3O1xyXG4gIGxldCBwZXJtOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICBpZiAoaXNUcmFuc3Bvc2VSZXF1aXJlZCkge1xyXG4gICAgcGVybSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGlucHV0UmFuayB9LCAoXywgaSkgPT4gaSk7XHJcbiAgICBwZXJtW2F4aXNdID0gaW5wdXRSYW5rIC0gMTtcclxuICAgIHBlcm1baW5wdXRSYW5rIC0gMV0gPSBheGlzO1xyXG5cclxuICAgIHRyYW5zcG9zZWRJbnB1dCA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dCwgcGVybSksIHtcclxuICAgICAgaW5wdXRzOiBbaW5wdXRdLFxyXG4gICAgICBvdXRwdXRzOiBbLTFdLFxyXG4gICAgfSlbMF07XHJcbiAgfSBlbHNlIHtcclxuICAgIHRyYW5zcG9zZWRJbnB1dCA9IGlucHV0O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJhbnNwb3NlZElucHV0U2hhcGUgPSB0cmFuc3Bvc2VkSW5wdXQuZGltcztcclxuICBjb25zdCBjb2xzID0gdHJhbnNwb3NlZElucHV0U2hhcGVbaW5wdXRSYW5rIC0gMV07XHJcbiAgY29uc3Qgcm93cyA9IG91dHB1dFNpemUgLyBjb2xzO1xyXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGNvbHMpO1xyXG4gIGNvbnN0IHBhY2tlZENvbHMgPSBjb2xzIC8gY29tcG9uZW50cztcclxuICBsZXQgV0cgPSA2NDtcclxuICAvLyBJZiBvbmx5IG9uZSB3b3JrZ3JvdXAgaXMgZGlzcGF0Y2hlZCwgaW5jcmVhc2Ugd29ya2dyb3VwU2l6ZSB0byBpbXByb3ZlIHBhcmFsbGVsaXNtLlxyXG4gIGlmIChyb3dzID09PSAxKSB7XHJcbiAgICBXRyA9IDI1NjtcclxuICB9XHJcbiAgY29uc3QgbWF4VmVjdG9yID0gKG5hbWU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyKSA9PiB7XHJcbiAgICBpZiAoY29tcG9uZW50cyA9PT0gNCkge1xyXG4gICAgICByZXR1cm4gYG1heChtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpLCBtYXgoJHtuYW1lfS56LCAke25hbWV9LncpKWA7XHJcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDIpIHtcclxuICAgICAgcmV0dXJuIGBtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpYDtcclxuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMykge1xyXG4gICAgICByZXR1cm4gYG1heChtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpLCAke25hbWV9LnopYDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmFtZTtcclxuICB9O1xyXG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgdHJhbnNwb3NlZElucHV0LmRhdGFUeXBlLCB0cmFuc3Bvc2VkSW5wdXQuZGltcywgY29tcG9uZW50cyk7XHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIHRyYW5zcG9zZWRJbnB1dC5kYXRhVHlwZSwgdHJhbnNwb3NlZElucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xyXG4gIGNvbnN0IHZhbHVlVHlwZSA9IHgudHlwZS52YWx1ZTtcclxuICAvLyA2LjIuNCBpbiB3Z3NsIHNwZWNcclxuICBjb25zdCB0aHJlYWRNYXhEZWNsID1cclxuICAgIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSh0cmFuc3Bvc2VkSW5wdXQuZGF0YVR5cGUpID09PSAnZjMyJ1xyXG4gICAgICA/IGB2YXIgdGhyZWFkTWF4ID0gJHt2YWx1ZVR5cGV9KC0zLjQwMjgyM2UrMzhmKTtgXHJcbiAgICAgIDogYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTY1NTA0LjBoKTtgO1xyXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxyXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke3ZhbHVlVHlwZX07XHJcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcclxuICAgICAgdmFyPHdvcmtncm91cD4gdGhyZWFkU2hhcmVkIDogYXJyYXk8JHt2YWx1ZVR5cGV9LCAke1dHfT47XHJcblxyXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHt2YWx1ZVR5cGV9IHtcclxuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xyXG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke3ZhbHVlVHlwZX0pIHtcclxuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xyXG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3BhY2tlZENvbHMnLCAnaTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxyXG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoV0cpfVxyXG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkeCk7XHJcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZHgpO1xyXG4gICAgICAgIGNvbnN0IHdnID0gJHtXR307XHJcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xyXG4gICAgICAgIGxldCBjb2xzID0gdW5pZm9ybXMucGFja2VkQ29scztcclxuICAgICAgICBsZXQgcm93X3N0cmlkZSA6IGkzMiA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3MgbWF4XHJcbiAgICAgICAgJHt0aHJlYWRNYXhEZWNsfVxyXG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XHJcbiAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSk7XHJcbiAgICAgICAgICB0aHJlYWRNYXggPSBtYXgodGhyZWFkTWF4LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW5kZXggPCBjb2xzKSB7XHJcbiAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZE1heDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XHJcbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxKSB7XHJcbiAgICAgICAgICByZWR1Y2VTaXplID0gY3VyclNpemUgKyAocmVkdWNlU2l6ZSAmIDEpO1xyXG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XHJcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gbWF4KHRocmVhZFNoYXJlZFtsaW5kZXhdLCB0aHJlYWRTaGFyZWRbbGluZGV4ICsgcmVkdWNlU2l6ZV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcclxuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7dmFsdWVUeXBlfSgke21heFZlY3RvcigndGhyZWFkU2hhcmVkWzBdJywgY29tcG9uZW50cyl9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIHN1bVxyXG4gICAgICAgIHZhciB0aHJlYWRTdW0gPSAke3ZhbHVlVHlwZX0oMC4wKTtcclxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xyXG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xyXG4gICAgICAgICAgdGhyZWFkU3VtICs9IHN1YkV4cDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XHJcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xyXG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XHJcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcclxuICAgICAgICAgIHJvd1N1bVNoYXJlZCA9ICR7dmFsdWVUeXBlfSgke3N1bVZlY3RvcigndGhyZWFkU2hhcmVkWzBdJywgY29tcG9uZW50cyl9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XHJcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpIC8gcm93U3VtU2hhcmVkO1xyXG4gICAgICAgICAgLy8gbWF4IG9wZXJhdGlvbiBwcm90ZWN0cyBhZ2FpbnN0IE5hTiBzaW5jZSBhbGwgdmFsdWVzIHNob3VsZCBiZSA+PTBcclxuICAgICAgICAgIHZhbHVlID0gbWF4KHZhbHVlLCAke3ZhbHVlVHlwZX0oMC4wKSk7XHJcbiAgICAgICAgICBzZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfWA7XHJcbiAgY29uc3QgcmVzdWx0ID0gY29udGV4dC5jb21wdXRlKFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnU29mdG1heCcsXHJcbiAgICAgIC8vIE5vdGUgdGhhdCBpbiBKU0VQLCBXRyBzaXplIGlzIG5vdCBpbmNsdWRlZCBpbiBjYWNoZSBieSBkZWZhdWx0LCBidXQgV2ViR1BVIEVQIGl0IGlzLlxyXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtjb21wb25lbnRzfTske1dHfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxyXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xyXG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IHRyYW5zcG9zZWRJbnB1dFNoYXBlLCBkYXRhVHlwZTogdHJhbnNwb3NlZElucHV0LmRhdGFUeXBlIH1dLFxyXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogcm93cyB9LFxyXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtczogW3sgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHBhY2tlZENvbHMgfV0sXHJcbiAgICAgIH0pLFxyXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBpbnB1dHM6IFt0cmFuc3Bvc2VkSW5wdXRdLFxyXG4gICAgICBvdXRwdXRzOiBbaXNUcmFuc3Bvc2VSZXF1aXJlZCA/IC0xIDogMF0sXHJcbiAgICB9LFxyXG4gIClbMF07XHJcblxyXG4gIGlmIChpc1RyYW5zcG9zZVJlcXVpcmVkKSB7XHJcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzdWx0LCBwZXJtKSwge1xyXG4gICAgICBpbnB1dHM6IFtyZXN1bHRdLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNvZnRtYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XHJcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xyXG4gIGNyZWF0ZVNvZnRtYXhQcm9ncmFtSW5mbyhjb250ZXh0LCBhdHRyaWJ1dGVzKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogU29mdG1heEF0dHJpYnV0ZXMgPT5cclxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xyXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcclxuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XHJcblxyXG5jb25zdCBnZXRSZXBlYXRzID0gKHJlcGVhdHNUZW5zb3JWaWV3OiBUZW5zb3JWaWV3KTogcmVhZG9ubHkgbnVtYmVyW10gPT5cclxuICBBcnJheS5mcm9tKHJlcGVhdHNUZW5zb3JWaWV3LmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcclxuXHJcbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XHJcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKFxyXG4gICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCAmJlxyXG4gICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdDE2ICYmXHJcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyICYmXHJcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLnVpbnQzMlxyXG4gICkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgZmxvYXQxNiwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlcycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1sxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIG9mIGludDY0IGRhdGEgdHlwZScpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgMS1EJyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSA9IGdldFJlcGVhdHMoaW5wdXRzWzFdKTtcclxuXHJcbiAgaWYgKHJlcGVhdHMubGVuZ3RoICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGhhdmUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgcmFuayBvZiBpbnB1dCBkYXRhIHRlbnNvcicpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGdldE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdID0+IHtcclxuICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XHJcbiAgICBvdXRwdXRTaGFwZS5wdXNoKGlucHV0U2hhcGVbaV0gKiByZXBlYXRzW2ldKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvdXRwdXRTaGFwZTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVUaWxlUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIHNoYXBlPzogbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XHJcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdID0gc2hhcGUgPT0gbnVsbCA/IGdldFJlcGVhdHMoaW5wdXRzWzFdKSA6IHNoYXBlO1xyXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZ2V0T3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgcmVwZWF0cyk7XHJcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcclxuXHJcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XHJcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XHJcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xyXG5cclxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcclxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7aW5wdXQuaW5kaWNlcyguLi5pbnB1dFNoYXBlKX07XHJcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cclxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XHJcbiAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcclxuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke2lucHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGlucHV0X2RpbV9pID0gJHtpbnB1dC5pbmRpY2VzR2V0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJyl9O1xyXG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9ICAlIGlucHV0X2RpbV9pO1xyXG5cclxuICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICdpbnB1dF9kaW1fdmFsdWUnKX1cclxuICAgICAgfVxyXG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpKX1cclxuICAgIH1gO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogJ1RpbGUnLFxyXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7cmVwZWF0c31gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxyXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXHJcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIG91dHB1dFNoYXBlKSxcclxuICAgICAgXSxcclxuICAgIH0pLFxyXG4gICAgZ2V0U2hhZGVyU291cmNlLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdGlsZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcclxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVGlsZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSwgeyBpbnB1dHM6IFswXSB9KTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcclxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgQnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xyXG5cclxuY29uc3QgY3JlYXRlV2hlcmVPcFByb2dyYW1TaGFkZXIgPSAoXHJcbiAgc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsXHJcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXHJcbiAgZGltc091dHB1dDogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgaXNCcm9hZGNhc3Q6IGJvb2xlYW4sXHJcbiAgdHlwZU91dHB1dDogbnVtYmVyLFxyXG4pID0+IHtcclxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X2RhdGEnLCB0eXBlT3V0cHV0LCBkaW1zT3V0cHV0Lmxlbmd0aCwgNCk7XHJcbiAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2FfZGF0YScsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCA0KTtcclxuICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYl9kYXRhJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIDQpO1xyXG4gIGNvbnN0IGMgPSBpbnB1dFZhcmlhYmxlKCdjX2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgNCk7XHJcblxyXG4gIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XHJcbiAgY29uc3QgZXhwcmVzc2lvbiA9IChhOiBzdHJpbmcsIGI6IHN0cmluZywgYzogc3RyaW5nKSA9PiBgc2VsZWN0KCR7Yn0sICR7YX0sICR7Y30pYDtcclxuICBpZiAoIWlzQnJvYWRjYXN0KSB7XHJcbiAgICBhc3NpZ25tZW50ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KFxyXG4gICAgICAnZ2xvYmFsX2lkeCcsXHJcbiAgICAgIGV4cHJlc3Npb24oYS5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLCBiLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksIGMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSksXHJcbiAgICApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCBzaW5nbGVBc3NpZ25tZW50ID0gKHJlc1N0cjogc3RyaW5nLCB4OiBudW1iZXIsIHR5cGVDYXN0ID0gJycpID0+IHtcclxuICAgICAgY29uc3QgZXhwcmVzc2lvbkEgPSBgYV9kYXRhW2luZGV4X2Eke3h9XVtjb21wb25lbnRfYSR7eH1dYDtcclxuICAgICAgY29uc3QgZXhwcmVzc2lvbkIgPSBgYl9kYXRhW2luZGV4X2Ike3h9XVtjb21wb25lbnRfYiR7eH1dYDtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICAgICAgY29uc3QgZXhwcmVzc2lvbkMgPSBgYm9vbChjX2RhdGFbaW5kZXhfYyR7eH1dICYgKDB4ZmZ1IDw8IChjb21wb25lbnRfYyR7eH0gKiA4KSkpYDtcclxuICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzJHt4fSA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHt4fXVgKX07XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYSR7eH0gPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Ike3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcclxuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHt4fSA9ICR7Yy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3h9YCwgb3V0cHV0KX07XHJcbiAgICAgICAgICAgIGxldCBpbmRleF9hJHt4fSA9IG9mZnNldF9hJHt4fSAvIDR1O1xyXG4gICAgICAgICAgICBsZXQgaW5kZXhfYiR7eH0gPSBvZmZzZXRfYiR7eH0gLyA0dTtcclxuICAgICAgICAgICAgbGV0IGluZGV4X2Mke3h9ID0gb2Zmc2V0X2Mke3h9IC8gNHU7XHJcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYSR7eH0gPSBvZmZzZXRfYSR7eH0gJSA0dTtcclxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9iJHt4fSA9IG9mZnNldF9iJHt4fSAlIDR1O1xyXG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Mke3h9ID0gb2Zmc2V0X2Mke3h9ICUgNHU7XHJcbiAgICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7ZXhwcmVzc2lvbihleHByZXNzaW9uQSwgZXhwcmVzc2lvbkIsIGV4cHJlc3Npb25DKX0pO1xyXG4gICAgICAgICAgYDtcclxuICAgIH07XHJcbiAgICBpZiAodHlwZU91dHB1dCA9PT0gRGF0YVR5cGUuYm9vbCkge1xyXG4gICAgICBhc3NpZ25tZW50ID0gYFxyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAxLCAndTMyJyl9XHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDIsICd1MzInKX1cclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxyXG4gICAgICAgICAgICBvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXNzaWdubWVudCA9IGBcclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDApfVxyXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dF9kYXRhW2dsb2JhbF9pZHhdJywgMSl9XHJcbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0nLCAyKX1cclxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDMpfVxyXG4gICAgICAgICAgYDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBgXHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGMsIGEsIGIsIG91dHB1dCl9XHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XHJcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cclxuICAgICAgICAke2Fzc2lnbm1lbnR9XHJcbiAgICAgIH1gO1xyXG59O1xyXG5cclxuY29uc3QgY3JlYXRlV2hlcmVPcFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xyXG4gIGNvbnN0IGRpbXNBID0gaW5wdXRzWzFdLmRpbXM7XHJcbiAgY29uc3QgZGltc0IgPSBpbnB1dHNbMl0uZGltcztcclxuICBjb25zdCBkaW1zQyA9IGlucHV0c1swXS5kaW1zO1xyXG4gIGNvbnN0IG91dHB1dERhdGFUeXBlID0gaW5wdXRzWzFdLmRhdGFUeXBlO1xyXG5cclxuICBjb25zdCBpc0Jyb2FkY2FzdCA9ICEoU2hhcGVVdGlsLmFyZUVxdWFsKGRpbXNBLCBkaW1zQikgJiYgU2hhcGVVdGlsLmFyZUVxdWFsKGRpbXNCLCBkaW1zQykpO1xyXG4gIGxldCBvdXRwdXRTaGFwZSA9IGRpbXNBO1xyXG4gIGxldCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoZGltc0EpO1xyXG4gIC8vIFRPRE86IGRlYWwgd2l0aCB6ZXJvLXNpemVkIHRlbnNvcnMgKGVnLiBkaW1zPVsxLDBdKVxyXG5cclxuICBpZiAoaXNCcm9hZGNhc3QpIHtcclxuICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGRpbXNBLCBkaW1zQiwgZmFsc2UpISwgZGltc0MsIGZhbHNlKTtcclxuICAgIGlmICghY2FsY3VsYXRlZFNoYXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XHJcbiAgICB9XHJcbiAgICBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZWRTaGFwZTtcclxuICAgIG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCB2ZWNTaXplID0gTWF0aC5jZWlsKG91dHB1dFNpemUgLyA0KTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWU6ICdXaGVyZScsXHJcbiAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnLCAncmFuayddIH0sXHJcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XHJcbiAgICAgIGNyZWF0ZVdoZXJlT3BQcm9ncmFtU2hhZGVyKHNoYWRlckhlbHBlciwgaW5wdXRzLCBvdXRwdXRTaGFwZSwgaXNCcm9hZGNhc3QsIG91dHB1dERhdGFUeXBlKSxcclxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XHJcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXHJcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogdmVjIHNpemUgKi8pIH0sXHJcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xyXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB2ZWNTaXplIH0sXHJcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoZGltc0MsIGRpbXNBLCBkaW1zQiwgb3V0cHV0U2hhcGUpLFxyXG4gICAgICBdLFxyXG4gICAgfSksXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB3aGVyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xyXG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVXaGVyZU9wUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgeyBhcmdNYXgsIGFyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvYXJnbWlubWF4JztcclxuaW1wb3J0IHsgYXR0ZW50aW9uIH0gZnJvbSAnLi9vcHMvYXR0ZW50aW9uJztcclxuaW1wb3J0IHsgYmF0Y2hOb3JtIH0gZnJvbSAnLi9vcHMvYmF0Y2gtbm9ybSc7XHJcbmltcG9ydCB7IGJpYXNBZGQgfSBmcm9tICcuL29wcy9iaWFzLWFkZCc7XHJcbmltcG9ydCB7IGJpYXNTcGxpdEdlbHUgfSBmcm9tICcuL29wcy9iaWFzLXNwbGl0LWdlbHUnO1xyXG5pbXBvcnQgKiBhcyBiaW5hcnlPcHMgZnJvbSAnLi9vcHMvYmluYXJ5LW9wJztcclxuaW1wb3J0IHsgY29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9jb25jYXQnO1xyXG5pbXBvcnQgeyBjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY29udic7XHJcbmltcG9ydCB7IGNvbnZUcmFuc3Bvc2UsIHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9jb252LXRyYW5zcG9zZSc7XHJcbmltcG9ydCB7IGN1bXN1bSwgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY3Vtc3VtJztcclxuaW1wb3J0IHsgZGVwdGhUb1NwYWNlLCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9kZXB0aC10by1zcGFjZSc7XHJcbmltcG9ydCB7IGVpbnN1bSwgcGFyc2VFaW5zdW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZWluc3VtJztcclxuaW1wb3J0IHsgZXhwYW5kIH0gZnJvbSAnLi9vcHMvZXhwYW5kJztcclxuaW1wb3J0IHsgZmFzdEdlbHUgfSBmcm9tICcuL29wcy9mYXN0LWdlbHUnO1xyXG5pbXBvcnQgeyBnYXRoZXIsIHBhcnNlR2F0aGVyQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlcic7XHJcbmltcG9ydCB7IGdhdGhlck5ELCBwYXJzZUdhdGhlck5EQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlci1uZCc7XHJcbmltcG9ydCB7IGdhdGhlckJsb2NrUXVhbnRpemVkLCBwYXJzZUdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlci1ibG9jay1xdWFudGl6ZWQnO1xyXG5pbXBvcnQgeyBnYXRoZXJFbGVtZW50cywgcGFyc2VHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9nYXRoZXItZWxlbWVudHMnO1xyXG5pbXBvcnQgeyBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2VtbSc7XHJcbmltcG9ydCB7IGdyaWRTYW1wbGUsIHBhcnNlR3JpZFNhbXBsZUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9ncmlkLXNhbXBsZSc7XHJcbmltcG9ydCB7IGdyb3VwUXVlcnlBdHRlbnRpb24gfSBmcm9tICcuL29wcy9ncm91cC1xdWVyeS1hdHRlbnRpb24nO1xyXG5pbXBvcnQgeyBpbnN0YW5jZU5vcm0gfSBmcm9tICcuL29wcy9pbnN0YW5jZS1ub3JtJztcclxuaW1wb3J0IHsgbGF5ZXJOb3JtIH0gZnJvbSAnLi9vcHMvbGF5ZXItbm9ybSc7XHJcbmltcG9ydCB7IG1hdE11bCB9IGZyb20gJy4vb3BzL21hdG11bCc7XHJcbmltcG9ydCB7IG1hdE11bE5CaXRzLCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL21hdG11bG5iaXRzJztcclxuaW1wb3J0IHsgbXVsdGlIZWFkQXR0ZW50aW9uLCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9tdWx0aWhlYWQtYXR0ZW50aW9uJztcclxuaW1wb3J0IHsgcGFkIH0gZnJvbSAnLi9vcHMvcGFkJztcclxuaW1wb3J0ICogYXMgcG9vbCBmcm9tICcuL29wcy9wb29sJztcclxuaW1wb3J0IHsgZGVxdWFudGl6ZUxpbmVhciwgcGFyc2VEZXF1YW50aXplTGluZWFyQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL3F1YW50aXplLWxpbmVhcic7XHJcbmltcG9ydCB7IHJhbmdlIH0gZnJvbSAnLi9vcHMvcmFuZ2UnO1xyXG5pbXBvcnQgeyBzY2F0dGVyTkQsIHBhcnNlU2NhdHRlck5EQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL3NjYXR0ZXItbmQnO1xyXG5pbXBvcnQge1xyXG4gIHJlZHVjZUwxLFxyXG4gIHJlZHVjZUwyLFxyXG4gIHJlZHVjZUxvZ1N1bSxcclxuICByZWR1Y2VMb2dTdW1FeHAsXHJcbiAgcmVkdWNlTWF4LFxyXG4gIHJlZHVjZU1lYW4sXHJcbiAgcmVkdWNlTWluLFxyXG4gIHJlZHVjZVByb2QsXHJcbiAgcmVkdWNlU3VtLFxyXG4gIHJlZHVjZVN1bVNxdWFyZSxcclxufSBmcm9tICcuL29wcy9yZWR1Y2UnO1xyXG5pbXBvcnQgeyBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXMsIHJlc2l6ZSB9IGZyb20gJy4vb3BzL3Jlc2l6ZSc7XHJcbmltcG9ydCB7IHJvdGFyeUVtYmVkZGluZyB9IGZyb20gJy4vb3BzL3JvdGFyeS1lbWJlZGRpbmcnO1xyXG5pbXBvcnQgeyBza2lwTGF5ZXJOb3JtIH0gZnJvbSAnLi9vcHMvc2tpcC1sYXllci1ub3JtJztcclxuaW1wb3J0IHsgcGFyc2VTbGljZUF0dHJpYnV0ZXMsIHNsaWNlIH0gZnJvbSAnLi9vcHMvc2xpY2UnO1xyXG5pbXBvcnQgeyBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzLCBzb2Z0bWF4IH0gZnJvbSAnLi9vcHMvc29mdG1heCc7XHJcbmltcG9ydCB7IHBhcnNlU3BsaXRBdHRyaWJ1dGVzLCBzcGxpdCB9IGZyb20gJy4vb3BzL3NwbGl0JztcclxuaW1wb3J0IHsgdGlsZSB9IGZyb20gJy4vb3BzL3RpbGUnO1xyXG5pbXBvcnQgeyBwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXMsIHRyYW5zcG9zZSB9IGZyb20gJy4vb3BzL3RyYW5zcG9zZSc7XHJcbmltcG9ydCAqIGFzIHVuYXJ5T3BzIGZyb20gJy4vb3BzL3VuYXJ5LW9wJztcclxuaW1wb3J0IHsgd2hlcmUgfSBmcm9tICcuL29wcy93aGVyZSc7XHJcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5leHBvcnQgdHlwZSBSdW5GdW5jdGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlPzogdW5rbm93bikgPT4gdm9pZDtcclxuZXhwb3J0IHR5cGUgUGFyc2VBdHRyaWJ1dGVGdW5jdGlvbiA9IChhdHRyaWJ1dGVSYXc6IHVua25vd24pID0+IHVua25vd247XHJcbmV4cG9ydCB0eXBlIE9wZXJhdG9ySW1wbGVtZW50YXRpb24gPSBbUnVuRnVuY3Rpb25dIHwgW1J1bkZ1bmN0aW9uLCBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uXTtcclxuXHJcbmV4cG9ydCBjb25zdCBXRUJHUFVfT1BfUkVTT0xWRV9SVUxFUzogTWFwPHN0cmluZywgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbj4gPSBuZXcgTWFwKFtcclxuICBbJ0FicycsIFt1bmFyeU9wcy5hYnNdXSxcclxuICBbJ0Fjb3MnLCBbdW5hcnlPcHMuYWNvc11dLFxyXG4gIFsnQWNvc2gnLCBbdW5hcnlPcHMuYWNvc2hdXSxcclxuICBbJ0FkZCcsIFtiaW5hcnlPcHMuYWRkXV0sXHJcbiAgWydBcmdNYXgnLCBbYXJnTWF4LCBwYXJzZUFyZ01pbk1heEF0dHJpYnV0ZXNdXSxcclxuICBbJ0FyZ01pbicsIFthcmdNaW4sIHBhcnNlQXJnTWluTWF4QXR0cmlidXRlc11dLFxyXG4gIFsnQXNpbicsIFt1bmFyeU9wcy5hc2luXV0sXHJcbiAgWydBc2luaCcsIFt1bmFyeU9wcy5hc2luaF1dLFxyXG4gIFsnQXRhbicsIFt1bmFyeU9wcy5hdGFuXV0sXHJcbiAgWydBdGFuaCcsIFt1bmFyeU9wcy5hdGFuaF1dLFxyXG4gIFsnQXR0ZW50aW9uJywgW2F0dGVudGlvbl1dLFxyXG4gIC8vIFRPRE86IHN1cHBvcnQgbmV3IGF0dHJpYnV0ZXMgZm9yIEF2ZXJhZ2VQb29sLTEwXHJcbiAgWydBdmVyYWdlUG9vbCcsIFtwb29sLmF2ZXJhZ2VQb29sLCBwb29sLnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXV0sXHJcbiAgWydCYXRjaE5vcm1hbGl6YXRpb24nLCBbYmF0Y2hOb3JtXV0sXHJcbiAgWydCaWFzQWRkJywgW2JpYXNBZGRdXSxcclxuICBbJ0JpYXNTcGxpdEdlbHUnLCBbYmlhc1NwbGl0R2VsdV1dLFxyXG4gIFsnQ2FzdCcsIFt1bmFyeU9wcy5jYXN0LCB1bmFyeU9wcy5wYXJzZUNhc3RBdHRyaWJ1dGVzXV0sXHJcbiAgWydDZWlsJywgW3VuYXJ5T3BzLmNlaWxdXSxcclxuICBbJ0NsaXAnLCBbdW5hcnlPcHMuY2xpcF1dLFxyXG4gIFsnQ29uY2F0JywgW2NvbmNhdCwgcGFyc2VDb25jYXRBdHRyaWJ1dGVzXV0sXHJcbiAgWydDb252JywgW2NvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXNdXSxcclxuICBbJ0NvbnZUcmFuc3Bvc2UnLCBbY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlc11dLFxyXG4gIFsnQ29zJywgW3VuYXJ5T3BzLmNvc11dLFxyXG4gIFsnQ29zaCcsIFt1bmFyeU9wcy5jb3NoXV0sXHJcbiAgWydDdW1TdW0nLCBbY3Vtc3VtLCBwYXJzZUN1bVN1bUF0dHJpYnV0ZXNdXSxcclxuICBbJ0RlcHRoVG9TcGFjZScsIFtkZXB0aFRvU3BhY2UsIHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc11dLFxyXG4gIFsnRGVxdWFudGl6ZUxpbmVhcicsIFtkZXF1YW50aXplTGluZWFyLCBwYXJzZURlcXVhbnRpemVMaW5lYXJBdHRyaWJ1dGVzXV0sXHJcbiAgWydEaXYnLCBbYmluYXJ5T3BzLmRpdl1dLFxyXG4gIFsnRWluc3VtJywgW2VpbnN1bSwgcGFyc2VFaW5zdW1BdHRyaWJ1dGVzXV0sXHJcbiAgWydFbHUnLCBbdW5hcnlPcHMuZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxyXG4gIFsnRXF1YWwnLCBbYmluYXJ5T3BzLmVxdWFsXV0sXHJcbiAgWydFcmYnLCBbdW5hcnlPcHMuZXJmXV0sXHJcbiAgWydFeHAnLCBbdW5hcnlPcHMuZXhwXV0sXHJcbiAgWydFeHBhbmQnLCBbZXhwYW5kXV0sXHJcbiAgWydGYXN0R2VsdScsIFtmYXN0R2VsdV1dLFxyXG4gIFsnRmxvb3InLCBbdW5hcnlPcHMuZmxvb3JdXSxcclxuICBbJ0Z1c2VkQ29udicsIFtjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzXV0sXHJcbiAgWydHYXRoZXInLCBbZ2F0aGVyLCBwYXJzZUdhdGhlckF0dHJpYnV0ZXNdXSxcclxuICBbJ0dhdGhlckVsZW1lbnRzJywgW2dhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlc11dLFxyXG4gIFsnR2F0aGVyQmxvY2tRdWFudGl6ZWQnLCBbZ2F0aGVyQmxvY2tRdWFudGl6ZWQsIHBhcnNlR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzXV0sXHJcbiAgWydHYXRoZXJORCcsIFtnYXRoZXJORCwgcGFyc2VHYXRoZXJOREF0dHJpYnV0ZXNdXSxcclxuICBbJ0dlbHUnLCBbdW5hcnlPcHMuZ2VsdV1dLFxyXG4gIFsnR2VtbScsIFtnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzXV0sXHJcbiAgWydHbG9iYWxBdmVyYWdlUG9vbCcsIFtwb29sLmdsb2JhbEF2ZXJhZ2VQb29sLCBwb29sLnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXV0sXHJcbiAgWydHbG9iYWxNYXhQb29sJywgW3Bvb2wuZ2xvYmFsTWF4UG9vbCwgcG9vbC5wYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzXV0sXHJcbiAgWydHcmVhdGVyJywgW2JpbmFyeU9wcy5ncmVhdGVyXV0sXHJcbiAgWydHcmVhdGVyT3JFcXVhbCcsIFtiaW5hcnlPcHMuZ3JlYXRlck9yRXF1YWxdXSxcclxuICBbJ0dyaWRTYW1wbGUnLCBbZ3JpZFNhbXBsZSwgcGFyc2VHcmlkU2FtcGxlQXR0cmlidXRlc11dLFxyXG4gIFsnR3JvdXBRdWVyeUF0dGVudGlvbicsIFtncm91cFF1ZXJ5QXR0ZW50aW9uXV0sXHJcbiAgWydIYXJkU2lnbW9pZCcsIFt1bmFyeU9wcy5oYXJkU2lnbW9pZCwgdW5hcnlPcHMucGFyc2VIYXJkU2lnbW9pZEF0dHJpYnV0ZXNdXSxcclxuICBbJ0luc3RhbmNlTm9ybWFsaXphdGlvbicsIFtpbnN0YW5jZU5vcm1dXSxcclxuICBbJ0xheWVyTm9ybWFsaXphdGlvbicsIFtsYXllck5vcm1dXSxcclxuICBbJ0xlYWt5UmVsdScsIFt1bmFyeU9wcy5sZWFreVJlbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXHJcbiAgWydMZXNzJywgW2JpbmFyeU9wcy5sZXNzXV0sXHJcbiAgWydMZXNzT3JFcXVhbCcsIFtiaW5hcnlPcHMubGVzc09yRXF1YWxdXSxcclxuICBbJ0xvZycsIFt1bmFyeU9wcy5sb2ddXSxcclxuICBbJ01hdE11bCcsIFttYXRNdWxdXSxcclxuICBbJ01hdE11bE5CaXRzJywgW21hdE11bE5CaXRzLCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlc11dLFxyXG4gIC8vIFRPRE86IHN1cHBvcnQgbmV3IGF0dHJpYnV0ZXMgZm9yIE1heFBvb2wtOCBhbmQgTWF4UG9vbC0xMFxyXG4gIFsnTWF4UG9vbCcsIFtwb29sLm1heFBvb2wsIHBvb2wucGFyc2VNYXhQb29sQXR0cmlidXRlc11dLFxyXG4gIFsnTXVsJywgW2JpbmFyeU9wcy5tdWxdXSxcclxuICBbJ011bHRpSGVhZEF0dGVudGlvbicsIFttdWx0aUhlYWRBdHRlbnRpb24sIHBhcnNlTXVsdGlIZWFkQXR0ZW50aW9uQXR0cmlidXRlc11dLFxyXG4gIFsnTmVnJywgW3VuYXJ5T3BzLm5lZ11dLFxyXG4gIFsnTm90JywgW3VuYXJ5T3BzLm5vdF1dLFxyXG4gIFsnUGFkJywgW3BhZF1dLFxyXG4gIFsnUG93JywgW2JpbmFyeU9wcy5wb3ddXSxcclxuICBbJ1F1aWNrR2VsdScsIFt1bmFyeU9wcy5xdWlja2dlbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXHJcbiAgWydSYW5nZScsIFtyYW5nZV1dLFxyXG4gIFsnUmVjaXByb2NhbCcsIFt1bmFyeU9wcy5yZWNpcHJvY2FsXV0sXHJcbiAgWydSZWR1Y2VNaW4nLCBbcmVkdWNlTWluXV0sXHJcbiAgWydSZWR1Y2VNZWFuJywgW3JlZHVjZU1lYW5dXSxcclxuICBbJ1JlZHVjZU1heCcsIFtyZWR1Y2VNYXhdXSxcclxuICBbJ1JlZHVjZVN1bScsIFtyZWR1Y2VTdW1dXSxcclxuICBbJ1JlZHVjZVByb2QnLCBbcmVkdWNlUHJvZF1dLFxyXG4gIFsnUmVkdWNlTDEnLCBbcmVkdWNlTDFdXSxcclxuICBbJ1JlZHVjZUwyJywgW3JlZHVjZUwyXV0sXHJcbiAgWydSZWR1Y2VMb2dTdW0nLCBbcmVkdWNlTG9nU3VtXV0sXHJcbiAgWydSZWR1Y2VMb2dTdW1FeHAnLCBbcmVkdWNlTG9nU3VtRXhwXV0sXHJcbiAgWydSZWR1Y2VTdW1TcXVhcmUnLCBbcmVkdWNlU3VtU3F1YXJlXV0sXHJcbiAgWydSZWx1JywgW3VuYXJ5T3BzLnJlbHVdXSxcclxuICBbJ1Jlc2l6ZScsIFtyZXNpemUsIHBhcnNlUmVzaXplQXR0cmlidXRlc11dLFxyXG4gIFsnUm90YXJ5RW1iZWRkaW5nJywgW3JvdGFyeUVtYmVkZGluZ11dLFxyXG4gIFsnU2NhdHRlck5EJywgW3NjYXR0ZXJORCwgcGFyc2VTY2F0dGVyTkRBdHRyaWJ1dGVzXV0sXHJcbiAgWydTaWdtb2lkJywgW3VuYXJ5T3BzLnNpZ21vaWRdXSxcclxuICBbJ1NpbicsIFt1bmFyeU9wcy5zaW5dXSxcclxuICBbJ1NpbmgnLCBbdW5hcnlPcHMuc2luaF1dLFxyXG4gIFsnU2xpY2UnLCBbc2xpY2UsIHBhcnNlU2xpY2VBdHRyaWJ1dGVzXV0sXHJcbiAgWydTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJywgW3NraXBMYXllck5vcm1dXSxcclxuICBbJ1NwbGl0JywgW3NwbGl0LCBwYXJzZVNwbGl0QXR0cmlidXRlc11dLFxyXG4gIFsnU3FydCcsIFt1bmFyeU9wcy5zcXJ0XV0sXHJcbiAgWydTb2Z0bWF4JywgW3NvZnRtYXgsIHBhcnNlU29mdG1heEF0dHJpYnV0ZXNdXSxcclxuICBbJ1N1YicsIFtiaW5hcnlPcHMuc3ViXV0sXHJcbiAgWydUYW4nLCBbdW5hcnlPcHMudGFuXV0sXHJcbiAgWydUYW5oJywgW3VuYXJ5T3BzLnRhbmhdXSxcclxuICBbJ1RocmVzaG9sZGVkUmVsdScsIFt1bmFyeU9wcy50aHJlc2hvbGRlZFJlbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXHJcbiAgWydUaWxlJywgW3RpbGVdXSxcclxuICBbJ1RyYW5zcG9zZScsIFt0cmFuc3Bvc2UsIHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc11dLFxyXG4gIFsnV2hlcmUnLCBbd2hlcmVdXSxcclxuXSk7XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkQgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgV2ViR3B1QmFja2VuZCB9IGZyb20gJy4uL2JhY2tlbmQtd2ViZ3B1JztcclxuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vbG9nJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVNoYWRlckhlbHBlciB9IGZyb20gJy4vb3BzL2NvbW1vbic7XHJcbmltcG9ydCB7IEFydGlmYWN0LCBHcHVEYXRhLCBQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIFByb2dyYW1NYW5hZ2VyIGlzIHRoZSBtYWluIGNsYXNzIGJlaGluZCBydW5uaW5nIGNvbXB1dGF0aW9uc1xyXG4gKiBJdCBidWlsZHMgUHJvZ3JhbUluZm8ncyBpbnRvIEFydGlmYWN0c1xyXG4gKiBJdCBjb21waWxlcyBnaXZlbiBQcm9ncmFtSW5mbydzIGludG8gV2ViR0wgUHJvcmFtcyAoY2FjaGVkIGFzIEFydGlmYWN0cylcclxuICogVXNlcyB0aGUgYXJ0aWZhY3QgdG8gcnVuIHRoZSBjb21wdXRhdGlvbiBieSBjYWxsaW5nIERyYXcgb25cclxuICogdGhlIFdlYkdMIGRyYXdpbmcgYnVmZmVyXHJcbiAqIFByb2dyYW1NYW5hZ2VyIGF1dG9tYXRpY2FsbHkgbWFwcyAoYmluZHMpIGlucHV0IHZhcmlhYmxlcyB0byB0aGVpclxyXG4gKiBjb3JyZXNwb25kaW5nIExvY2F0aW9uJ3MgaW4gdGhlIGJpbmFyeSBwcm9ncmFtXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUHJvZ3JhbU1hbmFnZXIge1xyXG4gIHJlcG86IE1hcDx1bmtub3duLCBBcnRpZmFjdD47IC8vIHRoaXMgc2hvdWxkIGJlIHBlci1zZXNzaW9uIG9iamVjdFxyXG4gIGF0dHJpYnV0ZXNCb3VuZDogYm9vbGVhbjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kKSB7XHJcbiAgICB0aGlzLnJlcG8gPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmF0dHJpYnV0ZXNCb3VuZCA9IGZhbHNlO1xyXG4gIH1cclxuICBnZXRBcnRpZmFjdChrZXk6IHVua25vd24pOiBBcnRpZmFjdCB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXBvLmdldChrZXkpO1xyXG4gIH1cclxuICBzZXRBcnRpZmFjdChrZXk6IHVua25vd24sIGFydGlmYWN0OiBBcnRpZmFjdCk6IHZvaWQge1xyXG4gICAgdGhpcy5yZXBvLnNldChrZXksIGFydGlmYWN0KTtcclxuICB9XHJcbiAgcnVuKFxyXG4gICAgYnVpbGRBcnRpZmFjdDogQXJ0aWZhY3QsXHJcbiAgICBpbnB1dHM6IEdwdURhdGFbXSxcclxuICAgIG91dHB1dHM6IEdwdURhdGFbXSxcclxuICAgIGRpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcclxuICAgIHVuaWZvcm1CdWZmZXJCaW5kaW5nOiBHUFVCaW5kaW5nUmVzb3VyY2UgfCB1bmRlZmluZWQsXHJcbiAgKTogdm9pZCB7XHJcbiAgICBUUkFDRV9GVU5DX0JFR0lOKGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSk7XHJcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmJhY2tlbmQuZGV2aWNlO1xyXG4gICAgY29uc3QgY29tcHV0ZVBhc3NFbmNvZGVyID0gdGhpcy5iYWNrZW5kLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO1xyXG4gICAgdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyKTtcclxuICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XHJcbiAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCByZXNvdXJjZTogeyBidWZmZXI6IGlucHV0LmJ1ZmZlciB9IH0pO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBvdXRwdXQgb2Ygb3V0cHV0cykge1xyXG4gICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBlbnRyaWVzLmxlbmd0aCwgcmVzb3VyY2U6IHsgYnVmZmVyOiBvdXRwdXQuYnVmZmVyIH0gfSk7XHJcbiAgICB9XHJcbiAgICBpZiAodW5pZm9ybUJ1ZmZlckJpbmRpbmcpIHtcclxuICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB1bmlmb3JtQnVmZmVyQmluZGluZyB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGJpbmRHcm91cCA9IGRldmljZS5jcmVhdGVCaW5kR3JvdXAoe1xyXG4gICAgICBsYXlvdXQ6IGJ1aWxkQXJ0aWZhY3QuY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxcclxuICAgICAgZW50cmllcyxcclxuICAgICAgbGFiZWw6IGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cyA9PT0gJ2NhcHR1cmluZycpIHtcclxuICAgICAgY29uc3QgY29tbWFuZEluZm8gPSB7XHJcbiAgICAgICAga2VybmVsSWQ6IHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQhLFxyXG4gICAgICAgIGNvbXB1dGVQaXBlbGluZTogYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUsXHJcbiAgICAgICAgYmluZEdyb3VwLFxyXG4gICAgICAgIGRpc3BhdGNoR3JvdXAsXHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IHNlc3Npb25Db21tYW5kTGlzdCA9IHRoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCEpO1xyXG4gICAgICBzZXNzaW9uQ29tbWFuZExpc3QhLnB1c2goY29tbWFuZEluZm8pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShidWlsZEFydGlmYWN0LmNvbXB1dGVQaXBlbGluZSk7XHJcbiAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGJpbmRHcm91cCk7XHJcbiAgICBjb21wdXRlUGFzc0VuY29kZXIuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLmRpc3BhdGNoR3JvdXApO1xyXG4gICAgdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSk7XHJcbiAgICB0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKys7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICB0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlciB8fFxyXG4gICAgICB0aGlzLmJhY2tlbmQucXVlcnlUeXBlID09PSAnYXQtcGFzc2VzJ1xyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPj0gdGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyKSB7XHJcbiAgICAgIHRoaXMuYmFja2VuZC5mbHVzaCgpO1xyXG4gICAgfVxyXG4gICAgVFJBQ0VfRlVOQ19FTkQoYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lKTtcclxuICB9XHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIC8vIHRoaXMucmVwby5mb3JFYWNoKGEgPT4gdGhpcy5nbENvbnRleHQuZGVsZXRlUHJvZ3JhbShhLnByb2dyYW0pKTtcclxuICB9XHJcbiAgYnVpbGQocHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IEFydGlmYWN0IHtcclxuICAgIFRSQUNFX0ZVTkNfQkVHSU4ocHJvZ3JhbUluZm8ubmFtZSk7XHJcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmJhY2tlbmQuZGV2aWNlO1xyXG4gICAgY29uc3QgZW5hYmxlRGlyZWN0aXZlczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICAvLyBFbmFibGUgV0dTTCBleHRlbnNpb25zIGJhc2VkIG9uIGF2YWlsYWJsZSBXZWJHUFUgZmVhdHVyZXNcclxuICAgIGNvbnN0IGV4dGVuc2lvbnNJbmZvOiBBcnJheTx7IGZlYXR1cmU6IEdQVUZlYXR1cmVOYW1lOyBleHRlbnNpb246IHN0cmluZyB9PiA9IFtcclxuICAgICAgeyBmZWF0dXJlOiAnc2hhZGVyLWYxNicsIGV4dGVuc2lvbjogJ2YxNicgfSxcclxuICAgICAgeyBmZWF0dXJlOiAnc3ViZ3JvdXBzJyBhcyBHUFVGZWF0dXJlTmFtZSwgZXh0ZW5zaW9uOiAnc3ViZ3JvdXBzJyB9LFxyXG4gICAgXTtcclxuICAgIGV4dGVuc2lvbnNJbmZvLmZvckVhY2goKGluZm8pID0+IHtcclxuICAgICAgaWYgKGRldmljZS5mZWF0dXJlcy5oYXMoaW5mby5mZWF0dXJlKSkge1xyXG4gICAgICAgIGVuYWJsZURpcmVjdGl2ZXMucHVzaChgZW5hYmxlICR7aW5mby5leHRlbnNpb259O2ApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBzaGFkZXJIZWxwZXIgPSBjcmVhdGVTaGFkZXJIZWxwZXIobm9ybWFsaXplZERpc3BhdGNoR3JvdXBTaXplLCB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cyk7XHJcbiAgICBjb25zdCB1c2VyQ29kZSA9IHByb2dyYW1JbmZvLmdldFNoYWRlclNvdXJjZShzaGFkZXJIZWxwZXIpO1xyXG4gICAgY29uc3QgY29kZSA9IGAke2VuYWJsZURpcmVjdGl2ZXMuam9pbignXFxuJyl9XFxuJHtzaGFkZXJIZWxwZXIuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cXG4ke3VzZXJDb2RlfWA7XHJcbiAgICBjb25zdCBzaGFkZXJNb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKHsgY29kZSwgbGFiZWw6IHByb2dyYW1JbmZvLm5hbWUgfSk7XHJcbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gJHtwcm9ncmFtSW5mby5uYW1lfSBzaGFkZXIgY29kZTogJHtjb2RlfWApO1xyXG5cclxuICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe1xyXG4gICAgICBjb21wdXRlOiB7IG1vZHVsZTogc2hhZGVyTW9kdWxlLCBlbnRyeVBvaW50OiAnbWFpbicgfSxcclxuICAgICAgbGF5b3V0OiAnYXV0bycsXHJcbiAgICAgIGxhYmVsOiBwcm9ncmFtSW5mby5uYW1lLFxyXG4gICAgfSk7XHJcblxyXG4gICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbUluZm8ubmFtZSk7XHJcbiAgICByZXR1cm4geyBwcm9ncmFtSW5mbywgY29tcHV0ZVBpcGVsaW5lLCB1bmlmb3JtVmFyaWFibGVzSW5mbzogc2hhZGVySGVscGVyLnZhcmlhYmxlc0luZm8gfTtcclxuICB9XHJcblxyXG4gIG5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKFxyXG4gICAgZGlzcGF0Y2hHcm91cDogUmV0dXJuVHlwZTxQcm9ncmFtSW5mb1snZ2V0UnVuRGF0YSddPlsnZGlzcGF0Y2hHcm91cCddLFxyXG4gICk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XHJcbiAgICBjb25zdCB4ID0gdHlwZW9mIGRpc3BhdGNoR3JvdXAgPT09ICdudW1iZXInID8gZGlzcGF0Y2hHcm91cCA6IGRpc3BhdGNoR3JvdXAueDtcclxuICAgIGNvbnN0IHkgPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyAxIDogZGlzcGF0Y2hHcm91cC55IHx8IDE7XHJcbiAgICBjb25zdCB6ID0gdHlwZW9mIGRpc3BhdGNoR3JvdXAgPT09ICdudW1iZXInID8gMSA6IGRpc3BhdGNoR3JvdXAueiB8fCAxO1xyXG4gICAgY29uc3QgbGltaXRQZXJEaW1lbnNpb24gPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtcclxuICAgIGlmICh4IDw9IGxpbWl0UGVyRGltZW5zaW9uICYmIHkgPD0gbGltaXRQZXJEaW1lbnNpb24gJiYgeiA8PSBsaW1pdFBlckRpbWVuc2lvbikge1xyXG4gICAgICByZXR1cm4gW3gsIHksIHpdO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2l6ZSA9IHggKiB5ICogejtcclxuICAgIGxldCBkaXNwYXRjaEF2ZXJhZ2UgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KHNpemUpKTtcclxuICAgIGlmIChkaXNwYXRjaEF2ZXJhZ2UgPiBsaW1pdFBlckRpbWVuc2lvbikge1xyXG4gICAgICBkaXNwYXRjaEF2ZXJhZ2UgPSBNYXRoLmNlaWwoTWF0aC5jYnJ0KHNpemUpKTtcclxuICAgICAgaWYgKGRpc3BhdGNoQXZlcmFnZSA+IGxpbWl0UGVyRGltZW5zaW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFtkaXNwYXRjaEF2ZXJhZ2UsIGRpc3BhdGNoQXZlcmFnZSwgZGlzcGF0Y2hBdmVyYWdlXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBbZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2UsIDFdO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IEVudiwgVGVuc29yLCBUUkFDRSwgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkQgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgRGF0YVR5cGUsIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgY29uZmlndXJlTG9nZ2VyLCBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XHJcbmltcG9ydCB7IGNyZWF0ZVZpZXcsIFRlbnNvclZpZXcgfSBmcm9tICcuL3RlbnNvci12aWV3JztcclxuaW1wb3J0IHsgY3JlYXRlR3B1RGF0YU1hbmFnZXIsIGRvd25sb2FkR3B1RGF0YSwgR3B1RGF0YU1hbmFnZXIgfSBmcm9tICcuL3dlYmdwdS9ncHUtZGF0YS1tYW5hZ2VyJztcclxuaW1wb3J0IHsgUnVuRnVuY3Rpb24sIFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTIH0gZnJvbSAnLi93ZWJncHUvb3AtcmVzb2x2ZS1ydWxlcyc7XHJcbmltcG9ydCB7IFByb2dyYW1NYW5hZ2VyIH0gZnJvbSAnLi93ZWJncHUvcHJvZ3JhbS1tYW5hZ2VyJztcclxuaW1wb3J0IHtcclxuICBBZGFwdGVySW5mbyxcclxuICBDb21wdXRlQ29udGV4dCxcclxuICBHcHVBcmNoaXRlY3R1cmUsXHJcbiAgR3B1RGF0YSxcclxuICBHcHVWZW5kb3IsXHJcbiAgUHJvZ3JhbUluZm8sXHJcbiAgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksXHJcbiAgU2Vzc2lvblN0YXRlLFxyXG4gIFRpbWVzdGFtcFF1ZXJ5LFxyXG59IGZyb20gJy4vd2ViZ3B1L3R5cGVzJztcclxuXHJcbmludGVyZmFjZSBDb21tYW5kSW5mbyB7XHJcbiAgcmVhZG9ubHkga2VybmVsSWQ6IG51bWJlcjtcclxuICByZWFkb25seSBjb21wdXRlUGlwZWxpbmU6IEdQVUNvbXB1dGVQaXBlbGluZTtcclxuICByZWFkb25seSBiaW5kR3JvdXA6IEdQVUJpbmRHcm91cDtcclxuICByZWFkb25seSBkaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XHJcbn1cclxuXHJcbmludGVyZmFjZSBLZXJuZWxJbmZvIHtcclxuICByZWFkb25seSBrZXJuZWxUeXBlOiBzdHJpbmc7XHJcbiAgcmVhZG9ubHkga2VybmVsTmFtZTogc3RyaW5nO1xyXG4gIHJlYWRvbmx5IGtlcm5lbEVudHJ5OiBSdW5GdW5jdGlvbjtcclxuICByZWFkb25seSBhdHRyaWJ1dGVzOiBbKChhdHRyaWJ1dGU6IHVua25vd24pID0+IHVua25vd24pIHwgdW5kZWZpbmVkLCB1bmtub3duXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFBlbmRpbmdLZXJuZWxJbmZvIHtcclxuICByZWFkb25seSBrZXJuZWxJZDogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IHByb2dyYW1OYW1lOiBzdHJpbmc7XHJcbiAgcmVhZG9ubHkgaW5wdXRUZW5zb3JWaWV3czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xyXG4gIHJlYWRvbmx5IG91dHB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W107XHJcbn1cclxuXHJcbmNvbnN0IGdldFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5S2V5ID0gKFxyXG4gIGlucHV0VGVuc29yczogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGlucHV0RGVwZW5kZW5jaWVzOiByZWFkb25seSBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdLFxyXG4pOiBzdHJpbmcgPT4ge1xyXG4gIGlmIChpbnB1dERlcGVuZGVuY2llcy5sZW5ndGggIT09IGlucHV0VGVuc29ycy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke2lucHV0RGVwZW5kZW5jaWVzLmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtcclxuICAgICAgICBpbnB1dFRlbnNvcnMubGVuZ3RoXHJcbiAgICAgIH0uYCxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBpbnB1dEluZm9zOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRUZW5zb3JzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBjb25zdCB0eXBlID0gaW5wdXRUZW5zb3JzW2ldLmRhdGFUeXBlO1xyXG4gICAgc3dpdGNoIChpbnB1dERlcGVuZGVuY2llc1tpXSkge1xyXG4gICAgICBjYXNlICdub25lJzoge1xyXG4gICAgICAgIGlucHV0SW5mb3MucHVzaCgnJyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgY2FzZSAndHlwZSc6IHtcclxuICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX1gKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlICdyYW5rJzoge1xyXG4gICAgICAgIGNvbnN0IHJhbmsgPSBpbnB1dFRlbnNvcnNbaV0uZGltcy5sZW5ndGg7XHJcbiAgICAgICAgaW5wdXRJbmZvcy5wdXNoKGAke3R5cGV9OyR7cmFua31gKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjYXNlICdkaW1zJzoge1xyXG4gICAgICAgIGNvbnN0IGRpbXMgPSBpbnB1dFRlbnNvcnNbaV0uZGltcy5qb2luKCcsJyk7XHJcbiAgICAgICAgaW5wdXRJbmZvcy5wdXNoKGAke3R5cGV9OyR7ZGltc31gKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgaW5wdXQgZGVwZW5kZW5jeTogJHtpbnB1dERlcGVuZGVuY2llc1tpXX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBpbnB1dEluZm9zLmpvaW4oJ3wnKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBnZXQgYSB1bmlxdWUga2V5IHJlcHJlc2VudGluZyB0aGUgcHJvZ3JhbSBmcm9tIHRoZSBwcm9ncmFtIGluZm8sIGlucHV0IHNoYXBlcyBhbmQgdHlwZXMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIGEgdW5pcXVlIGtleSBpcyBhIHNob3J0ZXIgc3RyaW5nIHRoYW4gdGhlIHNoYWRlciBzb3VyY2UsIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdG8gaWRlbnRpZnkgYVxyXG4gKiBwcm9ncmFtLiBpZiB0aGUga2V5IGlzIHRoZSBzYW1lLCB0aGUgcHJvZ3JhbSBzaGFkZXIgc291cmNlIHNob3VsZCBiZSB0aGUgc2FtZSwgc28gd2UgY2FuIHJldXNlIHRoZSBwcm9ncmFtLlxyXG4gKlxyXG4gKi9cclxuY29uc3QgZ2V0UHJvZ3JhbUluZm9VbmlxdWVLZXkgPSAoXHJcbiAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLFxyXG4gIGlucHV0VGVuc29yczogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxyXG4gIGlzMURpbWVuc2lvbkRpc3BhdGNoOiBib29sZWFuLFxyXG4pOiBzdHJpbmcgPT4ge1xyXG4gIC8vIGZpbmFsIGtleSBmb3JtYXQ6XHJcbiAgLy8gPFBST0dSQU1fTkFNRT5bPFBST0dSQU1fQ1VTVE9NX0NBQ0hFX0hJTlQ+XTppczFEaW1lbnNpb25EaXNwYXRjaDo8SU5QVVRTX0lORk9fMD58PElOUFVUU19JTkZPXzE+fC4uLlxyXG4gIGxldCBrZXkgPSBwcm9ncmFtSW5mby5uYW1lO1xyXG4gIGlmIChwcm9ncmFtSW5mby5zaGFkZXJDYWNoZT8uaGludCkge1xyXG4gICAga2V5ICs9ICdbJyArIHByb2dyYW1JbmZvLnNoYWRlckNhY2hlLmhpbnQgKyAnXSc7XHJcbiAgfVxyXG4gIGtleSArPVxyXG4gICAgJzonICtcclxuICAgIGlzMURpbWVuc2lvbkRpc3BhdGNoICtcclxuICAgIGA6JHtnZXRQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeUtleShcclxuICAgICAgaW5wdXRUZW5zb3JzLFxyXG4gICAgICBwcm9ncmFtSW5mby5zaGFkZXJDYWNoZT8uaW5wdXREZXBlbmRlbmNpZXMgPz9cclxuICAgICAgICBuZXcgQXJyYXk8UHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3k+KGlucHV0VGVuc29ycy5sZW5ndGgpLmZpbGwoJ2RpbXMnKSxcclxuICAgICl9YDtcclxuICByZXR1cm4ga2V5O1xyXG59O1xyXG5cclxuY2xhc3MgQWRhcHRlckluZm9JbXBsIGltcGxlbWVudHMgQWRhcHRlckluZm8ge1xyXG4gIHJlYWRvbmx5IGFyY2hpdGVjdHVyZT86IHN0cmluZztcclxuICByZWFkb25seSB2ZW5kb3I/OiBzdHJpbmc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXJJbmZvOiBHUFVBZGFwdGVySW5mbykge1xyXG4gICAgaWYgKGFkYXB0ZXJJbmZvKSB7XHJcbiAgICAgIHRoaXMuYXJjaGl0ZWN0dXJlID0gYWRhcHRlckluZm8uYXJjaGl0ZWN0dXJlO1xyXG4gICAgICB0aGlzLnZlbmRvciA9IGFkYXB0ZXJJbmZvLnZlbmRvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlzQXJjaGl0ZWN0dXJlKGFyY2hpdGVjdHVyZTogR3B1QXJjaGl0ZWN0dXJlKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5hcmNoaXRlY3R1cmUgPT09IGFyY2hpdGVjdHVyZTtcclxuICB9XHJcblxyXG4gIGlzVmVuZG9yKHZlbmRvcjogR3B1VmVuZG9yKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy52ZW5kb3IgPT09IHZlbmRvcjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB0aGlzIGNsYXNzIGlzIGRlc2lnbmVkIHRvIHN0b3JlIHN0YXR1cyBhbmQgYmVpbmcgdXNlZCBhcyBhIHNpbmdsZXRvbiBmb3IgSlNFUC4gSXQgd2lsbCBiZSBwYXNzZWQgdG8ganNlcEluaXQoKSBhc1xyXG4gKiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNvIHRoYXQgaXQgaXMgc3RvcmVkIGZvciBmdXR1cmUgdXNlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdlYkdwdUJhY2tlbmQge1xyXG4gIGFkYXB0ZXJJbmZvOiBBZGFwdGVySW5mb0ltcGw7XHJcbiAgZGV2aWNlOiBHUFVEZXZpY2U7XHJcbiAgLyoqXHJcbiAgICogYW4gaW5zdGFuY2Ugb2YgR3B1RGF0YU1hbmFnZXIgdG8gbWFuYWdlIGEgR3B1RGF0YUlkIC0+IEdwdUJ1ZmZlciBtYXBwaW5nXHJcbiAgICovXHJcbiAgZ3B1RGF0YU1hbmFnZXI6IEdwdURhdGFNYW5hZ2VyO1xyXG4gIC8qKlxyXG4gICAqIGFuIGluc3RhbmNlIG9mIFByb2dyYW1NYW5hZ2VyIHRvIGJ1aWxkIGFuZCBydW4gV2ViR1BVIGNvbXB1dGUgc2hhZGVyIHByb2dyYW0sIGFuZCBtYW5hZ2UgYSBQcm9ncmFtS2V5IC0+IFByb2dyYW1cclxuICAgKiBhcnRpZmFjdHMgbWFwcGluZ1xyXG4gICAqL1xyXG4gIHByb2dyYW1NYW5hZ2VyOiBQcm9ncmFtTWFuYWdlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogcmVwcmVzZW50aW5nIHRoZSBzZXNzaW9uIElEIG9mIHdoaWNoIGlzIGN1cnJlbnRseSBiZWluZyBydW4uXHJcbiAgICogYG51bGxgIG1lYW5zIG5vIHNlc3Npb24gaXMgYmVpbmcgcnVuLlxyXG4gICAqIG9ubHkgdmFsaWQgd2hlbiBzZXNzaW9uLnJ1biBpcyBleGVjdXRlZC5cclxuICAgKi9cclxuICBjdXJyZW50U2Vzc2lvbklkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgLyoqXHJcbiAgICogcmVwcmVzZW50aW5nIHRoZSBrZXJuZWwgSUQgb2Ygd2hpY2ggaXMgY3VycmVudGx5IGJlaW5nIGNvbXB1dGVkIChDUFUgY29kZSBwZXJzcGVjdGl2ZSkuXHJcbiAgICogYG51bGxgIG1lYW5zIG5vIGtlcm5lbCBpcyBiZWluZyBjb21wdXRlZC5cclxuICAgKiBvbmx5IG9uZSBrZXJuZWwgY2FuIGJlIGNvbXB1dGVkIGF0IGEgbW9tZW50LlxyXG4gICAqL1xyXG4gIGN1cnJlbnRLZXJuZWxJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgLyoqXHJcbiAgICogYSBsaXN0IG9mIHRlbXBvcmFyeSBHUFUgZGF0YSBmb3IgdGhlIGN1cnJlbnQga2VybmVsLiBzaG91bGQgcmVsZWFzZSB3aGVuIHRoZSBrZXJuZWwgZG9uZSBjb21wdXRhdGlvbi5cclxuICAgKi9cclxuICBwcml2YXRlIHRlbXBvcmFyeURhdGE6IEdwdURhdGFbXTtcclxuICAvKipcclxuICAgKiBhIEtlcm5lbElEIC0+IGEgR1BVIGRhdGEgbGlzdCwgd2hpY2ggc3RvcmVzIHBlcnNpc3RlbnQgR1BVIGRhdGEgb3duZWQgYnkgdGhlIHNwZWNpZmljIGtlcm5lbC5cclxuICAgKi9cclxuICBwcml2YXRlIGtlcm5lbFBlcnNpc3RlbnREYXRhOiBNYXA8bnVtYmVyLCBHcHVEYXRhW10+O1xyXG4gIC8qKlxyXG4gICAqIGEgS2VybmVsSUQgLT4gYSBjdXN0b20gZGF0YSwgd2hpY2ggc3RvcmVzIGN1c3RvbSBkYXRhIG93bmVkIGJ5IHRoZSBzcGVjaWZpYyBrZXJuZWwuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBrZXJuZWxDdXN0b21EYXRhOiBNYXA8bnVtYmVyLCB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfT47XHJcbiAgLyoqXHJcbiAgICogZ2V0IHRoZSBjdXN0b20gZGF0YSBvZiB0aGUgY3VycmVudCBrZXJuZWxcclxuICAgKi9cclxuICBnZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0ge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudEtlcm5lbElkID09PSBudWxsKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbiknKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZGF0YSA9IHRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO1xyXG4gICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgIGRhdGEgPSB7fTtcclxuICAgICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICAvLyBLZXJuZWxJRCAtPiBrZXJuZWxJbmZvIG1hcHBpbmdcclxuICBrZXJuZWxzOiBNYXA8bnVtYmVyLCBLZXJuZWxJbmZvPjtcclxuICBwcml2YXRlIGNvbW1hbmRFbmNvZGVyOiBHUFVDb21tYW5kRW5jb2RlciB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgY29tcHV0ZVBhc3NFbmNvZGVyOiBHUFVDb21wdXRlUGFzc0VuY29kZXIgfCBudWxsID0gbnVsbDtcclxuICBtYXhEaXNwYXRjaE51bWJlciA9IDE2O1xyXG4gIHBlbmRpbmdEaXNwYXRjaE51bWJlciA9IDA7XHJcblxyXG4gIC8vIGluZm8gb2Yga2VybmVscyBwZW5kaW5nIHN1Ym1pc3Npb24gZm9yIGEgc2luZ2xlIGJhdGNoXHJcbiAgcHJpdmF0ZSBwZW5kaW5nS2VybmVsczogUGVuZGluZ0tlcm5lbEluZm9bXSA9IFtdO1xyXG4gIC8vIHF1ZXJ5UmVhZEJ1ZmZlciAtPiBwZW5kaW5nS2VybmVscyBtYXBwaW5nIGZvciBhbGwgdGhlIGJhdGNoZXNcclxuICBwcml2YXRlIHBlbmRpbmdRdWVyaWVzOiBNYXA8R1BVQnVmZmVyLCBQZW5kaW5nS2VybmVsSW5mb1tdPiA9IG5ldyBNYXAoKTtcclxuICBwcml2YXRlIHF1ZXJ5UmVzb2x2ZUJ1ZmZlcj86IEdQVUJ1ZmZlcjtcclxuICBwcml2YXRlIHF1ZXJ5U2V0PzogR1BVUXVlcnlTZXQ7XHJcbiAgcHJpdmF0ZSBxdWVyeVRpbWVCYXNlPzogYmlnaW50O1xyXG4gIHF1ZXJ5VHlwZTogVGltZXN0YW1wUXVlcnk7XHJcblxyXG4gIGVudjogRW52O1xyXG4gIHNlc3Npb25TdGF0dXM6IFNlc3Npb25TdGF0ZSA9ICdkZWZhdWx0JztcclxuICAvKipcclxuICAgKiBhIFNlc3Npb25JRCAtPiBDb21tYW5kSW5mb1tdIG1hcHBpbmcuIEl0J3MgdXNlZCB0byByZWNvcmQgYWxsIEdQVSBjb21tYW5kcyBmb3IgY29ycmVzcG9uZGluZyBzZXNzaW9uLlxyXG4gICAqL1xyXG4gIGNhcHR1cmVkQ29tbWFuZExpc3Q6IE1hcDxudW1iZXIsIENvbW1hbmRJbmZvW10+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAvKipcclxuICAgKiBhIFNlc3Npb25JRCAtPiBQZW5kaW5nS2VybmVsSW5mb1tdIG1hcHBpbmcgZm9yIHByb2ZpbGluZy5cclxuICAgKi9cclxuICBwcml2YXRlIGNhcHR1cmVkUGVuZGluZ0tlcm5lbHM6IE1hcDxudW1iZXIsIFBlbmRpbmdLZXJuZWxJbmZvW10+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAvKipcclxuICAgKiBhIFNlc3Npb25JRCAtPiBhIE1hcCBvZiAoSW5wdXRPdXRwdXRJbmRleCAtPiBbSUQsIEdQVUJ1ZmZlcl0pIG1hcHBpbmcuXHJcbiAgICovXHJcbiAgc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc6IE1hcDxudW1iZXIsIE1hcDxudW1iZXIsIFtudW1iZXIsIEdQVUJ1ZmZlcl0+PiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgYXN5bmMgaW5pdGlhbGl6ZShlbnY6IEVudiwgYWRhcHRlcjogR1BVQWRhcHRlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdGhpcy5lbnYgPSBlbnY7XHJcbiAgICBjb25zdCByZXF1aXJlZEZlYXR1cmVzOiBHUFVGZWF0dXJlTmFtZVtdID0gW107XHJcbiAgICBjb25zdCBkZXZpY2VEZXNjcmlwdG9yOiBHUFVEZXZpY2VEZXNjcmlwdG9yID0ge1xyXG4gICAgICByZXF1aXJlZExpbWl0czoge1xyXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplLFxyXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixcclxuICAgICAgICBtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6IGFkYXB0ZXIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxcclxuICAgICAgICBtYXhCdWZmZXJTaXplOiBhZGFwdGVyLmxpbWl0cy5tYXhCdWZmZXJTaXplLFxyXG4gICAgICAgIG1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cDogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLFxyXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLFxyXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZLFxyXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWjogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaLFxyXG4gICAgICB9LFxyXG4gICAgICByZXF1aXJlZEZlYXR1cmVzLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUcnkgcmVxdWlyaW5nIFdlYkdQVSBmZWF0dXJlc1xyXG4gICAgY29uc3QgcmVxdWlyZUZlYXR1cmVJZkF2YWlsYWJsZSA9IChmZWF0dXJlOiBHUFVGZWF0dXJlTmFtZSkgPT5cclxuICAgICAgYWRhcHRlci5mZWF0dXJlcy5oYXMoZmVhdHVyZSkgJiYgcmVxdWlyZWRGZWF0dXJlcy5wdXNoKGZlYXR1cmUpICYmIHRydWU7XHJcbiAgICAvLyBUcnkgY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzIGFuZCBmYWxsYmFjayB0byB0aW1lc3RhbXAtcXVlcnlcclxuICAgIGlmICghcmVxdWlyZUZlYXR1cmVJZkF2YWlsYWJsZSgnY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzJyBhcyBHUFVGZWF0dXJlTmFtZSkpIHtcclxuICAgICAgcmVxdWlyZUZlYXR1cmVJZkF2YWlsYWJsZSgndGltZXN0YW1wLXF1ZXJ5Jyk7XHJcbiAgICB9XHJcbiAgICByZXF1aXJlRmVhdHVyZUlmQXZhaWxhYmxlKCdzaGFkZXItZjE2Jyk7XHJcbiAgICAvLyBUcnkgc3ViZ3JvdXBzXHJcbiAgICByZXF1aXJlRmVhdHVyZUlmQXZhaWxhYmxlKCdzdWJncm91cHMnIGFzIEdQVUZlYXR1cmVOYW1lKTtcclxuXHJcbiAgICB0aGlzLmRldmljZSA9IGF3YWl0IGFkYXB0ZXIucmVxdWVzdERldmljZShkZXZpY2VEZXNjcmlwdG9yKTtcclxuICAgIHRoaXMuYWRhcHRlckluZm8gPSBuZXcgQWRhcHRlckluZm9JbXBsKGFkYXB0ZXIuaW5mbyB8fCAoYXdhaXQgYWRhcHRlci5yZXF1ZXN0QWRhcHRlckluZm8oKSkpO1xyXG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlciA9IGNyZWF0ZUdwdURhdGFNYW5hZ2VyKHRoaXMpO1xyXG4gICAgdGhpcy5wcm9ncmFtTWFuYWdlciA9IG5ldyBQcm9ncmFtTWFuYWdlcih0aGlzKTtcclxuICAgIHRoaXMua2VybmVscyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmtlcm5lbEN1c3RvbURhdGEgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgLy8gc2V0IHVwIGZsYWdzIGZvciBsb2dnZXJcclxuICAgIGNvbmZpZ3VyZUxvZ2dlcihlbnYubG9nTGV2ZWwhLCAhIWVudi5kZWJ1Zyk7XHJcblxyXG4gICAgLy8gVE9ETzogc2V0IHVwIGZsYWdzXHJcblxyXG4gICAgdGhpcy5kZXZpY2Uub251bmNhcHR1cmVkZXJyb3IgPSAoZXYpID0+IHtcclxuICAgICAgaWYgKGV2LmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke2V2LmVycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSwgJ2RldmljZScsIHtcclxuICAgICAgdmFsdWU6IHRoaXMuZGV2aWNlLFxyXG4gICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsICdhZGFwdGVyJywge1xyXG4gICAgICB2YWx1ZTogYWRhcHRlcixcclxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaW5pdCBxdWVyeVR5cGUsIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGVcclxuICAgIHRoaXMuc2V0UXVlcnlUeXBlKCk7XHJcbiAgfVxyXG5cclxuICBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLnF1ZXJ5U2V0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB0aGlzLnF1ZXJ5U2V0LmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29tbWFuZEVuY29kZXIoKTogR1BVQ29tbWFuZEVuY29kZXIge1xyXG4gICAgaWYgKCF0aGlzLmNvbW1hbmRFbmNvZGVyKSB7XHJcbiAgICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZEVuY29kZXI7XHJcbiAgfVxyXG5cclxuICBnZXRDb21wdXRlUGFzc0VuY29kZXIoKTogR1BVQ29tcHV0ZVBhc3NFbmNvZGVyIHtcclxuICAgIGlmICghdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpIHtcclxuICAgICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmdldENvbW1hbmRFbmNvZGVyKCk7XHJcbiAgICAgIGNvbnN0IGNvbXB1dGVQYXNzRGVzY3JpcHRvcjogR1BVQ29tcHV0ZVBhc3NEZXNjcmlwdG9yID0ge307XHJcblxyXG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnKSB7XHJcbiAgICAgICAgY29tcHV0ZVBhc3NEZXNjcmlwdG9yLnRpbWVzdGFtcFdyaXRlcyA9IHtcclxuICAgICAgICAgIHF1ZXJ5U2V0OiB0aGlzLnF1ZXJ5U2V0ISxcclxuICAgICAgICAgIGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMixcclxuICAgICAgICAgIGVuZE9mUGFzc1dyaXRlSW5kZXg6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiArIDEsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jb21wdXRlUGFzc0VuY29kZXIgPSBjb21tYW5kRW5jb2Rlci5iZWdpbkNvbXB1dGVQYXNzKGNvbXB1dGVQYXNzRGVzY3JpcHRvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlUGFzc0VuY29kZXI7XHJcbiAgfVxyXG5cclxuICBlbmRDb21wdXRlUGFzcygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcikge1xyXG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKTtcclxuICAgICAgdGhpcy5jb21wdXRlUGFzc0VuY29kZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZmx1c2goKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuY29tbWFuZEVuY29kZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcclxuXHJcbiAgICB0aGlzLmVuZENvbXB1dGVQYXNzKCk7XHJcbiAgICBsZXQgcXVlcnlSZWFkQnVmZmVyOiBHUFVCdWZmZXI7XHJcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xyXG4gICAgICB0aGlzLmNvbW1hbmRFbmNvZGVyLnJlc29sdmVRdWVyeVNldChcclxuICAgICAgICB0aGlzLnF1ZXJ5U2V0ISxcclxuICAgICAgICAwLFxyXG4gICAgICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMixcclxuICAgICAgICB0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciEsXHJcbiAgICAgICAgMCxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHF1ZXJ5UmVhZEJ1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgIHsgc2l6ZTogdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICogOCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHRoaXMucGVuZGluZ1F1ZXJpZXMuc2V0KHF1ZXJ5UmVhZEJ1ZmZlciwgdGhpcy5wZW5kaW5nS2VybmVscyk7XHJcbiAgICAgIHRoaXMucGVuZGluZ0tlcm5lbHMgPSBbXTtcclxuICAgICAgdGhpcy5jb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXHJcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIhLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgcXVlcnlSZWFkQnVmZmVyLFxyXG4gICAgICAgIDAsXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICogOCxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcclxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVmcmVzaFBlbmRpbmdCdWZmZXJzKCk7XHJcbiAgICB0aGlzLmNvbW1hbmRFbmNvZGVyID0gbnVsbDtcclxuICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID0gMDtcclxuXHJcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xyXG4gICAgICB2b2lkIHF1ZXJ5UmVhZEJ1ZmZlciEubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpID0+IHtcclxuICAgICAgICBjb25zdCBtYXBwZWREYXRhID0gbmV3IEJpZ1VpbnQ2NEFycmF5KHF1ZXJ5UmVhZEJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpKTtcclxuICAgICAgICBjb25zdCBwZW5kaW5nS2VybmVscyA9IHRoaXMucGVuZGluZ1F1ZXJpZXMuZ2V0KHF1ZXJ5UmVhZEJ1ZmZlcikhO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVkRGF0YS5sZW5ndGggLyAyOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxJbmZvID0gcGVuZGluZ0tlcm5lbHNbaV07XHJcbiAgICAgICAgICBjb25zdCBrZXJuZWxJZCA9IHBlbmRpbmdLZXJuZWxJbmZvLmtlcm5lbElkO1xyXG4gICAgICAgICAgY29uc3Qga2VybmVsSW5mbyA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpITtcclxuICAgICAgICAgIGNvbnN0IGtlcm5lbFR5cGUgPSBrZXJuZWxJbmZvLmtlcm5lbFR5cGU7XHJcbiAgICAgICAgICBjb25zdCBrZXJuZWxOYW1lID0ga2VybmVsSW5mby5rZXJuZWxOYW1lO1xyXG4gICAgICAgICAgY29uc3QgcHJvZ3JhbU5hbWUgPSBwZW5kaW5nS2VybmVsSW5mby5wcm9ncmFtTmFtZTtcclxuICAgICAgICAgIGNvbnN0IGlucHV0VGVuc29yVmlld3MgPSBwZW5kaW5nS2VybmVsSW5mby5pbnB1dFRlbnNvclZpZXdzO1xyXG4gICAgICAgICAgY29uc3Qgb3V0cHV0VGVuc29yVmlld3MgPSBwZW5kaW5nS2VybmVsSW5mby5vdXRwdXRUZW5zb3JWaWV3cztcclxuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZVU2NCA9IG1hcHBlZERhdGFbaSAqIDJdO1xyXG4gICAgICAgICAgY29uc3QgZW5kVGltZVU2NCA9IG1hcHBlZERhdGFbaSAqIDIgKyAxXTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucXVlcnlUaW1lQmFzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeVRpbWVCYXNlID0gc3RhcnRUaW1lVTY0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IE51bWJlcihzdGFydFRpbWVVNjQgLSB0aGlzLnF1ZXJ5VGltZUJhc2UpO1xyXG4gICAgICAgICAgY29uc3QgZW5kVGltZSA9IE51bWJlcihlbmRUaW1lVTY0IC0gdGhpcy5xdWVyeVRpbWVCYXNlKTtcclxuXHJcbiAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHN0YXJ0VGltZSkgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGVuZFRpbWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm9uZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7XHJcbiAgICAgICAgICAgICAgdmVyc2lvbjogMSxcclxuICAgICAgICAgICAgICBpbnB1dHNNZXRhZGF0YTogaW5wdXRUZW5zb3JWaWV3cy5tYXAoKHZhbHVlKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgZGltczogdmFsdWUuZGltcyxcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSksXHJcbiAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgIG91dHB1dHNNZXRhZGF0YTogb3V0cHV0VGVuc29yVmlld3MubWFwKCh2YWx1ZSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIGRpbXM6IHZhbHVlLmRpbXMsXHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpLFxyXG4gICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICBrZXJuZWxJZCxcclxuICAgICAgICAgICAgICBrZXJuZWxUeXBlLFxyXG4gICAgICAgICAgICAgIGtlcm5lbE5hbWUsXHJcbiAgICAgICAgICAgICAgcHJvZ3JhbU5hbWUsXHJcbiAgICAgICAgICAgICAgc3RhcnRUaW1lLFxyXG4gICAgICAgICAgICAgIGVuZFRpbWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHByaW50IHRoZSBwcm9maWxpbmcgbWVzc2FnZSB0byBjb25zb2xlXHJcbiAgICAgICAgICAgIGxldCBpbnB1dFNoYXBlcyA9ICcnO1xyXG4gICAgICAgICAgICBpbnB1dFRlbnNvclZpZXdzLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgaW5wdXRTaGFwZXMgKz0gYGlucHV0WyR7aX1dOiBbJHt2YWx1ZS5kaW1zfV0gfCAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0sIGA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgb3V0cHV0U2hhcGVzID0gJyc7XHJcbiAgICAgICAgICAgIG91dHB1dFRlbnNvclZpZXdzLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0U2hhcGVzICs9IGBvdXRwdXRbJHtpfV06IFske3ZhbHVlLmRpbXN9XSB8ICR7dGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpfSwgYDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgIGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke2tlcm5lbElkfXwke2tlcm5lbFR5cGV9fCR7a2VybmVsTmFtZX18JHtwcm9ncmFtTmFtZX1cIiAke2lucHV0U2hhcGVzfSR7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZXNcclxuICAgICAgICAgICAgICB9c3RhcnQgdGltZTogJHtzdGFydFRpbWV9IG5zLCBleGVjdXRpb24gdGltZTogJHtlbmRUaW1lIC0gc3RhcnRUaW1lfSBuc2AsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBUUkFDRSgnR1BVJywgYCR7cHJvZ3JhbU5hbWV9Ojoke3N0YXJ0VGltZVU2NH06OiR7ZW5kVGltZVU2NH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVlcnlSZWFkQnVmZmVyLnVubWFwKCk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUocXVlcnlSZWFkQnVmZmVyKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogcnVuIGEgV2ViR1BVIHByb2dyYW0uXHJcbiAgICogQHBhcmFtIHByb2dyYW0gYSBQcm9ncmFtSW5mbyBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSBpbnB1dFRlbnNvclZpZXdzIGEgVGVuc29yVmlldyBhcnJheS4gZWFjaCBlbGVtZW50IHJlcHJlc2VudHMgYSB2YWx1ZSBhbHJlYWR5IGV4aXN0cyBpbiBHUFUuXHJcbiAgICogQHBhcmFtIG91dHB1dEluZGljZXMgYW4gaW5kaWNlcyBhcnJheS4gZWFjaCBlbGVtZW50IGNhbiBiZSBlaXRoZXIgLTEgKHRlbXBvcmFyeSBkYXRhKSwgLTIgKHBlcnNpc3RlbnQgZGF0YSkgb3IgYW5cclxuICAgKiBpbmRleCB0byB0aGUga2VybmVsJ3Mgb3V0cHV0LlxyXG4gICAqIEBwYXJhbSBjcmVhdGVLZXJuZWxPdXRwdXQgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhIHZhbHVlIHRvIGtlcm5lbCdzIG91dHB1dCB3aXRoIHRoZSBnaXZlbiBpbmRleFxyXG4gICAqIEBwYXJhbSBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhIHZhbHVlIGFzIGEgaW50ZXJtZWRpYXRlIHZhbHVlLCBlaXRoZXIgdGVtcG9yYXJ5XHJcbiAgICogb3IgcGVyc2lzdGVudCAob3duZWQgYnkgdGhlIGN1cnJlbnQga2VybmVsKVxyXG4gICAqIEByZXR1cm5zIGEgVGVuc29yVmlldyBhcnJheSByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cclxuICAgKi9cclxuICBydW4oXHJcbiAgICBwcm9ncmFtOiBQcm9ncmFtSW5mbyxcclxuICAgIGlucHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcclxuICAgIG91dHB1dEluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLFxyXG4gICAgY3JlYXRlS2VybmVsT3V0cHV0OiAoaW5kZXg6IG51bWJlciwgZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pID0+IFRlbnNvclZpZXcsXHJcbiAgICBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQ6IChkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSkgPT4gVGVuc29yVmlldyxcclxuICAgIG91dHB1dENvdW50OiBudW1iZXIsXHJcbiAgKTogVGVuc29yVmlld1tdIHtcclxuICAgIFRSQUNFX0ZVTkNfQkVHSU4ocHJvZ3JhbS5uYW1lKTtcclxuICAgIC8vIGNyZWF0ZSBpbmZvIGZvciBpbnB1dHNcclxuICAgIGNvbnN0IGlucHV0RGF0YXM6IEdwdURhdGFbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFRlbnNvclZpZXdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBpbnB1dFRlbnNvclZpZXdzW2ldLmRhdGE7XHJcbiAgICAgIC8vIGlmIHRlbnNvciB2aWV3IGRhdGEgaXMgMCwgaXQgbWVhbnMgdGhlIG91dHB1dCBpcyB6ZXJvLXNpemVkIHRlbnNvciwgYW5kIHRoZXJlIGlzIG5vIEdQVSBkYXRhIGZvciBpdC5cclxuICAgICAgaWYgKGRhdGEgPT09IDApIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBncHVEYXRhID0gdGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoZGF0YSk7XHJcbiAgICAgIGlmICghZ3B1RGF0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke2RhdGF9YCk7XHJcbiAgICAgIH1cclxuICAgICAgaW5wdXREYXRhcy5wdXNoKGdwdURhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgb3V0cHV0cywgZGlzcGF0Y2hHcm91cCwgcHJvZ3JhbVVuaWZvcm1zIH0gPSBwcm9ncmFtLmdldFJ1bkRhdGEoaW5wdXRUZW5zb3JWaWV3cyk7XHJcblxyXG4gICAgLy8gY2hlY2sgb3V0cHV0IGluZGljZXNcclxuICAgIGNvbnN0IHZhbGlkYXRlZE91dHB1dEluZGljZXMgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aCA9PT0gMCA/IG91dHB1dHMubWFwKChfLCBpKSA9PiBpKSA6IG91dHB1dEluZGljZXM7XHJcbiAgICBpZiAodmFsaWRhdGVkT3V0cHV0SW5kaWNlcy5sZW5ndGggIT09IG91dHB1dHMubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHt2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke291dHB1dHMubGVuZ3RofS5gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjcmVhdGUgaW5mbyBmb3Igb3V0cHV0c1xyXG4gICAgY29uc3Qgb3V0cHV0VGVuc29yVmlld3M6IFRlbnNvclZpZXdbXSA9IFtdO1xyXG4gICAgY29uc3Qgb3V0cHV0RGF0YXM6IEdwdURhdGFbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIC8vIHZhbHVlIC0xIGFuZCAtMiBhcmUgdXNlZCBmb3IgY3JlYXRpbmcgdGVtcG9yYXJ5IGFuZCBwZXJzaXN0ZW50IG91dHB1dHMuXHJcbiAgICAgIC8vIHZhbHVlIC0zIGlzIHVzZWQgZm9yIHBsYWNlaG9sZGVyIG91dHB1dC4gU28gLTMsIC0yLCAtMSBhbmQgMCwgMSwgMiwgLi4uIGFyZSB2YWxpZFxyXG4gICAgICAvLyBvdXRwdXQgaW5kaWNlcy4gc2VlIHR5cGUgZGVmaW5pdGlvbiBvZiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICAgIGlmIChcclxuICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcih2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldKSB8fFxyXG4gICAgICAgIHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPCAtMyB8fFxyXG4gICAgICAgIHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPj0gb3V0cHV0Q291bnRcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHt2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldfWApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGlzVGVtcG9yYXJ5ID0gdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA9PT0gLTE7XHJcbiAgICAgIGNvbnN0IGlzUGVyc2lzdGVudCA9IHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPT09IC0yO1xyXG4gICAgICBjb25zdCB0ZW5zb3JWaWV3ID1cclxuICAgICAgICBpc1RlbXBvcmFyeSB8fCBpc1BlcnNpc3RlbnRcclxuICAgICAgICAgID8gY3JlYXRlSW50ZXJtZWRpYXRlT3V0cHV0KG91dHB1dHNbaV0uZGF0YVR5cGUsIG91dHB1dHNbaV0uZGltcylcclxuICAgICAgICAgIDogY3JlYXRlS2VybmVsT3V0cHV0KHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0sIG91dHB1dHNbaV0uZGF0YVR5cGUsIG91dHB1dHNbaV0uZGltcyk7XHJcbiAgICAgIG91dHB1dFRlbnNvclZpZXdzLnB1c2godGVuc29yVmlldyk7XHJcbiAgICAgIC8vIGlmIHRlbnNvciB2aWV3IGRhdGEgaXMgMCwgaXQgbWVhbnMgdGhlIG91dHB1dCBpcyB6ZXJvLXNpemVkIHRlbnNvciwgYW5kIHRoZXJlIGlzIG5vIEdQVSBkYXRhIGZvciBpdC5cclxuICAgICAgaWYgKHRlbnNvclZpZXcuZGF0YSA9PT0gMCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0ZW5zb3JWaWV3LmRhdGEpO1xyXG4gICAgICBpZiAoIWdwdURhdGEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7dGVuc29yVmlldy5kYXRhfWApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1RlbXBvcmFyeSkge1xyXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKGdwdURhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1BlcnNpc3RlbnQpIHtcclxuICAgICAgICBsZXQgcGVyc2lzdGVudERhdGEgPSB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCEpO1xyXG4gICAgICAgIGlmICghcGVyc2lzdGVudERhdGEpIHtcclxuICAgICAgICAgIHBlcnNpc3RlbnREYXRhID0gW107XHJcbiAgICAgICAgICB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCEsIHBlcnNpc3RlbnREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGVyc2lzdGVudERhdGEucHVzaChncHVEYXRhKTtcclxuICAgICAgfVxyXG4gICAgICBvdXRwdXREYXRhcy5wdXNoKGdwdURhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gdGhlcmUgYXJlIGFueSB6ZXJvLXNpemVkIHRlbnNvciBpbiB0aGUgaW5wdXRzIG9yIG91dHB1dHMsIHdlIHNob3VsZCByZXBvcnQgZXJyb3IgdW5sZXNzIGFsbCBvdXRwdXRzIGFyZVxyXG4gICAgLy8gemVyby1zaXplZCB0ZW5zb3JzLlxyXG4gICAgaWYgKGlucHV0RGF0YXMubGVuZ3RoICE9PSBpbnB1dFRlbnNvclZpZXdzLmxlbmd0aCB8fCBvdXRwdXREYXRhcy5sZW5ndGggIT09IG91dHB1dFRlbnNvclZpZXdzLmxlbmd0aCkge1xyXG4gICAgICAvLyBpZiBhbGwgb3V0cHV0cyBhcmUgemVyby1zaXplZCB0ZW5zb3JzLCB0aGVyZSBpcyBubyBuZWVkIHRvIHJ1biB0aGUgcHJvZ3JhbS5cclxuICAgICAgaWYgKG91dHB1dERhdGFzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIFRSQUNFX0ZVTkNfRU5EKHByb2dyYW0ubmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dFRlbnNvclZpZXdzO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGlmIHNvbWUgb3V0cHV0cyBhcmUgemVyby1zaXplZCB0ZW5zb3JzLCByZXBvcnQgYW4gZXJyb3IuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRPRE86IHNvIGZhciB3ZSBkb24ndCBzZWUgYW55IHVzZSBjYXNlIHRoYXQgb3V0cHV0cyBpbmNsdWRlIGJvdGggemVyby1zaXplZCB0ZW5zb3JzIGFuZCBub24temVyby1zaXplZCB0ZW5zb3JzLlxyXG4gICAgICAvLyBJZiB3ZSBzZWUgc3VjaCB1c2UgY2FzZSwgd2UgbmVlZCB0byBtYWtlIGEgY2hhbmdlIGhlcmUgdG8gc3VwcG9ydCBpdC5cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBQcm9ncmFtICR7cHJvZ3JhbS5uYW1lfSBoYXMgemVyby1zaXplZCB0ZW5zb3IocykgaW4gaW5wdXRzIG9yIG91dHB1dHMuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBub3cuYCxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBsb2FkIHVuaWZvcm1zXHJcbiAgICAvLyBUT0RPOiBhZGQgY2FjaGUgZm9yIHVuaWZvcm0gKGlzIGl0IG5lY2Vzc2FyeT8pXHJcbiAgICAvL1xyXG4gICAgbGV0IHVuaWZvcm1CdWZmZXJCaW5kaW5nOiBHUFVCaW5kaW5nUmVzb3VyY2UgfCB1bmRlZmluZWQ7XHJcbiAgICBpZiAocHJvZ3JhbVVuaWZvcm1zKSB7XHJcbiAgICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gMDtcclxuICAgICAgY29uc3Qgb2Zmc2V0czogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiB2LmRhdGEgPT09ICdudW1iZXInID8gW3YuZGF0YV0gOiB2LmRhdGE7XHJcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XR1NMLyNhbGlnbm9mXHJcbiAgICAgICAgY29uc3Qgc2l6ZU9mRWxlbWVudCA9IHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNiA/IDIgOiA0O1xyXG4gICAgICAgIGxldCBzaXplT2ZWZWNPck1hdDtcclxuICAgICAgICBsZXQgYmFzZUFsaWdubWVudDtcclxuICAgICAgICBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2KSB7XHJcbiAgICAgICAgICBiYXNlQWxpZ25tZW50ID0gZGF0YS5sZW5ndGggPiA0ID8gMTYgOiBkYXRhLmxlbmd0aCA+IDIgPyA4IDogZGF0YS5sZW5ndGggKiBzaXplT2ZFbGVtZW50O1xyXG4gICAgICAgICAgc2l6ZU9mVmVjT3JNYXQgPSBkYXRhLmxlbmd0aCA+IDQgPyAxNiA6IHNpemVPZkVsZW1lbnQgKiBkYXRhLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmFzZUFsaWdubWVudCA9IGRhdGEubGVuZ3RoIDw9IDIgPyBkYXRhLmxlbmd0aCAqIHNpemVPZkVsZW1lbnQgOiAxNjtcclxuICAgICAgICAgIHNpemVPZlZlY09yTWF0ID0gMTY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRPZmZzZXQgPSBNYXRoLmNlaWwoY3VycmVudE9mZnNldCAvIGJhc2VBbGlnbm1lbnQpICogYmFzZUFsaWdubWVudDtcclxuICAgICAgICBvZmZzZXRzLnB1c2goY3VycmVudE9mZnNldCk7XHJcbiAgICAgICAgLy8gRm9yIG5vbi1mbG9hdDE2IHR5cGUsIHdoZW4gZGF0YS5sZW5ndGggPiA0LCB0aGUgdW5pZm9ybSB2YXJpYWJsZSBpcyBvZiB0eXBlIGFycmF5PHZlYzQ8aTMyfHUzMnxmMzI+LE4+LCB3aGVyZVxyXG4gICAgICAgIC8vIE4gPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyA0KSBhbmQgU2l6ZU9mKHZlYzQ8aTMyfHUzMnxmMzI+KSA9IDE2LiBUaGUgdG90YWwgYnl0ZSBsZW5ndGggaXMgTiAqXHJcbiAgICAgICAgLy8gU2l6ZU9mKHZlYzQ8aTMyfHUzMnxmMzI+KS4gRm9yIGZsb2F0MTYgdHlwZSwgd2hlbiBkYXRhLmxlbmd0aCA+IDQsIHRoZSB1bmlmb3JtIHZhcmlhYmxlIGlzIG9mIHR5cGVcclxuICAgICAgICAvLyBhcnJheTxtYXQyeDQ8ZjE2PixOPiwgd2hlcmUgTiA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDgpIGFuZCBTaXplT2YobWF0Mng0PGYxNj4pID0gMTYuIFRoZSB0b3RhbCBieXRlXHJcbiAgICAgICAgLy8gbGVuZ3RoIGlzIE4gKiBTaXplT2YobWF0Mng0PGYxNj4pLlxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRQZXJWZWNPck1hdCA9IHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNiA/IDggOiA0O1xyXG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz1cclxuICAgICAgICAgIGRhdGEubGVuZ3RoID4gNCA/IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIGVsZW1lbnRQZXJWZWNPck1hdCkgKiBzaXplT2ZWZWNPck1hdCA6IGRhdGEubGVuZ3RoICogc2l6ZU9mRWxlbWVudDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBNZWV0IGFsaWdubWVudCBvZiBzdHJ1Y3QgaGVyZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1dHU0wvI2FsaWdubWVudC1hbmQtc2l6ZS4gRm9yIHNpbXBsaWNpdHksIHNldFxyXG4gICAgICAvLyBtYXhBbGlnbm1lbnRPZkZpZWxkIHRvIDE2IHNpbmNlIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBoYXMgYmVlbiByb3VuZGVkIHVwIHRvIDE2LlxyXG4gICAgICBjb25zdCBtYXhBbGlnbm1lbnRPZkZpZWxkID0gMTY7XHJcbiAgICAgIGN1cnJlbnRPZmZzZXQgPSBNYXRoLmNlaWwoY3VycmVudE9mZnNldCAvIG1heEFsaWdubWVudE9mRmllbGQpICogbWF4QWxpZ25tZW50T2ZGaWVsZDtcclxuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3VycmVudE9mZnNldCk7XHJcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0c1tpXTtcclxuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIHYuZGF0YSA9PT0gJ251bWJlcicgPyBbdi5kYXRhXSA6IHYuZGF0YTtcclxuICAgICAgICBpZiAodi50eXBlID09PSBEYXRhVHlwZS5pbnQzMikge1xyXG4gICAgICAgICAgbmV3IEludDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUudWludDMyKSB7XHJcbiAgICAgICAgICBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNikge1xyXG4gICAgICAgICAgbmV3IFVpbnQxNkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0KSB7XHJcbiAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlOiAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHYudHlwZSl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHVuaWZvcm1CdWZmZXJEYXRhID1cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKGN1cnJlbnRPZmZzZXQsIEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7XHJcbiAgICAgIHRoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKHVuaWZvcm1CdWZmZXJEYXRhLmJ1ZmZlciwgMCwgYXJyYXlCdWZmZXIsIDAsIGN1cnJlbnRPZmZzZXQpO1xyXG4gICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodW5pZm9ybUJ1ZmZlckRhdGEuaWQpO1xyXG4gICAgICB1bmlmb3JtQnVmZmVyQmluZGluZyA9IHsgb2Zmc2V0OiAwLCBzaXplOiBjdXJyZW50T2Zmc2V0LCBidWZmZXI6IHVuaWZvcm1CdWZmZXJEYXRhLmJ1ZmZlciB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwID0gdGhpcy5wcm9ncmFtTWFuYWdlci5ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShkaXNwYXRjaEdyb3VwKTtcclxuICAgIGNvbnN0IGlzMURpbWVuc2lvbkRpc3BhdGNoID0gbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV0gPT09IDEgJiYgbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl0gPT09IDE7XHJcbiAgICAvLyBnZXQgcHJvZ3JhbSBpbmZvXHJcbiAgICBjb25zdCBrZXkgPSBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleShwcm9ncmFtLCBpbnB1dFRlbnNvclZpZXdzLCBpczFEaW1lbnNpb25EaXNwYXRjaCk7XHJcbiAgICBsZXQgYXJ0aWZhY3QgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KGtleSk7XHJcbiAgICBpZiAoIWFydGlmYWN0KSB7XHJcbiAgICAgIGFydGlmYWN0ID0gdGhpcy5wcm9ncmFtTWFuYWdlci5idWlsZChwcm9ncmFtLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cCk7XHJcbiAgICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qoa2V5LCBhcnRpZmFjdCk7XHJcbiAgICAgIExPR19ERUJVRygnaW5mbycsICgpID0+IGBbYXJ0aWZhY3RdIGtleTogJHtrZXl9LCBwcm9ncmFtTmFtZTogJHtwcm9ncmFtLm5hbWV9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdmFsaWRhdGUgdW5pZm9ybSB2YXJpYWJsZXNcclxuICAgIGlmIChwcm9ncmFtVW5pZm9ybXMgJiYgYXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm8pIHtcclxuICAgICAgaWYgKHByb2dyYW1Vbmlmb3Jtcy5sZW5ndGggIT09IGFydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBVbmlmb3JtIHZhcmlhYmxlcyBjb3VudCBtaXNtYXRjaDogZXhwZWN0ICR7YXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RofSwgZ290ICR7XHJcbiAgICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5sZW5ndGhcclxuICAgICAgICAgIH0gaW4gcHJvZ3JhbSBcIiR7YXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZX1cIi5gLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtVW5pZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB1bmlmb3JtID0gcHJvZ3JhbVVuaWZvcm1zW2ldO1xyXG4gICAgICAgIGNvbnN0IGFjdHVhbFR5cGUgPSB1bmlmb3JtLnR5cGU7XHJcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gdHlwZW9mIHVuaWZvcm0uZGF0YSA9PT0gJ251bWJlcicgPyAxIDogdW5pZm9ybS5kYXRhLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBbdHlwZSwgbGVuZ3RoXSA9IGFydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvW2ldO1xyXG4gICAgICAgIGlmIChhY3R1YWxUeXBlICE9PSB0eXBlIHx8IGFjdHVhbExlbmd0aCAhPT0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIGBVbmlmb3JtIHZhcmlhYmxlICR7aX0gbWlzbWF0Y2g6IGV4cGVjdCB0eXBlICR7dHlwZX0gd2l0aCBzaXplICR7bGVuZ3RofSwgZ290IHR5cGUgJHtcclxuICAgICAgICAgICAgICBhY3R1YWxUeXBlXHJcbiAgICAgICAgICAgIH0gd2l0aCBzaXplICR7YWN0dWFsTGVuZ3RofSBpbiBwcm9ncmFtIFwiJHthcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lfVwiLmAsXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIExPR19ERUJVRyhcclxuICAgICAgJ2luZm8nLFxyXG4gICAgICAoKSA9PlxyXG4gICAgICAgIGBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7cHJvZ3JhbS5uYW1lfVwiIChrZXk9JHtrZXl9KSB3aXRoICR7bm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMF19eCR7XHJcbiAgICAgICAgICBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXVxyXG4gICAgICAgIH14JHtub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXX1gLFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJyB8fCB0aGlzLnNlc3Npb25TdGF0dXMgPT09ICdjYXB0dXJpbmcnKSB7XHJcbiAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxJbmZvOiBQZW5kaW5nS2VybmVsSW5mbyA9IHtcclxuICAgICAgICBrZXJuZWxJZDogdGhpcy5jdXJyZW50S2VybmVsSWQhLFxyXG4gICAgICAgIHByb2dyYW1OYW1lOiBhcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lLFxyXG4gICAgICAgIGlucHV0VGVuc29yVmlld3MsXHJcbiAgICAgICAgb3V0cHV0VGVuc29yVmlld3MsXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMucGVuZGluZ0tlcm5lbHMucHVzaChwZW5kaW5nS2VybmVsSW5mbyk7XHJcblxyXG4gICAgICBpZiAodGhpcy5zZXNzaW9uU3RhdHVzID09PSAnY2FwdHVyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IHNlc3Npb25QZW5kaW5nS2VybmVscyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XHJcbiAgICAgICAgc2Vzc2lvblBlbmRpbmdLZXJuZWxzIS5wdXNoKHBlbmRpbmdLZXJuZWxJbmZvKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIucnVuKGFydGlmYWN0LCBpbnB1dERhdGFzLCBvdXRwdXREYXRhcywgbm9ybWFsaXplZERpc3BhdGNoR3JvdXAsIHVuaWZvcm1CdWZmZXJCaW5kaW5nKTtcclxuXHJcbiAgICBUUkFDRV9GVU5DX0VORChwcm9ncmFtLm5hbWUpO1xyXG4gICAgcmV0dXJuIG91dHB1dFRlbnNvclZpZXdzO1xyXG4gIH1cclxuXHJcbiAgdXBsb2FkKGdwdURhdGFJZDogbnVtYmVyLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XHJcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZChncHVEYXRhSWQsIGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgbWVtY3B5KHNyYzogbnVtYmVyLCBkc3Q6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5tZW1jcHkoc3JjLCBkc3QpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZG93bmxvYWQoZ3B1RGF0YUlkOiBudW1iZXIsIGdldFRhcmdldEJ1ZmZlcjogKCkgPT4gVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gdGhlIHVuZGVybHlpbmcgYnVmZmVyIG1heSBiZSBjaGFuZ2VkIGFmdGVyIHRoZSBhc3luYyBmdW5jdGlvbiBpcyBjYWxsZWQuIHNvIHdlIHVzZSBhIGdldHRlciBmdW5jdGlvbiB0byBtYWtlIHN1cmVcclxuICAgIC8vIHRoZSBidWZmZXIgaXMgdXAtdG8tZGF0ZS5cclxuICAgIGF3YWl0IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZG93bmxvYWQoZ3B1RGF0YUlkLCBnZXRUYXJnZXRCdWZmZXIpO1xyXG4gIH1cclxuXHJcbiAgYWxsb2Moc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplKS5pZDtcclxuICB9XHJcblxyXG4gIGZyZWUocHRyOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShwdHIpO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlS2VybmVsKGtlcm5lbFR5cGU6IHN0cmluZywga2VybmVsSWQ6IG51bWJlciwgYXR0cmlidXRlOiB1bmtub3duLCBrZXJuZWxOYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGNvbnN0IG9wID0gV0VCR1BVX09QX1JFU09MVkVfUlVMRVMuZ2V0KGtlcm5lbFR5cGUpO1xyXG4gICAgaWYgKCFvcCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7a2VybmVsVHlwZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBrZXJuZWxJbmZvOiBLZXJuZWxJbmZvID0ge1xyXG4gICAgICBrZXJuZWxUeXBlLFxyXG4gICAgICBrZXJuZWxOYW1lLFxyXG4gICAgICBrZXJuZWxFbnRyeTogb3BbMF0sXHJcbiAgICAgIGF0dHJpYnV0ZXM6IFtvcFsxXSwgYXR0cmlidXRlXSxcclxuICAgIH07XHJcbiAgICB0aGlzLmtlcm5lbHMuc2V0KGtlcm5lbElkLCBrZXJuZWxJbmZvKTtcclxuICB9XHJcblxyXG4gIHJlbGVhc2VLZXJuZWwoa2VybmVsSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3QgcGVyc2lzdGVudERhdGEgPSB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldChrZXJuZWxJZCk7XHJcbiAgICBpZiAocGVyc2lzdGVudERhdGEpIHtcclxuICAgICAgZm9yIChjb25zdCBkYXRhIG9mIHBlcnNpc3RlbnREYXRhKSB7XHJcbiAgICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGRhdGEuaWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKGtlcm5lbElkKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKGtlcm5lbElkKTtcclxuICAgIHRoaXMua2VybmVscy5kZWxldGUoa2VybmVsSWQpO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZUtlcm5lbChrZXJuZWxJZDogbnVtYmVyLCBjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgZXJyb3JzOiBBcnJheTxQcm9taXNlPHN0cmluZyB8IG51bGw+Pik6IG51bWJlciB7XHJcbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbHMuZ2V0KGtlcm5lbElkKTtcclxuICAgIGlmICgha2VybmVsKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke2tlcm5lbElkfWApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qga2VybmVsVHlwZSA9IGtlcm5lbC5rZXJuZWxUeXBlO1xyXG4gICAgY29uc3Qga2VybmVsTmFtZSA9IGtlcm5lbC5rZXJuZWxOYW1lO1xyXG4gICAgY29uc3Qga2VybmVsRW50cnkgPSBrZXJuZWwua2VybmVsRW50cnk7XHJcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ga2VybmVsLmF0dHJpYnV0ZXM7XHJcbiAgICBpZiAodGhpcy5jdXJyZW50S2VybmVsSWQgIT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNhbGxlZCByZWN1cnNpdmVseWApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jdXJyZW50S2VybmVsSWQgPSBrZXJuZWxJZDtcclxuXHJcbiAgICAvLyBwYXJzZSBhdHRyaWJ1dGVzIGlmIG5lY2Vzc2FyeVxyXG4gICAgaWYgKGF0dHJpYnV0ZXNbMF0pIHtcclxuICAgICAgYXR0cmlidXRlc1sxXSA9IGF0dHJpYnV0ZXNbMF0oYXR0cmlidXRlc1sxXSk7XHJcbiAgICAgIGF0dHJpYnV0ZXNbMF0gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgTE9HX0RFQlVHKCdpbmZvJywgKCkgPT4gYFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiLi4uYCk7XHJcblxyXG4gICAgY29uc3QgdXNlRXJyb3JTY29wZSA9IHRoaXMuZW52LmRlYnVnO1xyXG5cclxuICAgIHRoaXMudGVtcG9yYXJ5RGF0YSA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHVzZUVycm9yU2NvcGUpIHtcclxuICAgICAgICB0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZSgndmFsaWRhdGlvbicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBrZXJuZWxFbnRyeShjb250ZXh0LCBhdHRyaWJ1dGVzWzFdKTtcclxuICAgICAgcmV0dXJuIDA7IC8vIE9SVF9PS1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBlcnJvcnMucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIgZmFpbGVkLiAke2V9YCkpO1xyXG4gICAgICByZXR1cm4gMTsgLy8gT1JUX0ZBSUxcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGlmICh1c2VFcnJvclNjb3BlKSB7XHJcbiAgICAgICAgZXJyb3JzLnB1c2goXHJcbiAgICAgICAgICB0aGlzLmRldmljZVxyXG4gICAgICAgICAgICAucG9wRXJyb3JTY29wZSgpXHJcbiAgICAgICAgICAgIC50aGVuKChlcnIpID0+XHJcbiAgICAgICAgICAgICAgZXJyID8gYEdQVSB2YWxpZGF0aW9uIGVycm9yIGZvciBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiOiAke2Vyci5tZXNzYWdlfWAgOiBudWxsLFxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoY29uc3QgZGF0YSBvZiB0aGlzLnRlbXBvcmFyeURhdGEpIHtcclxuICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZGF0YS5pZCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50ZW1wb3JhcnlEYXRhID0gW107XHJcbiAgICAgIHRoaXMuY3VycmVudEtlcm5lbElkID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vICNyZWdpb24gZXh0ZXJuYWwgYnVmZmVyXHJcbiAgcmVnaXN0ZXJCdWZmZXIoc2Vzc2lvbklkOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGJ1ZmZlcjogR1BVQnVmZmVyLCBzaXplOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgbGV0IHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcgPSB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldChzZXNzaW9uSWQpO1xyXG4gICAgaWYgKCFzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKSB7XHJcbiAgICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcgPSBuZXcgTWFwKCk7XHJcbiAgICAgIHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHNlc3Npb25JZCwgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gdGhlIGJ1ZmZlciBtYXkgYmUgdXNlciBjcmVhdGVkLCBvciBtYW5hZ2VkIGJ5IEdQVSBkYXRhIG1hbmFnZXIuXHJcbiAgICAvLyBUaGUgR1BVIGRhdGEgbWFuYWdlciB3aWxsIG5vdCBtYW5hZ2UgdGhlc2UgYnVmZmVycy4gd2UgcmVnaXN0ZXIgdGhlbSBhcyBleHRlcm5hbCBidWZmZXJzLlxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBtYXAgYHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmdgIGlzIHVzZWQgdG8gc3RvcmUgdGhlIGRhdGEgSUQgYW5kIGJ1ZmZlciBmb3IgZWFjaCBpbnB1dC9vdXRwdXQuIE9uY2UgYVxyXG4gICAgLy8gc3BlY2lmaWMgaW5wdXQvb3V0cHV0IGlzIHJlZ2lzdGVyZWQsIHRoZSBkYXRhIElEIHdpbGwgbm90IGNoYW5nZS5cclxuICAgIGNvbnN0IHByZXZpb3VzQnVmZmVyID0gc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZy5nZXQoaW5kZXgpO1xyXG4gICAgY29uc3QgaWQgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYnVmZmVyLCBzaXplLCBwcmV2aW91c0J1ZmZlcik7XHJcbiAgICBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nLnNldChpbmRleCwgW2lkLCBidWZmZXJdKTtcclxuICAgIHJldHVybiBpZDtcclxuICB9XHJcbiAgdW5yZWdpc3RlckJ1ZmZlcnMoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGNvbnN0IHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcgPSB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldChzZXNzaW9uSWQpO1xyXG4gICAgaWYgKHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpIHtcclxuICAgICAgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZy5mb3JFYWNoKChidWZmZXJJbmZvKSA9PiB0aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXJJbmZvWzBdKSk7XHJcbiAgICAgIHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldEJ1ZmZlcihncHVEYXRhSWQ6IG51bWJlcik6IEdQVUJ1ZmZlciB7XHJcbiAgICBjb25zdCBncHVEYXRhID0gdGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoZ3B1RGF0YUlkKTtcclxuICAgIGlmICghZ3B1RGF0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBidWZmZXI6ICR7Z3B1RGF0YUlkfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdwdURhdGEuYnVmZmVyO1xyXG4gIH1cclxuICBjcmVhdGVEb3dubG9hZGVyKFxyXG4gICAgZ3B1QnVmZmVyOiBHUFVCdWZmZXIsXHJcbiAgICBzaXplOiBudW1iZXIsXHJcbiAgICB0eXBlOiBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzLFxyXG4gICk6ICgpID0+IFByb21pc2U8VGVuc29yLkRhdGFUeXBlPiB7XHJcbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZG93bmxvYWRHcHVEYXRhKHRoaXMsIGdwdUJ1ZmZlciwgc2l6ZSk7XHJcbiAgICAgIHJldHVybiBjcmVhdGVWaWV3KGRhdGEuYnVmZmVyLCB0eXBlKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIC8vICNlbmRyZWdpb25cclxuICB3cml0ZVRpbWVzdGFtcChpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdpbnNpZGUtcGFzc2VzJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICh0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciBhcyBhbnkpLndyaXRlVGltZXN0YW1wKHRoaXMucXVlcnlTZXQsIGluZGV4KTtcclxuICB9XHJcbiAgc2V0UXVlcnlUeXBlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5xdWVyeVR5cGUgPSAnbm9uZSc7XHJcbiAgICBpZiAoXHJcbiAgICAgIHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm1vZGUgPT09ICdkZWZhdWx0JyB8fFxyXG4gICAgICAodHlwZW9mIHRoaXMuZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/IHRoaXMuZW52Lndhc20udHJhY2UgOiB0aGlzLmVudi50cmFjZSlcclxuICAgICkge1xyXG4gICAgICBpZiAodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnKSkge1xyXG4gICAgICAgIHRoaXMucXVlcnlUeXBlID0gJ2luc2lkZS1wYXNzZXMnO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcygndGltZXN0YW1wLXF1ZXJ5JykpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdhdC1wYXNzZXMnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJyAmJiB0eXBlb2YgdGhpcy5xdWVyeVNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5U2V0ID0gdGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoe1xyXG4gICAgICAgICAgdHlwZTogJ3RpbWVzdGFtcCcsXHJcbiAgICAgICAgICBjb3VudDogdGhpcy5tYXhEaXNwYXRjaE51bWJlciAqIDIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoXHJcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxyXG4gICAgICAgICAgeyBzaXplOiB0aGlzLm1heERpc3BhdGNoTnVtYmVyICogMiAqIDgsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyB8IEdQVUJ1ZmZlclVzYWdlLlFVRVJZX1JFU09MVkUgfSxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjYXB0dXJlQmVnaW4oKTogdm9pZCB7XHJcbiAgICBMT0dfREVCVUcoJ2luZm8nLCAnY2FwdHVyZUJlZ2luJyk7XHJcbiAgICBpZiAoIXRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISkpIHtcclxuICAgICAgdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhLCBbXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISkpIHtcclxuICAgICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhLCBbXSk7XHJcbiAgICB9XHJcbiAgICAvLyBmbHVzaCB0aGUgbGVmdCBjb21tYW5kcyBiZWZvcmUgd2UgY2hhbmdlIHRoZSBzdGF0dXMuXHJcbiAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnY2FwdHVyaW5nJztcclxuICB9XHJcbiAgY2FwdHVyZUVuZCgpOiB2b2lkIHtcclxuICAgIExPR19ERUJVRygnaW5mbycsICdjYXB0dXJlRW5kJyk7XHJcbiAgICAvLyBmbHVzaCB0aGUgbGVmdCBjb21tYW5kcyBiZWZvcmUgd2UgY2hhbmdlIHRoZSBzdGF0dXMuXHJcbiAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XHJcbiAgfVxyXG4gIHJlcGxheSgpOiB2b2lkIHtcclxuICAgIExPR19ERUJVRygnaW5mbycsICdyZXBsYXknKTtcclxuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdyZXBsYXlpbmcnO1xyXG4gICAgY29uc3Qgc2Vzc2lvbkNvbW1hbmRMaXN0ID0gdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhKTtcclxuICAgIGNvbnN0IHNlc3Npb25QZW5kaW5nS2VybmVscyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XHJcbiAgICBjb25zdCBsZW5ndGggPSBzZXNzaW9uQ29tbWFuZExpc3QhLmxlbmd0aDtcclxuICAgIHRoaXMucGVuZGluZ0tlcm5lbHMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgY29tcHV0ZVBhc3NFbmNvZGVyID0gdGhpcy5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTtcclxuICAgICAgY29uc3QgY29tbWFuZCA9IHNlc3Npb25Db21tYW5kTGlzdCFbaV07XHJcbiAgICAgIHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyKTtcclxuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKGNvbW1hbmQuY29tcHV0ZVBpcGVsaW5lKTtcclxuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgwLCBjb21tYW5kLmJpbmRHcm91cCk7XHJcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5kaXNwYXRjaFdvcmtncm91cHMoLi4uY29tbWFuZC5kaXNwYXRjaEdyb3VwKTtcclxuICAgICAgdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKyAxKTtcclxuICAgICAgdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKztcclxuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2goc2Vzc2lvblBlbmRpbmdLZXJuZWxzIVtpXSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgfHwgdGhpcy5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnKSB7XHJcbiAgICAgICAgdGhpcy5lbmRDb21wdXRlUGFzcygpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLm1heERpc3BhdGNoTnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBmbHVzaCB0aGUgbGVmdCBjb21tYW5kcyBiZWZvcmUgd2UgY2hhbmdlIHRoZSBzdGF0dXMuXHJcbiAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XHJcbiAgfVxyXG5cclxuICBvbkNyZWF0ZVNlc3Npb24oKTogdm9pZCB7XHJcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLm9uQ3JlYXRlU2Vzc2lvbigpO1xyXG4gIH1cclxuXHJcbiAgb25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy51bnJlZ2lzdGVyQnVmZmVycyhzZXNzaW9uSWQpO1xyXG4gICAgaWYgKHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXMoc2Vzc2lvbklkKSkge1xyXG4gICAgICB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZGVsZXRlKHNlc3Npb25JZCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmhhcyhzZXNzaW9uSWQpKSB7XHJcbiAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5kZWxldGUoc2Vzc2lvbklkKTtcclxuICAgIH1cclxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIub25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xyXG4gIH1cclxuXHJcbiAgb25SdW5TdGFydChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgdGhpcy5jdXJyZW50U2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gICAgdGhpcy5zZXRRdWVyeVR5cGUoKTtcclxuICB9XHJcbn1cclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQgdHlwZSB7IEVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcywgRGF0YVR5cGUgfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XHJcblxyXG5pbXBvcnQgdHlwZSB7IE9ydFdhc21Nb2R1bGUgfSBmcm9tICcuLi93YXNtLXR5cGVzJztcclxuXHJcbmltcG9ydCB0eXBlIHsgV2ViR3B1QmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC13ZWJncHUnO1xyXG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XHJcbmltcG9ydCB0eXBlIHsgVGVuc29yVmlldyB9IGZyb20gJy4vdGVuc29yLXZpZXcnO1xyXG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuL3V0aWwnO1xyXG5pbXBvcnQgdHlwZSB7IEFkYXB0ZXJJbmZvLCBDb21wdXRlQ29udGV4dCwgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZywgUHJvZ3JhbUluZm8gfSBmcm9tICcuL3dlYmdwdS90eXBlcyc7XHJcbmltcG9ydCB7IFdlYk5OQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC13ZWJubic7XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXHJcblxyXG5jbGFzcyBUZW5zb3JWaWV3SW1wbCBpbXBsZW1lbnRzIFRlbnNvclZpZXcge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGF0YVR5cGU6IG51bWJlcixcclxuICAgIHB1YmxpYyByZWFkb25seSBkYXRhOiBudW1iZXIsXHJcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW10sXHJcbiAgKSB7fVxyXG5cclxuICBnZXRGbG9hdDMyQXJyYXkoKTogRmxvYXQzMkFycmF5IHtcclxuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMFxyXG4gICAgICA/IG5ldyBGbG9hdDMyQXJyYXkoKVxyXG4gICAgICA6IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLCB0aGlzLmRhdGEsIGVsZW1lbnRDb3VudCk7XHJcbiAgfVxyXG5cclxuICBnZXRCaWdJbnQ2NEFycmF5KCk6IEJpZ0ludDY0QXJyYXkge1xyXG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDY0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XHJcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwXHJcbiAgICAgID8gbmV3IEJpZ0ludDY0QXJyYXkoKVxyXG4gICAgICA6IG5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xyXG4gIH1cclxuXHJcbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5IHtcclxuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQzMikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMCA/IG5ldyBJbnQzMkFycmF5KCkgOiBuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcclxuICB9XHJcblxyXG4gIGdldFVpbnQxNkFycmF5KCk6IFVpbnQxNkFycmF5IHtcclxuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdDE2ICYmIHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLnVpbnQxNikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMCA/IG5ldyBVaW50MTZBcnJheSgpIDogbmV3IFVpbnQxNkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xyXG4gIH1cclxuXHJcbiAgcmVzaGFwZShuZXdEaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcge1xyXG4gICAgaWYgKFNoYXBlVXRpbC5zaXplKG5ld0RpbXMpICE9PSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuZXcgc2hhcGUnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIHRoaXMuZGF0YVR5cGUsIHRoaXMuZGF0YSwgbmV3RGltcyk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBDb21wdXRlQ29udGV4dEltcGwgaW1wbGVtZW50cyBDb21wdXRlQ29udGV4dCB7XHJcbiAgcmVhZG9ubHkgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvO1xyXG4gIHJlYWRvbmx5IG9wS2VybmVsQ29udGV4dDogbnVtYmVyO1xyXG4gIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xyXG4gIHJlYWRvbmx5IG91dHB1dENvdW50OiBudW1iZXI7XHJcbiAgZ2V0IGtlcm5lbEN1c3RvbURhdGEoKTogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0ge1xyXG4gICAgcmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YTtcclxuICB9XHJcbiAgZ2V0IGN1c3RvbURhdGFCdWZmZXIoKTogVWludDhBcnJheSB7XHJcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuSEVBUFU4LnN1YmFycmF5KHRoaXMuY3VzdG9tRGF0YU9mZnNldCwgdGhpcy5jdXN0b21EYXRhT2Zmc2V0ICsgdGhpcy5jdXN0b21EYXRhU2l6ZSk7XHJcbiAgfVxyXG4gIHByaXZhdGUgY3VzdG9tRGF0YU9mZnNldCA9IDA7XHJcbiAgcHJpdmF0ZSBjdXN0b21EYXRhU2l6ZSA9IDA7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIG1vZHVsZTogT3J0V2FzbU1vZHVsZSxcclxuICAgIHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCxcclxuICAgIGNvbnRleHREYXRhT2Zmc2V0OiBudW1iZXIsXHJcbiAgKSB7XHJcbiAgICB0aGlzLmFkYXB0ZXJJbmZvID0gYmFja2VuZC5hZGFwdGVySW5mbztcclxuXHJcbiAgICAvLyBleHRyYWN0IGNvbnRleHQgZGF0YVxyXG4gICAgY29uc3QgcHRyU2l6ZSA9IG1vZHVsZS5QVFJfU0laRTtcclxuICAgIGxldCBkYXRhSW5kZXggPSBjb250ZXh0RGF0YU9mZnNldCAvIG1vZHVsZS5QVFJfU0laRTtcclxuICAgIGNvbnN0IHR5cGUgPSBwdHJTaXplID09PSA0ID8gJ2kzMicgOiAnaTY0JztcclxuICAgIHRoaXMub3BLZXJuZWxDb250ZXh0ID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcclxuICAgIGNvbnN0IGlucHV0Q291bnQgPSBOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgdHlwZSkpO1xyXG4gICAgdGhpcy5vdXRwdXRDb3VudCA9IE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCB0eXBlKSk7XHJcbiAgICB0aGlzLmN1c3RvbURhdGFPZmZzZXQgPSBOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgJyonKSk7XHJcbiAgICB0aGlzLmN1c3RvbURhdGFTaXplID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssIHR5cGUpKTtcclxuXHJcbiAgICBjb25zdCBpbnB1dHM6IFRlbnNvclZpZXdbXSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcclxuICAgICAgY29uc3QgZGF0YVR5cGUgPSBOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgdHlwZSkpO1xyXG4gICAgICBjb25zdCBkYXRhID0gTnVtYmVyKG1vZHVsZS5nZXRWYWx1ZShwdHJTaXplICogZGF0YUluZGV4KyssICcqJykpO1xyXG4gICAgICBjb25zdCBkaW0gPSBOdW1iZXIobW9kdWxlLmdldFZhbHVlKHB0clNpemUgKiBkYXRhSW5kZXgrKywgdHlwZSkpO1xyXG4gICAgICBjb25zdCBkaW1zOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgZCsrKSB7XHJcbiAgICAgICAgZGltcy5wdXNoKE51bWJlcihtb2R1bGUuZ2V0VmFsdWUocHRyU2l6ZSAqIGRhdGFJbmRleCsrLCB0eXBlKSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlucHV0cy5wdXNoKG5ldyBUZW5zb3JWaWV3SW1wbChtb2R1bGUsIGRhdGFUeXBlLCBkYXRhLCBkaW1zKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcclxuICB9XHJcblxyXG4gIGNvbXB1dGUocHJvZ3JhbTogUHJvZ3JhbUluZm8sIGlucHV0c091dHB1dHNNYXBwaW5nPzogQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyk6IFRlbnNvclZpZXdbXSB7XHJcbiAgICAvLyBwcmVwYXJlIGlucHV0cy4gaW5wdXRzIHNob3VsZCBhbHdheXMgYmUgdmFsaWQgZGF0YS5cclxuICAgIGNvbnN0IG1hcHBlZElucHV0cyA9XHJcbiAgICAgIGlucHV0c091dHB1dHNNYXBwaW5nPy5pbnB1dHM/Lm1hcCgoaSkgPT4gKHR5cGVvZiBpID09PSAnbnVtYmVyJyA/IHRoaXMuaW5wdXRzW2ldIDogaSkpID8/IHRoaXMuaW5wdXRzO1xyXG4gICAgLy8gcHJlcGFyZSBvdXRwdXRzLlxyXG4gICAgY29uc3Qgb3V0cHV0SW5kaWNlcyA9IGlucHV0c091dHB1dHNNYXBwaW5nPy5vdXRwdXRzID8/IFtdO1xyXG4gICAgY29uc3QgY3JlYXRlS2VybmVsT3V0cHV0ID0gKGluZGV4OiBudW1iZXIsIGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yVmlldyA9PlxyXG4gICAgICBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIGRhdGFUeXBlLCB0aGlzLm91dHB1dChpbmRleCwgZGltcyksIGRpbXMpO1xyXG4gICAgY29uc3QgY3JlYXRlVGVtcG9yYXJ5T3V0cHV0ID0gKGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yVmlldyA9PiB7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyhkYXRhVHlwZSwgZGltcyk7XHJcbiAgICAgIGlmICghYnVmZmVyU2l6ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfWApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGdwdURhdGFJZCA9IGJ1ZmZlclNpemUgPiAwID8gdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShidWZmZXJTaXplKS5pZCA6IDA7XHJcbiAgICAgIHJldHVybiBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIGRhdGFUeXBlLCBncHVEYXRhSWQsIGRpbXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB0aGlzLmJhY2tlbmQucnVuKFxyXG4gICAgICBwcm9ncmFtLFxyXG4gICAgICBtYXBwZWRJbnB1dHMsXHJcbiAgICAgIG91dHB1dEluZGljZXMsXHJcbiAgICAgIGNyZWF0ZUtlcm5lbE91dHB1dCxcclxuICAgICAgY3JlYXRlVGVtcG9yYXJ5T3V0cHV0LFxyXG4gICAgICB0aGlzLm91dHB1dENvdW50LFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIG91dHB1dChpbmRleDogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XHJcbiAgICBjb25zdCBzdGFjayA9IHRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcHRyU2l6ZSA9IHRoaXMubW9kdWxlLlBUUl9TSVpFO1xyXG4gICAgICBjb25zdCB0eXBlID0gcHRyU2l6ZSA9PT0gNCA/ICdpMzInIDogJ2k2NCc7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm1vZHVsZS5zdGFja0FsbG9jKCgxICsgZGltcy5sZW5ndGgpICogcHRyU2l6ZSAvKiBzaXplb2Yoc2l6ZV90KSAqLyk7XHJcbiAgICAgIHRoaXMubW9kdWxlLnNldFZhbHVlKGRhdGEsIGRpbXMubGVuZ3RoLCB0eXBlKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5tb2R1bGUuc2V0VmFsdWUoZGF0YSArIHB0clNpemUgKiAoaSArIDEpLCBkaW1zW2ldLCB0eXBlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5tb2R1bGUuX0pzZXBPdXRwdXQhKHRoaXMub3BLZXJuZWxDb250ZXh0LCBpbmRleCwgZGF0YSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbCdzIG91dHB1dFske2luZGV4fV0gd2l0aCBkaW1zIFske2RpbXN9XS4gYCArXHJcbiAgICAgICAgICAnSWYgeW91IGFyZSBydW5uaW5nIHdpdGggcHJlLWFsbG9jYXRlZCBvdXRwdXQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIG91dHB1dCB0eXBlL2RpbXMgYXJlIGNvcnJlY3QuICcgK1xyXG4gICAgICAgICAgYEVycm9yOiAke2V9YCxcclxuICAgICAgKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHRoaXMubW9kdWxlLnN0YWNrUmVzdG9yZShzdGFjayk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBKU0VQIHdpdGggV2ViR1BVIGJhY2tlbmQuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBsb2FkZWQgYW5kIGluaXRpYWxpemVkIChcIl9PcnRJbml0XCIgaXMgY2FsbGVkKSwgb25jZSBmb3JcclxuICogZWFjaCBvZiB0aGUgZm9sbG93aW5nIEVQcyBpZiB0aGV5IGFyZSBzcGVjaWZpZWQ6XHJcbiAqIC0gXCJ3ZWJncHVcIlxyXG4gKiAtIFwid2Vibm5cIlxyXG4gKlxyXG4gKiBGb3IgV2ViR1BVLCB0aGlzIGZ1bmN0aW9uIGV4cGVjdHM6XHJcbiAqICAtIFdlYkdQVSBpcyBlbmFibGVkIGluIGJ1aWxkIChCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCA9PT0gZmFsc2UpLlxyXG4gKiAgLSBXZWJHUFUgaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuIChhIHZhbGlkIEdQVUFkYXB0ZXIgaXMgcGFzc2VkIGluKVxyXG4gKlxyXG4gKiBGb3IgV2ViTk4sIHRoaXMgZnVuY3Rpb24gZXhwZWN0czpcclxuICogLSBXZWJOTiBpcyBlbmFibGVkIGluIGJ1aWxkIChCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCA9PT0gZmFsc2UpLlxyXG4gKiAtIFdlYk5OIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LiAobmF2aWdhdG9yLm1sIGlzIG5vdCB1bmRlZmluZWQpXHJcbiAqXHJcbiAqIElmIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUgaXMgbm90IGJ1aWx0IHdpdGggSlNFUCBzdXBwb3J0LCB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgd2lsbCBpbnZhbGlkYXRlXHJcbiAqICd3ZWJncHUnLyd3ZWJubicgYmFja2VuZC5cclxuICpcclxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgRVAsIGVpdGhlciBcIndlYmdwdVwiIG9yIFwid2Vibm5cIlxyXG4gKiBAcGFyYW0gbW9kdWxlIC0gdGhlIE9SVCBXZWJBc3NlbWJseSBtb2R1bGVcclxuICogQHBhcmFtIGVudiAtIHRoZSBPUlQgZW52aXJvbm1lbnQgdmFyaWFibGUgKG9ydC5lbnYpXHJcbiAqIEBwYXJhbSBncHVBZGFwdGVyIC0gdGhlIHByZS1jcmVhdGVkIEdQVSBhZGFwdGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaW5pdCA9IGFzeW5jIChcclxuICBuYW1lOiAnd2ViZ3B1JyB8ICd3ZWJubicsXHJcbiAgbW9kdWxlOiBPcnRXYXNtTW9kdWxlLFxyXG4gIGVudjogRW52LFxyXG4gIGdwdUFkYXB0ZXI/OiBHUFVBZGFwdGVyLFxyXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICBjb25zdCBqc2VwSW5pdCA9IG1vZHVsZS5qc2VwSW5pdDtcclxuICBpZiAoIWpzZXBJbml0KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIEpTRVAuIFRoZSBXZWJBc3NlbWJseSBtb2R1bGUgaXMgbm90IGJ1aWx0IHdpdGggSlNFUCBzdXBwb3J0LicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5hbWUgPT09ICd3ZWJncHUnKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xyXG4gICAgY29uc3Qgd2ViR3B1QmFja2VuZEltcGwgPSByZXF1aXJlKCcuL2JhY2tlbmQtd2ViZ3B1JykuV2ViR3B1QmFja2VuZDtcclxuICAgIGNvbnN0IGJhY2tlbmQgPSBuZXcgd2ViR3B1QmFja2VuZEltcGwoKTtcclxuICAgIGF3YWl0IGJhY2tlbmQuaW5pdGlhbGl6ZShlbnYsIGdwdUFkYXB0ZXIhKTtcclxuXHJcbiAgICBqc2VwSW5pdCgnd2ViZ3B1JywgW1xyXG4gICAgICAvLyBiYWNrZW5kXHJcbiAgICAgIGJhY2tlbmQsXHJcblxyXG4gICAgICAvLyBqc2VwQWxsb2MoKVxyXG4gICAgICAoc2l6ZTogbnVtYmVyKSA9PiBiYWNrZW5kLmFsbG9jKE51bWJlcihzaXplKSksXHJcblxyXG4gICAgICAvLyBqc2VwRnJlZSgpXHJcbiAgICAgIChwdHI6IG51bWJlcikgPT4gYmFja2VuZC5mcmVlKHB0ciksXHJcblxyXG4gICAgICAvLyBqc2VwQ29weShzcmMsIGRzdCwgc2l6ZSwgaXNTb3VyY2VHcHUpXHJcbiAgICAgIChzcmM6IG51bWJlciwgZHN0OiBudW1iZXIsIHNpemU6IG51bWJlciwgaXNTb3VyY2VHcHUgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGlmIChpc1NvdXJjZUdwdSkge1xyXG4gICAgICAgICAgTE9HX0RFQlVHKFxyXG4gICAgICAgICAgICAndmVyYm9zZScsXHJcbiAgICAgICAgICAgICgpID0+IGBbV2ViR1BVXSBqc2VwQ29weUdwdVRvR3B1OiBzcmM9JHtOdW1iZXIoc3JjKX0sIGRzdD0ke051bWJlcihkc3QpfSwgc2l6ZT0ke051bWJlcihzaXplKX1gLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGJhY2tlbmQubWVtY3B5KE51bWJlcihzcmMpLCBOdW1iZXIoZHN0KSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIExPR19ERUJVRyhcclxuICAgICAgICAgICAgJ3ZlcmJvc2UnLFxyXG4gICAgICAgICAgICAoKSA9PlxyXG4gICAgICAgICAgICAgIGBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7TnVtYmVyKHNyYyl9LCBncHVEYXRhSWQ9JHtOdW1iZXIoZHN0KX0sIHNpemU9JHtOdW1iZXIoc2l6ZSl9YCxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBjb25zdCBkYXRhID0gbW9kdWxlLkhFQVBVOC5zdWJhcnJheShOdW1iZXIoc3JjID4+PiAwKSwgTnVtYmVyKHNyYyA+Pj4gMCkgKyBOdW1iZXIoc2l6ZSkpO1xyXG4gICAgICAgICAgYmFja2VuZC51cGxvYWQoTnVtYmVyKGRzdCksIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIGpzZXBDb3B5QXN5bmMoc3JjLCBkc3QsIHNpemUpXHJcbiAgICAgIGFzeW5jIChncHVEYXRhSWQ6IG51bWJlciwgZGF0YU9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgICAgICBMT0dfREVCVUcoXHJcbiAgICAgICAgICAndmVyYm9zZScsXHJcbiAgICAgICAgICAoKSA9PiBgW1dlYkdQVV0ganNlcENvcHlHcHVUb0NwdTogZ3B1RGF0YUlkPSR7Z3B1RGF0YUlkfSwgZGF0YU9mZnNldD0ke2RhdGFPZmZzZXR9LCBzaXplPSR7c2l6ZX1gLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGF3YWl0IGJhY2tlbmQuZG93bmxvYWQoTnVtYmVyKGdwdURhdGFJZCksICgpID0+XHJcbiAgICAgICAgICBtb2R1bGUuSEVBUFU4LnN1YmFycmF5KE51bWJlcihkYXRhT2Zmc2V0KSA+Pj4gMCwgTnVtYmVyKGRhdGFPZmZzZXQgKyBzaXplKSA+Pj4gMCksXHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIGpzZXBDcmVhdGVLZXJuZWxcclxuICAgICAgKGtlcm5lbFR5cGU6IHN0cmluZywga2VybmVsSWQ6IG51bWJlciwgYXR0cmlidXRlOiB1bmtub3duKSA9PlxyXG4gICAgICAgIGJhY2tlbmQuY3JlYXRlS2VybmVsKFxyXG4gICAgICAgICAga2VybmVsVHlwZSxcclxuICAgICAgICAgIE51bWJlcihrZXJuZWxJZCksXHJcbiAgICAgICAgICBhdHRyaWJ1dGUsXHJcbiAgICAgICAgICBtb2R1bGUuVVRGOFRvU3RyaW5nKG1vZHVsZS5fSnNlcEdldE5vZGVOYW1lIShOdW1iZXIoa2VybmVsSWQpKSksXHJcbiAgICAgICAgKSxcclxuXHJcbiAgICAgIC8vIGpzZXBSZWxlYXNlS2VybmVsXHJcbiAgICAgIChrZXJuZWw6IG51bWJlcikgPT4gYmFja2VuZC5yZWxlYXNlS2VybmVsKGtlcm5lbCksXHJcblxyXG4gICAgICAvLyBqc2VwUnVuXHJcbiAgICAgIChrZXJuZWw6IG51bWJlciwgY29udGV4dERhdGFPZmZzZXQ6IG51bWJlciwgc2Vzc2lvbkhhbmRsZTogbnVtYmVyLCBlcnJvcnM6IEFycmF5PFByb21pc2U8c3RyaW5nIHwgbnVsbD4+KSA9PiB7XHJcbiAgICAgICAgTE9HX0RFQlVHKFxyXG4gICAgICAgICAgJ3ZlcmJvc2UnLFxyXG4gICAgICAgICAgKCkgPT5cclxuICAgICAgICAgICAgYFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHtzZXNzaW9uSGFuZGxlfSwga2VybmVsPSR7a2VybmVsfSwgY29udGV4dERhdGFPZmZzZXQ9JHtjb250ZXh0RGF0YU9mZnNldH1gLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBDb21wdXRlQ29udGV4dEltcGwobW9kdWxlLCBiYWNrZW5kLCBOdW1iZXIoY29udGV4dERhdGFPZmZzZXQpKTtcclxuICAgICAgICByZXR1cm4gYmFja2VuZC5jb21wdXRlS2VybmVsKE51bWJlcihrZXJuZWwpLCBjb250ZXh0LCBlcnJvcnMpO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyBqc2VwQ2FwdHVyZUJlZ2luXHJcbiAgICAgICgpID0+IGJhY2tlbmQuY2FwdHVyZUJlZ2luKCksXHJcbiAgICAgIC8vIGpzZXBDYXB0dXJlRW5kXHJcbiAgICAgICgpID0+IGJhY2tlbmQuY2FwdHVyZUVuZCgpLFxyXG4gICAgICAvLyBqc2VwUmVwbGF5XHJcbiAgICAgICgpID0+IGJhY2tlbmQucmVwbGF5KCksXHJcbiAgICBdKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgYmFja2VuZCA9IG5ldyBXZWJOTkJhY2tlbmQoZW52KTtcclxuICAgIGpzZXBJbml0KCd3ZWJubicsIFtcclxuICAgICAgYmFja2VuZCxcclxuICAgICAgLy8gd2Vibm5SZXNlcnZlVGVuc29ySWRcclxuICAgICAgKCkgPT4gYmFja2VuZC5yZXNlcnZlVGVuc29ySWQoKSxcclxuICAgICAgLy8gd2Vibm5SZWxlYXNlVGVuc29ySWRcclxuICAgICAgKHRlbnNvcklkOiBudW1iZXIpID0+IGJhY2tlbmQucmVsZWFzZVRlbnNvcklkKHRlbnNvcklkKSxcclxuICAgICAgLy8gd2Vibm5FbnN1cmVUZW5zb3JcclxuICAgICAgYXN5bmMgKFxyXG4gICAgICAgIHNlc3Npb25JZDogbnVtYmVyIHwgdW5kZWZpbmVkLFxyXG4gICAgICAgIHRlbnNvcklkOiBudW1iZXIsXHJcbiAgICAgICAgb25ueERhdGFUeXBlOiBudW1iZXIsXHJcbiAgICAgICAgc2hhcGU6IG51bWJlcltdLFxyXG4gICAgICAgIGNvcHlPbGQ6IGJvb2xlYW4sXHJcbiAgICAgICkgPT4gYmFja2VuZC5lbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCB0ZW5zb3JJZCwgb25ueERhdGFUeXBlLCBzaGFwZSwgY29weU9sZCksXHJcbiAgICAgIC8vIHdlYm5uVXBsb2FkVGVuc29yXHJcbiAgICAgICh0ZW5zb3JJZDogbnVtYmVyLCBkYXRhOiBVaW50OEFycmF5KSA9PiB7XHJcbiAgICAgICAgYmFja2VuZC51cGxvYWRUZW5zb3IodGVuc29ySWQsIGRhdGEpO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyB3ZWJubkRvd25sb2FkVGVuc29yXHJcbiAgICAgIGFzeW5jICh0ZW5zb3JJZDogbnVtYmVyLCBkc3RCdWZmZXI6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKSA9PiBiYWNrZW5kLmRvd25sb2FkVGVuc29yKHRlbnNvcklkLCBkc3RCdWZmZXIpLFxyXG4gICAgICAvLyB3ZWJublJlZ2lzdGVyTUxDb250ZXh0XHJcbiAgICAgIChzZXNzaW9uSWQ6IG51bWJlciwgbWxDb250ZXh0OiBNTENvbnRleHQpID0+IGJhY2tlbmQucmVnaXN0ZXJNTENvbnRleHQoc2Vzc2lvbklkLCBtbENvbnRleHQpLFxyXG4gICAgICAvLyB3ZWJubkVuYWJsZVRyYWNlRXZlbnRcclxuICAgICAgISFlbnYudHJhY2UsXHJcbiAgICBdKTtcclxuICB9XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuLy8gV2ViTk4gQVBJIGN1cnJlbnRseSBkb2VzIG5vdCBoYXZlIGEgVHlwZVNjcmlwdCBkZWZpbml0aW9uIGZpbGUuIFRoaXMgZmlsZSBpcyBhIHdvcmthcm91bmQgd2l0aCB0eXBlcyBnZW5lcmF0ZWQgZnJvbVxyXG4vLyBXZWJOTiBBUEkgc3BlY2lmaWNhdGlvbi5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYm1hY2hpbmVsZWFybmluZy93ZWJubi9pc3N1ZXMvNjc3XHJcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJqc2VwL3dlYm5uL3dlYm5uLmQudHNcIiAvPlxyXG5cclxuaW1wb3J0IHsgRW52LCBJbmZlcmVuY2VTZXNzaW9uLCBUZW5zb3IsIFRSQUNFX0VWRU5UX0JFR0lOLCBUUkFDRV9FVkVOVF9FTkQgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHtcclxuICBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcixcclxuICBTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGEsXHJcbiAgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsXHJcbiAgVGVuc29yTWV0YWRhdGEsXHJcbn0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XHJcbmltcG9ydCB7IHNldFJ1bk9wdGlvbnMgfSBmcm9tICcuL3J1bi1vcHRpb25zJztcclxuaW1wb3J0IHsgc2V0U2Vzc2lvbk9wdGlvbnMgfSBmcm9tICcuL3Nlc3Npb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7XHJcbiAgY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMsXHJcbiAgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtLFxyXG4gIGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSxcclxuICBpc01MVGVuc29yU3VwcG9ydGVkVHlwZSxcclxuICBsb2dMZXZlbFN0cmluZ1RvRW51bSxcclxuICB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyxcclxuICB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSxcclxuICB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IsXHJcbn0gZnJvbSAnLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xyXG5pbXBvcnQgeyBhbGxvY1dhc21TdHJpbmcsIGNoZWNrTGFzdEVycm9yIH0gZnJvbSAnLi93YXNtLXV0aWxzJztcclxuaW1wb3J0IHsgbG9hZEZpbGUgfSBmcm9tICcuL3dhc20tdXRpbHMtbG9hZC1maWxlJztcclxuXHJcbi8vICNyZWdpb24gSW5pdGlhbGl6YXRpb25zXHJcblxyXG4vKipcclxuICogVGhlcmUgYXJlIDQgZGlmZmVyZW50IFwiaW5pdGlhbGl6YXRpb25cIiBzdGVwcyBmb3IgT1JULiBUaGV5IGhhcHBlbiBpbiBkaWZmZXJlbnQgcGxhY2VzIGFuZCBkaWZmZXJlbnQgdGltZS5cclxuICpcclxuICogMS4gSmF2YVNjcmlwdCBpbml0aWFsaXphdGlvbiBmb3Igb25ueHJ1bnRpbWUtY29tbW9uIGFuZCBvbm54cnVudGltZS13ZWIuXHJcbiAqICAgIFRoaXMgaXMgdGhlIGZpcnN0IGluaXRpYWxpemF0aW9uIHN0ZXAuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGNhbGxzIG9ubnhydW50aW1lLWNvbW1vbidzIHJlZ2lzdGVyQmFja2VuZCgpXHJcbiAqIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIGFsbCB0aGUgYXZhaWxhYmxlIGJhY2tlbmRzLiBUaGUgYmFja2VuZCByZWdpc3RyYXRpb24gaXMgdmVyeSBmYXN0LiBJdCBvbmx5XHJcbiAqIHJlZ2lzdGVycyB0aGUgYmFja2VuZCBuYW1lIHdpdGggdGhlIHVuaW5pdGlhbGl6ZWQgYmFja2VuZCBvYmplY3QuIE5vIGhlYXZ5IGluaXRpYWxpemF0aW9uIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxyXG4gKiAgICBSZWZlciB0byB3ZWIvbGliL2luZGV4LnRzIGZvciB0aGUgYmFja2VuZCByZWdpc3RyYXRpb24uXHJcbiAqXHJcbiAqIDIuIFdlYkFzc2VtYmx5IGFydGlmYWN0IGluaXRpYWxpemF0aW9uLlxyXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBhbnkgcmVnaXN0ZXJlZCB3YXNtIGJhY2tlbmQgaXMgdXNlZCBmb3IgdGhlIGZpcnN0IHRpbWUgKGllLiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIGlzXHJcbiAqIGNhbGxlZCkuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGRvZXMgdGhlIGZvbGxvd2luZ3M6XHJcbiAqICAgICAtIGNyZWF0ZSBhIHByb3h5IHdvcmtlciBhbmQgbWFrZSBzdXJlIHRoZSBwcm94eSB3b3JrZXIgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtZXNzYWdlcywgaWYgcHJveHkgaXMgZW5hYmxlZC5cclxuICogICAgIC0gcGVyZm9ybSBmZWF0dXJlIGRldGVjdGlvbiwgbG9jYXRlIGNvcnJlY3QgV2ViQXNzZW1ibHkgYXJ0aWZhY3QgcGF0aCBhbmQgY2FsbCB0aGUgRW1zY3JpcHRlbiBnZW5lcmF0ZWRcclxuICogSmF2YVNjcmlwdCBjb2RlIHRvIGluaXRpYWxpemUgdGhlIFdlYkFzc2VtYmx5IHJ1bnRpbWUuXHJcbiAqICAgICAgICAgLSBpZiBwcm94eSBpcyBlbmFibGVkLCB0aGlzIHN0ZXAgaGFwcGVucyBpbiB0aGUgcHJveHkgd29ya2VyIHVzaW5nIG1lc3NhZ2UgJ2luaXQtd2FzbScuXHJcbiAqICAgICAgICAgLSBkb3dubG9hZGluZyB0aGUgJ29ydC13YXNtey4uLn0ud2FzbScgZmlsZSBpcyBkb25lIGluIHRoaXMgc3RlcC5cclxuICogICAgICAgICAtIGlmIG11bHRpLXRocmVhZCBpcyBlbmFibGVkLCBvbmUgb3IgbW9yZSB3ZWJ3b3JrZXIgd2lsbCBiZSBjcmVhdGVkIHRvIGluaXRpYWxpemUgdGhlIFBUaHJlYWQgdGhyZWFkcG9vbC5cclxuICpcclxuICogMy4gT1JUIGVudmlyb25tZW50IGluaXRpYWxpemF0aW9uLlxyXG4gKiAgICBUaGlzIGhhcHBlbnMgYWZ0ZXIgc3RlcCAyLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBwZXJmb3JtcyBPTk5YIFJ1bnRpbWUgZW52aXJvbm1lbnQgaW5pdGlhbGl6YXRpb24uXHJcbiAqIEZ1bmN0aW9uIGBfT3J0SW5pdCgpYCBpcyBjYWxsZWQgaW4gdGhpcyBzdGVwLlxyXG4gKiAgICAgLSBpZiBwcm94eSBpcyBlbmFibGVkLCB0aGlzIHN0ZXAgaGFwcGVucyBpbiB0aGUgcHJveHkgd29ya2VyIHVzaW5nIG1lc3NhZ2UgJ2luaXQtb3J0Jy5cclxuICogICAgIC0gbG9nZ2luZyBsZXZlbCAob3J0LmVudi5sb2dMZXZlbCkgYW5kIHRocmVhZCBudW1iZXIgKG9ydC5lbnYud2FzbS5udW1UaHJlYWRzKSBhcmUgc2V0IGluIHRoaXMgc3RlcC5cclxuICpcclxuICogNC4gU2Vzc2lvbiBpbml0aWFsaXphdGlvbi5cclxuICogICAgVGhpcyBoYXBwZW5zIHdoZW4gYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpcyBjYWxsZWQuIFVubGlrZSB0aGUgZmlyc3QgMyBzdGVwcyAodGhleSBvbmx5IGNhbGxlZCBvbmNlKSxcclxuICogdGhpcyBzdGVwIHdpbGwgYmUgZG9uZSBmb3IgZWFjaCBzZXNzaW9uLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBkb2VzIHRoZSBmb2xsb3dpbmdzOlxyXG4gKiAgICBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgVVJMOlxyXG4gKiAgICAtIGRvd25sb2FkIHRoZSBtb2RlbCBkYXRhIGZyb20gdGhlIFVSTC5cclxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXHJcbiAqICAgIC0gZGVyZWZlcmVuY2UgdGhlIG1vZGVsIGJ1ZmZlci4gVGhpcyBzdGVwIGFsbG93cyB0aGUgb3JpZ2luYWwgQXJyYXlCdWZmZXIgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXHJcbiAqICAgIC0gY2FsbCBgX09ydENyZWF0ZVNlc3Npb24oKWAgdG8gY3JlYXRlIHRoZSBzZXNzaW9uLiAocHJveHk6ICdjcmVhdGUnKVxyXG4gKlxyXG4gKiAgICBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgVWludDhBcnJheSBvYmplY3Q6XHJcbiAqICAgIC0gY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLiAocHJveHk6ICdjb3B5LWZyb20nKVxyXG4gKiAgICAtIGNhbGwgYF9PcnRDcmVhdGVTZXNzaW9uKClgIHRvIGNyZWF0ZSB0aGUgc2Vzc2lvbi4gKHByb3h5OiAnY3JlYXRlJylcclxuICpcclxuICpcclxuICovXHJcblxyXG4vKipcclxuICogaW5pdGlhbGl6ZSBPUlQgZW52aXJvbm1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBudW1UaHJlYWRzIFNldEdsb2JhbEludHJhT3BOdW1UaHJlYWRzKG51bVRocmVhZHMpXHJcbiAqIEBwYXJhbSBsb2dnaW5nTGV2ZWwgQ3JlYXRlRW52KHN0YXRpY19jYXN0PE9ydExvZ2dpbmdMZXZlbD4obG9nZ2luZ19sZXZlbCkpXHJcbiAqL1xyXG5jb25zdCBpbml0T3J0ID0gKG51bVRocmVhZHM6IG51bWJlciwgbG9nZ2luZ0xldmVsOiBudW1iZXIpOiB2b2lkID0+IHtcclxuICBjb25zdCBlcnJvckNvZGUgPSBnZXRJbnN0YW5jZSgpLl9PcnRJbml0KG51bVRocmVhZHMsIGxvZ2dpbmdMZXZlbCk7XHJcbiAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xyXG4gICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogaW5pdGlhbGl6ZSBydW50aW1lIGVudmlyb25tZW50LlxyXG4gKiBAcGFyYW0gZW52IHBhc3NlZCBpbiB0aGUgZW52aXJvbm1lbnQgY29uZmlnIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBpbml0UnVudGltZSA9IGFzeW5jIChlbnY6IEVudik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIC8vIGluaXQgT1JUXHJcbiAgaW5pdE9ydChlbnYud2FzbS5udW1UaHJlYWRzISwgbG9nTGV2ZWxTdHJpbmdUb0VudW0oZW52LmxvZ0xldmVsKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogcGVyZm9ybSBFUCBzcGVjaWZpYyBpbml0aWFsaXphdGlvbi5cclxuICpcclxuICogQHBhcmFtIGVudlxyXG4gKiBAcGFyYW0gZXBOYW1lXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaW5pdEVwID0gYXN5bmMgKGVudjogRW52LCBlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIC8vIGluaXRpYWxpemUgQVNZTkNJRlkgc3VwcG9ydFxyXG4gIGdldEluc3RhbmNlKCkuYXN5bmNJbml0Py4oKTtcclxuXHJcbiAgLy8gcGVyZm9ybSBXZWJHUFUgYXZhaWxhYmlsaXR5IGNoZWNrICggZWl0aGVyIEpTRVAgb3IgV2ViR1BVIEVQIClcclxuICBsZXQgd2ViZ3B1QWRhcHRlciA9IGVudi53ZWJncHUuYWRhcHRlciBhcyBHUFVBZGFwdGVyIHwgbnVsbDtcclxuICBpZiAoZXBOYW1lID09PSAnd2ViZ3B1Jykge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IuZ3B1KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR1BVIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKCF3ZWJncHVBZGFwdGVyKSB7XHJcbiAgICAgIC8vIGlmIGFkYXB0ZXIgaXMgbm90IHNldCwgcmVxdWVzdCBhIG5ldyBhZGFwdGVyLlxyXG4gICAgICBjb25zdCBwb3dlclByZWZlcmVuY2UgPSBlbnYud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtcclxuICAgICAgaWYgKHBvd2VyUHJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkICYmIHBvd2VyUHJlZmVyZW5jZSAhPT0gJ2xvdy1wb3dlcicgJiYgcG93ZXJQcmVmZXJlbmNlICE9PSAnaGlnaC1wZXJmb3JtYW5jZScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcG93ZXJQcmVmZXJlbmNlIHNldHRpbmc6IFwiJHtwb3dlclByZWZlcmVuY2V9XCJgKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBmb3JjZUZhbGxiYWNrQWRhcHRlciA9IGVudi53ZWJncHUuZm9yY2VGYWxsYmFja0FkYXB0ZXI7XHJcbiAgICAgIGlmIChmb3JjZUZhbGxiYWNrQWRhcHRlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBmb3JjZUZhbGxiYWNrQWRhcHRlciAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHtmb3JjZUZhbGxiYWNrQWRhcHRlcn1cImApO1xyXG4gICAgICB9XHJcbiAgICAgIHdlYmdwdUFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKHsgcG93ZXJQcmVmZXJlbmNlLCBmb3JjZUZhbGxiYWNrQWRhcHRlciB9KTtcclxuICAgICAgaWYgKCF3ZWJncHVBZGFwdGVyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgJ0ZhaWxlZCB0byBnZXQgR1BVIGFkYXB0ZXIuICcgK1xyXG4gICAgICAgICAgICAnWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaWYgYWRhcHRlciBpcyBzZXQsIHZhbGlkYXRlIGl0LlxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHlwZW9mIHdlYmdwdUFkYXB0ZXIubGltaXRzICE9PSAnb2JqZWN0JyB8fFxyXG4gICAgICAgIHR5cGVvZiB3ZWJncHVBZGFwdGVyLmZlYXR1cmVzICE9PSAnb2JqZWN0JyB8fFxyXG4gICAgICAgIHR5cGVvZiB3ZWJncHVBZGFwdGVyLnJlcXVlc3REZXZpY2UgIT09ICdmdW5jdGlvbidcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdQVSBhZGFwdGVyIHNldCBpbiBgZW52LndlYmdwdS5hZGFwdGVyYC4gSXQgbXVzdCBiZSBhIEdQVUFkYXB0ZXIgb2JqZWN0LicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBwZXJmb3JtIFdlYk5OIGF2YWlsYWJpbGl0eSBjaGVjayAoIGVpdGhlciBKU0VQIG9yIFdlYk5OIEVQIClcclxuICBpZiAoZXBOYW1lID09PSAnd2Vibm4nKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIShuYXZpZ2F0b3IgYXMgdW5rbm93biBhcyB7IG1sOiB1bmtub3duIH0pLm1sKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xyXG4gICAgY29uc3QgaW5pdEpzZXAgPSByZXF1aXJlKCcuL2pzZXAvaW5pdCcpLmluaXQ7XHJcblxyXG4gICAgaWYgKGVwTmFtZSA9PT0gJ3dlYmdwdScpIHtcclxuICAgICAgYXdhaXQgaW5pdEpzZXAoJ3dlYmdwdScsIGdldEluc3RhbmNlKCksIGVudiwgd2ViZ3B1QWRhcHRlcik7XHJcbiAgICB9XHJcbiAgICBpZiAoZXBOYW1lID09PSAnd2Vibm4nKSB7XHJcbiAgICAgIGF3YWl0IGluaXRKc2VwKCd3ZWJubicsIGdldEluc3RhbmNlKCksIGVudik7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVSAmJiBlcE5hbWUgPT09ICd3ZWJncHUnKSB7XHJcbiAgICAgIGdldEluc3RhbmNlKCkud2ViZ3B1SW5pdCEoKGRldmljZSkgPT4ge1xyXG4gICAgICAgIGVudi53ZWJncHUuZGV2aWNlID0gZGV2aWNlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQk5OICYmIGVwTmFtZSA9PT0gJ3dlYm5uJykge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xyXG4gICAgICBjb25zdCBiYWNrZW5kID0gbmV3IChyZXF1aXJlKCcuL2pzZXAvYmFja2VuZC13ZWJubicpLldlYk5OQmFja2VuZCkoZW52KTtcclxuICAgICAgZ2V0SW5zdGFuY2UoKS53ZWJubkluaXQhKFtcclxuICAgICAgICBiYWNrZW5kLFxyXG4gICAgICAgIC8vIHdlYm5uUmVzZXJ2ZVRlbnNvcklkXHJcbiAgICAgICAgKCkgPT4gYmFja2VuZC5yZXNlcnZlVGVuc29ySWQoKSxcclxuICAgICAgICAvLyB3ZWJublJlbGVhc2VUZW5zb3JJZCxcclxuICAgICAgICAodGVuc29ySWQ6IG51bWJlcikgPT4gYmFja2VuZC5yZWxlYXNlVGVuc29ySWQodGVuc29ySWQpLFxyXG4gICAgICAgIC8vIHdlYm5uRW5zdXJlVGVuc29yXHJcbiAgICAgICAgYXN5bmMgKHNlc3Npb25JZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB0ZW5zb3JJZDogbnVtYmVyLCBvbm54RGF0YVR5cGU6IG51bWJlciwgc2hhcGU6IG51bWJlcltdLCBjb3B5T2xkKSA9PlxyXG4gICAgICAgICAgYmFja2VuZC5lbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCB0ZW5zb3JJZCwgb25ueERhdGFUeXBlLCBzaGFwZSwgY29weU9sZCksXHJcbiAgICAgICAgLy8gd2Vibm5VcGxvYWRUZW5zb3JcclxuICAgICAgICAodGVuc29ySWQ6IG51bWJlciwgZGF0YTogVWludDhBcnJheSkgPT4ge1xyXG4gICAgICAgICAgYmFja2VuZC51cGxvYWRUZW5zb3IodGVuc29ySWQsIGRhdGEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gd2Vibm5Eb3dubG9hZFRlbnNvclxyXG4gICAgICAgIGFzeW5jICh0ZW5zb3JJZDogbnVtYmVyLCBkc3RCdWZmZXI6IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKSA9PlxyXG4gICAgICAgICAgYmFja2VuZC5kb3dubG9hZFRlbnNvcih0ZW5zb3JJZCwgZHN0QnVmZmVyKSxcclxuICAgICAgICAvLyB3ZWJublJlZ2lzdGVyTUxDb250ZXh0XHJcbiAgICAgICAgKHNlc3Npb25JZDogbnVtYmVyLCBtbENvbnRleHQ6IE1MQ29udGV4dCkgPT4gYmFja2VuZC5yZWdpc3Rlck1MQ29udGV4dChzZXNzaW9uSWQsIG1sQ29udGV4dCksXHJcbiAgICAgICAgLy8gd2Vibm5FbmFibGVUcmFjZUV2ZW50XHJcbiAgICAgICAgISFlbnYudHJhY2UsXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8vICNlbmRyZWdpb24gSW5pdGlhbGl6YXRpb25zXHJcblxyXG4vKipcclxuICogdmFsaWQgZGF0YSBsb2NhdGlvbnMgZm9yIGlucHV0L291dHB1dCB0ZW5zb3JzLlxyXG4gKi9cclxudHlwZSBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dCA9XHJcbiAgfCAnY3B1J1xyXG4gIHwgJ2NwdS1waW5uZWQnXHJcbiAgfCAnZ3B1LWJ1ZmZlcidcclxuICB8ICdtbC10ZW5zb3InXHJcbiAgLy8gVXNlICdtbC10ZW5zb3InIGR1cmluZyBpbmZlcmVuY2UsIGJ1dCBvdXRwdXQgYSB0ZW5zb3IgbG9jYXRlZCBvbiB0aGUgQ1BVLlxyXG4gIHwgJ21sLXRlbnNvci1jcHUtb3V0cHV0JztcclxuXHJcbnR5cGUgSU9CaW5kaW5nU3RhdGUgPSB7XHJcbiAgLyoqXHJcbiAgICogdGhlIGhhbmRsZSBvZiBJTyBiaW5kaW5nLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IGhhbmRsZTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiB0aGUgcHJlZmVycmVkIGxvY2F0aW9uIGZvciBlYWNoIG91dHB1dCB0ZW5zb3IuXHJcbiAgICpcclxuICAgKiB2YWx1ZSBpcyBvbmUgb2YgJ2NwdScsICdjcHUtcGlubmVkJywgJ2dwdS1idWZmZXInLCAnbWwtdGVuc29yJy5cclxuICAgKi9cclxuICByZWFkb25seSBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IHJlYWRvbmx5IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W107XHJcblxyXG4gIC8qKlxyXG4gICAqIGVudW0gdmFsdWUgb2YgdGhlIHByZWZlcnJlZCBsb2NhdGlvbiBmb3IgZWFjaCBvdXRwdXQgdGVuc29yLlxyXG4gICAqL1xyXG4gIHJlYWRvbmx5IG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IHJlYWRvbmx5IG51bWJlcltdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqICB0dXBsZSBlbGVtZW50cyBhcmU6IEluZmVyZW5jZVNlc3Npb24gSUQ7IGlucHV0TmFtZXNVVEY4RW5jb2RlZDsgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDsgYmluZGluZ1N0YXRlXHJcbiAqL1xyXG50eXBlIFNlc3Npb25NZXRhZGF0YSA9IFtcclxuICBpbmZlcmVuY2VTZXNzaW9uSWQ6IG51bWJlcixcclxuICBpbnB1dE5hbWVzVVRGOEVuY29kZWQ6IG51bWJlcltdLFxyXG4gIG91dHB1dE5hbWVzVVRGOEVuY29kZWQ6IG51bWJlcltdLFxyXG4gIGJpbmRpbmdTdGF0ZTogSU9CaW5kaW5nU3RhdGUgfCBudWxsLFxyXG4gIGVuYWJsZUdyYXBoQ2FwdHVyZTogYm9vbGVhbixcclxuICBpbnB1dE91dHB1dEJvdW5kOiBib29sZWFuLFxyXG5dO1xyXG5cclxuY29uc3QgYWN0aXZlU2Vzc2lvbnMgPSBuZXcgTWFwPG51bWJlciwgU2Vzc2lvbk1ldGFkYXRhPigpO1xyXG5cclxuLyoqXHJcbiAqIGdldCB0aGUgaW5wdXQvb3V0cHV0IGNvdW50IG9mIHRoZSBzZXNzaW9uLlxyXG4gKiBAcGFyYW0gc2Vzc2lvbkhhbmRsZSB0aGUgaGFuZGxlIHJlcHJlc2VudGluZyB0aGUgc2Vzc2lvbi4gc2hvdWxkIGJlIG5vbi16ZXJvLlxyXG4gKiBAcmV0dXJucyBhIHR1cGxlIGluY2x1ZGluZyAyIG51bWJlcnMsIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgY291bnQgYW5kIG91dHB1dCBjb3VudC5cclxuICovXHJcbmNvbnN0IGdldFNlc3Npb25JbnB1dE91dHB1dENvdW50ID0gKHNlc3Npb25IYW5kbGU6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xyXG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xyXG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcHRyU2l6ZSA9IHdhc20uUFRSX1NJWkU7XHJcbiAgICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDIgKiBwdHJTaXplKTtcclxuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSwgZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIHB0clNpemUpO1xyXG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC5cIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0eXBlID0gcHRyU2l6ZSA9PT0gNCA/ICdpMzInIDogJ2k2NCc7XHJcbiAgICByZXR1cm4gW051bWJlcih3YXNtLmdldFZhbHVlKGRhdGFPZmZzZXQsIHR5cGUpKSwgTnVtYmVyKHdhc20uZ2V0VmFsdWUoZGF0YU9mZnNldCArIHB0clNpemUsIHR5cGUpKV07XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBnZXRTZXNzaW9uSW5wdXRPdXRwdXRNZXRhZGF0YSA9IChcclxuICBzZXNzaW9uSGFuZGxlOiBudW1iZXIsXHJcbiAgaW5kZXg6IG51bWJlcixcclxuKTogW25hbWVPZmZzZXQ6IG51bWJlciwgZWxlbWVudFR5cGU6IG51bWJlciwgZGltcz86IEFycmF5PG51bWJlciB8IHN0cmluZz5dID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XHJcbiAgbGV0IG1ldGFkYXRhT2Zmc2V0ID0gMDtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcHRyU2l6ZSA9IHdhc20uUFRSX1NJWkU7XHJcbiAgICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDIgKiBwdHJTaXplKTtcclxuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0TWV0YWRhdGEoc2Vzc2lvbkhhbmRsZSwgaW5kZXgsIGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBwdHJTaXplKTtcclxuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcclxuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgbWV0YWRhdGEuXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmFtZU9mZnNldCA9IE51bWJlcih3YXNtLmdldFZhbHVlKGRhdGFPZmZzZXQsICcqJykpO1xyXG4gICAgbWV0YWRhdGFPZmZzZXQgPSBOdW1iZXIod2FzbS5nZXRWYWx1ZShkYXRhT2Zmc2V0ICsgcHRyU2l6ZSwgJyonKSk7XHJcbiAgICAvLyBnZXQgZWxlbWVudCB0eXBlXHJcbiAgICBjb25zdCBlbGVtZW50VHlwZSA9IHdhc20uSEVBUDMyW21ldGFkYXRhT2Zmc2V0IC8gNF07XHJcbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IDApIHtcclxuICAgICAgcmV0dXJuIFtuYW1lT2Zmc2V0LCAwXTsgLy8gbm9uLXRlbnNvclxyXG4gICAgfVxyXG5cclxuICAgIC8vIGdldCBkaW1zIGNvdW50XHJcbiAgICBjb25zdCBkaW1zQ291bnQgPSB3YXNtLkhFQVBVMzJbbWV0YWRhdGFPZmZzZXQgLyA0ICsgMV07XHJcbiAgICAvLyBnZXQgZGltc1xyXG4gICAgY29uc3QgZGltczogQXJyYXk8bnVtYmVyIHwgc3RyaW5nPiA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zQ291bnQ7IGkrKykge1xyXG4gICAgICBjb25zdCBzeW1ib2xpY0RpbU5hbWVPZmZzZXQgPSBOdW1iZXIod2FzbS5nZXRWYWx1ZShtZXRhZGF0YU9mZnNldCArIDggKyBpICogcHRyU2l6ZSwgJyonKSk7XHJcbiAgICAgIGRpbXMucHVzaChcclxuICAgICAgICBzeW1ib2xpY0RpbU5hbWVPZmZzZXQgIT09IDBcclxuICAgICAgICAgID8gd2FzbS5VVEY4VG9TdHJpbmcoc3ltYm9saWNEaW1OYW1lT2Zmc2V0KVxyXG4gICAgICAgICAgOiBOdW1iZXIod2FzbS5nZXRWYWx1ZShtZXRhZGF0YU9mZnNldCArIDggKyAoaSArIGRpbXNDb3VudCkgKiBwdHJTaXplLCAnKicpKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBbbmFtZU9mZnNldCwgZWxlbWVudFR5cGUsIGRpbXNdO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XHJcbiAgICBpZiAobWV0YWRhdGFPZmZzZXQgIT09IDApIHtcclxuICAgICAgd2FzbS5fT3J0RnJlZShtZXRhZGF0YU9mZnNldCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIGFsbG9jYXRlIHRoZSBtZW1vcnkgYW5kIG1lbWNweSB0aGUgZXh0ZXJuYWwgYnVmZmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gbW9kZWwgLSB0aGUgZXh0ZXJuYWwgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIG1vZGVsIGRhdGEuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLlxyXG4gKiBAcmV0dXJucyBhIDItZWxlbWVudHMgdHVwbGUgLSB0aGUgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgYWxsb2NhdGVkIGJ1ZmZlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSAobW9kZWw6IFVpbnQ4QXJyYXkpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuICBjb25zdCBtb2RlbERhdGFPZmZzZXQgPSB3YXNtLl9tYWxsb2MobW9kZWwuYnl0ZUxlbmd0aCk7XHJcbiAgaWYgKG1vZGVsRGF0YU9mZnNldCA9PT0gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLiBmYWlsZWQgdG8gYWxsb2NhdGUgYSBidWZmZXIgb2Ygc2l6ZSAke21vZGVsLmJ5dGVMZW5ndGh9LmApO1xyXG4gIH1cclxuICB3YXNtLkhFQVBVOC5zZXQobW9kZWwsIG1vZGVsRGF0YU9mZnNldCk7XHJcbiAgcmV0dXJuIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsLmJ5dGVMZW5ndGhdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZSBhbiBpbmZlcmVuY2Ugc2Vzc2lvbiBmcm9tIGEgbW9kZWwgZGF0YSBidWZmZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBtb2RlbERhdGEgLSBlaXRoZXIgYSBVaW50OEFycmF5IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG1vZGVsIGRhdGEsIG9yIGEgMi1lbGVtZW50cyB0dXBsZSBjb250YWluaW5nIHRoZVxyXG4gKiAgICAgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgbW9kZWwgZGF0YSBidWZmZXIuXHJcbiAqIEBwYXJhbSBvcHRpb25zIGFuIG9wdGlvbmFsIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXHJcbiAqIEByZXR1cm5zIGEgMy1lbGVtZW50cyB0dXBsZSBjb250YWluaW5nIFtzZXNzaW9uIGhhbmRsZSwgaW5wdXQgbmFtZXMsIG91dHB1dCBuYW1lc11cclxuICovXHJcbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMgKFxyXG4gIG1vZGVsRGF0YTogVWludDhBcnJheSB8IFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLFxyXG4gIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxyXG4pOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xyXG4gIGxldCBtb2RlbERhdGFPZmZzZXQ6IG51bWJlciwgbW9kZWxEYXRhTGVuZ3RoOiBudW1iZXI7XHJcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KG1vZGVsRGF0YSkpIHtcclxuICAgIC8vIGlmIG1vZGVsIGRhdGEgaXMgYW4gYXJyYXksIGl0IG11c3QgYmUgYSAyLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIG1vZGVsIGRhdGFcclxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBtb2RlbERhdGE7XHJcbiAgfSBlbHNlIGlmIChtb2RlbERhdGEuYnVmZmVyID09PSB3YXNtLkhFQVBVOC5idWZmZXIpIHtcclxuICAgIC8vIGlmIG1vZGVsIGRhdGEgdXNlcyB0aGUgc2FtZSBidWZmZXIgYXMgdGhlIFdBU00gaGVhcCwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0LlxyXG4gICAgW21vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoXSA9IFttb2RlbERhdGEuYnl0ZU9mZnNldCwgbW9kZWxEYXRhLmJ5dGVMZW5ndGhdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBvdGhlcndpc2UsIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC5cclxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKG1vZGVsRGF0YSk7XHJcbiAgfVxyXG5cclxuICBsZXQgc2Vzc2lvbkhhbmRsZSA9IDA7XHJcbiAgbGV0IHNlc3Npb25PcHRpb25zSGFuZGxlID0gMDtcclxuICBsZXQgaW9CaW5kaW5nSGFuZGxlID0gMDtcclxuICBsZXQgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xyXG4gIGNvbnN0IGlucHV0TmFtZXNVVEY4RW5jb2RlZCA9IFtdO1xyXG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXSA9IGF3YWl0IHNldFNlc3Npb25PcHRpb25zKG9wdGlvbnMpO1xyXG5cclxuICAgIGlmIChvcHRpb25zPy5leHRlcm5hbERhdGEgJiYgd2FzbS5tb3VudEV4dGVybmFsRGF0YSkge1xyXG4gICAgICBjb25zdCBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcclxuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIG9wdGlvbnMuZXh0ZXJuYWxEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJyA/IGZpbGUgOiBmaWxlLnBhdGg7XHJcbiAgICAgICAgbG9hZGluZ1Byb21pc2VzLnB1c2goXHJcbiAgICAgICAgICBsb2FkRmlsZSh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5kYXRhKS50aGVuKChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIHdhc20ubW91bnRFeHRlcm5hbERhdGEocGF0aCwgZGF0YSk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB3YWl0IGZvciBhbGwgZXh0ZXJuYWwgZGF0YSBmaWxlcyB0byBiZSBsb2FkZWRcclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwobG9hZGluZ1Byb21pc2VzKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIG9wdGlvbnM/LmV4ZWN1dGlvblByb3ZpZGVycyA/PyBbXSkge1xyXG4gICAgICBjb25zdCBwcm92aWRlck5hbWUgPSB0eXBlb2YgcHJvdmlkZXIgPT09ICdzdHJpbmcnID8gcHJvdmlkZXIgOiBwcm92aWRlci5uYW1lO1xyXG4gICAgICBpZiAocHJvdmlkZXJOYW1lID09PSAnd2Vibm4nKSB7XHJcbiAgICAgICAgd2FzbS5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IgPSBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gcHJvdmlkZXIgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xyXG4gICAgICAgICAgY29uc3QgY29udGV4dCA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0KT8uY29udGV4dDtcclxuICAgICAgICAgIGNvbnN0IGdwdURldmljZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTk9wdGlvbnNXZWJHcHUpPy5ncHVEZXZpY2U7XHJcbiAgICAgICAgICBjb25zdCBkZXZpY2VUeXBlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5kZXZpY2VUeXBlO1xyXG4gICAgICAgICAgY29uc3QgcG93ZXJQcmVmZXJlbmNlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5wb3dlclByZWZlcmVuY2U7XHJcbiAgICAgICAgICBpZiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gY29udGV4dCBhcyBNTENvbnRleHQ7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGdwdURldmljZSkge1xyXG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gYXdhaXQgd2FzbS53ZWJubkNyZWF0ZU1MQ29udGV4dCEoZ3B1RGV2aWNlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCB3YXNtLndlYm5uQ3JlYXRlTUxDb250ZXh0ISh7IGRldmljZVR5cGUsIHBvd2VyUHJlZmVyZW5jZSB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGF3YWl0IHdhc20ud2Vibm5DcmVhdGVNTENvbnRleHQhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2Vzc2lvbkhhbmRsZSA9IGF3YWl0IHdhc20uX09ydENyZWF0ZVNlc3Npb24obW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGgsIHNlc3Npb25PcHRpb25zSGFuZGxlKTtcclxuICAgIHdhc20ud2ViZ3B1T25DcmVhdGVTZXNzaW9uPy4oc2Vzc2lvbkhhbmRsZSk7XHJcbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSA9PT0gMCkge1xyXG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHdhc20uanNlcE9uQ3JlYXRlU2Vzc2lvbj8uKCk7XHJcblxyXG4gICAgLy8gY2xlYXIgY3VycmVudCBNTENvbnRleHQgYWZ0ZXIgc2Vzc2lvbiBjcmVhdGlvblxyXG4gICAgaWYgKHdhc20uY3VycmVudENvbnRleHQpIHtcclxuICAgICAgd2FzbS53ZWJublJlZ2lzdGVyTUxDb250ZXh0IShzZXNzaW9uSGFuZGxlLCB3YXNtLmN1cnJlbnRDb250ZXh0KTtcclxuICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IHVuZGVmaW5lZDtcclxuICAgICAgd2FzbS5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFtpbnB1dENvdW50LCBvdXRwdXRDb3VudF0gPSBnZXRTZXNzaW9uSW5wdXRPdXRwdXRDb3VudChzZXNzaW9uSGFuZGxlKTtcclxuXHJcbiAgICBjb25zdCBlbmFibGVHcmFwaENhcHR1cmUgPSAhIW9wdGlvbnM/LmVuYWJsZUdyYXBoQ2FwdHVyZTtcclxuXHJcbiAgICBjb25zdCBpbnB1dE5hbWVzID0gW107XHJcbiAgICBjb25zdCBvdXRwdXROYW1lcyA9IFtdO1xyXG4gICAgY29uc3QgaW5wdXRNZXRhZGF0YTogSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW10gPSBbXTtcclxuICAgIGNvbnN0IG91dHB1dE1ldGFkYXRhOiBJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGFbXSA9IFtdO1xyXG4gICAgY29uc3Qgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOiBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dFtdID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xyXG4gICAgICBjb25zdCBbbmFtZU9mZnNldCwgZWxlbWVudFR5cGUsIHNoYXBlXSA9IGdldFNlc3Npb25JbnB1dE91dHB1dE1ldGFkYXRhKHNlc3Npb25IYW5kbGUsIGkpO1xyXG4gICAgICBpZiAobmFtZU9mZnNldCA9PT0gMCkge1xyXG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWVPZmZzZXQpO1xyXG4gICAgICBjb25zdCBuYW1lID0gd2FzbS5VVEY4VG9TdHJpbmcobmFtZU9mZnNldCk7XHJcbiAgICAgIGlucHV0TmFtZXMucHVzaChuYW1lKTtcclxuICAgICAgaW5wdXRNZXRhZGF0YS5wdXNoKFxyXG4gICAgICAgIGVsZW1lbnRUeXBlID09PSAwXHJcbiAgICAgICAgICA/IHsgbmFtZSwgaXNUZW5zb3I6IGZhbHNlIH1cclxuICAgICAgICAgIDogeyBuYW1lLCBpc1RlbnNvcjogdHJ1ZSwgdHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoZWxlbWVudFR5cGUpLCBzaGFwZTogc2hhcGUhIH0sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcclxuICAgICAgY29uc3QgW25hbWVPZmZzZXQsIGVsZW1lbnRUeXBlLCBzaGFwZV0gPSBnZXRTZXNzaW9uSW5wdXRPdXRwdXRNZXRhZGF0YShzZXNzaW9uSGFuZGxlLCBpICsgaW5wdXRDb3VudCk7XHJcbiAgICAgIGlmIChuYW1lT2Zmc2V0ID09PSAwKSB7XHJcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQucHVzaChuYW1lT2Zmc2V0KTtcclxuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWVPZmZzZXQpO1xyXG4gICAgICBvdXRwdXROYW1lcy5wdXNoKG5hbWVTdHJpbmcpO1xyXG4gICAgICBvdXRwdXRNZXRhZGF0YS5wdXNoKFxyXG4gICAgICAgIGVsZW1lbnRUeXBlID09PSAwXHJcbiAgICAgICAgICA/IHsgbmFtZTogbmFtZVN0cmluZywgaXNUZW5zb3I6IGZhbHNlIH1cclxuICAgICAgICAgIDogeyBuYW1lOiBuYW1lU3RyaW5nLCBpc1RlbnNvcjogdHJ1ZSwgdHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoZWxlbWVudFR5cGUpLCBzaGFwZTogc2hhcGUhIH0sXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQIHx8ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XHJcbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaCgnZ3B1LWJ1ZmZlcicpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID1cclxuICAgICAgICAgIHR5cGVvZiBvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgPyBvcHRpb25zLnByZWZlcnJlZE91dHB1dExvY2F0aW9uXHJcbiAgICAgICAgICAgIDogKG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bbmFtZVN0cmluZ10gPz8gJ2NwdScpO1xyXG4gICAgICAgIGNvbnN0IGlzR3JhcGhPdXRwdXQgPSB3YXNtLndlYm5uSXNHcmFwaE91dHB1dDtcclxuICAgICAgICBpZiAobG9jYXRpb24gPT09ICdjcHUnICYmIGlzR3JhcGhPdXRwdXQgJiYgaXNHcmFwaE91dHB1dChzZXNzaW9uSGFuZGxlLCBuYW1lU3RyaW5nKSkge1xyXG4gICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnB1c2goJ21sLXRlbnNvci1jcHUtb3V0cHV0Jyk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAnY3B1JyAmJiBsb2NhdGlvbiAhPT0gJ2NwdS1waW5uZWQnICYmIGxvY2F0aW9uICE9PSAnZ3B1LWJ1ZmZlcicgJiYgbG9jYXRpb24gIT09ICdtbC10ZW5zb3InKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke2xvY2F0aW9ufS4gT25seSAnZ3B1LWJ1ZmZlcicgbG9jYXRpb24gaXMgc3VwcG9ydGVkIHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5wdXNoKGxvY2F0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHVzZSBJTyBiaW5kaW5nIG9ubHkgd2hlbiBhdCBsZWFzdCBvbmUgb3V0cHV0IGlzIHByZWZlcnJlZCB0byBiZSBvbiBHUFUuXHJcbiAgICBsZXQgYmluZGluZ1N0YXRlOiBJT0JpbmRpbmdTdGF0ZSB8IG51bGwgPSBudWxsO1xyXG4gICAgaWYgKFxyXG4gICAgICAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQIHx8ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSAmJlxyXG4gICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMuc29tZSgobCkgPT4gbCA9PT0gJ2dwdS1idWZmZXInIHx8IGwgPT09ICdtbC10ZW5zb3InIHx8IGwgPT09ICdtbC10ZW5zb3ItY3B1LW91dHB1dCcpXHJcbiAgICApIHtcclxuICAgICAgaW9CaW5kaW5nSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlQmluZGluZyhzZXNzaW9uSGFuZGxlKTtcclxuICAgICAgaWYgKGlvQmluZGluZ0hhbmRsZSA9PT0gMCkge1xyXG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBiaW5kaW5nU3RhdGUgPSB7XHJcbiAgICAgICAgaGFuZGxlOiBpb0JpbmRpbmdIYW5kbGUsXHJcbiAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLFxyXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IG91dHB1dFByZWZlcnJlZExvY2F0aW9uc1xyXG4gICAgICAgICAgLy8gJ21sLXRlbnNvci1jcHUtb3V0cHV0JyBpcyB0cmVhdGVkIGFzICdtbC10ZW5zb3InIGZvciB0aGUgcHVycG9zZSBvZiBJTyBiaW5kaW5nLlxyXG4gICAgICAgICAgLm1hcCgobCkgPT4gKGwgPT09ICdtbC10ZW5zb3ItY3B1LW91dHB1dCcgPyAnbWwtdGVuc29yJyA6IGwpKVxyXG4gICAgICAgICAgLm1hcCgobCkgPT4gZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGwpKSxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBhY3RpdmVTZXNzaW9ucy5zZXQoc2Vzc2lvbkhhbmRsZSwgW1xyXG4gICAgICBzZXNzaW9uSGFuZGxlLFxyXG4gICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQsXHJcbiAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsXHJcbiAgICAgIGJpbmRpbmdTdGF0ZSxcclxuICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxyXG4gICAgICBmYWxzZSxcclxuICAgIF0pO1xyXG4gICAgcmV0dXJuIFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzLCBvdXRwdXROYW1lcywgaW5wdXRNZXRhZGF0YSwgb3V0cHV0TWV0YWRhdGFdO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKChidWYpID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XHJcbiAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcclxuXHJcbiAgICBpZiAoaW9CaW5kaW5nSGFuZGxlICE9PSAwKSB7XHJcbiAgICAgIGlmICh3YXNtLl9PcnRSZWxlYXNlQmluZGluZyhpb0JpbmRpbmdIYW5kbGUpICE9PSAwKSB7XHJcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlc3Npb25IYW5kbGUgIT09IDApIHtcclxuICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpICE9PSAwKSB7XHJcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aHJvdyBlO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICB3YXNtLl9mcmVlKG1vZGVsRGF0YU9mZnNldCk7XHJcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcclxuICAgICAgaWYgKHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSkgIT09IDApIHtcclxuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XHJcblxyXG4gICAgLy8gdW5tb3VudCBleHRlcm5hbCBkYXRhIGlmIG5lY2Vzc2FyeVxyXG4gICAgd2FzbS51bm1vdW50RXh0ZXJuYWxEYXRhPy4oKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcmVsZWFzZVNlc3Npb24gPSAoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XHJcbiAgaWYgKCFzZXNzaW9uKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XHJcbiAgfVxyXG4gIGNvbnN0IFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWQsIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsIGlvQmluZGluZ1N0YXRlLCBlbmFibGVHcmFwaENhcHR1cmVdID0gc2Vzc2lvbjtcclxuXHJcbiAgaWYgKGlvQmluZGluZ1N0YXRlKSB7XHJcbiAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlKSB7XHJcbiAgICAgIGlmICh3YXNtLl9PcnRDbGVhckJvdW5kT3V0cHV0cyhpb0JpbmRpbmdTdGF0ZS5oYW5kbGUpICE9PSAwKSB7XHJcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ1N0YXRlLmhhbmRsZSkgIT09IDApIHtcclxuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgd2FzbS5qc2VwT25SZWxlYXNlU2Vzc2lvbj8uKHNlc3Npb25JZCk7XHJcbiAgd2FzbS53ZWJubk9uUmVsZWFzZVNlc3Npb24/LihzZXNzaW9uSWQpO1xyXG4gIHdhc20ud2ViZ3B1T25SZWxlYXNlU2Vzc2lvbj8uKHNlc3Npb25JZCk7XHJcblxyXG4gIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKChidWYpID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XHJcbiAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKChidWYpID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XHJcbiAgaWYgKHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpICE9PSAwKSB7XHJcbiAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIik7XHJcbiAgfVxyXG4gIGFjdGl2ZVNlc3Npb25zLmRlbGV0ZShzZXNzaW9uSWQpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHByZXBhcmVJbnB1dE91dHB1dFRlbnNvciA9IGFzeW5jIChcclxuICB0ZW5zb3I6IFRlbnNvck1ldGFkYXRhIHwgbnVsbCxcclxuICB0ZW5zb3JIYW5kbGVzOiBudW1iZXJbXSxcclxuICBhbGxvY3M6IG51bWJlcltdLFxyXG4gIHNlc3Npb25JZDogbnVtYmVyLFxyXG4gIHRlbnNvck5hbWVVVEY4RW5jb2RlZDogbnVtYmVyLFxyXG4gIGluZGV4OiBudW1iZXIsXHJcbiAgZW5hYmxlR3JhcGhDYXB0dXJlID0gZmFsc2UsXHJcbik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGlmICghdGVuc29yKSB7XHJcbiAgICB0ZW5zb3JIYW5kbGVzLnB1c2goMCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcclxuXHJcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XHJcbiAgY29uc3QgZGltcyA9IHRlbnNvclsxXTtcclxuICBjb25zdCBsb2NhdGlvbiA9IHRlbnNvclszXTtcclxuICBsZXQgYWN0dWFsTG9jYXRpb24gPSBsb2NhdGlvbjtcclxuXHJcbiAgbGV0IHJhd0RhdGE6IG51bWJlcjtcclxuICBsZXQgZGF0YUJ5dGVMZW5ndGg6IG51bWJlcjtcclxuXHJcbiAgaWYgKGRhdGFUeXBlID09PSAnc3RyaW5nJyAmJiAobG9jYXRpb24gPT09ICdncHUtYnVmZmVyJyB8fCBsb2NhdGlvbiA9PT0gJ21sLXRlbnNvcicpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIGxvY2F0aW9uICE9PSAnZ3B1LWJ1ZmZlcicpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYEV4dGVybmFsIGJ1ZmZlciBtdXN0IGJlIHByb3ZpZGVkIGZvciBpbnB1dC9vdXRwdXQgaW5kZXggJHtpbmRleH0gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGlmIChsb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInKSB7XHJcbiAgICBjb25zdCBncHVCdWZmZXIgPSB0ZW5zb3JbMl0uZ3B1QnVmZmVyO1xyXG4gICAgZGF0YUJ5dGVMZW5ndGggPSBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyh0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIGRpbXMpITtcclxuXHJcbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpIHtcclxuICAgICAgY29uc3QgcmVnaXN0ZXJCdWZmZXIgPSB3YXNtLndlYmdwdVJlZ2lzdGVyQnVmZmVyO1xyXG4gICAgICBpZiAoIXJlZ2lzdGVyQnVmZmVyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmF3RGF0YSA9IHJlZ2lzdGVyQnVmZmVyKGdwdUJ1ZmZlciwgc2Vzc2lvbklkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHJlZ2lzdGVyQnVmZmVyID0gd2FzbS5qc2VwUmVnaXN0ZXJCdWZmZXI7XHJcbiAgICAgIGlmICghcmVnaXN0ZXJCdWZmZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xyXG4gICAgICB9XHJcbiAgICAgIHJhd0RhdGEgPSByZWdpc3RlckJ1ZmZlcihzZXNzaW9uSWQsIGluZGV4LCBncHVCdWZmZXIsIGRhdGFCeXRlTGVuZ3RoKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGxvY2F0aW9uID09PSAnbWwtdGVuc29yJykge1xyXG4gICAgY29uc3QgbWxUZW5zb3IgPSB0ZW5zb3JbMl0ubWxUZW5zb3IgYXMgTUxUZW5zb3I7XHJcbiAgICBkYXRhQnl0ZUxlbmd0aCA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcykhO1xyXG5cclxuICAgIGNvbnN0IHJlZ2lzdGVyTUxUZW5zb3IgPSB3YXNtLndlYm5uUmVnaXN0ZXJNTFRlbnNvcjtcclxuICAgIGlmICghcmVnaXN0ZXJNTFRlbnNvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtcclxuICAgIH1cclxuICAgIHJhd0RhdGEgPSByZWdpc3Rlck1MVGVuc29yKHNlc3Npb25JZCwgbWxUZW5zb3IsIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgLy8gc3RyaW5nIHRlbnNvclxyXG4gICAgICBkYXRhQnl0ZUxlbmd0aCA9IHB0clNpemUgKiBkYXRhLmxlbmd0aDtcclxuICAgICAgcmF3RGF0YSA9IHdhc20uX21hbGxvYyhkYXRhQnl0ZUxlbmd0aCk7XHJcbiAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbaV0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2l9IGlzIG5vdCBhIHN0cmluZ2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3YXNtLnNldFZhbHVlKHJhd0RhdGEgKyBpICogcHRyU2l6ZSwgYWxsb2NXYXNtU3RyaW5nKGRhdGFbaV0sIGFsbG9jcyksICcqJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGlzR3JhcGhJbnB1dCA9IHdhc20ud2Vibm5Jc0dyYXBoSW5wdXQ7XHJcbiAgICAgIGNvbnN0IGlzR3JhcGhPdXRwdXQgPSB3YXNtLndlYm5uSXNHcmFwaE91dHB1dDtcclxuICAgICAgaWYgKGRhdGFUeXBlICE9PSAnc3RyaW5nJyAmJiBpc0dyYXBoSW5wdXQgJiYgaXNHcmFwaE91dHB1dCkge1xyXG4gICAgICAgIGNvbnN0IHRlbnNvck5hbWUgPSB3YXNtLlVURjhUb1N0cmluZyh0ZW5zb3JOYW1lVVRGOEVuY29kZWQpO1xyXG4gICAgICAgIC8vIFByb21vdGUgdGhlIHRlbnNvciB0byAnbWwtdGVuc29yJyBpZiBpdCBpcyBhIGdyYXBoIGlucHV0LlxyXG4gICAgICAgIGlmIChpc0dyYXBoSW5wdXQoc2Vzc2lvbklkLCB0ZW5zb3JOYW1lKSB8fCBpc0dyYXBoT3V0cHV0KHNlc3Npb25JZCwgdGVuc29yTmFtZSkpIHtcclxuICAgICAgICAgIGNvbnN0IGRhdGFUeXBlRW51bSA9IHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKTtcclxuICAgICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGVFbnVtLCBkaW1zKSE7XHJcbiAgICAgICAgICBhY3R1YWxMb2NhdGlvbiA9ICdtbC10ZW5zb3InO1xyXG4gICAgICAgICAgY29uc3QgY3JlYXRlVGVtcG9yYXJ5VGVuc29yID0gd2FzbS53ZWJubkNyZWF0ZVRlbXBvcmFyeVRlbnNvcjtcclxuICAgICAgICAgIGNvbnN0IHVwbG9hZFRlbnNvciA9IHdhc20ud2Vibm5VcGxvYWRUZW5zb3I7XHJcbiAgICAgICAgICBpZiAoIWNyZWF0ZVRlbXBvcmFyeVRlbnNvciB8fCAhdXBsb2FkVGVuc29yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29uc3QgdGVuc29ySWQgPSBhd2FpdCBjcmVhdGVUZW1wb3JhcnlUZW5zb3Ioc2Vzc2lvbklkLCBkYXRhVHlwZUVudW0sIGRpbXMgYXMgbnVtYmVyW10pO1xyXG4gICAgICAgICAgdXBsb2FkVGVuc29yKHRlbnNvcklkLCBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpKTtcclxuICAgICAgICAgIHJhd0RhdGEgPSB0ZW5zb3JJZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGF0YUJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcclxuICAgICAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xyXG4gICAgICAgICAgd2FzbS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGFCeXRlTGVuZ3RoKSwgcmF3RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xyXG4gICAgICAgIHdhc20uSEVBUFU4LnNldChuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhQnl0ZUxlbmd0aCksIHJhd0RhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XHJcbiAgY29uc3QgZGltc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg0ICogZGltcy5sZW5ndGgpO1xyXG4gIHRyeSB7XHJcbiAgICBkaW1zLmZvckVhY2goKGQsIGluZGV4KSA9PiB3YXNtLnNldFZhbHVlKGRpbXNPZmZzZXQgKyBpbmRleCAqIHB0clNpemUsIGQsIHB0clNpemUgPT09IDQgPyAnaTMyJyA6ICdpNjQnKSk7XHJcbiAgICBjb25zdCB0ZW5zb3IgPSB3YXNtLl9PcnRDcmVhdGVUZW5zb3IoXHJcbiAgICAgIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSxcclxuICAgICAgcmF3RGF0YSxcclxuICAgICAgZGF0YUJ5dGVMZW5ndGgsXHJcbiAgICAgIGRpbXNPZmZzZXQsXHJcbiAgICAgIGRpbXMubGVuZ3RoLFxyXG4gICAgICBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0oYWN0dWFsTG9jYXRpb24pLFxyXG4gICAgKTtcclxuICAgIGlmICh0ZW5zb3IgPT09IDApIHtcclxuICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke3Nlc3Npb25JZH0sIGluZGV4PSR7aW5kZXh9LmApO1xyXG4gICAgfVxyXG4gICAgdGVuc29ySGFuZGxlcy5wdXNoKHRlbnNvcik7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogcGVyZm9ybSBpbmZlcmVuY2UgcnVuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxyXG4gIHNlc3Npb25JZDogbnVtYmVyLFxyXG4gIGlucHV0SW5kaWNlczogbnVtYmVyW10sXHJcbiAgaW5wdXRUZW5zb3JzOiBUZW5zb3JNZXRhZGF0YVtdLFxyXG4gIG91dHB1dEluZGljZXM6IG51bWJlcltdLFxyXG4gIG91dHB1dFRlbnNvcnM6IEFycmF5PFRlbnNvck1ldGFkYXRhIHwgbnVsbD4sXHJcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxyXG4pOiBQcm9taXNlPFRlbnNvck1ldGFkYXRhW10+ID0+IHtcclxuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcclxuICBjb25zdCBwdHJTaXplID0gd2FzbS5QVFJfU0laRTtcclxuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XHJcbiAgaWYgKCFzZXNzaW9uKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7c2Vzc2lvbklkfWApO1xyXG4gIH1cclxuICBjb25zdCBzZXNzaW9uSGFuZGxlID0gc2Vzc2lvblswXTtcclxuICBjb25zdCBpbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBzZXNzaW9uWzFdO1xyXG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBzZXNzaW9uWzJdO1xyXG4gIGNvbnN0IGlvQmluZGluZ1N0YXRlID0gc2Vzc2lvblszXTtcclxuICBjb25zdCBlbmFibGVHcmFwaENhcHR1cmUgPSBzZXNzaW9uWzRdO1xyXG4gIGNvbnN0IGlucHV0T3V0cHV0Qm91bmQgPSBzZXNzaW9uWzVdO1xyXG5cclxuICBjb25zdCBpbnB1dENvdW50ID0gaW5wdXRJbmRpY2VzLmxlbmd0aDtcclxuICBjb25zdCBvdXRwdXRDb3VudCA9IG91dHB1dEluZGljZXMubGVuZ3RoO1xyXG5cclxuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XHJcbiAgbGV0IHJ1bk9wdGlvbnNBbGxvY3M6IG51bWJlcltdID0gW107XHJcblxyXG4gIGNvbnN0IGlucHV0VGVuc29ySGFuZGxlczogbnVtYmVyW10gPSBbXTtcclxuICBjb25zdCBvdXRwdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xyXG4gIGNvbnN0IGlucHV0T3V0cHV0QWxsb2NzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICBjb25zdCBiZWZvcmVSdW5TdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XHJcbiAgY29uc3QgaW5wdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoaW5wdXRDb3VudCAqIHB0clNpemUpO1xyXG4gIGNvbnN0IGlucHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoaW5wdXRDb3VudCAqIHB0clNpemUpO1xyXG4gIGNvbnN0IG91dHB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIHB0clNpemUpO1xyXG4gIGNvbnN0IG91dHB1dE5hbWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKG91dHB1dENvdW50ICogcHRyU2l6ZSk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBbcnVuT3B0aW9uc0hhbmRsZSwgcnVuT3B0aW9uc0FsbG9jc10gPSBzZXRSdW5PcHRpb25zKG9wdGlvbnMpO1xyXG5cclxuICAgIFRSQUNFX0VWRU5UX0JFR0lOKCd3YXNtIHByZXBhcmVJbnB1dE91dHB1dFRlbnNvcicpO1xyXG4gICAgLy8gY3JlYXRlIGlucHV0IHRlbnNvcnNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XHJcbiAgICAgIGF3YWl0IHByZXBhcmVJbnB1dE91dHB1dFRlbnNvcihcclxuICAgICAgICBpbnB1dFRlbnNvcnNbaV0sXHJcbiAgICAgICAgaW5wdXRUZW5zb3JIYW5kbGVzLFxyXG4gICAgICAgIGlucHV0T3V0cHV0QWxsb2NzLFxyXG4gICAgICAgIHNlc3Npb25JZCxcclxuICAgICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5wdXRJbmRpY2VzW2ldXSxcclxuICAgICAgICBpbnB1dEluZGljZXNbaV0sXHJcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNyZWF0ZSBvdXRwdXQgdGVuc29yc1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XHJcbiAgICAgIGF3YWl0IHByZXBhcmVJbnB1dE91dHB1dFRlbnNvcihcclxuICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLFxyXG4gICAgICAgIG91dHB1dFRlbnNvckhhbmRsZXMsXHJcbiAgICAgICAgaW5wdXRPdXRwdXRBbGxvY3MsXHJcbiAgICAgICAgc2Vzc2lvbklkLFxyXG4gICAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWRbb3V0cHV0SW5kaWNlc1tpXV0sXHJcbiAgICAgICAgaW5wdXRDb3VudCArIG91dHB1dEluZGljZXNbaV0sXHJcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgVFJBQ0VfRVZFTlRfRU5EKCd3YXNtIHByZXBhcmVJbnB1dE91dHB1dFRlbnNvcicpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XHJcbiAgICAgIHdhc20uc2V0VmFsdWUoaW5wdXRWYWx1ZXNPZmZzZXQgKyBpICogcHRyU2l6ZSwgaW5wdXRUZW5zb3JIYW5kbGVzW2ldLCAnKicpO1xyXG4gICAgICB3YXNtLnNldFZhbHVlKGlucHV0TmFtZXNPZmZzZXQgKyBpICogcHRyU2l6ZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkW2lucHV0SW5kaWNlc1tpXV0sICcqJyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcclxuICAgICAgd2FzbS5zZXRWYWx1ZShvdXRwdXRWYWx1ZXNPZmZzZXQgKyBpICogcHRyU2l6ZSwgb3V0cHV0VGVuc29ySGFuZGxlc1tpXSwgJyonKTtcclxuICAgICAgd2FzbS5zZXRWYWx1ZShvdXRwdXROYW1lc09mZnNldCArIGkgKiBwdHJTaXplLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW291dHB1dEluZGljZXNbaV1dLCAnKicpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQIHx8ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSAmJiBpb0JpbmRpbmdTdGF0ZSAmJiAhaW5wdXRPdXRwdXRCb3VuZCkge1xyXG4gICAgICBjb25zdCB7IGhhbmRsZSwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIH0gPSBpb0JpbmRpbmdTdGF0ZTtcclxuXHJcbiAgICAgIGlmIChpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RoICE9PSBpbnB1dENvdW50KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYGlucHV0IGNvdW50IGZyb20gZmVlZHMgKCR7aW5wdXRDb3VudH0pIGlzIGV4cGVjdGVkIHRvIGJlIGFsd2F5cyBlcXVhbCB0byBtb2RlbCdzIGlucHV0IGNvdW50ICgke2lucHV0TmFtZXNVVEY4RW5jb2RlZC5sZW5ndGh9KS5gLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFRSQUNFX0VWRU5UX0JFR0lOKCd3YXNtIGJpbmRJbnB1dHNPdXRwdXRzJyk7XHJcbiAgICAgIC8vIHByb2Nlc3MgaW5wdXRzXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBpbnB1dEluZGljZXNbaV07XHJcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0QmluZElucHV0KGhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgaW5wdXRUZW5zb3JIYW5kbGVzW2ldKTtcclxuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBpbnB1dFske2l9XSBmb3Igc2Vzc2lvbj0ke3Nlc3Npb25JZH0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBwcm9jZXNzIHByZS1hbGxvY2F0ZWQgb3V0cHV0c1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IG91dHB1dEluZGljZXNbaV07XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBvdXRwdXRUZW5zb3JzW2ldPy5bM107IC8vIHVuZGVmaW5lZCBtZWFucyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuXHJcblxyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgLy8gb3V0cHV0IGlzIHByZS1hbGxvY2F0ZWQuIGJpbmQgdGhlIHRlbnNvci5cclxuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEJpbmRPdXRwdXQoaGFuZGxlLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgb3V0cHV0VGVuc29ySGFuZGxlc1tpXSwgMCk7XHJcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBiaW5kIHByZS1hbGxvY2F0ZWQgb3V0cHV0WyR7aX1dIGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gb3V0cHV0IGlzIG5vdCBwcmUtYWxsb2NhdGVkLiByZXNldCBwcmVmZXJyZWQgbG9jYXRpb24uXHJcbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRCaW5kT3V0cHV0KFxyXG4gICAgICAgICAgICBoYW5kbGUsXHJcbiAgICAgICAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLFxyXG4gICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkW2luZGV4XSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBiaW5kIG91dHB1dFske2l9XSB0byAke291dHB1dFByZWZlcnJlZExvY2F0aW9uc1tpXX0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBUUkFDRV9FVkVOVF9FTkQoJ3dhc20gYmluZElucHV0c091dHB1dHMnKTtcclxuICAgICAgYWN0aXZlU2Vzc2lvbnMuc2V0KHNlc3Npb25JZCwgW1xyXG4gICAgICAgIHNlc3Npb25IYW5kbGUsXHJcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxyXG4gICAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsXHJcbiAgICAgICAgaW9CaW5kaW5nU3RhdGUsXHJcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxyXG4gICAgICAgIHRydWUsXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHdhc20uanNlcE9uUnVuU3RhcnQ/LihzZXNzaW9uSGFuZGxlKTtcclxuICAgIHdhc20ud2Vibm5PblJ1blN0YXJ0Py4oc2Vzc2lvbkhhbmRsZSk7XHJcblxyXG4gICAgbGV0IGVycm9yQ29kZTogbnVtYmVyO1xyXG4gICAgaWYgKCghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgfHwgIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHUFUpICYmIGlvQmluZGluZ1N0YXRlKSB7XHJcbiAgICAgIGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydFJ1bldpdGhCaW5kaW5nKFxyXG4gICAgICAgIHNlc3Npb25IYW5kbGUsXHJcbiAgICAgICAgaW9CaW5kaW5nU3RhdGUuaGFuZGxlLFxyXG4gICAgICAgIG91dHB1dENvdW50LFxyXG4gICAgICAgIG91dHB1dFZhbHVlc09mZnNldCxcclxuICAgICAgICBydW5PcHRpb25zSGFuZGxlLFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0UnVuKFxyXG4gICAgICAgIHNlc3Npb25IYW5kbGUsXHJcbiAgICAgICAgaW5wdXROYW1lc09mZnNldCxcclxuICAgICAgICBpbnB1dFZhbHVlc09mZnNldCxcclxuICAgICAgICBpbnB1dENvdW50LFxyXG4gICAgICAgIG91dHB1dE5hbWVzT2Zmc2V0LFxyXG4gICAgICAgIG91dHB1dENvdW50LFxyXG4gICAgICAgIG91dHB1dFZhbHVlc09mZnNldCxcclxuICAgICAgICBydW5PcHRpb25zSGFuZGxlLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcclxuICAgICAgY2hlY2tMYXN0RXJyb3IoJ2ZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG91dHB1dDogVGVuc29yTWV0YWRhdGFbXSA9IFtdO1xyXG4gICAgY29uc3Qgb3V0cHV0UHJvbWlzZXM6IEFycmF5PFByb21pc2U8W251bWJlciwgVGVuc29yLkRhdGFUeXBlXT4+ID0gW107XHJcblxyXG4gICAgVFJBQ0VfRVZFTlRfQkVHSU4oJ3dhc20gUHJvY2Vzc091dHB1dFRlbnNvcicpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHRlbnNvciA9IE51bWJlcih3YXNtLmdldFZhbHVlKG91dHB1dFZhbHVlc09mZnNldCArIGkgKiBwdHJTaXplLCAnKicpKTtcclxuICAgICAgaWYgKHRlbnNvciA9PT0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXSkge1xyXG4gICAgICAgIC8vIG91dHB1dCB0ZW5zb3IgaXMgcHJlLWFsbG9jYXRlZC4gbm8gbmVlZCB0byBjb3B5IGRhdGEuXHJcbiAgICAgICAgb3V0cHV0LnB1c2gob3V0cHV0VGVuc29yc1tpXSEpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBiZWZvcmVHZXRUZW5zb3JEYXRhU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xyXG4gICAgICAvLyBzdGFjayBhbGxvY2F0ZSA0IHBvaW50ZXIgdmFsdWVcclxuICAgICAgY29uc3QgdGVuc29yRGF0YU9mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg0ICogcHRyU2l6ZSk7XHJcblxyXG4gICAgICBsZXQga2VlcE91dHB1dFRlbnNvciA9IGZhbHNlO1xyXG4gICAgICBsZXQgdHlwZTogVGVuc29yLlR5cGUgfCB1bmRlZmluZWQsXHJcbiAgICAgICAgZGF0YU9mZnNldCA9IDA7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0R2V0VGVuc29yRGF0YShcclxuICAgICAgICAgIHRlbnNvcixcclxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQsXHJcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0ICsgcHRyU2l6ZSxcclxuICAgICAgICAgIHRlbnNvckRhdGFPZmZzZXQgKyAyICogcHRyU2l6ZSxcclxuXHJcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0ICsgMyAqIHB0clNpemUsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XHJcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke2l9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBwdHJTaXplID09PSA0ID8gJ2kzMicgOiAnaTY0JztcclxuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IE51bWJlcih3YXNtLmdldFZhbHVlKHRlbnNvckRhdGFPZmZzZXQsIHZhbHVlVHlwZSkpO1xyXG4gICAgICAgIGRhdGFPZmZzZXQgPSB3YXNtLmdldFZhbHVlKHRlbnNvckRhdGFPZmZzZXQgKyBwdHJTaXplLCAnKicpO1xyXG4gICAgICAgIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLmdldFZhbHVlKHRlbnNvckRhdGFPZmZzZXQgKyBwdHJTaXplICogMiwgJyonKTtcclxuICAgICAgICBjb25zdCBkaW1zTGVuZ3RoID0gTnVtYmVyKHdhc20uZ2V0VmFsdWUodGVuc29yRGF0YU9mZnNldCArIHB0clNpemUgKiAzLCB2YWx1ZVR5cGUpKTtcclxuICAgICAgICBjb25zdCBkaW1zID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGRpbXMucHVzaChOdW1iZXIod2FzbS5nZXRWYWx1ZShkaW1zT2Zmc2V0ICsgaSAqIHB0clNpemUsIHZhbHVlVHlwZSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdhc20uX09ydEZyZWUoZGltc09mZnNldCkgIT09IDApIHtcclxuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZnJlZSBtZW1vcnkgZm9yIHRlbnNvciBkaW1zLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XHJcbiAgICAgICAgdHlwZSA9IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKGRhdGFUeXBlKTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJlZmVycmVkTG9jYXRpb24gPSBpb0JpbmRpbmdTdGF0ZT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW291dHB1dEluZGljZXNbaV1dO1xyXG5cclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInIHx8IHByZWZlcnJlZExvY2F0aW9uID09PSAnbWwtdGVuc29yJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBzdHJpbmdEYXRhOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2FzbS5nZXRWYWx1ZShkYXRhT2Zmc2V0ICsgaSAqIHB0clNpemUsICcqJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSB3YXNtLmdldFZhbHVlKGRhdGFPZmZzZXQgKyAoaSArIDEpICogcHRyU2l6ZSwgJyonKTtcclxuICAgICAgICAgICAgY29uc3QgbWF4Qnl0ZXNUb1JlYWQgPSBpID09PSBzaXplIC0gMSA/IHVuZGVmaW5lZCA6IG5leHRPZmZzZXQgLSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHN0cmluZ0RhdGEucHVzaCh3YXNtLlVURjhUb1N0cmluZyhvZmZzZXQsIG1heEJ5dGVzVG9SZWFkKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgc3RyaW5nRGF0YSwgJ2NwdSddKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gSWYgYSBjZXJ0YWluIG91dHB1dCdzIHByZWZlcnJlZCBsb2NhdGlvbiBpcyBHUFUgYnV0IHRoZSB0ZW5zb3IgaXMgZW1wdHksIHdlIHN0aWxsIG5lZWQgdG8gY3JlYXRlIGEgQ1BVXHJcbiAgICAgICAgICAvLyB0ZW5zb3IgZm9yIGl0LiBUaGVyZSBpcyBubyBtYXBwaW5nIEdQVSBidWZmZXIgZm9yIGFuIGVtcHR5IHRlbnNvci5cclxuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInICYmIHNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdldEJ1ZmZlciA9ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVID8gd2FzbS53ZWJncHVHZXRCdWZmZXIgOiB3YXNtLmpzZXBHZXRCdWZmZXI7XHJcbiAgICAgICAgICAgIGlmICghZ2V0QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGdwdUJ1ZmZlciA9IGdldEJ1ZmZlcihkYXRhT2Zmc2V0KTtcclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyU2l6ZSA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKGRhdGFUeXBlLCBzaXplKTtcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlclNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZG8gbm90IHJlbGVhc2UgdGhlIHRlbnNvciByaWdodCBub3cuIGl0IHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB1c2VyIGNhbGxzIHRlbnNvci5kaXNwb3NlKCkuXHJcbiAgICAgICAgICAgIGtlZXBPdXRwdXRUZW5zb3IgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XHJcbiAgICAgICAgICAgICAgd2FzbS53ZWJncHVSZWdpc3RlckJ1ZmZlciEoZ3B1QnVmZmVyLCBzZXNzaW9uSWQsIGRhdGFPZmZzZXQpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkRGF0YUZ1bmN0aW9uID0gd2FzbS53ZWJncHVDcmVhdGVEb3dubG9hZGVyIShncHVCdWZmZXIsIGJ1ZmZlclNpemUsIHNlc3Npb25JZCk7XHJcbiAgICAgICAgICAgICAgb3V0cHV0LnB1c2goW1xyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIGRpbXMsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGdwdUJ1ZmZlcixcclxuICAgICAgICAgICAgICAgICAgZG93bmxvYWQ6IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGRvd25sb2FkRGF0YUZ1bmN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyAodGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKHR5cGUhKSkoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhIGFzIFRlbnNvci5EYXRhVHlwZU1hcFtUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzXTtcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcikgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgcmVsZWFzZSB0ZW5zb3IuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAnZ3B1LWJ1ZmZlcicsXHJcbiAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgb3V0cHV0LnB1c2goW1xyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIGRpbXMsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIGdwdUJ1ZmZlcixcclxuICAgICAgICAgICAgICAgICAgZG93bmxvYWQ6IHdhc20uanNlcENyZWF0ZURvd25sb2FkZXIhKGdwdUJ1ZmZlciwgYnVmZmVyU2l6ZSwgdHlwZSksXHJcbiAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJ2dwdS1idWZmZXInLFxyXG4gICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnbWwtdGVuc29yJyAmJiBzaXplID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbnN1cmVUZW5zb3IgPSB3YXNtLndlYm5uRW5zdXJlVGVuc29yO1xyXG4gICAgICAgICAgICBjb25zdCBpc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkID0gd2FzbS53ZWJubklzR3JhcGhJbnB1dE91dHB1dFR5cGVTdXBwb3J0ZWQ7XHJcbiAgICAgICAgICAgIGlmICghZW5zdXJlVGVuc29yIHx8ICFpc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0ZW5zb3JTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xyXG4gICAgICAgICAgICBpZiAodGVuc29yU2l6ZSA9PT0gdW5kZWZpbmVkIHx8ICFpc01MVGVuc29yU3VwcG9ydGVkVHlwZSh0eXBlKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0dyYXBoSW5wdXRPdXRwdXRUeXBlU3VwcG9ydGVkKHNlc3Npb25JZCwgdHlwZSwgZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgYHByZWZlcnJlZExvY2F0aW9uIFwibWwtdGVuc29yXCIgZm9yICR7dHlwZX0gb3V0cHV0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgY3VycmVudCBXZWJOTiBDb250ZXh0LmAsXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGdyYXBoIGhhcyBiZWVuIHBhcnRpdGlvbmVkLCB0aGUgb3V0cHV0IHRlbnNvciBtYXkgaGF2ZSBub3QgYmVlbiBjcmVhdGVkLiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZVxyXG4gICAgICAgICAgICAvLyBlbnN1cmVUZW5zb3IgdG8gZ2V0L2NyZWF0ZSB0aGUgTUxUZW5zb3IuIEluIHdoaWNoIGNhc2UsIHdlIGRvbid0IG5lZWQgdG8gY29weSB0aGUgZGF0YSBpZiBhIG5ldyB0ZW5zb3JcclxuICAgICAgICAgICAgLy8gaGFzIGJlZW4gY3JlYXRlZC5cclxuICAgICAgICAgICAgY29uc3QgbWxUZW5zb3IgPSBhd2FpdCBlbnN1cmVUZW5zb3Ioc2Vzc2lvbklkLCBkYXRhT2Zmc2V0LCBkYXRhVHlwZSwgZGltcywgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gZG8gbm90IHJlbGVhc2UgdGhlIHRlbnNvciByaWdodCBub3cuIGl0IHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB1c2VyIGNhbGxzIHRlbnNvci5kaXNwb3NlKCkuXHJcbiAgICAgICAgICAgIGtlZXBPdXRwdXRUZW5zb3IgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goW1xyXG4gICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgZGltcyxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtbFRlbnNvcixcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkOiB3YXNtLndlYm5uQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyIShkYXRhT2Zmc2V0LCB0eXBlKSxcclxuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgd2FzbS53ZWJublJlbGVhc2VUZW5zb3JJZCEoZGF0YU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAnbWwtdGVuc29yJyxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnbWwtdGVuc29yLWNwdS1vdXRwdXQnICYmIHNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB3YXNtLndlYm5uQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyIShkYXRhT2Zmc2V0LCB0eXBlIGFzIFRlbnNvci5NTFRlbnNvckRhdGFUeXBlcykoKTtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvdXRwdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAvLyBEZWxheSB0aGUgZGF0YSBkb3dubG9hZCBhbmQgcmVsZWFzaW5nIHRoZSB0ZW5zb3IgdW50aWwgd2UgY2FuIHdhaXQgZm9yIGFsbCBvdXRwdXQgdGVuc29ycyB0byBiZSBkb3dubG9hZGVkLlxyXG4gICAgICAgICAgICBrZWVwT3V0cHV0VGVuc29yID0gdHJ1ZTtcclxuICAgICAgICAgICAgb3V0cHV0UHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBbbnVtYmVyLCBUZW5zb3IuRGF0YVR5cGVdID0gW2luZGV4LCBhd2FpdCBkYXRhXTtcclxuICAgICAgICAgICAgICAgIHdhc20ud2Vibm5SZWxlYXNlVGVuc29ySWQhKGRhdGFPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgW10sICdjcHUnXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgdHlwZWRBcnJheUNvbnN0cnVjdG9yKHNpemUpO1xyXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpLnNldChcclxuICAgICAgICAgICAgICB3YXNtLkhFQVBVOC5zdWJhcnJheShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goW3R5cGUsIGRpbXMsIGRhdGEsICdjcHUnXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayk7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIGRhdGFPZmZzZXQpIHtcclxuICAgICAgICAgIHdhc20uX2ZyZWUoZGF0YU9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgha2VlcE91dHB1dFRlbnNvcikge1xyXG4gICAgICAgICAgd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChpb0JpbmRpbmdTdGF0ZSAmJiAhZW5hYmxlR3JhcGhDYXB0dXJlKSB7XHJcbiAgICAgIGlmICh3YXNtLl9PcnRDbGVhckJvdW5kT3V0cHV0cyhpb0JpbmRpbmdTdGF0ZS5oYW5kbGUpICE9PSAwKSB7XHJcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKTtcclxuICAgICAgfVxyXG4gICAgICBhY3RpdmVTZXNzaW9ucy5zZXQoc2Vzc2lvbklkLCBbXHJcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcclxuICAgICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQsXHJcbiAgICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCxcclxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcclxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLy8gV2FpdCBmb3IgYWxsIG91dHB1dCB0ZW5zb3IgZGF0YSB0byBiZSBkb3dubG9hZGVkLlxyXG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGRhdGFdIG9mIGF3YWl0IFByb21pc2UuYWxsKG91dHB1dFByb21pc2VzKSkge1xyXG4gICAgICBvdXRwdXRbaW5kZXhdWzJdID0gZGF0YTtcclxuICAgIH1cclxuICAgIFRSQUNFX0VWRU5UX0VORCgnd2FzbSBQcm9jZXNzT3V0cHV0VGVuc29yJyk7XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICB3YXNtLndlYm5uT25SdW5FbmQ/LihzZXNzaW9uSGFuZGxlKTtcclxuXHJcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShiZWZvcmVSdW5TdGFjayk7XHJcblxyXG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XHJcbiAgICAgIGlucHV0VGVuc29ycy5mb3JFYWNoKCh0KSA9PiB7XHJcbiAgICAgICAgaWYgKHQgJiYgdFszXSA9PT0gJ2dwdS1idWZmZXInKSB7XHJcbiAgICAgICAgICB3YXNtLndlYmdwdVVucmVnaXN0ZXJCdWZmZXIhKHRbMl0uZ3B1QnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBvdXRwdXRUZW5zb3JzLmZvckVhY2goKHQpID0+IHtcclxuICAgICAgICBpZiAodCAmJiB0WzNdID09PSAnZ3B1LWJ1ZmZlcicpIHtcclxuICAgICAgICAgIHdhc20ud2ViZ3B1VW5yZWdpc3RlckJ1ZmZlciEodFsyXS5ncHVCdWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpbnB1dFRlbnNvckhhbmRsZXMuZm9yRWFjaCgodikgPT4gd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih2KSk7XHJcbiAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLmZvckVhY2goKHYpID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xyXG4gICAgaW5wdXRPdXRwdXRBbGxvY3MuZm9yRWFjaCgocCkgPT4gd2FzbS5fZnJlZShwKSk7XHJcblxyXG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgIT09IDApIHtcclxuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICBydW5PcHRpb25zQWxsb2NzLmZvckVhY2goKHApID0+IHdhc20uX2ZyZWUocCkpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBlbmQgcHJvZmlsaW5nXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZW5kUHJvZmlsaW5nID0gKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XHJcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xyXG4gIGlmICghc2Vzc2lvbikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNlc3Npb24gaWQnKTtcclxuICB9XHJcbiAgY29uc3Qgc2Vzc2lvbkhhbmRsZSA9IHNlc3Npb25bMF07XHJcblxyXG4gIC8vIHByb2ZpbGUgZmlsZSBuYW1lIGlzIG5vdCB1c2VkIHlldCwgYnV0IGl0IG11c3QgYmUgZnJlZWQuXHJcbiAgY29uc3QgcHJvZmlsZUZpbGVOYW1lID0gd2FzbS5fT3J0RW5kUHJvZmlsaW5nKHNlc3Npb25IYW5kbGUpO1xyXG4gIGlmIChwcm9maWxlRmlsZU5hbWUgPT09IDApIHtcclxuICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKTtcclxuICB9XHJcbiAgd2FzbS5fT3J0RnJlZShwcm9maWxlRmlsZU5hbWUpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzID0gKHRlbnNvcnM6IHJlYWRvbmx5IFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10pOiBBcnJheUJ1ZmZlckxpa2VbXSA9PiB7XHJcbiAgY29uc3QgYnVmZmVyczogQXJyYXlCdWZmZXJMaWtlW10gPSBbXTtcclxuICBmb3IgKGNvbnN0IHRlbnNvciBvZiB0ZW5zb3JzKSB7XHJcbiAgICBjb25zdCBkYXRhID0gdGVuc29yWzJdO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpICYmICdidWZmZXInIGluIGRhdGEpIHtcclxuICAgICAgYnVmZmVycy5wdXNoKGRhdGEuYnVmZmVyKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGJ1ZmZlcnM7XHJcbn07XHJcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgZW52LCBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcclxuXHJcbmltcG9ydCB7XHJcbiAgT3J0V2FzbU1lc3NhZ2UsXHJcbiAgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXHJcbiAgU2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhLFxyXG4gIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhLFxyXG4gIFRlbnNvck1ldGFkYXRhLFxyXG59IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xyXG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJy4vd2FzbS1jb3JlLWltcGwnO1xyXG5pbXBvcnQgeyBpbml0aWFsaXplV2ViQXNzZW1ibHkgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XHJcbmltcG9ydCB7XHJcbiAgaW1wb3J0UHJveHlXb3JrZXIsXHJcbiAgaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMsXHJcbiAgaXNFc21JbXBvcnRNZXRhVXJsSGFyZGNvZGVkQXNGaWxlVXJpLFxyXG59IGZyb20gJy4vd2FzbS11dGlscy1pbXBvcnQnO1xyXG5cclxuY29uc3QgaXNQcm94eSA9ICgpOiBib29sZWFuID0+ICEhZW52Lndhc20ucHJveHkgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcclxubGV0IHByb3h5V29ya2VyOiBXb3JrZXIgfCB1bmRlZmluZWQ7XHJcbmxldCBpbml0aWFsaXppbmcgPSBmYWxzZTtcclxubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XHJcbmxldCBhYm9ydGVkID0gZmFsc2U7XHJcbmxldCB0ZW1wb3JhcnlPYmplY3RVcmw6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuXHJcbnR5cGUgUHJvbWlzZUNhbGxiYWNrczxUID0gdm9pZD4gPSBbcmVzb2x2ZTogKHJlc3VsdDogVCkgPT4gdm9pZCwgcmVqZWN0OiAocmVhc29uOiB1bmtub3duKSA9PiB2b2lkXTtcclxubGV0IGluaXRXYXNtQ2FsbGJhY2tzOiBQcm9taXNlQ2FsbGJhY2tzO1xyXG5jb25zdCBxdWV1ZWRDYWxsYmFja3M6IE1hcDxPcnRXYXNtTWVzc2FnZVsndHlwZSddLCBBcnJheTxQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+Pj4gPSBuZXcgTWFwKCk7XHJcblxyXG5jb25zdCBlbnF1ZXVlQ2FsbGJhY2tzID0gKHR5cGU6IE9ydFdhc21NZXNzYWdlWyd0eXBlJ10sIGNhbGxiYWNrczogUHJvbWlzZUNhbGxiYWNrczx1bmtub3duPik6IHZvaWQgPT4ge1xyXG4gIGNvbnN0IHF1ZXVlID0gcXVldWVkQ2FsbGJhY2tzLmdldCh0eXBlKTtcclxuICBpZiAocXVldWUpIHtcclxuICAgIHF1ZXVlLnB1c2goY2FsbGJhY2tzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcXVldWVkQ2FsbGJhY2tzLnNldCh0eXBlLCBbY2FsbGJhY2tzXSk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZW5zdXJlV29ya2VyID0gKCk6IHZvaWQgPT4ge1xyXG4gIGlmIChpbml0aWFsaXppbmcgfHwgIWluaXRpYWxpemVkIHx8IGFib3J0ZWQgfHwgIXByb3h5V29ya2VyKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmtlciBub3QgcmVhZHknKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBvblByb3h5V29ya2VyTWVzc2FnZSA9IChldjogTWVzc2FnZUV2ZW50PE9ydFdhc21NZXNzYWdlPik6IHZvaWQgPT4ge1xyXG4gIHN3aXRjaCAoZXYuZGF0YS50eXBlKSB7XHJcbiAgICBjYXNlICdpbml0LXdhc20nOlxyXG4gICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcclxuICAgICAgaWYgKGV2LmRhdGEuZXJyKSB7XHJcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgaW5pdFdhc21DYWxsYmFja3NbMV0oZXYuZGF0YS5lcnIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICBpbml0V2FzbUNhbGxiYWNrc1swXSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0ZW1wb3JhcnlPYmplY3RVcmwpIHtcclxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRlbXBvcmFyeU9iamVjdFVybCk7XHJcbiAgICAgICAgdGVtcG9yYXJ5T2JqZWN0VXJsID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnaW5pdC1lcCc6XHJcbiAgICBjYXNlICdjb3B5LWZyb20nOlxyXG4gICAgY2FzZSAnY3JlYXRlJzpcclxuICAgIGNhc2UgJ3JlbGVhc2UnOlxyXG4gICAgY2FzZSAncnVuJzpcclxuICAgIGNhc2UgJ2VuZC1wcm9maWxpbmcnOiB7XHJcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlZENhbGxiYWNrcy5nZXQoZXYuZGF0YS50eXBlKSE7XHJcbiAgICAgIGlmIChldi5kYXRhLmVycikge1xyXG4gICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpIVsxXShldi5kYXRhLmVycik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkhWzBdKGV2LmRhdGEub3V0ISk7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0OlxyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGlmIChpbml0aWFsaXplZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO1xyXG4gIH1cclxuICBpZiAoYWJvcnRlZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtcclxuICB9XHJcblxyXG4gIGluaXRpYWxpemluZyA9IHRydWU7XHJcblxyXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBwcm94eVdvcmtlcj8udGVybWluYXRlKCk7XHJcblxyXG4gICAgICB2b2lkIGltcG9ydFByb3h5V29ya2VyKCkudGhlbigoW29iamVjdFVybCwgd29ya2VyXSkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBwcm94eVdvcmtlciA9IHdvcmtlcjtcclxuICAgICAgICAgIHByb3h5V29ya2VyLm9uZXJyb3IgPSAoZXY6IEVycm9yRXZlbnQpID0+IHJlamVjdChldik7XHJcbiAgICAgICAgICBwcm94eVdvcmtlci5vbm1lc3NhZ2UgPSBvblByb3h5V29ya2VyTWVzc2FnZTtcclxuICAgICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzID0gW3Jlc29sdmUsIHJlamVjdF07XHJcbiAgICAgICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2luaXQtd2FzbScsIGluOiBlbnYgfTtcclxuXHJcbiAgICAgICAgICAvLyBpZiB0aGUgcHJveHkgd29ya2VyIGlzIGxvYWRlZCBmcm9tIGEgYmxvYiBVUkwsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBwYXRoIGluZm9ybWF0aW9uIGlzIG5vdCBsb3N0LlxyXG4gICAgICAgICAgLy9cclxuICAgICAgICAgIC8vIHdoZW4gYGVudi53YXNtLndhc21QYXRoc2AgaXMgbm90IHNldCwgd2UgbmVlZCB0byBwYXNzIHRoZSBwYXRoIGluZm9ybWF0aW9uIHRvIHRoZSB3b3JrZXIuXHJcbiAgICAgICAgICAvL1xyXG4gICAgICAgICAgaWYgKCFCVUlMRF9ERUZTLkVOQUJMRV9CVU5ETEVfV0FTTV9KUyAmJiAhbWVzc2FnZS5pbiEud2FzbS53YXNtUGF0aHMgJiYgb2JqZWN0VXJsKSB7XHJcbiAgICAgICAgICAgIC8vIGZvciBhIGJ1aWxkIG5vdCBidW5kbGVkIHRoZSB3YXNtIEpTLCB3ZSBuZWVkIHRvIHBhc3MgdGhlIHBhdGggcHJlZml4IHRvIHRoZSB3b3JrZXIuXHJcbiAgICAgICAgICAgIC8vIHRoZSBwYXRoIHByZWZpeCB3aWxsIGJlIHVzZWQgdG8gcmVzb2x2ZSB0aGUgcGF0aCB0byBib3RoIHRoZSB3YXNtIEpTIGFuZCB0aGUgd2FzbSBmaWxlLlxyXG4gICAgICAgICAgICBjb25zdCBpbmZlcnJlZFdhc21QYXRoUHJlZml4ID0gaW5mZXJXYXNtUGF0aFByZWZpeEZyb21TY3JpcHRTcmMoKTtcclxuICAgICAgICAgICAgaWYgKGluZmVycmVkV2FzbVBhdGhQcmVmaXgpIHtcclxuICAgICAgICAgICAgICBtZXNzYWdlLmluIS53YXNtLndhc21QYXRocyA9IGluZmVycmVkV2FzbVBhdGhQcmVmaXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIEJVSUxEX0RFRlMuSVNfRVNNICYmXHJcbiAgICAgICAgICAgIEJVSUxEX0RFRlMuRU5BQkxFX0JVTkRMRV9XQVNNX0pTICYmXHJcbiAgICAgICAgICAgICFtZXNzYWdlLmluIS53YXNtLndhc21QYXRocyAmJlxyXG4gICAgICAgICAgICAob2JqZWN0VXJsIHx8IGlzRXNtSW1wb3J0TWV0YVVybEhhcmRjb2RlZEFzRmlsZVVyaSlcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAvLyBmb3IgYSBidWlsZCBidW5kbGVkIHRoZSB3YXNtIEpTLCBpZiBlaXRoZXIgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGlzIG1ldDpcclxuICAgICAgICAgICAgLy8gLSB0aGUgcHJveHkgd29ya2VyIGlzIGxvYWRlZCBmcm9tIGEgYmxvYiBVUkxcclxuICAgICAgICAgICAgLy8gLSBgaW1wb3J0Lm1ldGEudXJsYCBpcyBhIGZpbGUgVVJMLCBpdCBtZWFucyBpdCBpcyBvdmVyd3JpdHRlbiBieSB0aGUgYnVuZGxlci5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gaW4gZWl0aGVyIGNhc2UsIHRoZSBwYXRoIGluZm9ybWF0aW9uIGlzIGxvc3QsIHdlIG5lZWQgdG8gcGFzcyB0aGUgcGF0aCBvZiB0aGUgLndhc20gZmlsZSB0byB0aGUgd29ya2VyLlxyXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHVzZSB0aGUgYnVuZGxlciBwcmVmZXJyZWQgVVJMIGZvcm1hdDpcclxuICAgICAgICAgICAgLy8gbmV3IFVSTCgnZmlsZW5hbWUnLCBpbXBvcnQubWV0YS51cmwpXHJcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGJ1bmRsZXIgY2FuIGhhbmRsZSB0aGUgZmlsZSB1c2luZyBjb3JyZXNwb25kaW5nIGxvYWRlcnMuXHJcbiAgICAgICAgICAgIG1lc3NhZ2UuaW4hLndhc20ud2FzbVBhdGhzID0ge1xyXG4gICAgICAgICAgICAgIHdhc206ICFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUFxyXG4gICAgICAgICAgICAgICAgPyBuZXcgVVJMKCdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbScsIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCkuaHJlZlxyXG4gICAgICAgICAgICAgICAgOiAhQlVJTERfREVGUy5ESVNBQkxFX1dFQkdQVVxyXG4gICAgICAgICAgICAgICAgICA/IG5ldyBVUkwoJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQuYXN5bmNpZnkud2FzbScsIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCkuaHJlZlxyXG4gICAgICAgICAgICAgICAgICA6IG5ldyBVUkwoJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbScsIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCkuaHJlZixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHByb3h5V29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgdGVtcG9yYXJ5T2JqZWN0VXJsID0gb2JqZWN0VXJsO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIHJlamVjdCk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KGVudi53YXNtKTtcclxuICAgICAgYXdhaXQgY29yZS5pbml0UnVudGltZShlbnYpO1xyXG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGFib3J0ZWQgPSB0cnVlO1xyXG4gICAgICB0aHJvdyBlO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVPcnRFcCA9IGFzeW5jIChlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XHJcbiAgICBlbnN1cmVXb3JrZXIoKTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2luaXQtZXAnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnaW5pdC1lcCcsIGluOiB7IGVwTmFtZSwgZW52IH0gfTtcclxuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGF3YWl0IGNvcmUuaW5pdEVwKGVudiwgZXBOYW1lKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29weUZyb21FeHRlcm5hbEJ1ZmZlciA9IGFzeW5jIChidWZmZXI6IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiA9PiB7XHJcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcclxuICAgIGVuc3VyZVdvcmtlcigpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2NvcHktZnJvbScsIFtyZXNvbHZlLCByZWplY3RdKTtcclxuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdjb3B5LWZyb20nLCBpbjogeyBidWZmZXIgfSB9O1xyXG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgW2J1ZmZlci5idWZmZXJdKTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gY29yZS5jb3B5RnJvbUV4dGVybmFsQnVmZmVyKGJ1ZmZlcik7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNlc3Npb24gPSBhc3luYyAoXHJcbiAgbW9kZWw6IFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyIHwgVWludDhBcnJheSxcclxuICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcclxuKTogUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+ID0+IHtcclxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xyXG4gICAgLy8gY2hlY2sgdW5zdXBwb3J0ZWQgb3B0aW9uc1xyXG4gICAgaWYgKG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xyXG4gICAgfVxyXG4gICAgZW5zdXJlV29ya2VyKCk7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2NyZWF0ZScsIFtyZXNvbHZlLCByZWplY3RdKTtcclxuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdjcmVhdGUnLCBpbjogeyBtb2RlbCwgb3B0aW9uczogeyAuLi5vcHRpb25zIH0gfSB9O1xyXG4gICAgICBjb25zdCB0cmFuc2ZlcmFibGU6IFRyYW5zZmVyYWJsZVtdID0gW107XHJcbiAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICB0cmFuc2ZlcmFibGUucHVzaChtb2RlbC5idWZmZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcmFibGUpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBjb3JlLmNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCByZWxlYXNlU2Vzc2lvbiA9IGFzeW5jIChzZXNzaW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xyXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XHJcbiAgICBlbnN1cmVXb3JrZXIoKTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3JlbGVhc2UnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAncmVsZWFzZScsIGluOiBzZXNzaW9uSWQgfTtcclxuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvcmUucmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMgKFxyXG4gIHNlc3Npb25JZDogbnVtYmVyLFxyXG4gIGlucHV0SW5kaWNlczogbnVtYmVyW10sXHJcbiAgaW5wdXRzOiBUZW5zb3JNZXRhZGF0YVtdLFxyXG4gIG91dHB1dEluZGljZXM6IG51bWJlcltdLFxyXG4gIG91dHB1dHM6IEFycmF5PFRlbnNvck1ldGFkYXRhIHwgbnVsbD4sXHJcbiAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxyXG4pOiBQcm9taXNlPFRlbnNvck1ldGFkYXRhW10+ID0+IHtcclxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xyXG4gICAgLy8gY2hlY2sgaW5wdXRzIGxvY2F0aW9uXHJcbiAgICBpZiAoaW5wdXRzLnNvbWUoKHQpID0+IHRbM10gIT09ICdjcHUnKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvciBvbiBHUFUgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBvdXRwdXRzIGxvY2F0aW9uXHJcbiAgICBpZiAob3V0cHV0cy5zb21lKCh0KSA9PiB0KSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcclxuICAgIH1cclxuICAgIGVuc3VyZVdvcmtlcigpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygncnVuJywgW3Jlc29sdmUsIHJlamVjdF0pO1xyXG4gICAgICBjb25zdCBzZXJpYWxpemFibGVJbnB1dHMgPSBpbnB1dHMgYXMgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXTsgLy8gZXZlcnkgaW5wdXQgaXMgb24gQ1BVLlxyXG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHtcclxuICAgICAgICB0eXBlOiAncnVuJyxcclxuICAgICAgICBpbjogeyBzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzOiBzZXJpYWxpemFibGVJbnB1dHMsIG91dHB1dEluZGljZXMsIG9wdGlvbnMgfSxcclxuICAgICAgfTtcclxuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIGNvcmUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMoc2VyaWFsaXphYmxlSW5wdXRzKSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGNvcmUucnVuKHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG91dHB1dHMsIG9wdGlvbnMpO1xyXG4gIH1cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBlbmRQcm9maWxpbmcgPSBhc3luYyAoc2Vzc2lvbklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xyXG4gICAgZW5zdXJlV29ya2VyKCk7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdlbmQtcHJvZmlsaW5nJywgW3Jlc29sdmUsIHJlamVjdF0pO1xyXG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2VuZC1wcm9maWxpbmcnLCBpbjogc2Vzc2lvbklkIH07XHJcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlKTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb3JlLmVuZFByb2ZpbGluZyhzZXNzaW9uSWQpO1xyXG4gIH1cclxufTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG5pbXBvcnQge1xyXG4gIEluZmVyZW5jZVNlc3Npb24sXHJcbiAgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIsXHJcbiAgU2Vzc2lvbkhhbmRsZXIsXHJcbiAgVGVuc29yLFxyXG4gIFRSQUNFX0ZVTkNfQkVHSU4sXHJcbiAgVFJBQ0VfRlVOQ19FTkQsXHJcbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcclxuXHJcbmltcG9ydCB7IFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLCBUZW5zb3JNZXRhZGF0YSB9IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xyXG5pbXBvcnQgeyBjb3B5RnJvbUV4dGVybmFsQnVmZmVyLCBjcmVhdGVTZXNzaW9uLCBlbmRQcm9maWxpbmcsIHJlbGVhc2VTZXNzaW9uLCBydW4gfSBmcm9tICcuL3Byb3h5LXdyYXBwZXInO1xyXG5pbXBvcnQgeyBpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUsIGlzTUxUZW5zb3JTdXBwb3J0ZWRUeXBlIH0gZnJvbSAnLi93YXNtLWNvbW1vbic7XHJcbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4vd2FzbS11dGlscy1lbnYnO1xyXG5pbXBvcnQgeyBsb2FkRmlsZSB9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGVuY29kZVRlbnNvck1ldGFkYXRhID0gKHRlbnNvcjogVGVuc29yLCBnZXROYW1lOiAoKSA9PiBzdHJpbmcpOiBUZW5zb3JNZXRhZGF0YSA9PiB7XHJcbiAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcclxuICAgIGNhc2UgJ2NwdSc6XHJcbiAgICAgIHJldHVybiBbdGVuc29yLnR5cGUsIHRlbnNvci5kaW1zLCB0ZW5zb3IuZGF0YSwgJ2NwdSddO1xyXG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XHJcbiAgICAgIHJldHVybiBbdGVuc29yLnR5cGUsIHRlbnNvci5kaW1zLCB7IGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlciB9LCAnZ3B1LWJ1ZmZlciddO1xyXG4gICAgY2FzZSAnbWwtdGVuc29yJzpcclxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHsgbWxUZW5zb3I6IHRlbnNvci5tbFRlbnNvciB9LCAnbWwtdGVuc29yJ107XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3IubG9jYXRpb259IGZvciAke2dldE5hbWUoKX1gKTtcclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZGVjb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3JNZXRhZGF0YSk6IFRlbnNvciA9PiB7XHJcbiAgc3dpdGNoICh0ZW5zb3JbM10pIHtcclxuICAgIGNhc2UgJ2NwdSc6XHJcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvclswXSwgdGVuc29yWzJdLCB0ZW5zb3JbMV0pO1xyXG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcclxuICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XHJcbiAgICAgIGlmICghaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKGRhdGFUeXBlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZGF0YVR5cGV9IGZvciBkZXNlcmlhbGl6aW5nIEdQVSB0ZW5zb3JgKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB7IGdwdUJ1ZmZlciwgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IHRlbnNvclsyXTtcclxuICAgICAgcmV0dXJuIFRlbnNvci5mcm9tR3B1QnVmZmVyKGdwdUJ1ZmZlciwgeyBkYXRhVHlwZSwgZGltczogdGVuc29yWzFdLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcclxuICAgIH1cclxuICAgIGNhc2UgJ21sLXRlbnNvcic6IHtcclxuICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XHJcbiAgICAgIGlmICghaXNNTFRlbnNvclN1cHBvcnRlZFR5cGUoZGF0YVR5cGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX0gZm9yIGRlc2VyaWFsaXppbmcgTUxUZW5zb3IgdGVuc29yYCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgeyBtbFRlbnNvciwgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IHRlbnNvclsyXTtcclxuICAgICAgcmV0dXJuIFRlbnNvci5mcm9tTUxUZW5zb3IobWxUZW5zb3IsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3JbM119YCk7XHJcbiAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIE9ubnhydW50aW1lV2ViQXNzZW1ibHlTZXNzaW9uSGFuZGxlciBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIHtcclxuICBwcml2YXRlIHNlc3Npb25JZDogbnVtYmVyO1xyXG5cclxuICBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcclxuICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XHJcbiAgaW5wdXRNZXRhZGF0YTogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhW107XHJcbiAgb3V0cHV0TWV0YWRhdGE6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YVtdO1xyXG5cclxuICBhc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiB7XHJcbiAgICAvLyBmZXRjaCBtb2RlbCBmcm9tIHVybCBhbmQgbW92ZSB0byB3YXNtIGhlYXAuXHJcbiAgICByZXR1cm4gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihhd2FpdCBsb2FkRmlsZShwYXRoKSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBsb2FkTW9kZWwocGF0aE9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xyXG4gICAgbGV0IG1vZGVsOiBQYXJhbWV0ZXJzPHR5cGVvZiBjcmVhdGVTZXNzaW9uPlswXTtcclxuXHJcbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgaWYgKGlzTm9kZSkge1xyXG4gICAgICAgIC8vIG5vZGVcclxuICAgICAgICBtb2RlbCA9IGF3YWl0IGxvYWRGaWxlKHBhdGhPckJ1ZmZlcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gYnJvd3NlclxyXG4gICAgICAgIC8vIGZldGNoIG1vZGVsIGFuZCBjb3B5IHRvIHdhc20gaGVhcC5cclxuICAgICAgICBtb2RlbCA9IGF3YWl0IHRoaXMuZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkocGF0aE9yQnVmZmVyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbW9kZWwgPSBwYXRoT3JCdWZmZXI7XHJcbiAgICB9XHJcblxyXG4gICAgW3RoaXMuc2Vzc2lvbklkLCB0aGlzLmlucHV0TmFtZXMsIHRoaXMub3V0cHV0TmFtZXMsIHRoaXMuaW5wdXRNZXRhZGF0YSwgdGhpcy5vdXRwdXRNZXRhZGF0YV0gPSBhd2FpdCBjcmVhdGVTZXNzaW9uKFxyXG4gICAgICBtb2RlbCxcclxuICAgICAgb3B0aW9ucyxcclxuICAgICk7XHJcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHJldHVybiByZWxlYXNlU2Vzc2lvbih0aGlzLnNlc3Npb25JZCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBydW4oXHJcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxyXG4gICAgZmV0Y2hlczogU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsXHJcbiAgICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPiB7XHJcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XHJcbiAgICBjb25zdCBpbnB1dEFycmF5OiBUZW5zb3JbXSA9IFtdO1xyXG4gICAgY29uc3QgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgT2JqZWN0LmVudHJpZXMoZmVlZHMpLmZvckVhY2goKGt2cCkgPT4ge1xyXG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xyXG4gICAgICBjb25zdCB0ZW5zb3IgPSBrdnBbMV07XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbnB1dE5hbWVzLmluZGV4T2YobmFtZSk7XHJcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7bmFtZX0nYCk7XHJcbiAgICAgIH1cclxuICAgICAgaW5wdXRBcnJheS5wdXNoKHRlbnNvcik7XHJcbiAgICAgIGlucHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG91dHB1dEFycmF5OiBBcnJheTxUZW5zb3IgfCBudWxsPiA9IFtdO1xyXG4gICAgY29uc3Qgb3V0cHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcclxuICAgIE9iamVjdC5lbnRyaWVzKGZldGNoZXMpLmZvckVhY2goKGt2cCkgPT4ge1xyXG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xyXG4gICAgICBjb25zdCB0ZW5zb3IgPSBrdnBbMV07XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpO1xyXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHtuYW1lfSdgKTtcclxuICAgICAgfVxyXG4gICAgICBvdXRwdXRBcnJheS5wdXNoKHRlbnNvcik7XHJcbiAgICAgIG91dHB1dEluZGljZXMucHVzaChpbmRleCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBpbnB1dHMgPSBpbnB1dEFycmF5Lm1hcCgodCwgaSkgPT5cclxuICAgICAgZW5jb2RlVGVuc29yTWV0YWRhdGEodCwgKCkgPT4gYGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaW5wdXRJbmRpY2VzW2ldXX1cImApLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IG91dHB1dHMgPSBvdXRwdXRBcnJheS5tYXAoKHQsIGkpID0+XHJcbiAgICAgIHQgPyBlbmNvZGVUZW5zb3JNZXRhZGF0YSh0LCAoKSA9PiBgb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dfVwiYCkgOiBudWxsLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcnVuKHRoaXMuc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0TWFwOiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlID0ge307XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgcmVzdWx0TWFwW3RoaXMub3V0cHV0TmFtZXNbb3V0cHV0SW5kaWNlc1tpXV1dID0gb3V0cHV0QXJyYXlbaV0gPz8gZGVjb2RlVGVuc29yTWV0YWRhdGEocmVzdWx0c1tpXSk7XHJcbiAgICB9XHJcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdE1hcDtcclxuICB9XHJcblxyXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xyXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHByb2ZpbGluZ1xyXG4gIH1cclxuXHJcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xyXG4gICAgdm9pZCBlbmRQcm9maWxpbmcodGhpcy5zZXNzaW9uSWQpO1xyXG4gIH1cclxufVxyXG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IEJhY2tlbmQsIGVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5cclxuaW1wb3J0IHsgaW5pdGlhbGl6ZU9ydEVwLCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lIH0gZnJvbSAnLi93YXNtL3Byb3h5LXdyYXBwZXInO1xyXG5pbXBvcnQgeyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZSc7XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyBhbGwgZmxhZ3MgZm9yIFdlYkFzc2VtYmx5LlxyXG4gKlxyXG4gKiBUaG9zZSBmbGFncyBhcmUgYWNjZXNzaWJsZSBmcm9tIGBvcnQuZW52Lndhc21gLiBVc2VycyBhcmUgYWxsb3cgdG8gc2V0IHRob3NlIGZsYWdzIGJlZm9yZSB0aGUgZmlyc3QgaW5mZXJlbmNlIHNlc3Npb25cclxuICogYmVpbmcgY3JlYXRlZCwgdG8gb3ZlcnJpZGUgZGVmYXVsdCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRmxhZ3MgPSAoKTogdm9pZCA9PiB7XHJcbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5pbml0VGltZW91dCAhPT0gJ251bWJlcicgfHwgZW52Lndhc20uaW5pdFRpbWVvdXQgPCAwKSB7XHJcbiAgICBlbnYud2FzbS5pbml0VGltZW91dCA9IDA7XHJcbiAgfVxyXG5cclxuICBjb25zdCBzaW1kID0gZW52Lndhc20uc2ltZDtcclxuICBpZiAodHlwZW9mIHNpbWQgIT09ICdib29sZWFuJyAmJiBzaW1kICE9PSB1bmRlZmluZWQgJiYgc2ltZCAhPT0gJ2ZpeGVkJyAmJiBzaW1kICE9PSAncmVsYXhlZCcpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgIGBQcm9wZXJ0eSBcImVudi53YXNtLnNpbWRcIiBpcyBzZXQgdG8gdW5rbm93biB2YWx1ZSBcIiR7c2ltZH1cIi4gUmVzZXQgaXQgdG8gXFxgZmFsc2VcXGAgYW5kIGlnbm9yZSBTSU1EIGZlYXR1cmUgY2hlY2tpbmcuYCxcclxuICAgICk7XHJcbiAgICBlbnYud2FzbS5zaW1kID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGVudi53YXNtLnByb3h5ICE9PSAnYm9vbGVhbicpIHtcclxuICAgIGVudi53YXNtLnByb3h5ID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGVudi53YXNtLnRyYWNlICE9PSAnYm9vbGVhbicpIHtcclxuICAgIGVudi53YXNtLnRyYWNlID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIGVudi53YXNtLm51bVRocmVhZHMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGVudi53YXNtLm51bVRocmVhZHMpIHx8IGVudi53YXNtLm51bVRocmVhZHMgPD0gMCkge1xyXG4gICAgLy8gVGhlIGZvbGxvd2luZyBsb2dpYyBvbmx5IGFwcGxpZXMgd2hlbiBgb3J0LmVudi53YXNtLm51bVRocmVhZHNgIGlzIG5vdCBzZXQgYnkgdXNlci4gV2Ugd2lsbCBhbHdheXMgaG9ub3IgdXNlcidzXHJcbiAgICAvLyBzZXR0aW5nIGlmIGl0IGlzIHByb3ZpZGVkLlxyXG5cclxuICAgIC8vIEJyb3dzZXI6IHdoZW4gY3Jvc3NPcmlnaW5Jc29sYXRlZCBpcyBmYWxzZSwgU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGF2YWlsYWJsZSBzbyBXZWJBc3NlbWJseSB0aHJlYWRzIHdpbGwgbm90XHJcbiAgICAvLyB3b3JrLiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgc2V0IG51bVRocmVhZHMgdG8gMS5cclxuICAgIC8vXHJcbiAgICAvLyBUaGVyZSBpcyBhbiBleGNlcHRpb246IHdoZW4gdGhlIGJyb3dzZXIgaXMgY29uZmlndXJlZCB0byBmb3JjZS1lbmFibGUgU2hhcmVkQXJyYXlCdWZmZXIgKGUuZy4gQ2hyb211aW0gd2l0aFxyXG4gICAgLy8gLS1lbmFibGUtZmVhdHVyZXM9U2hhcmVkQXJyYXlCdWZmZXIpLCBpdCBpcyBwb3NzaWJsZSB0aGF0IGBzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWRgIGlzIGZhbHNlIGFuZFxyXG4gICAgLy8gU2hhcmVkQXJyYXlCdWZmZXIgaXMgYXZhaWxhYmxlIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXN1YWxseSBmb3IgdGVzdGluZy4gSW4gdGhpcyBjYXNlLCAgd2Ugd2lsbCBzdGlsbCBzZXRcclxuICAgIC8vIG51bVRocmVhZHMgdG8gMSBoZXJlLiBJZiB3ZSB3YW50IHRvIGVuYWJsZSBtdWx0aS10aHJlYWRpbmcgaW4gdGVzdCwgd2Ugc2hvdWxkIHNldCBgb3J0LmVudi53YXNtLm51bVRocmVhZHNgIHRvIGFcclxuICAgIC8vIHZhbHVlIGdyZWF0ZXIgdGhhbiAxLlxyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XHJcbiAgICAgIGVudi53YXNtLm51bVRocmVhZHMgPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgbnVtQ3B1TG9naWNhbENvcmVzID1cclxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ25vZGU6b3MnKS5jcHVzKCkubGVuZ3RoIDogbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XHJcbiAgICAgIGVudi53YXNtLm51bVRocmVhZHMgPSBNYXRoLm1pbig0LCBNYXRoLmNlaWwoKG51bUNwdUxvZ2ljYWxDb3JlcyB8fCAxKSAvIDIpKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgT25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQgaW1wbGVtZW50cyBCYWNrZW5kIHtcclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIHRoZSBXZWJBc3NlbWJseSBiYWNrZW5kLlxyXG4gICAqXHJcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UgZm9yIGVhY2ggYmFja2VuZCBuYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSB3aGVuXHJcbiAgICogYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpcyBjYWxsZWQgd2l0aCBhIHJlZ2lzdGVyZWQgYmFja2VuZCBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGJhY2tlbmROYW1lIC0gdGhlIHJlZ2lzdGVyZWQgYmFja2VuZCBuYW1lLlxyXG4gICAqL1xyXG4gIGFzeW5jIGluaXQoYmFja2VuZE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gcG9wdWxhdGUgd2FzbSBmbGFnc1xyXG4gICAgaW5pdGlhbGl6ZUZsYWdzKCk7XHJcblxyXG4gICAgLy8gaW5pdCB3YXNtXHJcbiAgICBhd2FpdCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lKCk7XHJcblxyXG4gICAgLy8gcGVyZm9ybWUgRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb25cclxuICAgIGF3YWl0IGluaXRpYWxpemVPcnRFcChiYWNrZW5kTmFtZSk7XHJcbiAgfVxyXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxyXG4gICAgcGF0aDogc3RyaW5nLFxyXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXHJcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XHJcbiAgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoXHJcbiAgICBidWZmZXI6IFVpbnQ4QXJyYXksXHJcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcclxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcclxuICBhc3luYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihcclxuICAgIHBhdGhPckJ1ZmZlcjogc3RyaW5nIHwgVWludDhBcnJheSxcclxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxyXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+IHtcclxuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyKCk7XHJcbiAgICBhd2FpdCBoYW5kbGVyLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIsIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIGhhbmRsZXI7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgd2FzbUJhY2tlbmQgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQoKTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXHJcblxyXG4vLyBXZSB1c2UgXCJyZXF1aXJlXCIgaW5zdGVhZCBvZiBcImltcG9ydFwiIGhlcmUgYmVjYXVzZSBpbXBvcnQgc3RhdGVtZW50IG11c3QgYmUgcHV0IGluIHRvcCBsZXZlbC4gT3VyIGN1cnJlbnQgY29kZSBkb2VzXHJcbi8vIG5vdCBhbGxvdyBidW5kbGVyIHRvIHRyZWUtc2hha2luZyBjb2RlIGFzIGV4cGVjdGVkIGJlY2F1c2Ugc29tZSBjb2RlcyBhcmUgdHJlYXRlZCBhcyBoYXZpbmcgc2lkZSBlZmZlY3RzLlxyXG4vLyBTbyB3ZSBpbXBvcnQgY29kZSBpbnNpZGUgdGhlIGlmLWNsYXVzZSB0byBhbGxvdyBidW5kbGVyIHJlbW92ZSB0aGUgY29kZSBzYWZlbHkuXHJcblxyXG5leHBvcnQgKiBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5pbXBvcnQgKiBhcyBvcnQgZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcclxuZXhwb3J0IGRlZmF1bHQgb3J0O1xyXG5cclxuaW1wb3J0IHsgcmVnaXN0ZXJCYWNrZW5kLCBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xyXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcclxuXHJcbmlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdMKSB7XHJcbiAgY29uc3Qgb25ueGpzQmFja2VuZCA9IHJlcXVpcmUoJy4vYmFja2VuZC1vbm54anMnKS5vbm54anNCYWNrZW5kO1xyXG4gIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBvbm54anNCYWNrZW5kLCAtMTApO1xyXG59XHJcblxyXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgJ1RoZSBjdXJyZW50IGJ1aWxkIGlzIHNwZWNpZmllZCB0byBlbmFibGUgYm90aCBKU0VQIGFuZCBXZWJHUFUgRVAuIFRoaXMgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbi4gJyArXHJcbiAgICAgICdKU0VQIGFuZCBXZWJHUFUgRVBzIGNhbm5vdCBiZSBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUuJyxcclxuICApO1xyXG59XHJcblxyXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJOTiAmJiBCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCAmJiBCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgJ1RoZSBjdXJyZW50IGJ1aWxkIGlzIHNwZWNpZmllZCB0byBlbmFibGUgV2ViTk4gRVAgd2l0aG91dCBKU0VQIG9yIFdlYkdQVSBFUC4gVGhpcyBpcyBub3QgYSB2YWxpZCBjb25maWd1cmF0aW9uLiAnICtcclxuICAgICAgJ1dlYk5OIEVQIHJlcXVpcmVzIGVpdGhlciBKU0VQIG9yIFdlYkdQVSBFUCB0byBiZSBlbmFibGVkLicsXHJcbiAgKTtcclxufVxyXG5cclxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTSkge1xyXG4gIGNvbnN0IHdhc21CYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLXdhc20nKS53YXNtQmFja2VuZDtcclxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQIHx8ICFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR1BVKSB7XHJcbiAgICByZWdpc3RlckJhY2tlbmQoJ3dlYmdwdScsIHdhc21CYWNrZW5kLCA1KTtcclxuICB9XHJcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCTk4pIHtcclxuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2Vibm4nLCB3YXNtQmFja2VuZCwgNSk7XHJcbiAgfVxyXG4gIHJlZ2lzdGVyQmFja2VuZCgnY3B1Jywgd2FzbUJhY2tlbmQsIDEwKTtcclxuICByZWdpc3RlckJhY2tlbmQoJ3dhc20nLCB3YXNtQmFja2VuZCwgMTApO1xyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LnZlcnNpb25zLCAnd2ViJywgeyB2YWx1ZTogdmVyc2lvbiwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcclxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcblxyXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IC9qcy9zY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLnRzXHJcbi8vIERvIG5vdCBtb2RpZnkgZmlsZSBjb250ZW50IG1hbnVhbGx5LlxyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4yMy4wJztcclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFnQk0sVUFDQSwwQkFZTyxpQkF3Q1AsZ0NBd0NPO0FBN0diOzs7QUFnQkEsSUFBTSxXQUFxQyxvQkFBSSxJQUFHO0FBQ2xELElBQU0sMkJBQXFDLENBQUE7QUFZcEMsSUFBTSxrQkFBa0IsQ0FBQyxNQUFjLFNBQWtCLGFBQTBCO0FBQ3hGLFVBQUksV0FBVyxPQUFPLFFBQVEsU0FBUyxjQUFjLE9BQU8sUUFBUSxrQ0FBa0MsWUFBWTtBQUNoSCxjQUFNLGlCQUFpQixTQUFTLElBQUksSUFBSTtBQUN4QyxZQUFJLG1CQUFtQixRQUFXO0FBQ2hDLG1CQUFTLElBQUksTUFBTSxFQUFFLFNBQVMsU0FBUSxDQUFFO21CQUMvQixlQUFlLFdBQVcsVUFBVTtBQUU3QzttQkFDUyxlQUFlLGFBQWEsVUFBVTtBQUMvQyxjQUFJLGVBQWUsWUFBWSxTQUFTO0FBQ3RDLGtCQUFNLElBQUksTUFBTSw0QkFBNEIsSUFBSSxvQkFBb0IsUUFBUSxFQUFFOzs7QUFJbEYsWUFBSSxZQUFZLEdBQUc7QUFDakIsZ0JBQU0sSUFBSSx5QkFBeUIsUUFBUSxJQUFJO0FBQy9DLGNBQUksTUFBTSxJQUFJO0FBQ1oscUNBQXlCLE9BQU8sR0FBRyxDQUFDOztBQUd0QyxtQkFBU0EsS0FBSSxHQUFHQSxLQUFJLHlCQUF5QixRQUFRQSxNQUFLO0FBQ3hELGdCQUFJLFNBQVMsSUFBSSx5QkFBeUJBLEVBQUMsQ0FBQyxFQUFHLFlBQVksVUFBVTtBQUNuRSx1Q0FBeUIsT0FBT0EsSUFBRyxHQUFHLElBQUk7QUFDMUM7OztBQUdKLG1DQUF5QixLQUFLLElBQUk7O0FBRXBDOztBQUdGLFlBQU0sSUFBSSxVQUFVLHFC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QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFJO0FBQUEsWUFBSTtBQUFBLFlBQUc7QUFBQSxZQUFJO0FBQUEsWUFBRztBQUFBLFlBQUk7QUFBQSxZQUFHO0FBQUEsWUFBSztBQUFBLFlBQUk7QUFBQSxZQUFLO0FBQUEsWUFBSTtBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFDN0c7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBSztBQUFBLFlBQUs7QUFBQSxZQUFHO0FBQUEsWUFBSTtBQUFBLFVBQzFELENBQUM7QUFBQSxRQUNIO0FBQUEsTUFDRixTQUFTLEdBQUc7QUFDVixlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFFQSxJQUFNLHlCQUF5QixNQUFlO0FBQzVDLFVBQUk7QUFnQkYsZUFBTyxZQUFZO0FBQUEsVUFDakIsSUFBSSxXQUFXO0FBQUEsWUFDYjtBQUFBLFlBQUc7QUFBQSxZQUFJO0FBQUEsWUFBSztBQUFBLFlBQUs7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBSTtBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBSztBQUFBLFlBQUc7QUFBQSxZQUFHO0FBQUEsWUFBRztBQUFBLFlBQUc7QUFBQSxZQUFJO0FBQUEsWUFBSTtBQUFBLFlBQUc7QUFBQSxZQUFJO0FBQUEsWUFBRztBQUFBLFlBQUk7QUFBQSxZQUFHO0FBQUEsWUFBSztBQUFBLFlBQUk7QUFBQSxZQUFJO0FBQUEsWUFBRztBQUFBLFlBQzFHO0FBQUEsWUFBSTtBQUFBLFlBQUk7QUFBQSxZQUFHO0FBQUEsWUFBSztBQUFBLFlBQUk7QUFBQSxZQUFLO0FB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QUFBLE1BQ1Q7QUFBQSxJQUNGO0FBRU8sSUFBTSxjQUFjLElBQUksOEJBQThCO0FBQUE7QUFBQTs7O0FDdEY3RDtBQUNBO0FBR0E7OztBQ1BPLElBQU1DLFdBQVU7OztBREt2QixJQUFPLGdCQUFRO0FBS2YsSUFBSSxPQUEyQjtBQUM3QixRQUFNLGdCQUFnQixLQUE0QjtBQUNsRCxrQkFBZ0IsU0FBUyxlQUFlLEdBQUc7QUFDN0M7QUFFQSxJQUFnQyxPQUE0QjtBQUMxRCxRQUFNLElBQUk7QUFBQSxJQUNSO0FBQUEsRUFFRjtBQUNGO0FBRUEsSUFBaUMsT0FBc0Q7QUFDckYsUUFBTSxJQUFJO0FBQUEsSUFDUjtBQUFBLEVBRUY7QUFDRjtBQUVBLElBQUksTUFBMEI7QUFDNUIsUUFBTUMsZUFBYywwREFBMEI7QUFDOUMsTUFBSSxNQUF3RDtBQUMxRCxvQkFBZ0IsVUFBVUEsY0FBYSxDQUFDO0FBQUEsRUFDMUM7QUFDQSxNQUFJLE1BQTJCO0FBQzdCLG9CQUFnQixTQUFTQSxjQUFhLENBQUM7QUFBQSxFQUN6QztBQUNBLGtCQUFnQixPQUFPQSxjQUFhLEVBQUU7QUFDdEMsa0JBQWdCLFFBQVFBLGNBQWEsRUFBRTtBQUN6QztBQUVBLE9BQU8sZUFBZUMsS0FBSSxVQUFVLE9BQU8sRUFBRSxPQUFPQyxVQUFTLFlBQVksS0FBSyxDQUFDOyIsCiAgIm5hbWVzIjogWyJpIiwgImVudiIsICJGbG9hdDE2QXJyYXkiLCAiVGVuc29yIiwgIlRlbnNvciIsICJJbmZlcmVuY2VTZXNzaW9uIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgImVudiIsICJlbnYiLCAid2FzbSIsICJ3YXNtIiwgIndhc20iLCAibG9jYXRpb24iLCAicGFkIiwgInRlbnNvciIsICJlbnYiLCAibWxDb250ZXh0SW5kZXgiLCAid2FzbSIsICJpbml0IiwgIm9mZnNldHMiLCAiaW5kaWNlcyIsICJpbXBsIiwgInZhbGlkYXRlSW5wdXRzIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiYSIsICJiIiwgInZhbGlkYXRlSW5wdXRzIiwgImkiLCAiaW5wdXRWYXJpYWJsZSIsICJ0cmFuc3Bvc2UiLCAib3V0cHV0VmFyaWFibGUiLCAiaW5uZXJFbGVtZW50U2l6ZSIsICJwYWQiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29udklucHV0cyIsICJ0cmFuc3Bvc2VkV2VpZ2h0IiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInBlcm1GdW5jdGlvbkJvZHkiLCAic3ltYm9sIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJjYWxjdWxhdGVPdXRwdXRTaGFwZSIsICJmYXN0R2VsdSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJpbnB1dHMiLCAib3V0cHV0U2l6ZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAid2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImRhdGFUeXBlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImVudiIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29tcG9uZW50cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJnZXRPdXRwdXRTaGFwZSIsICJhIiwgImIiLCAiYyIsICJmYXN0R2VsdSIsICJlbnYiLCAiaSIsICJlbnYiLCAiZW52IiwgIndhc20iLCAibG9jYXRpb24iLCAiaW5kZXgiLCAidGVuc29yIiwgImVycm9yQ29kZSIsICJpIiwgImluaXRpYWxpemluZyIsICJpbml0aWFsaXplZCIsICJhYm9ydGVkIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJUZW5zb3IiLCAiY29weUZyb21FeHRlcm5hbEJ1ZmZlciIsICJjcmVhdGVTZXNzaW9uIiwgInJlbGVhc2VTZXNzaW9uIiwgInJ1biIsICJlbmRQcm9maWxpbmciLCAiZW52IiwgInZlcnNpb24iLCAid2FzbUJhY2tlbmQiLCAiZW52IiwgInZlcnNpb24iXQp9Cg==
