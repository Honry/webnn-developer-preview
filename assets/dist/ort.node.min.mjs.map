{"version":3,"sources":["../lib/wasm/wasm-utils-env.ts","../lib/wasm/wasm-utils-import.ts","../lib/wasm/wasm-factory.ts","../lib/wasm/wasm-utils.ts","../lib/wasm/run-options.ts","../lib/wasm/session-options.ts","../lib/wasm/wasm-common.ts","../lib/wasm/wasm-utils-load-file.ts","../lib/wasm/wasm-core-impl.ts","../lib/wasm/proxy-wrapper.ts","../lib/wasm/session-handler-inference.ts","../lib/backend-wasm.ts","../lib/index.ts","../lib/version.ts"],"names":["isNode","init_wasm_utils_env","__esmMin","origin","isEsmImportMetaUrlHardcodedAsFileUri","getScriptSrc","scriptSrc","inferWasmPathPrefixFromScriptSrc","isSameOrigin","normalizeUrl","fallbackUrl","preload","dynamicImportDefault","embeddedWasmModule","importWasmModule","init_wasm_utils_import","URL2","filename","prefixOverride","baseUrl","absoluteUrl","blob","url","urlOverride","isMultiThreaded","isWasmOverridden","useEmbeddedModule","wasmModuleFilename","wasmModuleUrl","needPreload","wasm","initialized","initializing","aborted","isMultiThreadSupported","isSimdSupported","isRelaxedSimdSupported","initializeWebAssembly","getInstance","init_wasm_factory","flags","timeout","numThreads","multiThreadSupported","wasmPaths","wasmPrefixOverride","mjsPathOverrideFlag","mjsPathOverride","wasmPathOverrideFlag","wasmPathOverride","wasmBinaryOverride","objectUrl","ortWasmFactory","isTimeout","tasks","resolve","reject","config","fileName","inferredWasmPathPrefix","module","what","allocWasmString","iterateExtraOptions","checkLastError","init_wasm_utils","data","allocs","dataLength","dataOffset","options","prefix","seen","handler","key","value","name","message","stack","ptrSize","paramsOffset","errorCode","errorMessagePointer","errorMessage","setRunOptions","init_run_options","runOptionsHandle","runOptions","tagDataOffset","keyDataOffset","valueDataOffset","e","alloc","getGraphOptimzationLevel","getExecutionMode","appendDefaultOptions","appendSessionConfig","setExecutionProviders","setSessionOptions","init_session_options","graphOptimizationLevel","executionMode","session","ep","sessionOptionsHandle","executionProviders","epName","epOptions","deviceType","webgpuOptions","epNameDataOffset","epOptionsCount","keysOffset","valuesOffset","i","sessionOptions","logIdDataOffset","logSeverityLevel","logVerbosityLevel","optimizedModelFilePathOffset","nameOffset","tensorDataTypeStringToEnum","tensorDataTypeEnumToString","calculateTensorSizeInBytes","tensorTypeToTypedArrayConstructor","logLevelStringToEnum","isGpuBufferSupportedType","isMLTensorSupportedType","dataLocationStringToEnum","init_wasm_common","type","typeProto","dateType","dimsOrSize","elementSize","size","a","b","logLevel","location","loadFile","init_wasm_utils_load_file","file","readFile","createReadStream","stream","chunks","chunk","response","contentLengthHeader","fileSize","reader","buffer","pages","offset","done","chunkSize","TRACE_EVENT_BEGIN","TRACE_EVENT_END","initOrt","initRuntime","initEp","activeSessions","getSessionInputOutputCount","getSessionInputOutputMetadata","copyFromExternalBuffer","createSession","releaseSession","prepareInputOutputTensor","run","endProfiling","init_wasm_core_impl","loggingLevel","env","webgpuAdapter","powerPreference","forceFallbackAdapter","sessionHandle","index","metadataOffset","elementType","dimsCount","dims","symbolicDimNameOffset","model","modelDataOffset","modelData","modelDataLength","ioBindingHandle","inputNamesUTF8Encoded","outputNamesUTF8Encoded","loadingPromises","path","provider","webnnOptions","context","gpuDevice","inputCount","outputCount","enableGraphCapture","inputNames","outputNames","inputMetadata","outputMetadata","outputPreferredLocations","shape","nameString","buf","sessionId","ioBindingState","tensor","tensorHandles","tensorNameUTF8Encoded","dataType","actualLocation","rawData","dataByteLength","gpuBuffer","registerBuffer","mlTensor","registerMLTensor","isGraphInput","isGraphOutput","tensorName","dataTypeEnum","createTemporaryTensor","uploadTensor","tensorId","dimsOffset","d","inputIndices","inputTensors","outputIndices","outputTensors","inputOutputBound","runOptionsAllocs","inputTensorHandles","outputTensorHandles","inputOutputAllocs","beforeRunStack","inputValuesOffset","inputNamesOffset","outputValuesOffset","outputNamesOffset","output","outputPromises","beforeGetTensorDataStack","tensorDataOffset","keepOutputTensor","valueType","dimsLength","preferredLocation","stringData","nextOffset","maxBytesToRead","getBuffer","bufferSize","ensureTensor","isGraphInputOutputTypeSupported","result","typedArrayConstructor","v","p","profileFileName","initializeWebAssemblyAndOrtRuntime","initializeOrtEp","init_proxy_wrapper","inputs","outputs","Tensor","TRACE_FUNC_BEGIN","TRACE_FUNC_END","encodeTensorMetadata","decodeTensorMetadata","OnnxruntimeWebAssemblySessionHandler","init_session_handler_inference","getName","download","dispose","pathOrBuffer","feeds","fetches","inputArray","kvp","outputArray","t","results","resultMap","backend_wasm_exports","__export","OnnxruntimeWebAssemblyBackend","initializeFlags","wasmBackend","init_backend_wasm","simd","numCpuLogicalCores","backendName","ort","registerBackend","version","index_default"],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nexport const isNode = !!(typeof process !== 'undefined' && process.versions && process.versions.node);\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport type { OrtWasmModule } from './wasm-types';\r\nimport { isNode } from './wasm-utils-env';\r\n\r\n/**\r\n * The origin of the current location.\r\n *\r\n * In Node.js, this is undefined.\r\n */\r\nconst origin = isNode || typeof location === 'undefined' ? undefined : location.origin;\r\n\r\n/**\r\n * Some bundlers (eg. Webpack) will rewrite `import.meta.url` to a file URL at compile time.\r\n *\r\n * This function checks if `import.meta.url` starts with `file:`, but using the `>` and `<` operators instead of\r\n * `startsWith` function so that code minimizers can remove the dead code correctly.\r\n *\r\n * For example, if we use terser to minify the following code:\r\n * ```js\r\n * if (\"file://hard-coded-filename\".startsWith(\"file:\")) {\r\n *   console.log(1)\r\n * } else {\r\n *   console.log(2)\r\n * }\r\n *\r\n * if (\"file://hard-coded-filename\" > \"file:\" && \"file://hard-coded-filename\" < \"file;\") {\r\n *   console.log(3)\r\n * } else {\r\n *   console.log(4)\r\n * }\r\n * ```\r\n *\r\n * The minified code will be:\r\n * ```js\r\n * \"file://hard-coded-filename\".startsWith(\"file:\")?console.log(1):console.log(2),console.log(3);\r\n * ```\r\n *\r\n * (use Terser 5.39.0 with default options, https://try.terser.org/)\r\n *\r\n * @returns true if the import.meta.url is hardcoded as a file URI.\r\n */\r\nexport const isEsmImportMetaUrlHardcodedAsFileUri =\r\n  BUILD_DEFS.IS_ESM && BUILD_DEFS.ESM_IMPORT_META_URL! > 'file:' && BUILD_DEFS.ESM_IMPORT_META_URL! < 'file;';\r\n\r\nconst getScriptSrc = (): string | undefined => {\r\n  // if Nodejs, return undefined\r\n  if (isNode) {\r\n    return undefined;\r\n  }\r\n  // if It's ESM, use import.meta.url\r\n  if (BUILD_DEFS.IS_ESM) {\r\n    // For ESM, if the import.meta.url is a file URL, this usually means the bundler rewrites `import.meta.url` to\r\n    // the file path at compile time. In this case, this file path cannot be used to determine the runtime URL.\r\n    //\r\n    // We need to use the URL constructor like this:\r\n    // ```js\r\n    // new URL('actual-bundle-name.js', import.meta.url).href\r\n    // ```\r\n    // So that bundler can preprocess the URL correctly.\r\n    if (isEsmImportMetaUrlHardcodedAsFileUri) {\r\n      // if the rewritten URL is a relative path, we need to use the origin to resolve the URL.\r\n\r\n      // The following is a workaround for Vite.\r\n      //\r\n      // Vite uses a bundler(rollup/rolldown) that does not rewrite `import.meta.url` to a file URL. So in theory, this\r\n      // code path should not be executed in Vite. However, the bundler does not know it and it still try to load the\r\n      // following pattern:\r\n      // - `return new URL('filename', import.meta.url).href`\r\n      //\r\n      // By replacing the pattern above with the following code, we can skip the resource loading behavior:\r\n      // - `const URL2 = URL; return new URL2('filename', import.meta.url).href;`\r\n      //\r\n      // And it still works in Webpack.\r\n      const URL2 = URL;\r\n      return new URL(new URL2(BUILD_DEFS.BUNDLE_FILENAME, BUILD_DEFS.ESM_IMPORT_META_URL).href, origin).href;\r\n    }\r\n\r\n    return BUILD_DEFS.ESM_IMPORT_META_URL;\r\n  }\r\n\r\n  return typeof document !== 'undefined'\r\n    ? (document.currentScript as HTMLScriptElement)?.src\r\n    : // use `self.location.href` if available\r\n      typeof self !== 'undefined'\r\n      ? self.location?.href\r\n      : undefined;\r\n};\r\n\r\n/**\r\n * The classic script source URL. This is not always available in non ESModule environments.\r\n *\r\n * In Node.js, this is undefined.\r\n */\r\nexport const scriptSrc = getScriptSrc();\r\n\r\n/**\r\n * Infer the wasm path prefix from the script source URL.\r\n *\r\n * @returns The inferred wasm path prefix, or undefined if the script source URL is not available or is a blob URL.\r\n */\r\nexport const inferWasmPathPrefixFromScriptSrc = (): string | undefined => {\r\n  if (scriptSrc && !scriptSrc.startsWith('blob:')) {\r\n    return scriptSrc.substring(0, scriptSrc.lastIndexOf('/') + 1);\r\n  }\r\n  return undefined;\r\n};\r\n\r\n/**\r\n * Check if the given filename with prefix is from the same origin.\r\n */\r\nconst isSameOrigin = (filename: string, prefixOverride?: string) => {\r\n  try {\r\n    const baseUrl = prefixOverride ?? scriptSrc;\r\n    const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);\r\n    return url.origin === origin;\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Normalize the inputs to an absolute URL with the given prefix override. If failed, return undefined.\r\n */\r\nconst normalizeUrl = (filename: string, prefixOverride?: string) => {\r\n  const baseUrl = prefixOverride ?? scriptSrc;\r\n  try {\r\n    const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);\r\n    return url.href;\r\n  } catch {\r\n    return undefined;\r\n  }\r\n};\r\n\r\n/**\r\n * Create a fallback URL if an absolute URL cannot be created by the normalizeUrl function.\r\n */\r\nconst fallbackUrl = (filename: string, prefixOverride?: string) => `${prefixOverride ?? './'}${filename}`;\r\n\r\n/**\r\n * This helper function is used to preload a module from a URL.\r\n *\r\n * If the origin of the worker URL is different from the current origin, the worker cannot be loaded directly.\r\n * See discussions in https://github.com/webpack-contrib/worker-loader/issues/154\r\n *\r\n * In this case, we will fetch the worker URL and create a new Blob URL with the same origin as a workaround.\r\n *\r\n * @param absoluteUrl - The absolute URL to preload.\r\n *\r\n * @returns - A promise that resolves to a new Blob URL\r\n */\r\nconst preload = async (absoluteUrl: string): Promise<string> => {\r\n  const response = await fetch(absoluteUrl, { credentials: 'same-origin' });\r\n  const blob = await response.blob();\r\n  return URL.createObjectURL(blob);\r\n};\r\n\r\n/**\r\n * This helper function is used to dynamically import a module from a URL.\r\n *\r\n * The build script has special handling for this function to ensure that the URL is not bundled into the final output.\r\n *\r\n * @param url - The URL to import.\r\n *\r\n * @returns - A promise that resolves to the default export of the module.\r\n */\r\nconst dynamicImportDefault = async <T>(url: string): Promise<T> =>\r\n  (await import(/* webpackIgnore: true */ url)).default;\r\n\r\n/**\r\n * The proxy worker factory imported from the proxy worker module.\r\n *\r\n * This is only available when the WebAssembly proxy is not disabled.\r\n */\r\nconst createProxyWorker: ((urlOverride?: string) => Worker) | undefined =\r\n  // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\r\n  BUILD_DEFS.DISABLE_WASM_PROXY ? undefined : require('./proxy-worker/main').default;\r\n\r\n/**\r\n * Import the proxy worker.\r\n *\r\n * This function will perform the following steps:\r\n * 1. If a preload is needed, it will preload the module and return the object URL.\r\n * 2. Use the proxy worker factory to create the proxy worker.\r\n *\r\n * @returns - A promise that resolves to a tuple of 2 elements:\r\n *            - The object URL of the preloaded module, or undefined if no preload is needed.\r\n *            - The proxy worker.\r\n */\r\nexport const importProxyWorker = async (): Promise<[undefined | string, Worker]> => {\r\n  if (!scriptSrc) {\r\n    throw new Error('Failed to load proxy worker: cannot determine the script source URL.');\r\n  }\r\n\r\n  // If the script source is from the same origin, we can use the embedded proxy module directly.\r\n  if (isSameOrigin(scriptSrc)) {\r\n    return [undefined, createProxyWorker!()];\r\n  }\r\n\r\n  // Otherwise, need to preload\r\n  const url = await preload(scriptSrc);\r\n  return [url, createProxyWorker!(url)];\r\n};\r\n\r\n/**\r\n * The embedded WebAssembly module.\r\n *\r\n * This is only available in ESM and when embedding is not disabled.\r\n */\r\nconst embeddedWasmModule: EmscriptenModuleFactory<OrtWasmModule> | undefined =\r\n  BUILD_DEFS.IS_ESM && BUILD_DEFS.ENABLE_BUNDLE_WASM_JS\r\n    ? // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\r\n      require(\r\n        !BUILD_DEFS.DISABLE_JSEP\r\n          ? '../../dist/ort-wasm-simd-threaded.jsep.mjs'\r\n          : !BUILD_DEFS.DISABLE_WEBGPU\r\n            ? '../../dist/ort-wasm-simd-threaded.asyncify.mjs'\r\n            : '../../dist/ort-wasm-simd-threaded.mjs',\r\n      ).default\r\n    : undefined;\r\n\r\n/**\r\n * Import the WebAssembly module.\r\n *\r\n * This function will perform the following steps:\r\n * 1. If the embedded module exists and no custom URL is specified, use the embedded module.\r\n * 2. If a preload is needed, it will preload the module and return the object URL.\r\n * 3. Otherwise, it will perform a dynamic import of the module.\r\n *\r\n * @returns - A promise that resolves to a tuple of 2 elements:\r\n *            - The object URL of the preloaded module, or undefined if no preload is needed.\r\n *            - The default export of the module, which is a factory function to create the WebAssembly module.\r\n */\r\nexport const importWasmModule = async (\r\n  urlOverride: string | undefined,\r\n  prefixOverride: string | undefined,\r\n  isMultiThreaded: boolean,\r\n  isWasmOverridden: boolean,\r\n): Promise<[undefined | string, EmscriptenModuleFactory<OrtWasmModule>]> => {\r\n  //\r\n  // Check if we should use the embedded module.\r\n  //\r\n\r\n  // To use the embedded module, it should be available, and no URL override or prefix override should be specified.\r\n  let useEmbeddedModule = embeddedWasmModule && !(urlOverride || prefixOverride);\r\n  if (useEmbeddedModule) {\r\n    if (!scriptSrc) {\r\n      // no URL info available.\r\n      //\r\n      // Note: when the embedded module is available, it means the current script is ESM. Usually, in ESM, the\r\n      // `import.meta.url` is available. But in some cases (eg. Cloudflare Workers), the value of `import.meta.url`\r\n      // can be `null` or `undefined`. In this case, we can only load the embedded module when:\r\n      //\r\n      // 1. The WebAssembly module binary is overridden:\r\n      //    ```js\r\n      //    env.wasm.wasmPaths = undefined;  // or not specified\r\n      //    env.wasm.wasmBinary = /* a Uint8Array containing the WebAssembly binary */;\r\n      //    ```\r\n      //\r\n      // 2. The \".wasm\" only is overridden.\r\n      //    ```js\r\n      //    env.wasm.wasmPaths = { wasm: /* URL of the .wasm file */ };\r\n      //    ```\r\n      //\r\n      if (isWasmOverridden && !isMultiThreaded) {\r\n        useEmbeddedModule = true;\r\n      } else {\r\n        throw new Error('cannot determine the script source URL.');\r\n      }\r\n    } else {\r\n      // if the script source is available, we can check if it is from the same origin.\r\n      useEmbeddedModule = isSameOrigin(scriptSrc);\r\n    }\r\n  }\r\n  if (useEmbeddedModule) {\r\n    return [undefined, embeddedWasmModule!];\r\n  } else {\r\n    const wasmModuleFilename = !BUILD_DEFS.DISABLE_JSEP\r\n      ? 'ort-wasm-simd-threaded.jsep.mjs'\r\n      : !BUILD_DEFS.DISABLE_WEBGPU\r\n        ? 'ort-wasm-simd-threaded.asyncify.mjs'\r\n        : 'ort-wasm-simd-threaded.mjs';\r\n    const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);\r\n    // need to preload if all of the following conditions are met:\r\n    // 1. not in Node.js.\r\n    //    - Node.js does not have the same origin policy for creating workers.\r\n    // 2. multi-threaded is enabled.\r\n    //    - If multi-threaded is disabled, no worker will be created. So we don't need to preload the module.\r\n    // 3. the absolute URL is available.\r\n    //    - If the absolute URL is failed to be created, the origin cannot be determined. In this case, we will not\r\n    //    preload the module.\r\n    // 4. the worker URL is not from the same origin.\r\n    //    - If the worker URL is from the same origin, we can create the worker directly.\r\n    const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);\r\n    const url = needPreload\r\n      ? await preload(wasmModuleUrl)\r\n      : (wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride));\r\n    return [needPreload ? url : undefined, await dynamicImportDefault<EmscriptenModuleFactory<OrtWasmModule>>(url)];\r\n  }\r\n};\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Env } from 'onnxruntime-common';\r\n\r\nimport type { OrtWasmModule } from './wasm-types';\r\nimport { importWasmModule, inferWasmPathPrefixFromScriptSrc } from './wasm-utils-import';\r\n\r\nlet wasm: OrtWasmModule | undefined;\r\nlet initialized = false;\r\nlet initializing = false;\r\nlet aborted = false;\r\n\r\nconst isMultiThreadSupported = (): boolean => {\r\n  // If 'SharedArrayBuffer' is not available, WebAssembly threads will not work.\r\n  if (typeof SharedArrayBuffer === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  try {\r\n    // Test for transferability of SABs (for browsers. needed for Firefox)\r\n    // https://groups.google.com/forum/#!msg/mozilla.dev.platform/IHkBZlHETpA/dwsMNchWEQAJ\r\n    if (typeof MessageChannel !== 'undefined') {\r\n      new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));\r\n    }\r\n\r\n    // Test for WebAssembly threads capability (for both browsers and Node.js)\r\n    // This typed array is a WebAssembly program containing threaded instructions.\r\n    return WebAssembly.validate(\r\n      new Uint8Array([\r\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16,\r\n        2, 0, 26, 11,\r\n      ]),\r\n    );\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n};\r\n\r\nconst isSimdSupported = (): boolean => {\r\n  try {\r\n    // Test for WebAssembly SIMD capability (for both browsers and Node.js)\r\n    // This typed array is a WebAssembly program containing SIMD instructions.\r\n\r\n    // The binary data is generated from the following code by wat2wasm:\r\n    //\r\n    // (module\r\n    //   (type $t0 (func))\r\n    //   (func $f0 (type $t0)\r\n    //     (drop\r\n    //       (i32x4.dot_i16x8_s\r\n    //         (i8x16.splat\r\n    //           (i32.const 0))\r\n    //         (v128.const i32x4 0x00000000 0x00000000 0x00000000 0x00000000)))))\r\n\r\n    return WebAssembly.validate(\r\n      new Uint8Array([\r\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11,\r\n      ]),\r\n    );\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n};\r\n\r\nconst isRelaxedSimdSupported = (): boolean => {\r\n  try {\r\n    // Test for WebAssembly Relaxed SIMD capability (for both browsers and Node.js)\r\n    // This typed array is a WebAssembly program containing Relaxed SIMD instructions.\r\n\r\n    // The binary data is generated from the following code by wat2wasm:\r\n    // (module\r\n    //   (func (result v128)\r\n    //      i32.const 1\r\n    //      i8x16.splat\r\n    //      i32.const 2\r\n    //      i8x16.splat\r\n    //      i32.const 3\r\n    //      i8x16.splat\r\n    //      i32x4.relaxed_dot_i8x16_i7x16_add_s\r\n    //   )\r\n    //  )\r\n    return WebAssembly.validate(\r\n      new Uint8Array([\r\n        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 19, 1, 17, 0, 65, 1, 253, 15, 65, 2, 253,\r\n        15, 65, 3, 253, 15, 253, 147, 2, 11,\r\n      ]),\r\n    );\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n};\r\n\r\nexport const initializeWebAssembly = async (flags: Env.WebAssemblyFlags): Promise<void> => {\r\n  if (initialized) {\r\n    return Promise.resolve();\r\n  }\r\n  if (initializing) {\r\n    throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\r\n  }\r\n  if (aborted) {\r\n    throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\r\n  }\r\n\r\n  initializing = true;\r\n\r\n  // wasm flags are already initialized\r\n  const timeout = flags.initTimeout!;\r\n  let numThreads = flags.numThreads!;\r\n\r\n  // ensure SIMD is supported\r\n  if (flags.simd === false) {\r\n    // skip SIMD feature checking as it is disabled explicitly by user\r\n  } else if (flags.simd === 'relaxed') {\r\n    // check if relaxed SIMD is supported\r\n    if (!isRelaxedSimdSupported()) {\r\n      throw new Error('Relaxed WebAssembly SIMD is not supported in the current environment.');\r\n    }\r\n  } else if (!isSimdSupported()) {\r\n    throw new Error('WebAssembly SIMD is not supported in the current environment.');\r\n  }\r\n\r\n  // check if multi-threading is supported\r\n  const multiThreadSupported = isMultiThreadSupported();\r\n  if (numThreads > 1 && !multiThreadSupported) {\r\n    if (typeof self !== 'undefined' && !self.crossOriginIsolated) {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        'env.wasm.numThreads is set to ' +\r\n          numThreads +\r\n          ', but this will not work unless you enable crossOriginIsolated mode. ' +\r\n          'See https://web.dev/cross-origin-isolation-guide/ for more info.',\r\n      );\r\n    }\r\n\r\n    // eslint-disable-next-line no-console\r\n    console.warn(\r\n      'WebAssembly multi-threading is not supported in the current environment. ' + 'Falling back to single-threading.',\r\n    );\r\n\r\n    // set flags.numThreads to 1 so that OrtInit() will not create a global thread pool.\r\n    flags.numThreads = numThreads = 1;\r\n  }\r\n\r\n  const wasmPaths = flags.wasmPaths;\r\n  const wasmPrefixOverride = typeof wasmPaths === 'string' ? wasmPaths : undefined;\r\n  const mjsPathOverrideFlag = (wasmPaths as Env.WasmFilePaths)?.mjs;\r\n  const mjsPathOverride = (mjsPathOverrideFlag as URL)?.href ?? mjsPathOverrideFlag;\r\n  const wasmPathOverrideFlag = (wasmPaths as Env.WasmFilePaths)?.wasm;\r\n  const wasmPathOverride = (wasmPathOverrideFlag as URL)?.href ?? wasmPathOverrideFlag;\r\n  const wasmBinaryOverride = flags.wasmBinary;\r\n\r\n  const [objectUrl, ortWasmFactory] = await importWasmModule(\r\n    mjsPathOverride,\r\n    wasmPrefixOverride,\r\n    numThreads > 1,\r\n    !!wasmBinaryOverride || !!wasmPathOverride,\r\n  );\r\n\r\n  let isTimeout = false;\r\n\r\n  const tasks: Array<Promise<void>> = [];\r\n\r\n  // promise for timeout\r\n  if (timeout > 0) {\r\n    tasks.push(\r\n      new Promise((resolve) => {\r\n        setTimeout(() => {\r\n          isTimeout = true;\r\n          resolve();\r\n        }, timeout);\r\n      }),\r\n    );\r\n  }\r\n\r\n  // promise for module initialization\r\n  tasks.push(\r\n    new Promise((resolve, reject) => {\r\n      const config: Partial<OrtWasmModule> = {\r\n        /**\r\n         * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be\r\n         * created.\r\n         */\r\n        numThreads,\r\n      };\r\n\r\n      if (wasmBinaryOverride) {\r\n        // Set a custom buffer which contains the WebAssembly binary. This will skip the wasm file fetching.\r\n        config.wasmBinary = wasmBinaryOverride;\r\n      } else if (wasmPathOverride || wasmPrefixOverride) {\r\n        // A callback function to locate the WebAssembly file. The function should return the full path of the file.\r\n        //\r\n        // Since Emscripten 3.1.58, this function is only called for the .wasm file.\r\n        config.locateFile = (fileName) => wasmPathOverride ?? wasmPrefixOverride + fileName;\r\n      } else if (mjsPathOverride && mjsPathOverride.indexOf('blob:') !== 0) {\r\n        // if mjs path is specified, use it as the base path for the .wasm file.\r\n        config.locateFile = (fileName) => new URL(fileName, mjsPathOverride).href;\r\n      } else if (objectUrl) {\r\n        const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();\r\n        if (inferredWasmPathPrefix) {\r\n          // if the wasm module is preloaded, use the inferred wasm path as the base path for the .wasm file.\r\n          config.locateFile = (fileName) => inferredWasmPathPrefix + fileName;\r\n        }\r\n      }\r\n\r\n      ortWasmFactory(config).then(\r\n        // wasm module initialized successfully\r\n        (module) => {\r\n          initializing = false;\r\n          initialized = true;\r\n          wasm = module;\r\n          resolve();\r\n          if (objectUrl) {\r\n            URL.revokeObjectURL(objectUrl);\r\n          }\r\n        },\r\n        // wasm module failed to initialize\r\n        (what) => {\r\n          initializing = false;\r\n          aborted = true;\r\n          reject(what);\r\n        },\r\n      );\r\n    }),\r\n  );\r\n\r\n  await Promise.race(tasks);\r\n\r\n  if (isTimeout) {\r\n    throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);\r\n  }\r\n};\r\n\r\nexport const getInstance = (): OrtWasmModule => {\r\n  if (initialized && wasm) {\r\n    return wasm;\r\n  }\r\n\r\n  throw new Error('WebAssembly is not initialized yet.');\r\n};\r\n\r\nexport const dispose = (): void => {\r\n  if (initialized && !initializing && !aborted) {\r\n    // TODO: currently \"PThread.terminateAllThreads()\" is not exposed in the wasm module.\r\n    //       And this function is not yet called by any code.\r\n    //       If it is needed in the future, we should expose it in the wasm module and uncomment the following line.\r\n\r\n    // wasm?.PThread?.terminateAllThreads();\r\n    wasm = undefined;\r\n\r\n    initializing = false;\r\n    initialized = false;\r\n    aborted = true;\r\n  }\r\n};\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { getInstance } from './wasm-factory';\r\n\r\nexport const allocWasmString = (data: string, allocs: number[]): number => {\r\n  const wasm = getInstance();\r\n\r\n  const dataLength = wasm.lengthBytesUTF8(data) + 1;\r\n  const dataOffset = wasm._malloc(dataLength);\r\n  wasm.stringToUTF8(data, dataOffset, dataLength);\r\n  allocs.push(dataOffset);\r\n\r\n  return dataOffset;\r\n};\r\n\r\ninterface ExtraOptionsHandler {\r\n  (name: string, value: string): void;\r\n}\r\n\r\nexport const iterateExtraOptions = (\r\n  options: Record<string, unknown>,\r\n  prefix: string,\r\n  seen: WeakSet<Record<string, unknown>>,\r\n  handler: ExtraOptionsHandler,\r\n): void => {\r\n  if (typeof options == 'object' && options !== null) {\r\n    if (seen.has(options)) {\r\n      throw new Error('Circular reference in options');\r\n    } else {\r\n      seen.add(options);\r\n    }\r\n  }\r\n\r\n  Object.entries(options).forEach(([key, value]) => {\r\n    const name = prefix ? prefix + key : key;\r\n    if (typeof value === 'object') {\r\n      iterateExtraOptions(value as Record<string, unknown>, name + '.', seen, handler);\r\n    } else if (typeof value === 'string' || typeof value === 'number') {\r\n      handler(name, value.toString());\r\n    } else if (typeof value === 'boolean') {\r\n      handler(name, value ? '1' : '0');\r\n    } else {\r\n      throw new Error(`Can't handle extra config type: ${typeof value}`);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * check web assembly API's last error and throw error if any error occurred.\r\n * @param message a message used when an error occurred.\r\n */\r\nexport const checkLastError = (message: string): void => {\r\n  const wasm = getInstance();\r\n\r\n  const stack = wasm.stackSave();\r\n  try {\r\n    const ptrSize = wasm.PTR_SIZE;\r\n    const paramsOffset = wasm.stackAlloc(2 * ptrSize);\r\n    wasm._OrtGetLastError(paramsOffset, paramsOffset + ptrSize);\r\n    const errorCode = Number(wasm.getValue(paramsOffset, ptrSize === 4 ? 'i32' : 'i64'));\r\n    const errorMessagePointer = wasm.getValue(paramsOffset + ptrSize, '*');\r\n    const errorMessage = errorMessagePointer ? wasm.UTF8ToString(errorMessagePointer) : '';\r\n    throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);\r\n  } finally {\r\n    wasm.stackRestore(stack);\r\n  }\r\n};\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { InferenceSession } from 'onnxruntime-common';\r\n\r\nimport { getInstance } from './wasm-factory';\r\nimport { allocWasmString, checkLastError, iterateExtraOptions } from './wasm-utils';\r\n\r\nexport const setRunOptions = (options: InferenceSession.RunOptions): [number, number[]] => {\r\n  const wasm = getInstance();\r\n  let runOptionsHandle = 0;\r\n  const allocs: number[] = [];\r\n\r\n  const runOptions: InferenceSession.RunOptions = options || {};\r\n\r\n  try {\r\n    if (options?.logSeverityLevel === undefined) {\r\n      runOptions.logSeverityLevel = 2; // Default to warning\r\n    } else if (\r\n      typeof options.logSeverityLevel !== 'number' ||\r\n      !Number.isInteger(options.logSeverityLevel) ||\r\n      options.logSeverityLevel < 0 ||\r\n      options.logSeverityLevel > 4\r\n    ) {\r\n      throw new Error(`log severity level is not valid: ${options.logSeverityLevel}`);\r\n    }\r\n\r\n    if (options?.logVerbosityLevel === undefined) {\r\n      runOptions.logVerbosityLevel = 0; // Default to 0\r\n    } else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {\r\n      throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);\r\n    }\r\n\r\n    if (options?.terminate === undefined) {\r\n      runOptions.terminate = false;\r\n    }\r\n\r\n    let tagDataOffset = 0;\r\n    if (options?.tag !== undefined) {\r\n      tagDataOffset = allocWasmString(options.tag, allocs);\r\n    }\r\n\r\n    runOptionsHandle = wasm._OrtCreateRunOptions(\r\n      runOptions.logSeverityLevel!,\r\n      runOptions.logVerbosityLevel!,\r\n      !!runOptions.terminate!,\r\n      tagDataOffset,\r\n    );\r\n    if (runOptionsHandle === 0) {\r\n      checkLastError(\"Can't create run options.\");\r\n    }\r\n\r\n    if (options?.extra !== undefined) {\r\n      iterateExtraOptions(options.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\r\n        const keyDataOffset = allocWasmString(key, allocs);\r\n        const valueDataOffset = allocWasmString(value, allocs);\r\n\r\n        if (wasm._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\r\n          checkLastError(`Can't set a run config entry: ${key} - ${value}.`);\r\n        }\r\n      });\r\n    }\r\n\r\n    return [runOptionsHandle, allocs];\r\n  } catch (e) {\r\n    if (runOptionsHandle !== 0) {\r\n      wasm._OrtReleaseRunOptions(runOptionsHandle);\r\n    }\r\n    allocs.forEach((alloc) => wasm._free(alloc));\r\n    throw e;\r\n  }\r\n};\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport type { InferenceSession } from 'onnxruntime-common';\r\n\r\nimport { getInstance } from './wasm-factory';\r\nimport { allocWasmString, checkLastError, iterateExtraOptions } from './wasm-utils';\r\n\r\nconst getGraphOptimzationLevel = (graphOptimizationLevel: string | unknown): number => {\r\n  switch (graphOptimizationLevel) {\r\n    case 'disabled':\r\n      return 0;\r\n    case 'basic':\r\n      return 1;\r\n    case 'extended':\r\n      return 2;\r\n    case 'layout':\r\n      return 3;\r\n    case 'all':\r\n      return 99;\r\n    default:\r\n      throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);\r\n  }\r\n};\r\n\r\nconst getExecutionMode = (executionMode: 'sequential' | 'parallel'): number => {\r\n  switch (executionMode) {\r\n    case 'sequential':\r\n      return 0;\r\n    case 'parallel':\r\n      return 1;\r\n    default:\r\n      throw new Error(`unsupported execution mode: ${executionMode}`);\r\n  }\r\n};\r\n\r\nconst appendDefaultOptions = (options: InferenceSession.SessionOptions): void => {\r\n  if (!options.extra) {\r\n    options.extra = {};\r\n  }\r\n  if (!options.extra.session) {\r\n    options.extra.session = {};\r\n  }\r\n  const session = options.extra.session as Record<string, string>;\r\n  if (!session.use_ort_model_bytes_directly) {\r\n    // eslint-disable-next-line camelcase\r\n    session.use_ort_model_bytes_directly = '1';\r\n  }\r\n\r\n  // if using JSEP with WebGPU, always disable memory pattern\r\n  if (\r\n    options.executionProviders &&\r\n    options.executionProviders.some((ep) => (typeof ep === 'string' ? ep : ep.name) === 'webgpu')\r\n  ) {\r\n    options.enableMemPattern = false;\r\n  }\r\n};\r\n\r\nconst appendSessionConfig = (sessionOptionsHandle: number, key: string, value: string, allocs: number[]): void => {\r\n  const keyDataOffset = allocWasmString(key, allocs);\r\n  const valueDataOffset = allocWasmString(value, allocs);\r\n  if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\r\n    checkLastError(`Can't set a session config entry: ${key} - ${value}.`);\r\n  }\r\n};\r\n\r\nconst appendEpOption = (epOptions: Array<[number, number]>, key: string, value: string, allocs: number[]): void => {\r\n  const keyDataOffset = allocWasmString(key, allocs);\r\n  const valueDataOffset = allocWasmString(value, allocs);\r\n  epOptions.push([keyDataOffset, valueDataOffset]);\r\n};\r\n\r\nconst setExecutionProviders = async (\r\n  sessionOptionsHandle: number,\r\n  executionProviders: readonly InferenceSession.ExecutionProviderConfig[],\r\n  allocs: number[],\r\n): Promise<void> => {\r\n  for (const ep of executionProviders) {\r\n    let epName = typeof ep === 'string' ? ep : ep.name;\r\n    const epOptions: Array<[number, number]> = [];\r\n\r\n    // check EP name\r\n    switch (epName) {\r\n      case 'webnn':\r\n        epName = 'WEBNN';\r\n        if (typeof ep !== 'string') {\r\n          const webnnOptions = ep as InferenceSession.WebNNExecutionProviderOption;\r\n          // const context = (webnnOptions as InferenceSession.WebNNOptionsWithMLContext)?.context;\r\n          const deviceType = (webnnOptions as InferenceSession.WebNNContextOptions)?.deviceType;\r\n          if (deviceType) {\r\n            appendSessionConfig(sessionOptionsHandle, 'deviceType', deviceType, allocs);\r\n          }\r\n        }\r\n        break;\r\n      case 'webgpu':\r\n        if (!BUILD_DEFS.DISABLE_WEBGPU) {\r\n          epName = 'WebGPU';\r\n          let customDevice: GPUDevice | undefined;\r\n\r\n          if (typeof ep !== 'string') {\r\n            const customOptions = ep as unknown as { device: GPUDevice };\r\n            if (customOptions.device) {\r\n              if (typeof GPUDevice !== 'undefined' && customOptions.device instanceof GPUDevice) {\r\n                customDevice = customOptions.device;\r\n              } else {\r\n                throw new Error('Invalid GPU device set in WebGPU EP options.');\r\n              }\r\n            }\r\n\r\n            // TODO: handle more options\r\n          }\r\n\r\n          const info = getInstance().webgpuRegisterDevice!(customDevice);\r\n          if (info) {\r\n            const [deviceId, instanceHandle, deviceHandle] = info;\r\n            appendEpOption(epOptions, 'deviceId', deviceId.toString(), allocs);\r\n            appendEpOption(epOptions, 'webgpuInstance', instanceHandle.toString(), allocs);\r\n            appendEpOption(epOptions, 'webgpuDevice', deviceHandle.toString(), allocs);\r\n          }\r\n        } else {\r\n          epName = 'JS';\r\n          if (typeof ep !== 'string') {\r\n            const webgpuOptions = ep as InferenceSession.WebGpuExecutionProviderOption;\r\n            if (webgpuOptions?.preferredLayout) {\r\n              if (webgpuOptions.preferredLayout !== 'NCHW' && webgpuOptions.preferredLayout !== 'NHWC') {\r\n                throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);\r\n              }\r\n              appendSessionConfig(sessionOptionsHandle, 'preferredLayout', webgpuOptions.preferredLayout, allocs);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case 'wasm':\r\n      case 'cpu':\r\n        continue;\r\n      default:\r\n        throw new Error(`not supported execution provider: ${epName}`);\r\n    }\r\n\r\n    const epNameDataOffset = allocWasmString(epName, allocs);\r\n    const epOptionsCount = epOptions.length;\r\n    let keysOffset = 0;\r\n    let valuesOffset = 0;\r\n    if (epOptionsCount > 0) {\r\n      keysOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);\r\n      allocs.push(keysOffset);\r\n      valuesOffset = getInstance()._malloc(epOptionsCount * getInstance().PTR_SIZE);\r\n      allocs.push(valuesOffset);\r\n      for (let i = 0; i < epOptionsCount; i++) {\r\n        getInstance().setValue(keysOffset + i * getInstance().PTR_SIZE, epOptions[i][0], '*');\r\n        getInstance().setValue(valuesOffset + i * getInstance().PTR_SIZE, epOptions[i][1], '*');\r\n      }\r\n    }\r\n    if (\r\n      (await getInstance()._OrtAppendExecutionProvider(\r\n        sessionOptionsHandle,\r\n        epNameDataOffset,\r\n        keysOffset,\r\n        valuesOffset,\r\n        epOptionsCount,\r\n      )) !== 0\r\n    ) {\r\n      checkLastError(`Can't append execution provider: ${epName}.`);\r\n    }\r\n  }\r\n};\r\n\r\nexport const setSessionOptions = async (options?: InferenceSession.SessionOptions): Promise<[number, number[]]> => {\r\n  const wasm = getInstance();\r\n  let sessionOptionsHandle = 0;\r\n  const allocs: number[] = [];\r\n\r\n  const sessionOptions: InferenceSession.SessionOptions = options || {};\r\n  appendDefaultOptions(sessionOptions);\r\n\r\n  try {\r\n    const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? 'all');\r\n    const executionMode = getExecutionMode(sessionOptions.executionMode ?? 'sequential');\r\n    const logIdDataOffset =\r\n      typeof sessionOptions.logId === 'string' ? allocWasmString(sessionOptions.logId, allocs) : 0;\r\n\r\n    const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2; // Default to 2 - warning\r\n    if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {\r\n      throw new Error(`log severity level is not valid: ${logSeverityLevel}`);\r\n    }\r\n\r\n    const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0; // Default to 0 - verbose\r\n    if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {\r\n      throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);\r\n    }\r\n\r\n    const optimizedModelFilePathOffset =\r\n      typeof sessionOptions.optimizedModelFilePath === 'string'\r\n        ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs)\r\n        : 0;\r\n\r\n    sessionOptionsHandle = wasm._OrtCreateSessionOptions(\r\n      graphOptimizationLevel,\r\n      !!sessionOptions.enableCpuMemArena,\r\n      !!sessionOptions.enableMemPattern,\r\n      executionMode,\r\n      !!sessionOptions.enableProfiling,\r\n      0,\r\n      logIdDataOffset,\r\n      logSeverityLevel,\r\n      logVerbosityLevel,\r\n      optimizedModelFilePathOffset,\r\n    );\r\n    if (sessionOptionsHandle === 0) {\r\n      checkLastError(\"Can't create session options.\");\r\n    }\r\n\r\n    if (sessionOptions.executionProviders) {\r\n      await setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);\r\n    }\r\n\r\n    if (sessionOptions.enableGraphCapture !== undefined) {\r\n      if (typeof sessionOptions.enableGraphCapture !== 'boolean') {\r\n        throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);\r\n      }\r\n      appendSessionConfig(\r\n        sessionOptionsHandle,\r\n        'enableGraphCapture',\r\n        sessionOptions.enableGraphCapture.toString(),\r\n        allocs,\r\n      );\r\n    }\r\n\r\n    if (sessionOptions.freeDimensionOverrides) {\r\n      for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {\r\n        if (typeof name !== 'string') {\r\n          throw new Error(`free dimension override name must be a string: ${name}`);\r\n        }\r\n        if (typeof value !== 'number' || !Number.isInteger(value) || value < 0) {\r\n          throw new Error(`free dimension override value must be a non-negative integer: ${value}`);\r\n        }\r\n        const nameOffset = allocWasmString(name, allocs);\r\n        if (wasm._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {\r\n          checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (sessionOptions.extra !== undefined) {\r\n      iterateExtraOptions(sessionOptions.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\r\n        appendSessionConfig(sessionOptionsHandle, key, value, allocs);\r\n      });\r\n    }\r\n\r\n    return [sessionOptionsHandle, allocs];\r\n  } catch (e) {\r\n    if (sessionOptionsHandle !== 0) {\r\n      if (wasm._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {\r\n        checkLastError(\"Can't release session options.\");\r\n      }\r\n    }\r\n    allocs.forEach((alloc) => wasm._free(alloc));\r\n    throw e;\r\n  }\r\n};\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Tensor } from 'onnxruntime-common';\r\n\r\n// a dummy type declaration for Float16Array in case any polyfill is available.\r\ndeclare global {\r\n  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any\r\n  const Float16Array: any;\r\n}\r\n\r\n// This file includes common definitions. They do NOT have dependency on the WebAssembly instance.\r\n\r\n/**\r\n * Copied from ONNX definition. Use this to drop dependency 'onnx_proto' to decrease compiled .js file size.\r\n */\r\nexport const enum DataType {\r\n  undefined = 0,\r\n  float = 1,\r\n  uint8 = 2,\r\n  int8 = 3,\r\n  uint16 = 4,\r\n  int16 = 5,\r\n  int32 = 6,\r\n  int64 = 7,\r\n  string = 8,\r\n  bool = 9,\r\n  float16 = 10,\r\n  double = 11,\r\n  uint32 = 12,\r\n  uint64 = 13,\r\n  complex64 = 14,\r\n  complex128 = 15,\r\n  bfloat16 = 16,\r\n\r\n  // 4-bit data-types\r\n  uint4 = 21,\r\n  int4 = 22,\r\n}\r\n\r\n/**\r\n * Map string tensor data to enum value\r\n */\r\nexport const tensorDataTypeStringToEnum = (type: string): DataType => {\r\n  switch (type) {\r\n    case 'int8':\r\n      return DataType.int8;\r\n    case 'uint8':\r\n      return DataType.uint8;\r\n    case 'bool':\r\n      return DataType.bool;\r\n    case 'int16':\r\n      return DataType.int16;\r\n    case 'uint16':\r\n      return DataType.uint16;\r\n    case 'int32':\r\n      return DataType.int32;\r\n    case 'uint32':\r\n      return DataType.uint32;\r\n    case 'float16':\r\n      return DataType.float16;\r\n    case 'float32':\r\n      return DataType.float;\r\n    case 'float64':\r\n      return DataType.double;\r\n    case 'string':\r\n      return DataType.string;\r\n    case 'int64':\r\n      return DataType.int64;\r\n    case 'uint64':\r\n      return DataType.uint64;\r\n    case 'int4':\r\n      return DataType.int4;\r\n    case 'uint4':\r\n      return DataType.uint4;\r\n\r\n    default:\r\n      throw new Error(`unsupported data type: ${type}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Map enum value to string tensor data\r\n */\r\nexport const tensorDataTypeEnumToString = (typeProto: DataType): Tensor.Type => {\r\n  switch (typeProto) {\r\n    case DataType.int8:\r\n      return 'int8';\r\n    case DataType.uint8:\r\n      return 'uint8';\r\n    case DataType.bool:\r\n      return 'bool';\r\n    case DataType.int16:\r\n      return 'int16';\r\n    case DataType.uint16:\r\n      return 'uint16';\r\n    case DataType.int32:\r\n      return 'int32';\r\n    case DataType.uint32:\r\n      return 'uint32';\r\n    case DataType.float16:\r\n      return 'float16';\r\n    case DataType.float:\r\n      return 'float32';\r\n    case DataType.double:\r\n      return 'float64';\r\n    case DataType.string:\r\n      return 'string';\r\n    case DataType.int64:\r\n      return 'int64';\r\n    case DataType.uint64:\r\n      return 'uint64';\r\n    case DataType.int4:\r\n      return 'int4';\r\n    case DataType.uint4:\r\n      return 'uint4';\r\n\r\n    default:\r\n      throw new Error(`unsupported data type: ${typeProto}`);\r\n  }\r\n};\r\n\r\n/**\r\n * get tensor size in bytes by the given data type and dimensions\r\n * @returns size in integer or undefined if the data type is not supported\r\n */\r\nexport const calculateTensorSizeInBytes = (\r\n  dateType: number,\r\n  dimsOrSize: readonly number[] | number,\r\n): number | undefined => {\r\n  const elementSize = [\r\n    -1, // undefined = 0\r\n    4, // float = 1\r\n    1, // uint8 = 2\r\n    1, // int8 = 3\r\n    2, // uint16 = 4\r\n    2, // int16 = 5\r\n    4, // int32 = 6\r\n    8, // int64 = 7\r\n    -1, // string = 8\r\n    1, // bool = 9\r\n    2, // float16 = 10\r\n    8, // double = 11\r\n    4, // uint32 = 12\r\n    8, // uint64 = 13\r\n    -1, // complex64 = 14\r\n    -1, // complex128 = 15\r\n    -1, // bfloat16 = 16\r\n    -1, // FLOAT8E4M3FN = 17\r\n    -1, // FLOAT8E4M3FNUZ = 18\r\n    -1, // FLOAT8E5M2 = 19\r\n    -1, // FLOAT8E5M2FNUZ = 20\r\n    0.5, // uint4 = 21\r\n    0.5, // int4 = 22\r\n  ][dateType];\r\n\r\n  const size = typeof dimsOrSize === 'number' ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);\r\n  return elementSize > 0 ? Math.ceil(size * elementSize) : undefined;\r\n};\r\n\r\n/**\r\n * get typed array constructor by the given tensor type\r\n */\r\nexport const tensorTypeToTypedArrayConstructor = (\r\n  type: Tensor.Type,\r\n):\r\n  | Float32ArrayConstructor\r\n  | Uint8ArrayConstructor\r\n  | Int8ArrayConstructor\r\n  | Uint16ArrayConstructor\r\n  | Int16ArrayConstructor\r\n  | Int32ArrayConstructor\r\n  | BigInt64ArrayConstructor\r\n  | Uint8ArrayConstructor\r\n  | Float64ArrayConstructor\r\n  | Uint32ArrayConstructor\r\n  | BigUint64ArrayConstructor => {\r\n  switch (type) {\r\n    case 'float16':\r\n      // allow Float16Array polyfill.\r\n      return typeof Float16Array !== 'undefined' && Float16Array.from ? Float16Array : Uint16Array;\r\n    case 'float32':\r\n      return Float32Array;\r\n    case 'uint8':\r\n      return Uint8Array;\r\n    case 'int8':\r\n      return Int8Array;\r\n    case 'uint16':\r\n      return Uint16Array;\r\n    case 'int16':\r\n      return Int16Array;\r\n    case 'int32':\r\n      return Int32Array;\r\n    case 'bool':\r\n      return Uint8Array;\r\n    case 'float64':\r\n      return Float64Array;\r\n    case 'uint32':\r\n      return Uint32Array;\r\n    case 'int64':\r\n      return BigInt64Array;\r\n    case 'uint64':\r\n      return BigUint64Array;\r\n    default:\r\n      throw new Error(`unsupported type: ${type}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Map string log level to integer value\r\n */\r\nexport const logLevelStringToEnum = (logLevel?: 'verbose' | 'info' | 'warning' | 'error' | 'fatal'): number => {\r\n  switch (logLevel) {\r\n    case 'verbose':\r\n      return 0;\r\n    case 'info':\r\n      return 1;\r\n    case 'warning':\r\n      return 2;\r\n    case 'error':\r\n      return 3;\r\n    case 'fatal':\r\n      return 4;\r\n    default:\r\n      throw new Error(`unsupported logging level: ${logLevel}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Check whether the given tensor type is supported by GPU buffer\r\n */\r\nexport const isGpuBufferSupportedType = (type: Tensor.Type): type is Tensor.GpuBufferDataTypes =>\r\n  type === 'float32' ||\r\n  type === 'float16' ||\r\n  type === 'int32' ||\r\n  type === 'int64' ||\r\n  type === 'uint32' ||\r\n  type === 'uint8' ||\r\n  type === 'bool' ||\r\n  type === 'uint4' ||\r\n  type === 'int4';\r\n\r\n/**\r\n * Check whether the given tensor type is supported by WebNN MLTensor\r\n */\r\nexport const isMLTensorSupportedType = (type: Tensor.Type): type is Tensor.MLTensorDataTypes =>\r\n  type === 'float32' ||\r\n  type === 'float16' ||\r\n  type === 'int32' ||\r\n  type === 'int64' ||\r\n  type === 'uint32' ||\r\n  type === 'uint64' ||\r\n  type === 'int8' ||\r\n  type === 'uint8' ||\r\n  type === 'bool' ||\r\n  type === 'uint4' ||\r\n  type === 'int4';\r\n\r\n/**\r\n * Map string data location to integer value\r\n */\r\nexport const dataLocationStringToEnum = (location: Tensor.DataLocation): number => {\r\n  switch (location) {\r\n    case 'none':\r\n      return 0;\r\n    case 'cpu':\r\n      return 1;\r\n    case 'cpu-pinned':\r\n      return 2;\r\n    case 'texture':\r\n      return 3;\r\n    case 'gpu-buffer':\r\n      return 4;\r\n    case 'ml-tensor':\r\n      return 5;\r\n    default:\r\n      throw new Error(`unsupported data location: ${location}`);\r\n  }\r\n};\r\n\r\n/**\r\n * Map integer data location to string value\r\n */\r\nexport const dataLocationEnumToString = (location: number): Tensor.DataLocation | undefined =>\r\n  (['none', 'cpu', 'cpu-pinned', 'texture', 'gpu-buffer', 'ml-tensor'] as const)[location];\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { isNode } from './wasm-utils-env';\r\n\r\n/**\r\n * Load a file into a Uint8Array.\r\n *\r\n * @param file - the file to load. Can be a URL/path, a Blob, an ArrayBuffer, or a Uint8Array.\r\n * @returns a Uint8Array containing the file data.\r\n */\r\nexport const loadFile = async (file: string | Blob | ArrayBufferLike | Uint8Array): Promise<Uint8Array> => {\r\n  if (typeof file === 'string') {\r\n    if (isNode) {\r\n      // load file into ArrayBuffer in Node.js\r\n      try {\r\n        const { readFile } = require('node:fs/promises');\r\n        return new Uint8Array(await readFile(file));\r\n      } catch (e) {\r\n        if (e.code === 'ERR_FS_FILE_TOO_LARGE') {\r\n          // file is too large, use fs.createReadStream instead\r\n          const { createReadStream } = require('node:fs');\r\n          const stream = createReadStream(file);\r\n          const chunks: Uint8Array[] = [];\r\n          for await (const chunk of stream) {\r\n            chunks.push(chunk);\r\n          }\r\n          return new Uint8Array(Buffer.concat(chunks));\r\n        }\r\n        throw e;\r\n      }\r\n    } else {\r\n      // load file into ArrayBuffer in browsers\r\n      const response = await fetch(file);\r\n      if (!response.ok) {\r\n        throw new Error(`failed to load external data file: ${file}`);\r\n      }\r\n      const contentLengthHeader = response.headers.get('Content-Length');\r\n      const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;\r\n      if (fileSize < 1073741824 /* 1GB */) {\r\n        // when Content-Length header is not set, we cannot determine the file size. We assume it is small enough to\r\n        // load into memory.\r\n        return new Uint8Array(await response.arrayBuffer());\r\n      } else {\r\n        // file is too large, use stream instead\r\n        if (!response.body) {\r\n          throw new Error(`failed to load external data file: ${file}, no response body.`);\r\n        }\r\n        const reader = response.body.getReader();\r\n\r\n        let buffer;\r\n        try {\r\n          // try to create ArrayBuffer directly\r\n          buffer = new ArrayBuffer(fileSize);\r\n        } catch (e) {\r\n          if (e instanceof RangeError) {\r\n            // use WebAssembly Memory to allocate larger ArrayBuffer\r\n            const pages = Math.ceil(fileSize / 65536);\r\n            buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;\r\n          } else {\r\n            throw e;\r\n          }\r\n        }\r\n\r\n        let offset = 0;\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n          const { done, value } = await reader.read();\r\n          if (done) {\r\n            break;\r\n          }\r\n          const chunkSize = value.byteLength;\r\n          const chunk = new Uint8Array(buffer, offset, chunkSize);\r\n          chunk.set(value);\r\n          offset += chunkSize;\r\n        }\r\n        return new Uint8Array(buffer, 0, fileSize);\r\n      }\r\n    }\r\n  } else if (file instanceof Blob) {\r\n    return new Uint8Array(await file.arrayBuffer());\r\n  } else if (file instanceof Uint8Array) {\r\n    return file;\r\n  } else {\r\n    return new Uint8Array(file);\r\n  }\r\n};\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n// WebNN API currently does not have a TypeScript definition file. This file is a workaround with types generated from\r\n// WebNN API specification.\r\n// https://github.com/webmachinelearning/webnn/issues/677\r\n/// <reference path=\"jsep/webnn/webnn.d.ts\" />\r\n\r\nimport { Env, InferenceSession, Tensor, TRACE_EVENT_BEGIN, TRACE_EVENT_END } from 'onnxruntime-common';\r\n\r\nimport {\r\n  SerializableInternalBuffer,\r\n  SerializableSessionMetadata,\r\n  SerializableTensorMetadata,\r\n  TensorMetadata,\r\n} from './proxy-messages';\r\nimport { setRunOptions } from './run-options';\r\nimport { setSessionOptions } from './session-options';\r\nimport {\r\n  calculateTensorSizeInBytes,\r\n  dataLocationStringToEnum,\r\n  isGpuBufferSupportedType,\r\n  isMLTensorSupportedType,\r\n  logLevelStringToEnum,\r\n  tensorDataTypeEnumToString,\r\n  tensorDataTypeStringToEnum,\r\n  tensorTypeToTypedArrayConstructor,\r\n} from './wasm-common';\r\nimport { getInstance } from './wasm-factory';\r\nimport { allocWasmString, checkLastError } from './wasm-utils';\r\nimport { loadFile } from './wasm-utils-load-file';\r\n\r\n// #region Initializations\r\n\r\n/**\r\n * There are 4 different \"initialization\" steps for ORT. They happen in different places and different time.\r\n *\r\n * 1. JavaScript initialization for onnxruntime-common and onnxruntime-web.\r\n *    This is the first initialization step. In this step, onnxruntime-web calls onnxruntime-common's registerBackend()\r\n * function multiple times to register all the available backends. The backend registration is very fast. It only\r\n * registers the backend name with the uninitialized backend object. No heavy initialization is done in this step.\r\n *    Refer to web/lib/index.ts for the backend registration.\r\n *\r\n * 2. WebAssembly artifact initialization.\r\n *    This happens when any registered wasm backend is used for the first time (ie. `ort.InferenceSession.create()` is\r\n * called). In this step, onnxruntime-web does the followings:\r\n *     - create a proxy worker and make sure the proxy worker is ready to receive messages, if proxy is enabled.\r\n *     - perform feature detection, locate correct WebAssembly artifact path and call the Emscripten generated\r\n * JavaScript code to initialize the WebAssembly runtime.\r\n *         - if proxy is enabled, this step happens in the proxy worker using message 'init-wasm'.\r\n *         - downloading the 'ort-wasm{...}.wasm' file is done in this step.\r\n *         - if multi-thread is enabled, one or more webworker will be created to initialize the PThread threadpool.\r\n *\r\n * 3. ORT environment initialization.\r\n *    This happens after step 2. In this step, onnxruntime-web performs ONNX Runtime environment initialization.\r\n * Function `_OrtInit()` is called in this step.\r\n *     - if proxy is enabled, this step happens in the proxy worker using message 'init-ort'.\r\n *     - logging level (ort.env.logLevel) and thread number (ort.env.wasm.numThreads) are set in this step.\r\n *\r\n * 4. Session initialization.\r\n *    This happens when `ort.InferenceSession.create()` is called. Unlike the first 3 steps (they only called once),\r\n * this step will be done for each session. In this step, onnxruntime-web does the followings:\r\n *    If the parameter is a URL:\r\n *    - download the model data from the URL.\r\n *    - copy the model data to the WASM heap. (proxy: 'copy-from')\r\n *    - dereference the model buffer. This step allows the original ArrayBuffer to be garbage collected.\r\n *    - call `_OrtCreateSession()` to create the session. (proxy: 'create')\r\n *\r\n *    If the parameter is a Uint8Array object:\r\n *    - copy the model data to the WASM heap. (proxy: 'copy-from')\r\n *    - call `_OrtCreateSession()` to create the session. (proxy: 'create')\r\n *\r\n *\r\n */\r\n\r\n/**\r\n * initialize ORT environment.\r\n *\r\n * @param numThreads SetGlobalIntraOpNumThreads(numThreads)\r\n * @param loggingLevel CreateEnv(static_cast<OrtLoggingLevel>(logging_level))\r\n */\r\nconst initOrt = (numThreads: number, loggingLevel: number): void => {\r\n  const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);\r\n  if (errorCode !== 0) {\r\n    checkLastError(\"Can't initialize onnxruntime.\");\r\n  }\r\n};\r\n\r\n/**\r\n * initialize runtime environment.\r\n * @param env passed in the environment config object.\r\n */\r\nexport const initRuntime = async (env: Env): Promise<void> => {\r\n  // init ORT\r\n  initOrt(env.wasm.numThreads!, logLevelStringToEnum(env.logLevel));\r\n};\r\n\r\n/**\r\n * perform EP specific initialization.\r\n *\r\n * @param env\r\n * @param epName\r\n */\r\nexport const initEp = async (env: Env, epName: string): Promise<void> => {\r\n  // initialize ASYNCIFY support\r\n  getInstance().asyncInit?.();\r\n\r\n  // perform WebGPU availability check ( either JSEP or WebGPU EP )\r\n  let webgpuAdapter = env.webgpu.adapter as GPUAdapter | null;\r\n  if (epName === 'webgpu') {\r\n    if (typeof navigator === 'undefined' || !navigator.gpu) {\r\n      throw new Error('WebGPU is not supported in current environment');\r\n    }\r\n    if (!webgpuAdapter) {\r\n      // if adapter is not set, request a new adapter.\r\n      const powerPreference = env.webgpu.powerPreference;\r\n      if (powerPreference !== undefined && powerPreference !== 'low-power' && powerPreference !== 'high-performance') {\r\n        throw new Error(`Invalid powerPreference setting: \"${powerPreference}\"`);\r\n      }\r\n      const forceFallbackAdapter = env.webgpu.forceFallbackAdapter;\r\n      if (forceFallbackAdapter !== undefined && typeof forceFallbackAdapter !== 'boolean') {\r\n        throw new Error(`Invalid forceFallbackAdapter setting: \"${forceFallbackAdapter}\"`);\r\n      }\r\n      webgpuAdapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });\r\n      if (!webgpuAdapter) {\r\n        throw new Error(\r\n          'Failed to get GPU adapter. ' +\r\n            'You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.',\r\n        );\r\n      }\r\n    } else {\r\n      // if adapter is set, validate it.\r\n      if (\r\n        typeof webgpuAdapter.limits !== 'object' ||\r\n        typeof webgpuAdapter.features !== 'object' ||\r\n        typeof webgpuAdapter.requestDevice !== 'function'\r\n      ) {\r\n        throw new Error('Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.');\r\n      }\r\n    }\r\n  }\r\n\r\n  // perform WebNN availability check ( either JSEP or WebNN EP )\r\n  if (epName === 'webnn') {\r\n    if (typeof navigator === 'undefined' || !(navigator as unknown as { ml: unknown }).ml) {\r\n      throw new Error('WebNN is not supported in current environment');\r\n    }\r\n  }\r\n\r\n  if (!BUILD_DEFS.DISABLE_JSEP) {\r\n    // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\r\n    const initJsep = require('./jsep/init').init;\r\n\r\n    if (epName === 'webgpu') {\r\n      await initJsep('webgpu', getInstance(), env, webgpuAdapter);\r\n    }\r\n    if (epName === 'webnn') {\r\n      await initJsep('webnn', getInstance(), env);\r\n    }\r\n  } else {\r\n    if (!BUILD_DEFS.DISABLE_WEBGPU && epName === 'webgpu') {\r\n      getInstance().webgpuInit!((device) => {\r\n        env.webgpu.device = device;\r\n      });\r\n    }\r\n    if (!BUILD_DEFS.DISABLE_WEBNN && epName === 'webnn') {\r\n      // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\r\n      const backend = new (require('./jsep/backend-webnn').WebNNBackend)(env);\r\n      getInstance().webnnInit!([\r\n        backend,\r\n        // webnnReserveTensorId\r\n        () => backend.reserveTensorId(),\r\n        // webnnReleaseTensorId,\r\n        (tensorId: number) => backend.releaseTensorId(tensorId),\r\n        // webnnEnsureTensor\r\n        async (sessionId: number | undefined, tensorId: number, onnxDataType: number, shape: number[], copyOld) =>\r\n          backend.ensureTensor(sessionId, tensorId, onnxDataType, shape, copyOld),\r\n        // webnnUploadTensor\r\n        (tensorId: number, data: Uint8Array) => {\r\n          backend.uploadTensor(tensorId, data);\r\n        },\r\n        // webnnDownloadTensor\r\n        async (tensorId: number, dstBuffer: ArrayBufferView | ArrayBuffer) =>\r\n          backend.downloadTensor(tensorId, dstBuffer),\r\n        // webnnRegisterMLContext\r\n        (sessionId: number, mlContext: MLContext) => backend.registerMLContext(sessionId, mlContext),\r\n        // webnnEnableTraceEvent\r\n        !!env.trace,\r\n      ]);\r\n    }\r\n  }\r\n};\r\n\r\n// #endregion Initializations\r\n\r\n/**\r\n * valid data locations for input/output tensors.\r\n */\r\ntype SupportedTensorDataLocationForInputOutput =\r\n  | 'cpu'\r\n  | 'cpu-pinned'\r\n  | 'gpu-buffer'\r\n  | 'ml-tensor'\r\n  // Use 'ml-tensor' during inference, but output a tensor located on the CPU.\r\n  | 'ml-tensor-cpu-output';\r\n\r\ntype IOBindingState = {\r\n  /**\r\n   * the handle of IO binding.\r\n   */\r\n  readonly handle: number;\r\n\r\n  /**\r\n   * the preferred location for each output tensor.\r\n   *\r\n   * value is one of 'cpu', 'cpu-pinned', 'gpu-buffer', 'ml-tensor'.\r\n   */\r\n  readonly outputPreferredLocations: readonly SupportedTensorDataLocationForInputOutput[];\r\n\r\n  /**\r\n   * enum value of the preferred location for each output tensor.\r\n   */\r\n  readonly outputPreferredLocationsEncoded: readonly number[];\r\n};\r\n\r\n/**\r\n *  tuple elements are: InferenceSession ID; inputNamesUTF8Encoded; outputNamesUTF8Encoded; bindingState\r\n */\r\ntype SessionMetadata = [\r\n  inferenceSessionId: number,\r\n  inputNamesUTF8Encoded: number[],\r\n  outputNamesUTF8Encoded: number[],\r\n  bindingState: IOBindingState | null,\r\n  enableGraphCapture: boolean,\r\n  inputOutputBound: boolean,\r\n];\r\n\r\nconst activeSessions = new Map<number, SessionMetadata>();\r\n\r\n/**\r\n * get the input/output count of the session.\r\n * @param sessionHandle the handle representing the session. should be non-zero.\r\n * @returns a tuple including 2 numbers, representing the input count and output count.\r\n */\r\nconst getSessionInputOutputCount = (sessionHandle: number): [number, number] => {\r\n  const wasm = getInstance();\r\n  const stack = wasm.stackSave();\r\n  try {\r\n    const ptrSize = wasm.PTR_SIZE;\r\n    const dataOffset = wasm.stackAlloc(2 * ptrSize);\r\n    const errorCode = wasm._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + ptrSize);\r\n    if (errorCode !== 0) {\r\n      checkLastError(\"Can't get session input/output count.\");\r\n    }\r\n    const type = ptrSize === 4 ? 'i32' : 'i64';\r\n    return [Number(wasm.getValue(dataOffset, type)), Number(wasm.getValue(dataOffset + ptrSize, type))];\r\n  } finally {\r\n    wasm.stackRestore(stack);\r\n  }\r\n};\r\n\r\nconst getSessionInputOutputMetadata = (\r\n  sessionHandle: number,\r\n  index: number,\r\n): [nameOffset: number, elementType: number, dims?: Array<number | string>] => {\r\n  const wasm = getInstance();\r\n  const stack = wasm.stackSave();\r\n  let metadataOffset = 0;\r\n  try {\r\n    const ptrSize = wasm.PTR_SIZE;\r\n    const dataOffset = wasm.stackAlloc(2 * ptrSize);\r\n    const errorCode = wasm._OrtGetInputOutputMetadata(sessionHandle, index, dataOffset, dataOffset + ptrSize);\r\n    if (errorCode !== 0) {\r\n      checkLastError(\"Can't get session input/output metadata.\");\r\n    }\r\n    const nameOffset = Number(wasm.getValue(dataOffset, '*'));\r\n    metadataOffset = Number(wasm.getValue(dataOffset + ptrSize, '*'));\r\n    // get element type\r\n    const elementType = wasm.HEAP32[metadataOffset / 4];\r\n    if (elementType === 0) {\r\n      return [nameOffset, 0]; // non-tensor\r\n    }\r\n\r\n    // get dims count\r\n    const dimsCount = wasm.HEAPU32[metadataOffset / 4 + 1];\r\n    // get dims\r\n    const dims: Array<number | string> = [];\r\n    for (let i = 0; i < dimsCount; i++) {\r\n      const symbolicDimNameOffset = Number(wasm.getValue(metadataOffset + 8 + i * ptrSize, '*'));\r\n      dims.push(\r\n        symbolicDimNameOffset !== 0\r\n          ? wasm.UTF8ToString(symbolicDimNameOffset)\r\n          : Number(wasm.getValue(metadataOffset + 8 + (i + dimsCount) * ptrSize, '*')),\r\n      );\r\n    }\r\n    return [nameOffset, elementType, dims];\r\n  } finally {\r\n    wasm.stackRestore(stack);\r\n    if (metadataOffset !== 0) {\r\n      wasm._OrtFree(metadataOffset);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * allocate the memory and memcpy the external buffer.\r\n *\r\n * @param model - the external buffer containing the model data. Must not be the same buffer as the WASM heap.\r\n * @returns a 2-elements tuple - the pointer and size of the allocated buffer\r\n */\r\nexport const copyFromExternalBuffer = (model: Uint8Array): [number, number] => {\r\n  const wasm = getInstance();\r\n  const modelDataOffset = wasm._malloc(model.byteLength);\r\n  if (modelDataOffset === 0) {\r\n    throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);\r\n  }\r\n  wasm.HEAPU8.set(model, modelDataOffset);\r\n  return [modelDataOffset, model.byteLength];\r\n};\r\n\r\n/**\r\n * create an inference session from a model data buffer.\r\n *\r\n * @param modelData - either a Uint8Array object representing the model data, or a 2-elements tuple containing the\r\n *     pointer and size of the model data buffer.\r\n * @param options an optional session options object.\r\n * @returns a 3-elements tuple containing [session handle, input names, output names]\r\n */\r\nexport const createSession = async (\r\n  modelData: Uint8Array | SerializableInternalBuffer,\r\n  options?: InferenceSession.SessionOptions,\r\n): Promise<SerializableSessionMetadata> => {\r\n  let modelDataOffset: number, modelDataLength: number;\r\n  const wasm = getInstance();\r\n\r\n  if (Array.isArray(modelData)) {\r\n    // if model data is an array, it must be a 2-elements tuple containing the pointer and size of the model data\r\n    [modelDataOffset, modelDataLength] = modelData;\r\n  } else if (modelData.buffer === wasm.HEAPU8.buffer) {\r\n    // if model data uses the same buffer as the WASM heap, we don't need to copy it.\r\n    [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];\r\n  } else {\r\n    // otherwise, copy the model data to the WASM heap.\r\n    [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);\r\n  }\r\n\r\n  let sessionHandle = 0;\r\n  let sessionOptionsHandle = 0;\r\n  let ioBindingHandle = 0;\r\n  let allocs: number[] = [];\r\n  const inputNamesUTF8Encoded = [];\r\n  const outputNamesUTF8Encoded = [];\r\n\r\n  try {\r\n    [sessionOptionsHandle, allocs] = await setSessionOptions(options);\r\n\r\n    if (options?.externalData && wasm.mountExternalData) {\r\n      const loadingPromises = [];\r\n      for (const file of options.externalData) {\r\n        const path = typeof file === 'string' ? file : file.path;\r\n        loadingPromises.push(\r\n          loadFile(typeof file === 'string' ? file : file.data).then((data) => {\r\n            wasm.mountExternalData(path, data);\r\n          }),\r\n        );\r\n      }\r\n\r\n      // wait for all external data files to be loaded\r\n      await Promise.all(loadingPromises);\r\n    }\r\n\r\n    for (const provider of options?.executionProviders ?? []) {\r\n      const providerName = typeof provider === 'string' ? provider : provider.name;\r\n      if (providerName === 'webnn') {\r\n        wasm.shouldTransferToMLTensor = false;\r\n        if (typeof provider !== 'string') {\r\n          const webnnOptions = provider as InferenceSession.WebNNExecutionProviderOption;\r\n          const context = (webnnOptions as InferenceSession.WebNNOptionsWithMLContext)?.context;\r\n          const gpuDevice = (webnnOptions as InferenceSession.WebNNOptionsWebGpu)?.gpuDevice;\r\n          const deviceType = (webnnOptions as InferenceSession.WebNNContextOptions)?.deviceType;\r\n          const powerPreference = (webnnOptions as InferenceSession.WebNNContextOptions)?.powerPreference;\r\n          if (context) {\r\n            wasm.currentContext = context as MLContext;\r\n          } else if (gpuDevice) {\r\n            wasm.currentContext = await wasm.webnnCreateMLContext!(gpuDevice);\r\n          } else {\r\n            wasm.currentContext = await wasm.webnnCreateMLContext!({ deviceType, powerPreference });\r\n          }\r\n        } else {\r\n          wasm.currentContext = await wasm.webnnCreateMLContext!();\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    sessionHandle = await wasm._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);\r\n    wasm.webgpuOnCreateSession?.(sessionHandle);\r\n    if (sessionHandle === 0) {\r\n      checkLastError(\"Can't create a session.\");\r\n    }\r\n\r\n    wasm.jsepOnCreateSession?.();\r\n\r\n    // clear current MLContext after session creation\r\n    if (wasm.currentContext) {\r\n      wasm.webnnRegisterMLContext!(sessionHandle, wasm.currentContext);\r\n      wasm.currentContext = undefined;\r\n      wasm.shouldTransferToMLTensor = true;\r\n    }\r\n\r\n    const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);\r\n\r\n    const enableGraphCapture = !!options?.enableGraphCapture;\r\n\r\n    const inputNames = [];\r\n    const outputNames = [];\r\n    const inputMetadata: InferenceSession.ValueMetadata[] = [];\r\n    const outputMetadata: InferenceSession.ValueMetadata[] = [];\r\n    const outputPreferredLocations: SupportedTensorDataLocationForInputOutput[] = [];\r\n    for (let i = 0; i < inputCount; i++) {\r\n      const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i);\r\n      if (nameOffset === 0) {\r\n        checkLastError(\"Can't get an input name.\");\r\n      }\r\n      inputNamesUTF8Encoded.push(nameOffset);\r\n      const name = wasm.UTF8ToString(nameOffset);\r\n      inputNames.push(name);\r\n      inputMetadata.push(\r\n        elementType === 0\r\n          ? { name, isTensor: false }\r\n          : { name, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape: shape! },\r\n      );\r\n    }\r\n    for (let i = 0; i < outputCount; i++) {\r\n      const [nameOffset, elementType, shape] = getSessionInputOutputMetadata(sessionHandle, i + inputCount);\r\n      if (nameOffset === 0) {\r\n        checkLastError(\"Can't get an output name.\");\r\n      }\r\n      outputNamesUTF8Encoded.push(nameOffset);\r\n      const nameString = wasm.UTF8ToString(nameOffset);\r\n      outputNames.push(nameString);\r\n      outputMetadata.push(\r\n        elementType === 0\r\n          ? { name: nameString, isTensor: false }\r\n          : { name: nameString, isTensor: true, type: tensorDataTypeEnumToString(elementType), shape: shape! },\r\n      );\r\n\r\n      if (!BUILD_DEFS.DISABLE_JSEP || !BUILD_DEFS.DISABLE_WEBGPU) {\r\n        if (enableGraphCapture && options?.preferredOutputLocation === undefined) {\r\n          outputPreferredLocations.push('gpu-buffer');\r\n          continue;\r\n        }\r\n        const location =\r\n          typeof options?.preferredOutputLocation === 'string'\r\n            ? options.preferredOutputLocation\r\n            : (options?.preferredOutputLocation?.[nameString] ?? 'cpu');\r\n        const isGraphOutput = wasm.webnnIsGraphOutput;\r\n        if (location === 'cpu' && isGraphOutput && isGraphOutput(sessionHandle, nameString)) {\r\n          outputPreferredLocations.push('ml-tensor-cpu-output');\r\n          continue;\r\n        }\r\n        if (location !== 'cpu' && location !== 'cpu-pinned' && location !== 'gpu-buffer' && location !== 'ml-tensor') {\r\n          throw new Error(`Not supported preferred output location: ${location}.`);\r\n        }\r\n        if (enableGraphCapture && location !== 'gpu-buffer') {\r\n          throw new Error(\r\n            `Not supported preferred output location: ${location}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`,\r\n          );\r\n        }\r\n        outputPreferredLocations.push(location);\r\n      }\r\n    }\r\n\r\n    // use IO binding only when at least one output is preferred to be on GPU.\r\n    let bindingState: IOBindingState | null = null;\r\n    if (\r\n      (!BUILD_DEFS.DISABLE_JSEP || !BUILD_DEFS.DISABLE_WEBGPU) &&\r\n      outputPreferredLocations.some((l) => l === 'gpu-buffer' || l === 'ml-tensor' || l === 'ml-tensor-cpu-output')\r\n    ) {\r\n      ioBindingHandle = wasm._OrtCreateBinding(sessionHandle);\r\n      if (ioBindingHandle === 0) {\r\n        checkLastError(\"Can't create IO binding.\");\r\n      }\r\n\r\n      bindingState = {\r\n        handle: ioBindingHandle,\r\n        outputPreferredLocations,\r\n        outputPreferredLocationsEncoded: outputPreferredLocations\r\n          // 'ml-tensor-cpu-output' is treated as 'ml-tensor' for the purpose of IO binding.\r\n          .map((l) => (l === 'ml-tensor-cpu-output' ? 'ml-tensor' : l))\r\n          .map((l) => dataLocationStringToEnum(l)),\r\n      };\r\n    }\r\n\r\n    activeSessions.set(sessionHandle, [\r\n      sessionHandle,\r\n      inputNamesUTF8Encoded,\r\n      outputNamesUTF8Encoded,\r\n      bindingState,\r\n      enableGraphCapture,\r\n      false,\r\n    ]);\r\n    return [sessionHandle, inputNames, outputNames, inputMetadata, outputMetadata];\r\n  } catch (e) {\r\n    inputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\r\n    outputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\r\n\r\n    if (ioBindingHandle !== 0) {\r\n      if (wasm._OrtReleaseBinding(ioBindingHandle) !== 0) {\r\n        checkLastError(\"Can't release IO binding.\");\r\n      }\r\n    }\r\n\r\n    if (sessionHandle !== 0) {\r\n      if (wasm._OrtReleaseSession(sessionHandle) !== 0) {\r\n        checkLastError(\"Can't release session.\");\r\n      }\r\n    }\r\n    throw e;\r\n  } finally {\r\n    wasm._free(modelDataOffset);\r\n    if (sessionOptionsHandle !== 0) {\r\n      if (wasm._OrtReleaseSessionOptions(sessionOptionsHandle) !== 0) {\r\n        checkLastError(\"Can't release session options.\");\r\n      }\r\n    }\r\n    allocs.forEach((alloc) => wasm._free(alloc));\r\n\r\n    // unmount external data if necessary\r\n    wasm.unmountExternalData?.();\r\n  }\r\n};\r\n\r\nexport const releaseSession = (sessionId: number): void => {\r\n  const wasm = getInstance();\r\n  const session = activeSessions.get(sessionId);\r\n  if (!session) {\r\n    throw new Error(`cannot release session. invalid session id: ${sessionId}`);\r\n  }\r\n  const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;\r\n\r\n  if (ioBindingState) {\r\n    if (enableGraphCapture) {\r\n      if (wasm._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {\r\n        checkLastError(\"Can't clear bound outputs.\");\r\n      }\r\n    }\r\n    if (wasm._OrtReleaseBinding(ioBindingState.handle) !== 0) {\r\n      checkLastError(\"Can't release IO binding.\");\r\n    }\r\n  }\r\n\r\n  wasm.jsepOnReleaseSession?.(sessionId);\r\n  wasm.webnnOnReleaseSession?.(sessionId);\r\n  wasm.webgpuOnReleaseSession?.(sessionId);\r\n\r\n  inputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\r\n  outputNamesUTF8Encoded.forEach((buf) => wasm._OrtFree(buf));\r\n  if (wasm._OrtReleaseSession(sessionHandle) !== 0) {\r\n    checkLastError(\"Can't release session.\");\r\n  }\r\n  activeSessions.delete(sessionId);\r\n};\r\n\r\nexport const prepareInputOutputTensor = async (\r\n  tensor: TensorMetadata | null,\r\n  tensorHandles: number[],\r\n  allocs: number[],\r\n  sessionId: number,\r\n  tensorNameUTF8Encoded: number,\r\n  index: number,\r\n  enableGraphCapture = false,\r\n): Promise<void> => {\r\n  if (!tensor) {\r\n    tensorHandles.push(0);\r\n    return;\r\n  }\r\n\r\n  const wasm = getInstance();\r\n  const ptrSize = wasm.PTR_SIZE;\r\n\r\n  const dataType = tensor[0];\r\n  const dims = tensor[1];\r\n  const location = tensor[3];\r\n  let actualLocation = location;\r\n\r\n  let rawData: number;\r\n  let dataByteLength: number;\r\n\r\n  if (dataType === 'string' && (location === 'gpu-buffer' || location === 'ml-tensor')) {\r\n    throw new Error('String tensor is not supported on GPU.');\r\n  }\r\n\r\n  if (enableGraphCapture && location !== 'gpu-buffer') {\r\n    throw new Error(\r\n      `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`,\r\n    );\r\n  }\r\n\r\n  if (location === 'gpu-buffer') {\r\n    const gpuBuffer = tensor[2].gpuBuffer;\r\n    dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims)!;\r\n\r\n    if (!BUILD_DEFS.DISABLE_WEBGPU) {\r\n      const registerBuffer = wasm.webgpuRegisterBuffer;\r\n      if (!registerBuffer) {\r\n        throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\r\n      }\r\n\r\n      rawData = registerBuffer(gpuBuffer, sessionId);\r\n    } else {\r\n      const registerBuffer = wasm.jsepRegisterBuffer;\r\n      if (!registerBuffer) {\r\n        throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\r\n      }\r\n      rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);\r\n    }\r\n  } else if (location === 'ml-tensor') {\r\n    const mlTensor = tensor[2].mlTensor as MLTensor;\r\n    dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims)!;\r\n\r\n    const registerMLTensor = wasm.webnnRegisterMLTensor;\r\n    if (!registerMLTensor) {\r\n      throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\r\n    }\r\n    rawData = registerMLTensor(sessionId, mlTensor, tensorDataTypeStringToEnum(dataType), dims);\r\n  } else {\r\n    const data = tensor[2];\r\n\r\n    if (Array.isArray(data)) {\r\n      // string tensor\r\n      dataByteLength = ptrSize * data.length;\r\n      rawData = wasm._malloc(dataByteLength);\r\n      allocs.push(rawData);\r\n      for (let i = 0; i < data.length; i++) {\r\n        if (typeof data[i] !== 'string') {\r\n          throw new TypeError(`tensor data at index ${i} is not a string`);\r\n        }\r\n        wasm.setValue(rawData + i * ptrSize, allocWasmString(data[i], allocs), '*');\r\n      }\r\n    } else {\r\n      const isGraphInput = wasm.webnnIsGraphInput;\r\n      const isGraphOutput = wasm.webnnIsGraphOutput;\r\n      if (dataType !== 'string' && isGraphInput && isGraphOutput) {\r\n        const tensorName = wasm.UTF8ToString(tensorNameUTF8Encoded);\r\n        // Promote the tensor to 'ml-tensor' if it is a graph input.\r\n        if (isGraphInput(sessionId, tensorName) || isGraphOutput(sessionId, tensorName)) {\r\n          const dataTypeEnum = tensorDataTypeStringToEnum(dataType);\r\n          dataByteLength = calculateTensorSizeInBytes(dataTypeEnum, dims)!;\r\n          actualLocation = 'ml-tensor';\r\n          const createTemporaryTensor = wasm.webnnCreateTemporaryTensor;\r\n          const uploadTensor = wasm.webnnUploadTensor;\r\n          if (!createTemporaryTensor || !uploadTensor) {\r\n            throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\r\n          }\r\n          const tensorId = await createTemporaryTensor(sessionId, dataTypeEnum, dims as number[]);\r\n          uploadTensor(tensorId, new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\r\n          rawData = tensorId;\r\n        } else {\r\n          dataByteLength = data.byteLength;\r\n          rawData = wasm._malloc(dataByteLength);\r\n          allocs.push(rawData);\r\n          wasm.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);\r\n        }\r\n      } else {\r\n        dataByteLength = data.byteLength;\r\n        rawData = wasm._malloc(dataByteLength);\r\n        allocs.push(rawData);\r\n        wasm.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);\r\n      }\r\n    }\r\n  }\r\n\r\n  const stack = wasm.stackSave();\r\n  const dimsOffset = wasm.stackAlloc(4 * dims.length);\r\n  try {\r\n    dims.forEach((d, index) => wasm.setValue(dimsOffset + index * ptrSize, d, ptrSize === 4 ? 'i32' : 'i64'));\r\n    const tensor = wasm._OrtCreateTensor(\r\n      tensorDataTypeStringToEnum(dataType),\r\n      rawData,\r\n      dataByteLength,\r\n      dimsOffset,\r\n      dims.length,\r\n      dataLocationStringToEnum(actualLocation),\r\n    );\r\n    if (tensor === 0) {\r\n      checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);\r\n    }\r\n    tensorHandles.push(tensor);\r\n  } finally {\r\n    wasm.stackRestore(stack);\r\n  }\r\n};\r\n\r\n/**\r\n * perform inference run\r\n */\r\nexport const run = async (\r\n  sessionId: number,\r\n  inputIndices: number[],\r\n  inputTensors: TensorMetadata[],\r\n  outputIndices: number[],\r\n  outputTensors: Array<TensorMetadata | null>,\r\n  options: InferenceSession.RunOptions,\r\n): Promise<TensorMetadata[]> => {\r\n  const wasm = getInstance();\r\n  const ptrSize = wasm.PTR_SIZE;\r\n  const session = activeSessions.get(sessionId);\r\n  if (!session) {\r\n    throw new Error(`cannot run inference. invalid session id: ${sessionId}`);\r\n  }\r\n  const sessionHandle = session[0];\r\n  const inputNamesUTF8Encoded = session[1];\r\n  const outputNamesUTF8Encoded = session[2];\r\n  const ioBindingState = session[3];\r\n  const enableGraphCapture = session[4];\r\n  const inputOutputBound = session[5];\r\n\r\n  const inputCount = inputIndices.length;\r\n  const outputCount = outputIndices.length;\r\n\r\n  let runOptionsHandle = 0;\r\n  let runOptionsAllocs: number[] = [];\r\n\r\n  const inputTensorHandles: number[] = [];\r\n  const outputTensorHandles: number[] = [];\r\n  const inputOutputAllocs: number[] = [];\r\n\r\n  const beforeRunStack = wasm.stackSave();\r\n  const inputValuesOffset = wasm.stackAlloc(inputCount * ptrSize);\r\n  const inputNamesOffset = wasm.stackAlloc(inputCount * ptrSize);\r\n  const outputValuesOffset = wasm.stackAlloc(outputCount * ptrSize);\r\n  const outputNamesOffset = wasm.stackAlloc(outputCount * ptrSize);\r\n\r\n  try {\r\n    [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);\r\n\r\n    TRACE_EVENT_BEGIN('wasm prepareInputOutputTensor');\r\n    // create input tensors\r\n    for (let i = 0; i < inputCount; i++) {\r\n      await prepareInputOutputTensor(\r\n        inputTensors[i],\r\n        inputTensorHandles,\r\n        inputOutputAllocs,\r\n        sessionId,\r\n        inputNamesUTF8Encoded[inputIndices[i]],\r\n        inputIndices[i],\r\n        enableGraphCapture,\r\n      );\r\n    }\r\n\r\n    // create output tensors\r\n    for (let i = 0; i < outputCount; i++) {\r\n      await prepareInputOutputTensor(\r\n        outputTensors[i],\r\n        outputTensorHandles,\r\n        inputOutputAllocs,\r\n        sessionId,\r\n        outputNamesUTF8Encoded[outputIndices[i]],\r\n        inputCount + outputIndices[i],\r\n        enableGraphCapture,\r\n      );\r\n    }\r\n    TRACE_EVENT_END('wasm prepareInputOutputTensor');\r\n\r\n    for (let i = 0; i < inputCount; i++) {\r\n      wasm.setValue(inputValuesOffset + i * ptrSize, inputTensorHandles[i], '*');\r\n      wasm.setValue(inputNamesOffset + i * ptrSize, inputNamesUTF8Encoded[inputIndices[i]], '*');\r\n    }\r\n    for (let i = 0; i < outputCount; i++) {\r\n      wasm.setValue(outputValuesOffset + i * ptrSize, outputTensorHandles[i], '*');\r\n      wasm.setValue(outputNamesOffset + i * ptrSize, outputNamesUTF8Encoded[outputIndices[i]], '*');\r\n    }\r\n\r\n    if ((!BUILD_DEFS.DISABLE_JSEP || !BUILD_DEFS.DISABLE_WEBGPU) && ioBindingState && !inputOutputBound) {\r\n      const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;\r\n\r\n      if (inputNamesUTF8Encoded.length !== inputCount) {\r\n        throw new Error(\r\n          `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`,\r\n        );\r\n      }\r\n\r\n      TRACE_EVENT_BEGIN('wasm bindInputsOutputs');\r\n      // process inputs\r\n      for (let i = 0; i < inputCount; i++) {\r\n        const index = inputIndices[i];\r\n        const errorCode = await wasm._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);\r\n        if (errorCode !== 0) {\r\n          checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);\r\n        }\r\n      }\r\n\r\n      // process pre-allocated outputs\r\n      for (let i = 0; i < outputCount; i++) {\r\n        const index = outputIndices[i];\r\n        const location = outputTensors[i]?.[3]; // undefined means output is not pre-allocated.\r\n\r\n        if (location) {\r\n          // output is pre-allocated. bind the tensor.\r\n          const errorCode = wasm._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);\r\n          if (errorCode !== 0) {\r\n            checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);\r\n          }\r\n        } else {\r\n          // output is not pre-allocated. reset preferred location.\r\n          const errorCode = wasm._OrtBindOutput(\r\n            handle,\r\n            outputNamesUTF8Encoded[index],\r\n            0,\r\n            outputPreferredLocationsEncoded[index],\r\n          );\r\n          if (errorCode !== 0) {\r\n            checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);\r\n          }\r\n        }\r\n      }\r\n      TRACE_EVENT_END('wasm bindInputsOutputs');\r\n      activeSessions.set(sessionId, [\r\n        sessionHandle,\r\n        inputNamesUTF8Encoded,\r\n        outputNamesUTF8Encoded,\r\n        ioBindingState,\r\n        enableGraphCapture,\r\n        true,\r\n      ]);\r\n    }\r\n\r\n    wasm.jsepOnRunStart?.(sessionHandle);\r\n    wasm.webnnOnRunStart?.(sessionHandle);\r\n\r\n    let errorCode: number;\r\n    if ((!BUILD_DEFS.DISABLE_JSEP || !BUILD_DEFS.DISABLE_WEBGPU) && ioBindingState) {\r\n      errorCode = await wasm._OrtRunWithBinding(\r\n        sessionHandle,\r\n        ioBindingState.handle,\r\n        outputCount,\r\n        outputValuesOffset,\r\n        runOptionsHandle,\r\n      );\r\n    } else {\r\n      errorCode = await wasm._OrtRun(\r\n        sessionHandle,\r\n        inputNamesOffset,\r\n        inputValuesOffset,\r\n        inputCount,\r\n        outputNamesOffset,\r\n        outputCount,\r\n        outputValuesOffset,\r\n        runOptionsHandle,\r\n      );\r\n    }\r\n\r\n    if (errorCode !== 0) {\r\n      checkLastError('failed to call OrtRun().');\r\n    }\r\n\r\n    const output: TensorMetadata[] = [];\r\n    const outputPromises: Array<Promise<[number, Tensor.DataType]>> = [];\r\n\r\n    TRACE_EVENT_BEGIN('wasm ProcessOutputTensor');\r\n    for (let i = 0; i < outputCount; i++) {\r\n      const tensor = Number(wasm.getValue(outputValuesOffset + i * ptrSize, '*'));\r\n      if (tensor === outputTensorHandles[i]) {\r\n        // output tensor is pre-allocated. no need to copy data.\r\n        output.push(outputTensors[i]!);\r\n        continue;\r\n      }\r\n\r\n      const beforeGetTensorDataStack = wasm.stackSave();\r\n      // stack allocate 4 pointer value\r\n      const tensorDataOffset = wasm.stackAlloc(4 * ptrSize);\r\n\r\n      let keepOutputTensor = false;\r\n      let type: Tensor.Type | undefined,\r\n        dataOffset = 0;\r\n      try {\r\n        const errorCode = wasm._OrtGetTensorData(\r\n          tensor,\r\n          tensorDataOffset,\r\n          tensorDataOffset + ptrSize,\r\n          tensorDataOffset + 2 * ptrSize,\r\n\r\n          tensorDataOffset + 3 * ptrSize,\r\n        );\r\n        if (errorCode !== 0) {\r\n          checkLastError(`Can't access output tensor data on index ${i}.`);\r\n        }\r\n        const valueType = ptrSize === 4 ? 'i32' : 'i64';\r\n        const dataType = Number(wasm.getValue(tensorDataOffset, valueType));\r\n        dataOffset = wasm.getValue(tensorDataOffset + ptrSize, '*');\r\n        const dimsOffset = wasm.getValue(tensorDataOffset + ptrSize * 2, '*');\r\n        const dimsLength = Number(wasm.getValue(tensorDataOffset + ptrSize * 3, valueType));\r\n        const dims = [];\r\n        for (let i = 0; i < dimsLength; i++) {\r\n          dims.push(Number(wasm.getValue(dimsOffset + i * ptrSize, valueType)));\r\n        }\r\n        if (wasm._OrtFree(dimsOffset) !== 0) {\r\n          checkLastError(\"Can't free memory for tensor dims.\");\r\n        }\r\n        const size = dims.reduce((a, b) => a * b, 1);\r\n        type = tensorDataTypeEnumToString(dataType);\r\n\r\n        const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];\r\n\r\n        if (type === 'string') {\r\n          if (preferredLocation === 'gpu-buffer' || preferredLocation === 'ml-tensor') {\r\n            throw new Error('String tensor is not supported on GPU.');\r\n          }\r\n          const stringData: string[] = [];\r\n          for (let i = 0; i < size; i++) {\r\n            const offset = wasm.getValue(dataOffset + i * ptrSize, '*');\r\n            const nextOffset = wasm.getValue(dataOffset + (i + 1) * ptrSize, '*');\r\n            const maxBytesToRead = i === size - 1 ? undefined : nextOffset - offset;\r\n            stringData.push(wasm.UTF8ToString(offset, maxBytesToRead));\r\n          }\r\n          output.push([type, dims, stringData, 'cpu']);\r\n        } else {\r\n          // If a certain output's preferred location is GPU but the tensor is empty, we still need to create a CPU\r\n          // tensor for it. There is no mapping GPU buffer for an empty tensor.\r\n          if (preferredLocation === 'gpu-buffer' && size > 0) {\r\n            const getBuffer = !BUILD_DEFS.DISABLE_WEBGPU ? wasm.webgpuGetBuffer : wasm.jsepGetBuffer;\r\n            if (!getBuffer) {\r\n              throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');\r\n            }\r\n            const gpuBuffer = getBuffer(dataOffset);\r\n            const bufferSize = calculateTensorSizeInBytes(dataType, size);\r\n            if (bufferSize === undefined || !isGpuBufferSupportedType(type)) {\r\n              throw new Error(`Unsupported data type: ${type}`);\r\n            }\r\n\r\n            // do not release the tensor right now. it will be released when user calls tensor.dispose().\r\n            keepOutputTensor = true;\r\n\r\n            if (!BUILD_DEFS.DISABLE_WEBGPU) {\r\n              wasm.webgpuRegisterBuffer!(gpuBuffer, sessionId, dataOffset);\r\n              const downloadDataFunction = wasm.webgpuCreateDownloader!(gpuBuffer, bufferSize, sessionId);\r\n              output.push([\r\n                type,\r\n                dims,\r\n                {\r\n                  gpuBuffer,\r\n                  download: async () => {\r\n                    const arrayBuffer = await downloadDataFunction();\r\n                    const data = new (tensorTypeToTypedArrayConstructor(type!))(arrayBuffer);\r\n                    return data as Tensor.DataTypeMap[Tensor.GpuBufferDataTypes];\r\n                  },\r\n                  dispose: () => {\r\n                    if (wasm._OrtReleaseTensor(tensor) !== 0) {\r\n                      checkLastError(\"Can't release tensor.\");\r\n                    }\r\n                  },\r\n                },\r\n                'gpu-buffer',\r\n              ]);\r\n            } else {\r\n              output.push([\r\n                type,\r\n                dims,\r\n                {\r\n                  gpuBuffer,\r\n                  download: wasm.jsepCreateDownloader!(gpuBuffer, bufferSize, type),\r\n                  dispose: () => {\r\n                    if (wasm._OrtReleaseTensor(tensor) !== 0) {\r\n                      checkLastError(\"Can't release tensor.\");\r\n                    }\r\n                  },\r\n                },\r\n                'gpu-buffer',\r\n              ]);\r\n            }\r\n          } else if (preferredLocation === 'ml-tensor' && size > 0) {\r\n            const ensureTensor = wasm.webnnEnsureTensor;\r\n            const isGraphInputOutputTypeSupported = wasm.webnnIsGraphInputOutputTypeSupported;\r\n            if (!ensureTensor || !isGraphInputOutputTypeSupported) {\r\n              throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');\r\n            }\r\n            const tensorSize = calculateTensorSizeInBytes(dataType, size);\r\n            if (tensorSize === undefined || !isMLTensorSupportedType(type)) {\r\n              throw new Error(`Unsupported data type: ${type}`);\r\n            }\r\n            if (!isGraphInputOutputTypeSupported(sessionId, type, false)) {\r\n              throw new Error(\r\n                `preferredLocation \"ml-tensor\" for ${type} output is not supported by current WebNN Context.`,\r\n              );\r\n            }\r\n\r\n            // If the graph has been partitioned, the output tensor may have not been created. For this reason, we use\r\n            // ensureTensor to get/create the MLTensor. In which case, we don't need to copy the data if a new tensor\r\n            // has been created.\r\n            const mlTensor = await ensureTensor(sessionId, dataOffset, dataType, dims, false);\r\n\r\n            // do not release the tensor right now. it will be released when user calls tensor.dispose().\r\n            keepOutputTensor = true;\r\n\r\n            output.push([\r\n              type,\r\n              dims,\r\n              {\r\n                mlTensor,\r\n                download: wasm.webnnCreateMLTensorDownloader!(dataOffset, type),\r\n                dispose: () => {\r\n                  wasm.webnnReleaseTensorId!(dataOffset);\r\n                  wasm._OrtReleaseTensor(tensor);\r\n                },\r\n              },\r\n              'ml-tensor',\r\n            ]);\r\n          } else if (preferredLocation === 'ml-tensor-cpu-output' && size > 0) {\r\n            const data = wasm.webnnCreateMLTensorDownloader!(dataOffset, type as Tensor.MLTensorDataTypes)();\r\n            const index = output.length;\r\n            // Delay the data download and releasing the tensor until we can wait for all output tensors to be downloaded.\r\n            keepOutputTensor = true;\r\n            outputPromises.push(\r\n              (async () => {\r\n                const result: [number, Tensor.DataType] = [index, await data];\r\n                wasm.webnnReleaseTensorId!(dataOffset);\r\n                wasm._OrtReleaseTensor(tensor);\r\n                return result;\r\n              })(),\r\n            );\r\n            output.push([type, dims, [], 'cpu']);\r\n          } else {\r\n            const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);\r\n            const data = new typedArrayConstructor(size);\r\n            new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(\r\n              wasm.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength),\r\n            );\r\n            output.push([type, dims, data, 'cpu']);\r\n          }\r\n        }\r\n      } finally {\r\n        wasm.stackRestore(beforeGetTensorDataStack);\r\n        if (type === 'string' && dataOffset) {\r\n          wasm._free(dataOffset);\r\n        }\r\n        if (!keepOutputTensor) {\r\n          wasm._OrtReleaseTensor(tensor);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (ioBindingState && !enableGraphCapture) {\r\n      if (wasm._OrtClearBoundOutputs(ioBindingState.handle) !== 0) {\r\n        checkLastError(\"Can't clear bound outputs.\");\r\n      }\r\n      activeSessions.set(sessionId, [\r\n        sessionHandle,\r\n        inputNamesUTF8Encoded,\r\n        outputNamesUTF8Encoded,\r\n        ioBindingState,\r\n        enableGraphCapture,\r\n        false,\r\n      ]);\r\n    }\r\n    // Wait for all output tensor data to be downloaded.\r\n    for (const [index, data] of await Promise.all(outputPromises)) {\r\n      output[index][2] = data;\r\n    }\r\n    TRACE_EVENT_END('wasm ProcessOutputTensor');\r\n    return output;\r\n  } finally {\r\n    wasm.webnnOnRunEnd?.(sessionHandle);\r\n\r\n    wasm.stackRestore(beforeRunStack);\r\n\r\n    if (!BUILD_DEFS.DISABLE_WEBGPU) {\r\n      inputTensors.forEach((t) => {\r\n        if (t && t[3] === 'gpu-buffer') {\r\n          wasm.webgpuUnregisterBuffer!(t[2].gpuBuffer);\r\n        }\r\n      });\r\n      outputTensors.forEach((t) => {\r\n        if (t && t[3] === 'gpu-buffer') {\r\n          wasm.webgpuUnregisterBuffer!(t[2].gpuBuffer);\r\n        }\r\n      });\r\n    }\r\n    inputTensorHandles.forEach((v) => wasm._OrtReleaseTensor(v));\r\n    outputTensorHandles.forEach((v) => wasm._OrtReleaseTensor(v));\r\n    inputOutputAllocs.forEach((p) => wasm._free(p));\r\n\r\n    if (runOptionsHandle !== 0) {\r\n      wasm._OrtReleaseRunOptions(runOptionsHandle);\r\n    }\r\n    runOptionsAllocs.forEach((p) => wasm._free(p));\r\n  }\r\n};\r\n\r\n/**\r\n * end profiling\r\n */\r\nexport const endProfiling = (sessionId: number): void => {\r\n  const wasm = getInstance();\r\n  const session = activeSessions.get(sessionId);\r\n  if (!session) {\r\n    throw new Error('invalid session id');\r\n  }\r\n  const sessionHandle = session[0];\r\n\r\n  // profile file name is not used yet, but it must be freed.\r\n  const profileFileName = wasm._OrtEndProfiling(sessionHandle);\r\n  if (profileFileName === 0) {\r\n    checkLastError(\"Can't get an profile file name.\");\r\n  }\r\n  wasm._OrtFree(profileFileName);\r\n};\r\n\r\nexport const extractTransferableBuffers = (tensors: readonly SerializableTensorMetadata[]): ArrayBufferLike[] => {\r\n  const buffers: ArrayBufferLike[] = [];\r\n  for (const tensor of tensors) {\r\n    const data = tensor[2];\r\n    if (!Array.isArray(data) && 'buffer' in data) {\r\n      buffers.push(data.buffer);\r\n    }\r\n  }\r\n  return buffers;\r\n};\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { env, InferenceSession } from 'onnxruntime-common';\r\n\r\nimport {\r\n  OrtWasmMessage,\r\n  SerializableInternalBuffer,\r\n  SerializableSessionMetadata,\r\n  SerializableTensorMetadata,\r\n  TensorMetadata,\r\n} from './proxy-messages';\r\nimport * as core from './wasm-core-impl';\r\nimport { initializeWebAssembly } from './wasm-factory';\r\nimport {\r\n  importProxyWorker,\r\n  inferWasmPathPrefixFromScriptSrc,\r\n  isEsmImportMetaUrlHardcodedAsFileUri,\r\n} from './wasm-utils-import';\r\n\r\nconst isProxy = (): boolean => !!env.wasm.proxy && typeof document !== 'undefined';\r\nlet proxyWorker: Worker | undefined;\r\nlet initializing = false;\r\nlet initialized = false;\r\nlet aborted = false;\r\nlet temporaryObjectUrl: string | undefined;\r\n\r\ntype PromiseCallbacks<T = void> = [resolve: (result: T) => void, reject: (reason: unknown) => void];\r\nlet initWasmCallbacks: PromiseCallbacks;\r\nconst queuedCallbacks: Map<OrtWasmMessage['type'], Array<PromiseCallbacks<unknown>>> = new Map();\r\n\r\nconst enqueueCallbacks = (type: OrtWasmMessage['type'], callbacks: PromiseCallbacks<unknown>): void => {\r\n  const queue = queuedCallbacks.get(type);\r\n  if (queue) {\r\n    queue.push(callbacks);\r\n  } else {\r\n    queuedCallbacks.set(type, [callbacks]);\r\n  }\r\n};\r\n\r\nconst ensureWorker = (): void => {\r\n  if (initializing || !initialized || aborted || !proxyWorker) {\r\n    throw new Error('worker not ready');\r\n  }\r\n};\r\n\r\nconst onProxyWorkerMessage = (ev: MessageEvent<OrtWasmMessage>): void => {\r\n  switch (ev.data.type) {\r\n    case 'init-wasm':\r\n      initializing = false;\r\n      if (ev.data.err) {\r\n        aborted = true;\r\n        initWasmCallbacks[1](ev.data.err);\r\n      } else {\r\n        initialized = true;\r\n        initWasmCallbacks[0]();\r\n      }\r\n      if (temporaryObjectUrl) {\r\n        URL.revokeObjectURL(temporaryObjectUrl);\r\n        temporaryObjectUrl = undefined;\r\n      }\r\n      break;\r\n    case 'init-ep':\r\n    case 'copy-from':\r\n    case 'create':\r\n    case 'release':\r\n    case 'run':\r\n    case 'end-profiling': {\r\n      const callbacks = queuedCallbacks.get(ev.data.type)!;\r\n      if (ev.data.err) {\r\n        callbacks.shift()![1](ev.data.err);\r\n      } else {\r\n        callbacks.shift()![0](ev.data.out!);\r\n      }\r\n      break;\r\n    }\r\n    default:\r\n  }\r\n};\r\n\r\nexport const initializeWebAssemblyAndOrtRuntime = async (): Promise<void> => {\r\n  if (initialized) {\r\n    return;\r\n  }\r\n  if (initializing) {\r\n    throw new Error(\"multiple calls to 'initWasm()' detected.\");\r\n  }\r\n  if (aborted) {\r\n    throw new Error(\"previous call to 'initWasm()' failed.\");\r\n  }\r\n\r\n  initializing = true;\r\n\r\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\r\n    return new Promise<void>((resolve, reject) => {\r\n      proxyWorker?.terminate();\r\n\r\n      void importProxyWorker().then(([objectUrl, worker]) => {\r\n        try {\r\n          proxyWorker = worker;\r\n          proxyWorker.onerror = (ev: ErrorEvent) => reject(ev);\r\n          proxyWorker.onmessage = onProxyWorkerMessage;\r\n          initWasmCallbacks = [resolve, reject];\r\n          const message: OrtWasmMessage = { type: 'init-wasm', in: env };\r\n\r\n          // if the proxy worker is loaded from a blob URL, we need to make sure the path information is not lost.\r\n          //\r\n          // when `env.wasm.wasmPaths` is not set, we need to pass the path information to the worker.\r\n          //\r\n          if (!BUILD_DEFS.ENABLE_BUNDLE_WASM_JS && !message.in!.wasm.wasmPaths && objectUrl) {\r\n            // for a build not bundled the wasm JS, we need to pass the path prefix to the worker.\r\n            // the path prefix will be used to resolve the path to both the wasm JS and the wasm file.\r\n            const inferredWasmPathPrefix = inferWasmPathPrefixFromScriptSrc();\r\n            if (inferredWasmPathPrefix) {\r\n              message.in!.wasm.wasmPaths = inferredWasmPathPrefix;\r\n            }\r\n          }\r\n\r\n          if (\r\n            BUILD_DEFS.IS_ESM &&\r\n            BUILD_DEFS.ENABLE_BUNDLE_WASM_JS &&\r\n            !message.in!.wasm.wasmPaths &&\r\n            (objectUrl || isEsmImportMetaUrlHardcodedAsFileUri)\r\n          ) {\r\n            // for a build bundled the wasm JS, if either of the following conditions is met:\r\n            // - the proxy worker is loaded from a blob URL\r\n            // - `import.meta.url` is a file URL, it means it is overwritten by the bundler.\r\n            //\r\n            // in either case, the path information is lost, we need to pass the path of the .wasm file to the worker.\r\n            // we need to use the bundler preferred URL format:\r\n            // new URL('filename', import.meta.url)\r\n            // so that the bundler can handle the file using corresponding loaders.\r\n            message.in!.wasm.wasmPaths = {\r\n              wasm: !BUILD_DEFS.DISABLE_JSEP\r\n                ? new URL('ort-wasm-simd-threaded.jsep.wasm', BUILD_DEFS.ESM_IMPORT_META_URL).href\r\n                : !BUILD_DEFS.DISABLE_WEBGPU\r\n                  ? new URL('ort-wasm-simd-threaded.asyncify.wasm', BUILD_DEFS.ESM_IMPORT_META_URL).href\r\n                  : new URL('ort-wasm-simd-threaded.wasm', BUILD_DEFS.ESM_IMPORT_META_URL).href,\r\n            };\r\n          }\r\n          proxyWorker.postMessage(message);\r\n          temporaryObjectUrl = objectUrl;\r\n        } catch (e) {\r\n          reject(e);\r\n        }\r\n      }, reject);\r\n    });\r\n  } else {\r\n    try {\r\n      await initializeWebAssembly(env.wasm);\r\n      await core.initRuntime(env);\r\n      initialized = true;\r\n    } catch (e) {\r\n      aborted = true;\r\n      throw e;\r\n    } finally {\r\n      initializing = false;\r\n    }\r\n  }\r\n};\r\n\r\nexport const initializeOrtEp = async (epName: string): Promise<void> => {\r\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\r\n    ensureWorker();\r\n    return new Promise<void>((resolve, reject) => {\r\n      enqueueCallbacks('init-ep', [resolve, reject]);\r\n      const message: OrtWasmMessage = { type: 'init-ep', in: { epName, env } };\r\n      proxyWorker!.postMessage(message);\r\n    });\r\n  } else {\r\n    await core.initEp(env, epName);\r\n  }\r\n};\r\n\r\nexport const copyFromExternalBuffer = async (buffer: Uint8Array): Promise<SerializableInternalBuffer> => {\r\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\r\n    ensureWorker();\r\n    return new Promise<SerializableInternalBuffer>((resolve, reject) => {\r\n      enqueueCallbacks('copy-from', [resolve, reject]);\r\n      const message: OrtWasmMessage = { type: 'copy-from', in: { buffer } };\r\n      proxyWorker!.postMessage(message, [buffer.buffer]);\r\n    });\r\n  } else {\r\n    return core.copyFromExternalBuffer(buffer);\r\n  }\r\n};\r\n\r\nexport const createSession = async (\r\n  model: SerializableInternalBuffer | Uint8Array,\r\n  options?: InferenceSession.SessionOptions,\r\n): Promise<SerializableSessionMetadata> => {\r\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\r\n    // check unsupported options\r\n    if (options?.preferredOutputLocation) {\r\n      throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');\r\n    }\r\n    ensureWorker();\r\n    return new Promise<SerializableSessionMetadata>((resolve, reject) => {\r\n      enqueueCallbacks('create', [resolve, reject]);\r\n      const message: OrtWasmMessage = { type: 'create', in: { model, options: { ...options } } };\r\n      const transferable: Transferable[] = [];\r\n      if (model instanceof Uint8Array) {\r\n        transferable.push(model.buffer);\r\n      }\r\n      proxyWorker!.postMessage(message, transferable);\r\n    });\r\n  } else {\r\n    return core.createSession(model, options);\r\n  }\r\n};\r\n\r\nexport const releaseSession = async (sessionId: number): Promise<void> => {\r\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\r\n    ensureWorker();\r\n    return new Promise<void>((resolve, reject) => {\r\n      enqueueCallbacks('release', [resolve, reject]);\r\n      const message: OrtWasmMessage = { type: 'release', in: sessionId };\r\n      proxyWorker!.postMessage(message);\r\n    });\r\n  } else {\r\n    core.releaseSession(sessionId);\r\n  }\r\n};\r\n\r\nexport const run = async (\r\n  sessionId: number,\r\n  inputIndices: number[],\r\n  inputs: TensorMetadata[],\r\n  outputIndices: number[],\r\n  outputs: Array<TensorMetadata | null>,\r\n  options: InferenceSession.RunOptions,\r\n): Promise<TensorMetadata[]> => {\r\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\r\n    // check inputs location\r\n    if (inputs.some((t) => t[3] !== 'cpu')) {\r\n      throw new Error('input tensor on GPU is not supported for proxy.');\r\n    }\r\n    // check outputs location\r\n    if (outputs.some((t) => t)) {\r\n      throw new Error('pre-allocated output tensor is not supported for proxy.');\r\n    }\r\n    ensureWorker();\r\n    return new Promise<SerializableTensorMetadata[]>((resolve, reject) => {\r\n      enqueueCallbacks('run', [resolve, reject]);\r\n      const serializableInputs = inputs as SerializableTensorMetadata[]; // every input is on CPU.\r\n      const message: OrtWasmMessage = {\r\n        type: 'run',\r\n        in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options },\r\n      };\r\n      proxyWorker!.postMessage(message, core.extractTransferableBuffers(serializableInputs));\r\n    });\r\n  } else {\r\n    return core.run(sessionId, inputIndices, inputs, outputIndices, outputs, options);\r\n  }\r\n};\r\n\r\nexport const endProfiling = async (sessionId: number): Promise<void> => {\r\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\r\n    ensureWorker();\r\n    return new Promise<void>((resolve, reject) => {\r\n      enqueueCallbacks('end-profiling', [resolve, reject]);\r\n      const message: OrtWasmMessage = { type: 'end-profiling', in: sessionId };\r\n      proxyWorker!.postMessage(message);\r\n    });\r\n  } else {\r\n    core.endProfiling(sessionId);\r\n  }\r\n};\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport {\r\n  InferenceSession,\r\n  InferenceSessionHandler,\r\n  SessionHandler,\r\n  Tensor,\r\n  TRACE_FUNC_BEGIN,\r\n  TRACE_FUNC_END,\r\n} from 'onnxruntime-common';\r\n\r\nimport { SerializableInternalBuffer, TensorMetadata } from './proxy-messages';\r\nimport { copyFromExternalBuffer, createSession, endProfiling, releaseSession, run } from './proxy-wrapper';\r\nimport { isGpuBufferSupportedType, isMLTensorSupportedType } from './wasm-common';\r\nimport { isNode } from './wasm-utils-env';\r\nimport { loadFile } from './wasm-utils-load-file';\r\n\r\nexport const encodeTensorMetadata = (tensor: Tensor, getName: () => string): TensorMetadata => {\r\n  switch (tensor.location) {\r\n    case 'cpu':\r\n      return [tensor.type, tensor.dims, tensor.data, 'cpu'];\r\n    case 'gpu-buffer':\r\n      return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, 'gpu-buffer'];\r\n    case 'ml-tensor':\r\n      return [tensor.type, tensor.dims, { mlTensor: tensor.mlTensor }, 'ml-tensor'];\r\n    default:\r\n      throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);\r\n  }\r\n};\r\n\r\nexport const decodeTensorMetadata = (tensor: TensorMetadata): Tensor => {\r\n  switch (tensor[3]) {\r\n    case 'cpu':\r\n      return new Tensor(tensor[0], tensor[2], tensor[1]);\r\n    case 'gpu-buffer': {\r\n      const dataType = tensor[0];\r\n      if (!isGpuBufferSupportedType(dataType)) {\r\n        throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);\r\n      }\r\n      const { gpuBuffer, download, dispose } = tensor[2];\r\n      return Tensor.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });\r\n    }\r\n    case 'ml-tensor': {\r\n      const dataType = tensor[0];\r\n      if (!isMLTensorSupportedType(dataType)) {\r\n        throw new Error(`not supported data type: ${dataType} for deserializing MLTensor tensor`);\r\n      }\r\n      const { mlTensor, download, dispose } = tensor[2];\r\n      return Tensor.fromMLTensor(mlTensor, { dataType, dims: tensor[1], download, dispose });\r\n    }\r\n    default:\r\n      throw new Error(`invalid data location: ${tensor[3]}`);\r\n  }\r\n};\r\n\r\nexport class OnnxruntimeWebAssemblySessionHandler implements InferenceSessionHandler {\r\n  private sessionId: number;\r\n\r\n  inputNames: readonly string[];\r\n  outputNames: readonly string[];\r\n  inputMetadata: readonly InferenceSession.ValueMetadata[];\r\n  outputMetadata: readonly InferenceSession.ValueMetadata[];\r\n\r\n  async fetchModelAndCopyToWasmMemory(path: string): Promise<SerializableInternalBuffer> {\r\n    // fetch model from url and move to wasm heap.\r\n    return copyFromExternalBuffer(await loadFile(path));\r\n  }\r\n\r\n  async loadModel(pathOrBuffer: string | Uint8Array, options?: InferenceSession.SessionOptions): Promise<void> {\r\n    TRACE_FUNC_BEGIN();\r\n    let model: Parameters<typeof createSession>[0];\r\n\r\n    if (typeof pathOrBuffer === 'string') {\r\n      if (isNode) {\r\n        // node\r\n        model = await loadFile(pathOrBuffer);\r\n      } else {\r\n        // browser\r\n        // fetch model and copy to wasm heap.\r\n        model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);\r\n      }\r\n    } else {\r\n      model = pathOrBuffer;\r\n    }\r\n\r\n    [this.sessionId, this.inputNames, this.outputNames, this.inputMetadata, this.outputMetadata] = await createSession(\r\n      model,\r\n      options,\r\n    );\r\n    TRACE_FUNC_END();\r\n  }\r\n\r\n  async dispose(): Promise<void> {\r\n    return releaseSession(this.sessionId);\r\n  }\r\n\r\n  async run(\r\n    feeds: SessionHandler.FeedsType,\r\n    fetches: SessionHandler.FetchesType,\r\n    options: InferenceSession.RunOptions,\r\n  ): Promise<SessionHandler.ReturnType> {\r\n    TRACE_FUNC_BEGIN();\r\n    const inputArray: Tensor[] = [];\r\n    const inputIndices: number[] = [];\r\n    Object.entries(feeds).forEach((kvp) => {\r\n      const name = kvp[0];\r\n      const tensor = kvp[1];\r\n      const index = this.inputNames.indexOf(name);\r\n      if (index === -1) {\r\n        throw new Error(`invalid input '${name}'`);\r\n      }\r\n      inputArray.push(tensor);\r\n      inputIndices.push(index);\r\n    });\r\n\r\n    const outputArray: Array<Tensor | null> = [];\r\n    const outputIndices: number[] = [];\r\n    Object.entries(fetches).forEach((kvp) => {\r\n      const name = kvp[0];\r\n      const tensor = kvp[1];\r\n      const index = this.outputNames.indexOf(name);\r\n      if (index === -1) {\r\n        throw new Error(`invalid output '${name}'`);\r\n      }\r\n      outputArray.push(tensor);\r\n      outputIndices.push(index);\r\n    });\r\n\r\n    const inputs = inputArray.map((t, i) =>\r\n      encodeTensorMetadata(t, () => `input \"${this.inputNames[inputIndices[i]]}\"`),\r\n    );\r\n    const outputs = outputArray.map((t, i) =>\r\n      t ? encodeTensorMetadata(t, () => `output \"${this.outputNames[outputIndices[i]]}\"`) : null,\r\n    );\r\n\r\n    const results = await run(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);\r\n\r\n    const resultMap: SessionHandler.ReturnType = {};\r\n    for (let i = 0; i < results.length; i++) {\r\n      resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);\r\n    }\r\n    TRACE_FUNC_END();\r\n    return resultMap;\r\n  }\r\n\r\n  startProfiling(): void {\r\n    // TODO: implement profiling\r\n  }\r\n\r\n  endProfiling(): void {\r\n    void endProfiling(this.sessionId);\r\n  }\r\n}\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { Backend, env, InferenceSession, InferenceSessionHandler } from 'onnxruntime-common';\r\n\r\nimport { initializeOrtEp, initializeWebAssemblyAndOrtRuntime } from './wasm/proxy-wrapper';\r\nimport { OnnxruntimeWebAssemblySessionHandler } from './wasm/session-handler-inference';\r\n\r\n/**\r\n * This function initializes all flags for WebAssembly.\r\n *\r\n * Those flags are accessible from `ort.env.wasm`. Users are allow to set those flags before the first inference session\r\n * being created, to override default value.\r\n */\r\nexport const initializeFlags = (): void => {\r\n  if (typeof env.wasm.initTimeout !== 'number' || env.wasm.initTimeout < 0) {\r\n    env.wasm.initTimeout = 0;\r\n  }\r\n\r\n  const simd = env.wasm.simd;\r\n  if (typeof simd !== 'boolean' && simd !== undefined && simd !== 'fixed' && simd !== 'relaxed') {\r\n    // eslint-disable-next-line no-console\r\n    console.warn(\r\n      `Property \"env.wasm.simd\" is set to unknown value \"${simd}\". Reset it to \\`false\\` and ignore SIMD feature checking.`,\r\n    );\r\n    env.wasm.simd = false;\r\n  }\r\n\r\n  if (typeof env.wasm.proxy !== 'boolean') {\r\n    env.wasm.proxy = false;\r\n  }\r\n\r\n  if (typeof env.wasm.trace !== 'boolean') {\r\n    env.wasm.trace = false;\r\n  }\r\n\r\n  if (typeof env.wasm.numThreads !== 'number' || !Number.isInteger(env.wasm.numThreads) || env.wasm.numThreads <= 0) {\r\n    // The following logic only applies when `ort.env.wasm.numThreads` is not set by user. We will always honor user's\r\n    // setting if it is provided.\r\n\r\n    // Browser: when crossOriginIsolated is false, SharedArrayBuffer is not available so WebAssembly threads will not\r\n    // work. In this case, we will set numThreads to 1.\r\n    //\r\n    // There is an exception: when the browser is configured to force-enable SharedArrayBuffer (e.g. Chromuim with\r\n    // --enable-features=SharedArrayBuffer), it is possible that `self.crossOriginIsolated` is false and\r\n    // SharedArrayBuffer is available at the same time. This is usually for testing. In this case,  we will still set\r\n    // numThreads to 1 here. If we want to enable multi-threading in test, we should set `ort.env.wasm.numThreads` to a\r\n    // value greater than 1.\r\n    if (typeof self !== 'undefined' && !self.crossOriginIsolated) {\r\n      env.wasm.numThreads = 1;\r\n    } else {\r\n      const numCpuLogicalCores =\r\n        typeof navigator === 'undefined' ? require('node:os').cpus().length : navigator.hardwareConcurrency;\r\n      env.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));\r\n    }\r\n  }\r\n};\r\n\r\nexport class OnnxruntimeWebAssemblyBackend implements Backend {\r\n  /**\r\n   * This function initializes the WebAssembly backend.\r\n   *\r\n   * This function will be called only once for each backend name. It will be called the first time when\r\n   * `ort.InferenceSession.create()` is called with a registered backend name.\r\n   *\r\n   * @param backendName - the registered backend name.\r\n   */\r\n  async init(backendName: string): Promise<void> {\r\n    // populate wasm flags\r\n    initializeFlags();\r\n\r\n    // init wasm\r\n    await initializeWebAssemblyAndOrtRuntime();\r\n\r\n    // performe EP specific initialization\r\n    await initializeOrtEp(backendName);\r\n  }\r\n  createInferenceSessionHandler(\r\n    path: string,\r\n    options?: InferenceSession.SessionOptions,\r\n  ): Promise<InferenceSessionHandler>;\r\n  createInferenceSessionHandler(\r\n    buffer: Uint8Array,\r\n    options?: InferenceSession.SessionOptions,\r\n  ): Promise<InferenceSessionHandler>;\r\n  async createInferenceSessionHandler(\r\n    pathOrBuffer: string | Uint8Array,\r\n    options?: InferenceSession.SessionOptions,\r\n  ): Promise<InferenceSessionHandler> {\r\n    const handler = new OnnxruntimeWebAssemblySessionHandler();\r\n    await handler.loadModel(pathOrBuffer, options);\r\n    return handler;\r\n  }\r\n}\r\n\r\nexport const wasmBackend = new OnnxruntimeWebAssemblyBackend();\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n/* eslint-disable @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports */\r\n\r\n// We use \"require\" instead of \"import\" here because import statement must be put in top level. Our current code does\r\n// not allow bundler to tree-shaking code as expected because some codes are treated as having side effects.\r\n// So we import code inside the if-clause to allow bundler remove the code safely.\r\n\r\nexport * from 'onnxruntime-common';\r\nimport * as ort from 'onnxruntime-common';\r\nexport default ort;\r\n\r\nimport { registerBackend, env } from 'onnxruntime-common';\r\nimport { version } from './version';\r\n\r\nif (!BUILD_DEFS.DISABLE_WEBGL) {\r\n  const onnxjsBackend = require('./backend-onnxjs').onnxjsBackend;\r\n  registerBackend('webgl', onnxjsBackend, -10);\r\n}\r\n\r\nif (!BUILD_DEFS.DISABLE_JSEP && !BUILD_DEFS.DISABLE_WEBGPU) {\r\n  throw new Error(\r\n    'The current build is specified to enable both JSEP and WebGPU EP. This is not a valid configuration. ' +\r\n      'JSEP and WebGPU EPs cannot be enabled at the same time.',\r\n  );\r\n}\r\n\r\nif (!BUILD_DEFS.DISABLE_WEBNN && BUILD_DEFS.DISABLE_JSEP && BUILD_DEFS.DISABLE_WEBGPU) {\r\n  throw new Error(\r\n    'The current build is specified to enable WebNN EP without JSEP or WebGPU EP. This is not a valid configuration. ' +\r\n      'WebNN EP requires either JSEP or WebGPU EP to be enabled.',\r\n  );\r\n}\r\n\r\nif (!BUILD_DEFS.DISABLE_WASM) {\r\n  const wasmBackend = require('./backend-wasm').wasmBackend;\r\n  if (!BUILD_DEFS.DISABLE_JSEP || !BUILD_DEFS.DISABLE_WEBGPU) {\r\n    registerBackend('webgpu', wasmBackend, 5);\r\n  }\r\n  if (!BUILD_DEFS.DISABLE_WEBNN) {\r\n    registerBackend('webnn', wasmBackend, 5);\r\n  }\r\n  registerBackend('cpu', wasmBackend, 10);\r\n  registerBackend('wasm', wasmBackend, 10);\r\n}\r\n\r\nObject.defineProperty(env.versions, 'web', { value: version, enumerable: true });\r\n","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\n// This file is generated by /js/scripts/update-version.ts\r\n// Do not modify file content manually.\r\n\r\nexport const version = '1.23.0';\r\n"]}